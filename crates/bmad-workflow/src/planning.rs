//! BMAD Planning Phase - Agentic Planning with AI Agent Collaboration
//! 
//! This module implements Phase 1 of BMAD: AI agents collaborate to create
//! comprehensive project artifacts like PRDs, architecture diagrams, and UX briefs.

use crate::{BMADError, UserInput, ProjectArtifact, ArtifactType, AgentRole};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

/// Planning phase orchestrator
#[derive(Debug)]
pub struct PlanningPhase {
    pub agents: Vec<PlanningAgent>,
    pub collaboration_strategy: CollaborationStrategy,
    pub artifacts: Vec<ProjectArtifact>,
    pub user_input: Option<UserInput>,
}

/// Planning agent specialized in creating project artifacts
#[derive(Debug, Clone)]
pub struct PlanningAgent {
    pub id: Uuid,
    pub name: String,
    pub role: AgentRole,
    pub expertise: Vec<ArtifactType>,
    pub status: AgentStatus,
    pub created_at: DateTime<Utc>,
}

/// Collaboration strategies for planning agents
#[derive(Debug, Clone)]
pub enum CollaborationStrategy {
    Sequential,    // Agents work one after another
    Parallel,      // Agents work simultaneously  
    Iterative,     // Agents iterate and refine together
    Hierarchical,  // Lead agent coordinates others
}

/// Agent status during planning
#[derive(Debug, Clone)]
pub enum AgentStatus {
    Available,
    Working,
    Collaborating,
    Waiting,
    Completed,
}

/// Project artifact generated by planning agents
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectArtifact {
    pub id: Uuid,
    pub artifact_type: ArtifactType,
    pub title: String,
    pub content: String,
    pub metadata: ArtifactMetadata,
    pub created_by: String,
    pub created_at: DateTime<Utc>,
    pub version: u32,
    pub dependencies: Vec<Uuid>, // Other artifacts this depends on
}

/// Metadata for project artifacts
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArtifactMetadata {
    pub complexity_score: f32,
    pub completeness_score: f32,
    pub quality_score: f32,
    pub tags: Vec<String>,
    pub review_status: ReviewStatus,
    pub approval_status: ApprovalStatus,
}

/// Review status for artifacts
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ReviewStatus {
    Draft,
    UnderReview,
    Approved,
    NeedsRevision,
    Rejected,
}

/// Approval status for artifacts
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ApprovalStatus {
    Pending,
    Approved,
    Rejected,
    RequiresChanges,
}

impl PlanningPhase {
    /// Create a new planning phase
    pub fn new(agents: Vec<PlanningAgent>, strategy: CollaborationStrategy) -> Self {
        Self {
            agents,
            collaboration_strategy,
            artifacts: Vec::new(),
            user_input: None,
        }
    }
    
    /// Start the planning phase with user input
    pub async fn start_planning(&mut self, user_input: UserInput) -> Result<Vec<ProjectArtifact>, BMADError> {
        tracing::info!("🎯 Starting BMAD Planning Phase with {} agents", self.agents.len());
        
        self.user_input = Some(user_input.clone());
        
        // Execute collaboration strategy
        let artifacts = match self.collaboration_strategy {
            CollaborationStrategy::Sequential => {
                self.execute_sequential_collaboration(&user_input).await?
            },
            CollaborationStrategy::Parallel => {
                self.execute_parallel_collaboration(&user_input).await?
            },
            CollaborationStrategy::Iterative => {
                self.execute_iterative_collaboration(&user_input).await?
            },
            CollaborationStrategy::Hierarchical => {
                self.execute_hierarchical_collaboration(&user_input).await?
            },
        };
        
        self.artifacts.extend(artifacts.clone());
        
        tracing::info!("✅ Planning Phase completed with {} artifacts", artifacts.len());
        Ok(artifacts)
    }
    
    /// Execute sequential collaboration (agents work one after another)
    async fn execute_sequential_collaboration(&self, user_input: &UserInput) -> Result<Vec<ProjectArtifact>, BMADError> {
        let mut artifacts = Vec::new();
        
        for agent in &self.agents {
            tracing::info!("🔄 Agent {} starting work", agent.name);
            
            let agent_artifacts = agent.generate_artifacts(user_input, &artifacts).await?;
            artifacts.extend(agent_artifacts);
            
            tracing::info!("✅ Agent {} completed work", agent.name);
        }
        
        Ok(artifacts)
    }
    
    /// Execute parallel collaboration (agents work simultaneously)
    async fn execute_parallel_collaboration(&self, user_input: &UserInput) -> Result<Vec<ProjectArtifact>, BMADError> {
        use tokio::task;
        
        let mut tasks = Vec::new();
        
        // Start all agents in parallel
        for agent in &self.agents {
            let agent_clone = agent.clone();
            let user_input_clone = user_input.clone();
            let artifacts_clone = self.artifacts.clone();
            
            let task = task::spawn(async move {
                agent_clone.generate_artifacts(&user_input_clone, &artifacts_clone).await
            });
            
            tasks.push(task);
        }
        
        // Wait for all agents to complete
        let mut artifacts = Vec::new();
        for task in tasks {
            let agent_artifacts = task.await.map_err(|e| BMADError::AgentCollaborationFailed(e.to_string()))??;
            artifacts.extend(agent_artifacts);
        }
        
        Ok(artifacts)
    }
    
    /// Execute iterative collaboration (agents iterate and refine)
    async fn execute_iterative_collaboration(&self, user_input: &UserInput) -> Result<Vec<ProjectArtifact>, BMADError> {
        let mut artifacts = Vec::new();
        let max_iterations = 3;
        
        for iteration in 0..max_iterations {
            tracing::info!("🔄 Iteration {} of {}", iteration + 1, max_iterations);
            
            let mut iteration_artifacts = Vec::new();
            
            for agent in &self.agents {
                let agent_artifacts = agent.generate_artifacts(user_input, &artifacts).await?;
                iteration_artifacts.extend(agent_artifacts);
            }
            
            // Merge and refine artifacts
            artifacts = self.merge_and_refine_artifacts(artifacts, iteration_artifacts).await?;
            
            // Check if we've reached convergence
            if self.check_convergence(&artifacts) {
                tracing::info!("✅ Convergence reached after {} iterations", iteration + 1);
                break;
            }
        }
        
        Ok(artifacts)
    }
    
    /// Execute hierarchical collaboration (lead agent coordinates)
    async fn execute_hierarchical_collaboration(&self, user_input: &UserInput) -> Result<Vec<ProjectArtifact>, BMADError> {
        // Find lead agent (usually Product Manager or Architect)
        let lead_agent = self.agents.iter()
            .find(|agent| matches!(agent.role, AgentRole::ProductManager | AgentRole::Architect))
            .ok_or_else(|| BMADError::AgentCollaborationFailed("No lead agent found".to_string()))?;
        
        tracing::info!("👑 Lead agent {} coordinating collaboration", lead_agent.name);
        
        // Lead agent creates initial artifacts
        let mut artifacts = lead_agent.generate_artifacts(user_input, &[]).await?;
        
        // Other agents contribute based on lead agent's artifacts
        for agent in &self.agents {
            if agent.id != lead_agent.id {
                let agent_artifacts = agent.generate_artifacts(user_input, &artifacts).await?;
                artifacts.extend(agent_artifacts);
            }
        }
        
        // Lead agent reviews and refines all artifacts
        artifacts = lead_agent.review_and_refine_artifacts(artifacts).await?;
        
        Ok(artifacts)
    }
    
    /// Merge and refine artifacts from multiple iterations
    async fn merge_and_refine_artifacts(&self, mut existing: Vec<ProjectArtifact>, new: Vec<ProjectArtifact>) -> Result<Vec<ProjectArtifact>, BMADError> {
        // Simple merge strategy - in production, this would be more sophisticated
        for new_artifact in new {
            if let Some(existing_artifact) = existing.iter_mut().find(|a| a.artifact_type == new_artifact.artifact_type) {
                // Merge content and update metadata
                existing_artifact.content = format!("{}\n\n--- Updated ---\n\n{}", existing_artifact.content, new_artifact.content);
                existing_artifact.version += 1;
                existing_artifact.metadata.completeness_score = (existing_artifact.metadata.completeness_score + new_artifact.metadata.completeness_score) / 2.0;
            } else {
                existing.push(new_artifact);
            }
        }
        
        Ok(existing)
    }
    
    /// Check if artifacts have converged (simplified heuristic)
    fn check_convergence(&self, artifacts: &[ProjectArtifact]) -> bool {
        // Simple convergence check - all artifacts have high completeness scores
        artifacts.iter().all(|artifact| artifact.metadata.completeness_score > 0.8)
    }
}

impl PlanningAgent {
    /// Create a new planning agent
    pub fn new(name: String, role: AgentRole, expertise: Vec<ArtifactType>) -> Self {
        Self {
            id: Uuid::new_v4(),
            name,
            role,
            expertise,
            status: AgentStatus::Available,
            created_at: Utc::now(),
        }
    }
    
    /// Generate artifacts based on user input and existing artifacts
    pub async fn generate_artifacts(&self, user_input: &UserInput, existing_artifacts: &[ProjectArtifact]) -> Result<Vec<ProjectArtifact>, BMADError> {
        tracing::info!("🤖 Agent {} generating artifacts", self.name);
        
        let mut artifacts = Vec::new();
        
        for artifact_type in &self.expertise {
            let artifact = self.generate_single_artifact(artifact_type, user_input, existing_artifacts).await?;
            artifacts.push(artifact);
        }
        
        Ok(artifacts)
    }
    
    /// Generate a single artifact
    async fn generate_single_artifact(&self, artifact_type: &ArtifactType, user_input: &UserInput, existing_artifacts: &[ProjectArtifact]) -> Result<ProjectArtifact, BMADError> {
        let content = match artifact_type {
            ArtifactType::PRD => self.generate_prd(user_input, existing_artifacts).await?,
            ArtifactType::TechnicalArchitecture => self.generate_architecture(user_input, existing_artifacts).await?,
            ArtifactType::UXBrief => self.generate_ux_brief(user_input, existing_artifacts).await?,
            ArtifactType::APISpecification => self.generate_api_spec(user_input, existing_artifacts).await?,
            ArtifactType::DatabaseSchema => self.generate_database_schema(user_input, existing_artifacts).await?,
            ArtifactType::DeploymentPlan => self.generate_deployment_plan(user_input, existing_artifacts).await?,
            ArtifactType::TestingStrategy => self.generate_testing_strategy(user_input, existing_artifacts).await?,
            ArtifactType::SecurityPlan => self.generate_security_plan(user_input, existing_artifacts).await?,
            ArtifactType::PerformancePlan => self.generate_performance_plan(user_input, existing_artifacts).await?,
            ArtifactType::DocumentationPlan => self.generate_documentation_plan(user_input, existing_artifacts).await?,
        };
        
        Ok(ProjectArtifact {
            id: Uuid::new_v4(),
            artifact_type: artifact_type.clone(),
            title: self.get_artifact_title(artifact_type),
            content,
            metadata: ArtifactMetadata {
                complexity_score: self.calculate_complexity_score(user_input),
                completeness_score: 0.8, // Initial score
                quality_score: 0.7,     // Initial score
                tags: self.generate_tags(artifact_type, user_input),
                review_status: ReviewStatus::Draft,
                approval_status: ApprovalStatus::Pending,
            },
            created_by: self.name.clone(),
            created_at: Utc::now(),
            version: 1,
            dependencies: self.find_dependencies(artifact_type, existing_artifacts),
        })
    }
    
    /// Generate Product Requirements Document
    async fn generate_prd(&self, user_input: &UserInput, _existing_artifacts: &[ProjectArtifact]) -> Result<String, BMADError> {
        let content = format!(
            "# Product Requirements Document: {}\n\n## Project Overview\n{}\n\n## Target Users\n{}\n\n## Key Features\n{}\n\n## Success Metrics\n{}\n\n## Constraints\n{}\n\n## Timeline\n{}\n\n## Budget\n{}",
            user_input.project_name,
            user_input.project_description,
            user_input.target_users.join(", "),
            user_input.key_features.iter().enumerate().map(|(i, f)| format!("{}. {}", i + 1, f)).collect::<Vec<_>>().join("\n"),
            user_input.success_metrics.join(", "),
            user_input.constraints.join(", "),
            user_input.timeline.as_deref().unwrap_or("TBD"),
            user_input.budget.as_deref().unwrap_or("TBD")
        );
        
        Ok(content)
    }
    
    /// Generate Technical Architecture
    async fn generate_architecture(&self, user_input: &UserInput, _existing_artifacts: &[ProjectArtifact]) -> Result<String, BMADError> {
        let content = format!(
            "# Technical Architecture: {}\n\n## System Overview\n{}\n\n## Architecture Components\n- Frontend Layer\n- Backend Services\n- Database Layer\n- External Integrations\n\n## Technology Stack\n{}\n\n## Scalability Considerations\n- Horizontal scaling\n- Load balancing\n- Caching strategies\n\n## Security Architecture\n- Authentication\n- Authorization\n- Data encryption\n- API security",
            user_input.project_name,
            user_input.project_description,
            user_input.technical_preferences.join(", ")
        );
        
        Ok(content)
    }
    
    /// Generate UX Brief
    async fn generate_ux_brief(&self, user_input: &UserInput, _existing_artifacts: &[ProjectArtifact]) -> Result<String, BMADError> {
        let content = format!(
            "# UX Brief: {}\n\n## User Personas\n{}\n\n## User Journey\n1. Discovery\n2. Onboarding\n3. Core Usage\n4. Retention\n\n## Design Principles\n- User-centered design\n- Accessibility\n- Responsive design\n- Performance\n\n## Key Features UX\n{}\n\n## Success Metrics\n- User engagement\n- Task completion rate\n- User satisfaction",
            user_input.project_name,
            user_input.target_users.join(", "),
            user_input.key_features.join(", ")
        );
        
        Ok(content)
    }
    
    /// Generate API Specification
    async fn generate_api_spec(&self, user_input: &UserInput, _existing_artifacts: &[ProjectArtifact]) -> Result<String, BMADError> {
        let content = format!(
            "# API Specification: {}\n\n## Overview\nRESTful API for {}\n\n## Endpoints\n### Authentication\n- POST /auth/login\n- POST /auth/logout\n- POST /auth/refresh\n\n### Core Features\n{}\n\n## Data Models\n- User\n- Session\n- Core entities\n\n## Error Handling\n- HTTP status codes\n- Error response format\n- Rate limiting",
            user_input.project_name,
            user_input.project_description,
            user_input.key_features.iter().enumerate().map(|(i, f)| format!("- Feature {}: {}", i + 1, f)).collect::<Vec<_>>().join("\n")
        );
        
        Ok(content)
    }
    
    /// Generate Database Schema
    async fn generate_database_schema(&self, user_input: &UserInput, _existing_artifacts: &[ProjectArtifact]) -> Result<String, BMADError> {
        let content = format!(
            "# Database Schema: {}\n\n## Tables\n### users\n- id (UUID, Primary Key)\n- email (VARCHAR, Unique)\n- password_hash (VARCHAR)\n- created_at (TIMESTAMP)\n- updated_at (TIMESTAMP)\n\n### sessions\n- id (UUID, Primary Key)\n- user_id (UUID, Foreign Key)\n- token (VARCHAR)\n- expires_at (TIMESTAMP)\n\n## Indexes\n- users.email\n- sessions.token\n- sessions.user_id\n\n## Relationships\n- users -> sessions (1:many)\n\n## Constraints\n- Email uniqueness\n- Token uniqueness\n- Foreign key constraints",
            user_input.project_name
        );
        
        Ok(content)
    }
    
    /// Generate Deployment Plan
    async fn generate_deployment_plan(&self, user_input: &UserInput, _existing_artifacts: &[ProjectArtifact]) -> Result<String, BMADError> {
        let content = format!(
            "# Deployment Plan: {}\n\n## Infrastructure\n- Cloud provider: AWS/GCP/Azure\n- Container orchestration: Kubernetes\n- CI/CD: GitHub Actions\n\n## Environments\n- Development\n- Staging\n- Production\n\n## Deployment Strategy\n- Blue-green deployment\n- Rolling updates\n- Canary releases\n\n## Monitoring\n- Application metrics\n- Infrastructure metrics\n- Log aggregation\n- Alerting",
            user_input.project_name
        );
        
        Ok(content)
    }
    
    /// Generate Testing Strategy
    async fn generate_testing_strategy(&self, user_input: &UserInput, _existing_artifacts: &[ProjectArtifact]) -> Result<String, BMADError> {
        let content = format!(
            "# Testing Strategy: {}\n\n## Test Types\n- Unit tests\n- Integration tests\n- End-to-end tests\n- Performance tests\n- Security tests\n\n## Test Coverage\n- Target: 80%+\n- Critical paths: 100%\n\n## Testing Tools\n- Jest (Unit tests)\n- Playwright (E2E tests)\n- Artillery (Performance tests)\n\n## Test Data\n- Test fixtures\n- Mock data\n- Test databases",
            user_input.project_name
        );
        
        Ok(content)
    }
    
    /// Generate Security Plan
    async fn generate_security_plan(&self, user_input: &UserInput, _existing_artifacts: &[ProjectArtifact]) -> Result<String, BMADError> {
        let content = format!(
            "# Security Plan: {}\n\n## Security Requirements\n- Authentication\n- Authorization\n- Data encryption\n- API security\n\n## Security Measures\n- HTTPS/TLS\n- Input validation\n- SQL injection prevention\n- XSS protection\n- CSRF protection\n\n## Security Testing\n- Vulnerability scanning\n- Penetration testing\n- Code security review\n\n## Compliance\n- GDPR compliance\n- Data privacy\n- Audit logging",
            user_input.project_name
        );
        
        Ok(content)
    }
    
    /// Generate Performance Plan
    async fn generate_performance_plan(&self, user_input: &UserInput, _existing_artifacts: &[ProjectArtifact]) -> Result<String, BMADError> {
        let content = format!(
            "# Performance Plan: {}\n\n## Performance Requirements\n- Response time: < 200ms\n- Throughput: 1000 req/s\n- Availability: 99.9%\n\n## Performance Optimization\n- Caching strategies\n- Database optimization\n- CDN usage\n- Code optimization\n\n## Monitoring\n- Performance metrics\n- Alerting\n- Capacity planning\n\n## Load Testing\n- Stress testing\n- Volume testing\n- Spike testing",
            user_input.project_name
        );
        
        Ok(content)
    }
    
    /// Generate Documentation Plan
    async fn generate_documentation_plan(&self, user_input: &UserInput, _existing_artifacts: &[ProjectArtifact]) -> Result<String, BMADError> {
        let content = format!(
            "# Documentation Plan: {}\n\n## Documentation Types\n- API documentation\n- User guides\n- Developer documentation\n- Architecture documentation\n\n## Documentation Tools\n- Swagger/OpenAPI\n- GitBook\n- Markdown\n- TypeDoc\n\n## Documentation Maintenance\n- Version control\n- Regular updates\n- Review process\n- User feedback",
            user_input.project_name
        );
        
        Ok(content)
    }
    
    /// Get artifact title
    fn get_artifact_title(&self, artifact_type: &ArtifactType) -> String {
        match artifact_type {
            ArtifactType::PRD => "Product Requirements Document".to_string(),
            ArtifactType::TechnicalArchitecture => "Technical Architecture".to_string(),
            ArtifactType::UXBrief => "UX Design Brief".to_string(),
            ArtifactType::APISpecification => "API Specification".to_string(),
            ArtifactType::DatabaseSchema => "Database Schema".to_string(),
            ArtifactType::DeploymentPlan => "Deployment Plan".to_string(),
            ArtifactType::TestingStrategy => "Testing Strategy".to_string(),
            ArtifactType::SecurityPlan => "Security Plan".to_string(),
            ArtifactType::PerformancePlan => "Performance Plan".to_string(),
            ArtifactType::DocumentationPlan => "Documentation Plan".to_string(),
        }
    }
    
    /// Calculate complexity score
    fn calculate_complexity_score(&self, user_input: &UserInput) -> f32 {
        let mut score = 0.5; // Base score
        
        // Adjust based on number of features
        score += (user_input.key_features.len() as f32 * 0.1).min(0.3);
        
        // Adjust based on constraints
        score += (user_input.constraints.len() as f32 * 0.05).min(0.2);
        
        score.min(1.0)
    }
    
    /// Generate tags for artifact
    fn generate_tags(&self, artifact_type: &ArtifactType, user_input: &UserInput) -> Vec<String> {
        let mut tags = vec![artifact_type.to_string()];
        tags.extend(user_input.technical_preferences.clone());
        tags
    }
    
    /// Find dependencies for artifact
    fn find_dependencies(&self, artifact_type: &ArtifactType, existing_artifacts: &[ProjectArtifact]) -> Vec<Uuid> {
        let mut dependencies = Vec::new();
        
        match artifact_type {
            ArtifactType::TechnicalArchitecture => {
                // Architecture depends on PRD
                if let Some(prd) = existing_artifacts.iter().find(|a| matches!(a.artifact_type, ArtifactType::PRD)) {
                    dependencies.push(prd.id);
                }
            },
            ArtifactType::APISpecification => {
                // API spec depends on Architecture
                if let Some(arch) = existing_artifacts.iter().find(|a| matches!(a.artifact_type, ArtifactType::TechnicalArchitecture)) {
                    dependencies.push(arch.id);
                }
            },
            ArtifactType::DatabaseSchema => {
                // DB schema depends on Architecture
                if let Some(arch) = existing_artifacts.iter().find(|a| matches!(a.artifact_type, ArtifactType::TechnicalArchitecture)) {
                    dependencies.push(arch.id);
                }
            },
            _ => {}
        }
        
        dependencies
    }
    
    /// Review and refine artifacts (for lead agents)
    pub async fn review_and_refine_artifacts(&self, mut artifacts: Vec<ProjectArtifact>) -> Result<Vec<ProjectArtifact>, BMADError> {
        tracing::info!("🔍 Agent {} reviewing and refining artifacts", self.name);
        
        for artifact in &mut artifacts {
            // Update review status
            artifact.metadata.review_status = ReviewStatus::UnderReview;
            
            // Improve quality score
            artifact.metadata.quality_score = (artifact.metadata.quality_score + 0.1).min(1.0);
            
            // Add review comments
            artifact.content = format!("{}\n\n--- Reviewed by {} ---\nQuality improved through review process.", 
                artifact.content, self.name);
        }
        
        Ok(artifacts)
    }
}
