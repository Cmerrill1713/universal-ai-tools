/**
 * Security Vulnerability Detection Tests
 * Validates security scanning capabilities and vulnerability detection accuracy
 */

import { jest } from '@jest/globals';
import { securityScanningService } from '@/services/security-scanning-service';
import { autonomousCodeService } from '@/services/autonomous-code-service';
import { codeAnalysisService } from '@/services/code-analysis-service';
import { 
  mockSecurityVulnerabilities,
  generateMockGenerationRequest,
  generateMockVulnerability 
} from '../fixtures/test-data';

describe('Security Vulnerability Detection Tests', () => {
  jest.setTimeout(20000);

  describe('SQL Injection Detection', () => {
    const sqlInjectionSamples = [
      {
        name: 'Direct concatenation',
        code: `
          const query = "SELECT * FROM users WHERE id = " + userId;
          database.query(query);
        `,
        shouldDetect: true
      },
      {
        name: 'Template literal injection',
        code: `
          const query = \`SELECT * FROM users WHERE name = '\${userName}'\`;
          database.query(query);
        `,
        shouldDetect: true
      },
      {
        name: 'Safe parameterized query',
        code: `
          const query = "SELECT * FROM users WHERE id = $1";
          database.query(query, [userId]);
        `,
        shouldDetect: false
      },
      {
        name: 'Safe ORM usage',
        code: `
          const user = await User.findById(userId);
        `,
        shouldDetect: false
      }
    ];

    sqlInjectionSamples.forEach(({ name, code, shouldDetect }) => {
      it(`should ${shouldDetect ? 'detect' : 'not detect'} SQL injection in ${name}`, async () => {
        const request = {
          code,
          language: 'javascript',
          userId: 'security-test-user',
          vulnerabilityThreshold: 'medium' as const,
          scanTypes: [
            { type: 'injection' as const, options: {} },
            { type: 'static' as const, options: {} }
          ]
        };

        const result = await securityScanningService.scanCode(request);

        expect(result.success).toBe(true);
        
        const hasInjectionVuln = result.vulnerabilities.some(
          vuln => vuln.type === 'injection' && vuln.category === 'injection'
        );

        if (shouldDetect) {
          expect(hasInjectionVuln).toBe(true);
          expect(result.riskLevel).toBe('high');
          expect(result.overallSecurityScore).toBeLessThan(0.5);
        } else {
          expect(hasInjectionVuln).toBe(false);
          expect(result.overallSecurityScore).toBeGreaterThan(0.8);
        }

        console.log(`${name}: ${hasInjectionVuln ? 'VULNERABLE' : 'SAFE'} (Score: ${result.overallSecurityScore.toFixed(2)})`);
      });
    });
  });

  describe('XSS (Cross-Site Scripting) Detection', () => {
    const xssSamples = [
      {
        name: 'Direct innerHTML injection',
        code: `
          element.innerHTML = userInput;
        `,
        shouldDetect: true
      },
      {
        name: 'Document.write injection',
        code: `
          document.write(userData);
        `,
        shouldDetect: true
      },
      {
        name: 'Eval with user input',
        code: `
          eval(userCode);
        `,
        shouldDetect: true
      },
      {
        name: 'Safe textContent usage',
        code: `
          element.textContent = userInput;
        `,
        shouldDetect: false
      },
      {
        name: 'Safe template with escaping',
        code: `
          const sanitized = DOMPurify.sanitize(userInput);
          element.innerHTML = sanitized;
        `,
        shouldDetect: false
      }
    ];

    xssSamples.forEach(({ name, code, shouldDetect }) => {
      it(`should ${shouldDetect ? 'detect' : 'not detect'} XSS in ${name}`, async () => {
        const request = {
          code,
          language: 'javascript',
          userId: 'security-test-user',
          vulnerabilityThreshold: 'low' as const,
          scanTypes: [
            { type: 'injection' as const, options: {} },
            { type: 'static' as const, options: {} }
          ]
        };

        const result = await securityScanningService.scanCode(request);

        const hasXSSVuln = result.vulnerabilities.some(
          vuln => vuln.type === 'injection' && 
                  (vuln.description.toLowerCase().includes('xss') ||
                   vuln.description.toLowerCase().includes('script') ||
                   vuln.description.toLowerCase().includes('eval'))
        );

        if (shouldDetect) {
          expect(hasXSSVuln).toBe(true);
          expect(result.overallSecurityScore).toBeLessThan(0.6);
        } else {
          expect(hasXSSVuln).toBe(false);
        }

        console.log(`${name}: ${hasXSSVuln ? 'VULNERABLE' : 'SAFE'}`);
      });
    });
  });

  describe('Cryptographic Weakness Detection', () => {
    const cryptoSamples = [
      {
        name: 'MD5 hashing',
        code: `
          const hash = crypto.createHash('md5').update(password).digest('hex');
        `,
        shouldDetect: true,
        weakness: 'weak hash'
      },
      {
        name: 'SHA1 hashing',
        code: `
          const hash = crypto.createHash('sha1').update(data).digest('hex');
        `,
        shouldDetect: true,
        weakness: 'weak hash'
      },
      {
        name: 'Weak random number generation',
        code: `
          const token = Math.random().toString(36);
        `,
        shouldDetect: true,
        weakness: 'weak random'
      },
      {
        name: 'Strong bcrypt hashing',
        code: `
          const hash = await bcrypt.hash(password, 12);
        `,
        shouldDetect: false
      },
      {
        name: 'Strong SHA-256 with salt',
        code: `
          const salt = crypto.randomBytes(32);
          const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha256');
        `,
        shouldDetect: false
      },
      {
        name: 'Cryptographically secure random',
        code: `
          const token = crypto.randomBytes(32).toString('hex');
        `,
        shouldDetect: false
      }
    ];

    cryptoSamples.forEach(({ name, code, shouldDetect, weakness }) => {
      it(`should ${shouldDetect ? 'detect' : 'not detect'} ${weakness || 'crypto weakness'} in ${name}`, async () => {
        const request = {
          code,
          language: 'javascript',
          userId: 'security-test-user',
          vulnerabilityThreshold: 'medium' as const,
          scanTypes: [
            { type: 'crypto' as const, options: {} },
            { type: 'static' as const, options: {} }
          ]
        };

        const result = await securityScanningService.scanCode(request);

        const hasCryptoVuln = result.vulnerabilities.some(
          vuln => vuln.type === 'crypto' || vuln.category === 'crypto'
        );

        if (shouldDetect) {
          expect(hasCryptoVuln).toBe(true);
          expect(result.overallSecurityScore).toBeLessThan(0.7);
        } else {
          expect(hasCryptoVuln).toBe(false);
        }

        console.log(`${name}: ${hasCryptoVuln ? 'WEAK' : 'STRONG'} (Score: ${result.overallSecurityScore.toFixed(2)})`);
      });
    });
  });

  describe('Secrets Detection', () => {
    const secretsSamples = [
      {
        name: 'Hardcoded API key',
        code: `
          const apiKey = 'sk-1234567890abcdef1234567890abcdef';
          const config = { key: apiKey };
        `,
        shouldDetect: true
      },
      {
        name: 'Hardcoded JWT secret',
        code: `
          const jwtSecret = 'my-super-secret-jwt-key-12345';
          jwt.sign(payload, jwtSecret);
        `,
        shouldDetect: true
      },
      {
        name: 'Database credentials',
        code: `
          const dbConfig = {
            host: 'localhost',
            user: 'admin',
            password: 'admin123',
            database: 'myapp'
          };
        `,
        shouldDetect: true
      },
      {
        name: 'Safe environment variable usage',
        code: `
          const apiKey = process.env.API_KEY;
          const dbPassword = process.env.DB_PASSWORD;
        `,
        shouldDetect: false
      },
      {
        name: 'Safe vault usage',
        code: `
          const apiKey = await vaultService.getSecret('api_key');
        `,
        shouldDetect: false
      }
    ];

    secretsSamples.forEach(({ name, code, shouldDetect }) => {
      it(`should ${shouldDetect ? 'detect' : 'not detect'} secrets in ${name}`, async () => {
        const request = {
          code,
          language: 'javascript',
          userId: 'security-test-user',
          vulnerabilityThreshold: 'low' as const,
          scanTypes: [
            { type: 'secrets' as const, options: {} },
            { type: 'static' as const, options: {} }
          ]
        };

        const result = await securityScanningService.scanCode(request);

        const hasSecretsVuln = result.vulnerabilities.some(
          vuln => vuln.type === 'secrets' || vuln.category === 'secrets'
        );

        if (shouldDetect) {
          expect(hasSecretsVuln).toBe(true);
          expect(result.riskLevel).toBe('high');
        } else {
          expect(hasSecretsVuln).toBe(false);
        }

        console.log(`${name}: ${hasSecretsVuln ? 'SECRETS FOUND' : 'CLEAN'}`);
      });
    });
  });

  describe('Authentication and Authorization Vulnerabilities', () => {
    const authSamples = [
      {
        name: 'Missing authentication',
        code: `
          app.get('/admin/users', (req, res) => {
            const users = database.getAllUsers();
            res.json(users);
          });
        `,
        shouldDetect: true
      },
      {
        name: 'Weak JWT validation',
        code: `
          const token = req.headers.authorization;
          const decoded = jwt.decode(token); // No verification!
          req.user = decoded;
        `,
        shouldDetect: true
      },
      {
        name: 'Privilege escalation risk',
        code: `
          app.put('/user/:id', (req, res) => {
            // No check if user can modify this ID
            database.updateUser(req.params.id, req.body);
          });
        `,
        shouldDetect: true
      },
      {
        name: 'Proper authentication middleware',
        code: `
          app.get('/admin/users', authenticateToken, authorizeAdmin, (req, res) => {
            const users = database.getAllUsers();
            res.json(users);
          });
        `,
        shouldDetect: false
      },
      {
        name: 'Proper JWT validation',
        code: `
          const token = req.headers.authorization?.split(' ')[1];
          const decoded = jwt.verify(token, process.env.JWT_SECRET);
          req.user = decoded;
        `,
        shouldDetect: false
      }
    ];

    authSamples.forEach(({ name, code, shouldDetect }) => {
      it(`should ${shouldDetect ? 'detect' : 'not detect'} auth issues in ${name}`, async () => {
        const request = {
          code,
          language: 'javascript',
          userId: 'security-test-user',
          vulnerabilityThreshold: 'medium' as const,
          scanTypes: [
            { type: 'auth' as const, options: {} },
            { type: 'static' as const, options: {} }
          ]
        };

        const result = await securityScanningService.scanCode(request);

        const hasAuthVuln = result.vulnerabilities.some(
          vuln => vuln.type === 'auth' || 
                  vuln.description.toLowerCase().includes('auth') ||
                  vuln.description.toLowerCase().includes('permission')
        );

        if (shouldDetect) {
          expect(hasAuthVuln).toBe(true);
        } else {
          expect(hasAuthVuln).toBe(false);
        }

        console.log(`${name}: ${hasAuthVuln ? 'VULNERABLE' : 'SECURE'}`);
      });
    });
  });

  describe('Comprehensive Vulnerability Scanning', () => {
    it('should detect multiple vulnerability types in complex code', async () => {
      const complexVulnerableCode = `
        const express = require('express');
        const crypto = require('crypto');
        const app = express();
        
        // Hardcoded secrets
        const apiKey = 'sk-1234567890abcdef';
        const jwtSecret = 'my-secret-key';
        
        // SQL injection vulnerability
        app.get('/user/:id', (req, res) => {
          const query = "SELECT * FROM users WHERE id = " + req.params.id;
          
          database.query(query, (err, results) => {
            if (err) {
              // Information disclosure
              res.status(500).json({ error: err.message, stack: err.stack });
            } else {
              res.json(results);
            }
          });
        });
        
        // Weak cryptography
        app.post('/login', (req, res) => {
          const { username, password } = req.body;
          const hashedPassword = crypto.createHash('md5').update(password).digest('hex');
          
          // Another SQL injection
          const authQuery = \`SELECT * FROM users WHERE username = '\${username}' AND password = '\${hashedPassword}'\`;
          
          database.query(authQuery, (err, results) => {
            if (results.length > 0) {
              // Weak JWT
              const token = jwt.sign({ user: username }, 'hardcoded-secret');
              res.json({ token });
            } else {
              res.status(401).json({ error: 'Invalid credentials' });
            }
          });
        });
        
        // XSS vulnerability
        app.get('/profile/:username', (req, res) => {
          const username = req.params.username;
          const html = \`<h1>Welcome \${username}</h1>\`;
          res.send(html);
        });
        
        // Command injection
        app.post('/backup', (req, res) => {
          const filename = req.body.filename;
          const command = \`tar -czf \${filename}.tar.gz /data\`;
          exec(command, (err, stdout) => {
            res.json({ output: stdout });
          });
        });
      `;

      const request = {
        code: complexVulnerableCode,
        language: 'javascript',
        userId: 'security-test-user',
        vulnerabilityThreshold: 'low' as const,
        scanTypes: [
          { type: 'static' as const, options: {} },
          { type: 'injection' as const, options: {} },
          { type: 'secrets' as const, options: {} },
          { type: 'crypto' as const, options: {} },
          { type: 'auth' as const, options: {} }
        ]
      };

      const result = await securityScanningService.scanCode(request);

      expect(result.success).toBe(true);
      expect(result.vulnerabilities.length).toBeGreaterThan(5);
      expect(result.riskLevel).toBe('high');
      expect(result.overallSecurityScore).toBeLessThan(0.3);

      // Check for specific vulnerability types
      const vulnTypes = result.vulnerabilities.map(v => v.type);
      expect(vulnTypes).toContain('injection');
      expect(vulnTypes).toContain('secrets');
      expect(vulnTypes).toContain('crypto');

      console.log(`Complex vulnerable code analysis:`);
      console.log(`  Vulnerabilities found: ${result.vulnerabilities.length}`);
      console.log(`  Risk level: ${result.riskLevel}`);
      console.log(`  Security score: ${result.overallSecurityScore.toFixed(2)}`);
      
      result.vulnerabilities.forEach((vuln, i) => {
        console.log(`  ${i + 1}. ${vuln.severity.toUpperCase()}: ${vuln.title} (${vuln.type})`);
      });
    });

    it('should provide automatic fixes for common vulnerabilities', async () => {
      const fixableVulnerableCode = `
        const query = "SELECT * FROM users WHERE id = " + userId;
        const password = crypto.createHash('md5').update(pass).digest('hex');
        const secret = 'my-hardcoded-secret';
      `;

      const request = {
        code: fixableVulnerableCode,
        language: 'javascript',
        userId: 'security-test-user',
        vulnerabilityThreshold: 'medium' as const
      };

      const result = await securityScanningService.scanCode(request);

      expect(result.success).toBe(true);
      expect(result.vulnerabilities.length).toBeGreaterThan(0);
      expect(result.automaticFixes.length).toBeGreaterThan(0);

      // Check that fixes are provided for fixable vulnerabilities
      const fixableVulns = result.vulnerabilities.filter(v => v.fixable);
      expect(fixableVulns.length).toBeGreaterThan(0);

      console.log(`Automatic fixes available:`);
      result.automaticFixes.forEach((fix, i) => {
        console.log(`  ${i + 1}. ${fix.fixType}: ${fix.description} (confidence: ${fix.confidence})`);
      });
    });
  });

  describe('Integration with Code Generation', () => {
    it('should prevent generation of vulnerable code', async () => {
      const vulnerableRequest = generateMockGenerationRequest({
        prompt: 'Create a login endpoint that takes username and password and queries the database directly using string concatenation',
        language: 'javascript',
        generationType: 'completion',
        securityRequirements: {
          vulnerabilityThreshold: 'zero-tolerance' as const,
          requiredScans: ['injection', 'static'],
          complianceStandards: ['owasp']
        },
        enableSecurityValidation: true
      });

      const result = await autonomousCodeService.generateCode(vulnerableRequest);

      // Should either fix the vulnerabilities or fail generation
      if (result.success) {
        expect(result.securityValidation.passed).toBe(true);
        expect(result.securityValidation.vulnerabilities.length).toBe(0);
        expect(result.generatedCode).not.toContain("' + ");
        expect(result.generatedCode).not.toContain('` + ');
      } else {
        expect(result.securityValidation.passed).toBe(false);
        expect(result.securityValidation.vulnerabilities.length).toBeGreaterThan(0);
      }

      console.log(`Vulnerable generation request result:`);
      console.log(`  Success: ${result.success}`);
      console.log(`  Security passed: ${result.securityValidation.passed}`);
      console.log(`  Vulnerabilities: ${result.securityValidation.vulnerabilities.length}`);
    });

    it('should generate secure alternatives when vulnerabilities detected', async () => {
      const secureRequest = generateMockGenerationRequest({
        prompt: 'Create a secure user authentication system with proper password hashing and SQL injection prevention',
        language: 'javascript',
        generationType: 'completion',
        securityRequirements: {
          vulnerabilityThreshold: 'low' as const,
          requiredScans: ['injection', 'crypto', 'auth'],
          complianceStandards: ['owasp']
        },
        enableSecurityValidation: true
      });

      const result = await autonomousCodeService.generateCode(secureRequest);

      expect(result.success).toBe(true);
      expect(result.securityValidation.passed).toBe(true);
      expect(result.securityValidation.securityScore).toBeGreaterThan(0.8);

      // Should include secure practices
      expect(result.generatedCode).toMatch(/bcrypt|scrypt|argon2|pbkdf2/i); // Strong password hashing
      expect(result.generatedCode).toMatch(/\$1|\$2|\?\s*|\[|\]|prepare/i); // Parameterized queries
      expect(result.generatedCode).not.toContain('md5');
      expect(result.generatedCode).not.toContain("' + ");

      console.log(`Secure generation result:`);
      console.log(`  Security score: ${result.securityValidation.securityScore.toFixed(2)}`);
      console.log(`  Risk level: ${result.securityValidation.riskLevel}`);
    });
  });

  describe('Compliance Validation', () => {
    const complianceStandards = ['owasp', 'pci-dss', 'hipaa'];

    complianceStandards.forEach(standard => {
      it(`should validate ${standard.toUpperCase()} compliance`, async () => {
        const complianceCode = `
          const express = require('express');
          const bcrypt = require('bcrypt');
          const rateLimit = require('express-rate-limit');
          
          const app = express();
          
          // Rate limiting
          const loginLimiter = rateLimit({
            windowMs: 15 * 60 * 1000,
            max: 5
          });
          
          // Secure authentication
          app.post('/login', loginLimiter, async (req, res) => {
            const { username, password } = req.body;
            
            const user = await User.findOne({ username });
            if (!user) {
              return res.status(401).json({ error: 'Invalid credentials' });
            }
            
            const isValid = await bcrypt.compare(password, user.passwordHash);
            if (!isValid) {
              return res.status(401).json({ error: 'Invalid credentials' });
            }
            
            const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, { expiresIn: '1h' });
            res.json({ token });
          });
        `;

        const request = {
          code: complianceCode,
          language: 'javascript',
          userId: 'compliance-test-user',
          vulnerabilityThreshold: 'low' as const,
          complianceStandards: [standard]
        };

        const result = await securityScanningService.scanCode(request);

        expect(result.success).toBe(true);
        expect(result.complianceReport).toBeDefined();
        expect(result.complianceReport.standards).toBeDefined();

        const standardReport = result.complianceReport.standards.find(s => s.name === standard);
        if (standardReport) {
          expect(standardReport.compliant).toBeDefined();
          expect(standardReport.score).toBeGreaterThan(0);
        }

        console.log(`${standard.toUpperCase()} compliance: ${result.complianceReport.overallCompliance.toFixed(2)}`);
      });
    });
  });

  describe('Performance and Accuracy', () => {
    it('should maintain high detection accuracy', async () => {
      const testCases = [
        { code: "const q = 'SELECT * FROM users WHERE id = ' + id;", vulnerable: true },
        { code: "const q = 'SELECT * FROM users WHERE id = $1';", vulnerable: false },
        { code: "element.innerHTML = userInput;", vulnerable: true },
        { code: "element.textContent = userInput;", vulnerable: false },
        { code: "const h = crypto.createHash('md5');", vulnerable: true },
        { code: "const h = await bcrypt.hash(password, 12);", vulnerable: false }
      ];

      let correctDetections = 0;
      const results = [];

      for (const testCase of testCases) {
        const request = {
          code: testCase.code,
          language: 'javascript',
          userId: 'accuracy-test-user',
          vulnerabilityThreshold: 'medium' as const
        };

        const result = await securityScanningService.scanCode(request);
        const detected = result.vulnerabilities.length > 0;
        const correct = detected === testCase.vulnerable;

        if (correct) correctDetections++;

        results.push({
          code: testCase.code.substring(0, 50) + '...',
          expected: testCase.vulnerable ? 'VULNERABLE' : 'SAFE',
          detected: detected ? 'VULNERABLE' : 'SAFE',
          correct
        });
      }

      const accuracy = correctDetections / testCases.length * 100;

      console.log(`Detection accuracy: ${accuracy.toFixed(1)}%`);
      results.forEach(result => {
        const status = result.correct ? '✅' : '❌';
        console.log(`  ${status} ${result.expected} -> ${result.detected}: ${result.code}`);
      });

      expect(accuracy).toBeGreaterThan(80); // At least 80% accuracy
    });

    it('should handle edge cases and false positives', async () => {
      const edgeCases = [
        {
          name: 'Safe dynamic query building',
          code: `
            const allowedFields = ['name', 'email', 'created_at'];
            const field = allowedFields.includes(req.query.field) ? req.query.field : 'name';
            const query = 'SELECT ' + field + ' FROM users WHERE id = $1';
          `,
          shouldDetect: false
        },
        {
          name: 'Template in comments',
          code: `
            // Example: "SELECT * FROM users WHERE id = " + userId
            const query = "SELECT * FROM users WHERE id = $1";
            database.query(query, [userId]);
          `,
          shouldDetect: false
        },
        {
          name: 'Log message with concatenation',
          code: `
            logger.info("Processing user request for ID: " + userId);
            const query = "SELECT * FROM users WHERE id = $1";
          `,
          shouldDetect: false
        }
      ];

      for (const { name, code, shouldDetect } of edgeCases) {
        const request = {
          code,
          language: 'javascript',
          userId: 'edge-case-test-user',
          vulnerabilityThreshold: 'medium' as const
        };

        const result = await securityScanningService.scanCode(request);
        const detected = result.vulnerabilities.length > 0;

        if (shouldDetect) {
          expect(detected).toBe(true);
        } else {
          expect(detected).toBe(false);
        }

        console.log(`Edge case - ${name}: ${detected ? 'DETECTED' : 'CLEAN'} (expected: ${shouldDetect ? 'DETECTED' : 'CLEAN'})`);
      }
    });
  });
});