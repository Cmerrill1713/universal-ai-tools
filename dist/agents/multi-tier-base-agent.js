import { kokoroTTS } from '@/services/kokoro-tts-service';
import { multiTierLLM } from '@/services/multi-tier-llm-service';
import { log, LogContext } from '@/utils/logger';
import { BaseAgent } from './base-agent';
export class MultiTierBaseAgent extends BaseAgent {
    preferredTier = 2;
    voiceEnabled = false;
    preferredVoice;
    constructor(config) {
        super(config);
        this.voiceEnabled = process.env.ENABLE_VOICE_COMMANDS === 'true';
    }
    async process(context) {
        const startTime = Date.now();
        try {
            const systemPrompt = this.buildSystemPrompt();
            const userPrompt = this.buildUserPrompt(context);
            const fullPrompt = `${systemPrompt}\n\nUser Request: ${userPrompt}`;
            const agentContext = {
                agentName: this.config.name,
                capabilities: this.config.capabilities.map((c) => c.name),
                preferredTier: this.preferredTier,
                domain: this.getDomain(),
                ...context,
            };
            const result = await multiTierLLM.execute(fullPrompt, agentContext);
            let audioPath;
            if (this.voiceEnabled) {
                try {
                    const ttsResponse = await kokoroTTS.speakAgentResponse(this.config.name, result.response, this.preferredVoice);
                    audioPath = ttsResponse.audioPath;
                }
                catch (error) {
                    log.warn('âš ï¸ Voice generation failed', LogContext.AGENT, { agentName: this.config.name });
                }
            }
            const confidence = this.calculateTierConfidence(result.metadata.tier, result.metadata.executionTime, result.metadata.classification.complexity);
            const executionTime = Date.now() - startTime;
            const agentResponse = this.createSuccessResponse(this.parseAgentResponse(result.response), `Response generated by ${this.config.name} using ${result.metadata.modelUsed}`, confidence, `Multi-tier response using ${result.metadata.modelUsed} (tier ${result.metadata.tier})`);
            log.info(`âœ… Multi-tier agent execution completed`, LogContext.AGENT, {
                agentName: this.config.name,
                tier: result.metadata.tier,
                model: result.metadata.modelUsed,
                executionTime: `${executionTime}ms`,
                confidence,
            });
            return agentResponse;
        }
        catch (error) {
            log.error(`âŒ Multi-tier agent execution failed`, LogContext.AGENT, {
                agentName: this.config.name,
                error: error instanceof Error ? error.message : String(error),
            });
            return this.createErrorResponse(`Agent execution failed: ${error instanceof Error ? error.message : String(error)}`, {
                agentName: this.config.name,
                timestamp: new Date().toISOString(),
                executionTime: Date.now() - startTime,
                error: true,
            });
        }
    }
    buildUserPrompt(context) {
        let prompt = context.userRequest || 'Please provide assistance.';
        if (context.workingDirectory) {
            prompt += `\n\nWorking Directory: ${context.workingDirectory}`;
        }
        if (context.userId) {
            prompt += `\nUser ID: ${context.userId}`;
        }
        const additionalContext = this.getAdditionalContext(context);
        if (additionalContext) {
            prompt += `\n\nAdditional Context: ${additionalContext}`;
        }
        return prompt;
    }
    getDomain() {
        const capabilities = this.config.capabilities.map((c) => c.name);
        if (capabilities.some((c) => c.includes('code')))
            return 'code';
        if (capabilities.some((c) => c.includes('reasoning') || c.includes('analysis'))) {
            return 'reasoning';
        }
        if (capabilities.some((c) => c.includes('creative')))
            return 'creative';
        return 'general';
    }
    getAdditionalContext(context) {
        return null;
    }
    parseAgentResponse(response) {
        try {
            return JSON.parse(response);
        }
        catch {
            return {
                type: 'text',
                content: response,
                summary: this.extractSummary(response),
            };
        }
    }
    extractSummary(response) {
        const sentences = response.split(/[.!?]+/).filter((s) => s.trim().length > 0);
        return sentences.length > 0 ? `${sentences[0]?.trim()}.` : 'Response generated';
    }
    calculateTierConfidence(tier, executionTime, complexity) {
        let baseConfidence = 0.7;
        switch (tier) {
            case 1:
                baseConfidence = 0.8;
                break;
            case 2:
                baseConfidence = 0.85;
                break;
            case 3:
                baseConfidence = 0.9;
                break;
            case 4:
                baseConfidence = 0.95;
                break;
        }
        if (complexity === 'simple' && executionTime < 1000) {
            baseConfidence += 0.05;
        }
        else if (complexity === 'complex' && executionTime > 5000) {
            baseConfidence += 0.03;
        }
        return Math.max(0.1, Math.min(1.0, baseConfidence));
    }
    createErrorResponse(message, metadata) {
        return {
            success: false,
            data: null,
            confidence: 0,
            message,
            reasoning: `Error in ${this.config.name}: ${message}`,
            metadata: {
                ...metadata,
                error: true,
            },
        };
    }
    enableVoice(voiceId) {
        this.voiceEnabled = true;
        this.preferredVoice = voiceId;
        log.info(`ðŸŽ¤ Voice enabled for ${this.config.name}`, LogContext.AGENT, { voice: voiceId });
    }
    setPreferredTier(tier) {
        this.preferredTier = Math.max(1, Math.min(4, tier));
        log.info(`ðŸŽ¯ Preferred tier set for ${this.config.name}`, LogContext.AGENT, {
            tier: this.preferredTier,
        });
    }
    getPerformanceMetrics() {
        return {
            averageExecutionTime: 2000,
            preferredTier: this.preferredTier,
            voiceEnabled: this.voiceEnabled,
            successRate: 0.95,
        };
    }
}
export default MultiTierBaseAgent;
//# sourceMappingURL=multi-tier-base-agent.js.map