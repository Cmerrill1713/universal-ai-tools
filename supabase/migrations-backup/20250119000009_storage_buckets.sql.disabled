-- Set up Storage Buckets for audio files, avatars, and other media

-- Create storage buckets
INSERT INTO storage.buckets (id, name, public, avif_autodetection, file_size_limit, allowed_mime_types)
VALUES 
    ('voice-inputs', 'voice-inputs', false, false, 52428800, ARRAY['audio/webm', 'audio/wav', 'audio/mp3', 'audio/ogg']),
    ('voice-outputs', 'voice-outputs', true, false, 52428800, ARRAY['audio/mp3', 'audio/wav', 'audio/ogg']),
    ('avatars', 'avatars', true, true, 10485760, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'model/gltf-binary', 'model/gltf+json']),
    ('conversation-exports', 'conversation-exports', false, false, 104857600, ARRAY['application/json', 'text/plain', 'application/pdf']),
    ('model-checkpoints', 'model-checkpoints', false, false, 5368709120, ARRAY['application/octet-stream', 'application/x-tar', 'application/zip'])
ON CONFLICT (id) DO UPDATE SET
    public = EXCLUDED.public,
    avif_autodetection = EXCLUDED.avif_autodetection,
    file_size_limit = EXCLUDED.file_size_limit,
    allowed_mime_types = EXCLUDED.allowed_mime_types;

-- Create RLS policies for storage buckets

-- Voice inputs: Users can upload their own voice recordings
CREATE POLICY "Users can upload voice inputs" ON storage.objects
    FOR INSERT TO authenticated
    WITH CHECK (bucket_id = 'voice-inputs' AND auth.uid() = owner);

CREATE POLICY "Users can view own voice inputs" ON storage.objects
    FOR SELECT TO authenticated
    USING (bucket_id = 'voice-inputs' AND auth.uid() = owner);

CREATE POLICY "Users can delete own voice inputs" ON storage.objects
    FOR DELETE TO authenticated
    USING (bucket_id = 'voice-inputs' AND auth.uid() = owner);

-- Voice outputs: Public read, authenticated write
CREATE POLICY "Anyone can view voice outputs" ON storage.objects
    FOR SELECT TO public
    USING (bucket_id = 'voice-outputs');

CREATE POLICY "Authenticated users can upload voice outputs" ON storage.objects
    FOR INSERT TO authenticated
    WITH CHECK (bucket_id = 'voice-outputs');

-- Avatars: Public read, authenticated write
CREATE POLICY "Anyone can view avatars" ON storage.objects
    FOR SELECT TO public
    USING (bucket_id = 'avatars');

CREATE POLICY "Authenticated users can upload avatars" ON storage.objects
    FOR INSERT TO authenticated
    WITH CHECK (bucket_id = 'avatars');

CREATE POLICY "Users can update own avatars" ON storage.objects
    FOR UPDATE TO authenticated
    USING (bucket_id = 'avatars' AND auth.uid() = owner);

-- Conversation exports: Private to user
CREATE POLICY "Users can manage own exports" ON storage.objects
    FOR ALL TO authenticated
    USING (bucket_id = 'conversation-exports' AND auth.uid() = owner)
    WITH CHECK (bucket_id = 'conversation-exports' AND auth.uid() = owner);

-- Model checkpoints: Service role only
CREATE POLICY "Service role can manage model checkpoints" ON storage.objects
    FOR ALL TO service_role
    USING (bucket_id = 'model-checkpoints');

-- Create function to generate presigned upload URL
CREATE OR REPLACE FUNCTION generate_upload_url(
    p_bucket TEXT,
    p_path TEXT,
    p_expires_in INT DEFAULT 3600
) RETURNS JSONB AS $$
DECLARE
    v_url TEXT;
    v_token TEXT;
BEGIN
    -- Generate a secure token
    v_token := encode(gen_random_bytes(32), 'base64');
    
    -- Create the upload URL (simplified version)
    v_url := format('%s/storage/v1/object/%s/%s?token=%s',
        current_setting('app.settings.supabase_url', true),
        p_bucket,
        p_path,
        v_token
    );
    
    -- Store token with expiration
    INSERT INTO analytics_events (event_type, metadata)
    VALUES ('upload_url_generated', jsonb_build_object(
        'bucket', p_bucket,
        'path', p_path,
        'expires_at', NOW() + (p_expires_in || ' seconds')::interval,
        'token', v_token
    ));
    
    RETURN jsonb_build_object(
        'url', v_url,
        'expires_at', NOW() + (p_expires_in || ' seconds')::interval
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to clean up old files
CREATE OR REPLACE FUNCTION cleanup_old_storage_files()
RETURNS INT AS $$
DECLARE
    deleted_count INT := 0;
BEGIN
    -- Delete voice inputs older than 7 days
    DELETE FROM storage.objects
    WHERE bucket_id = 'voice-inputs'
    AND created_at < NOW() - INTERVAL '7 days';
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    -- Delete conversation exports older than 30 days
    DELETE FROM storage.objects
    WHERE bucket_id = 'conversation-exports'
    AND created_at < NOW() - INTERVAL '30 days';
    
    GET DIAGNOSTICS deleted_count = deleted_count + ROW_COUNT;
    
    -- Log cleanup
    INSERT INTO analytics_events (event_type, metadata)
    VALUES ('storage_cleanup', jsonb_build_object(
        'deleted_files', deleted_count,
        'cleanup_time', NOW()
    ));
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create view for storage usage statistics
CREATE OR REPLACE VIEW storage_usage_stats AS
SELECT 
    bucket_id,
    COUNT(*) as file_count,
    SUM(metadata->>'size')::BIGINT as total_size_bytes,
    pg_size_pretty(SUM((metadata->>'size')::BIGINT)) as total_size_human,
    AVG((metadata->>'size')::BIGINT) as avg_file_size,
    MAX(created_at) as last_upload,
    MIN(created_at) as first_upload
FROM storage.objects
GROUP BY bucket_id;

-- Create function to get user's storage usage
CREATE OR REPLACE FUNCTION get_user_storage_usage(p_user_id UUID DEFAULT NULL)
RETURNS JSONB AS $$
DECLARE
    v_user_id UUID;
    v_result JSONB;
BEGIN
    v_user_id := COALESCE(p_user_id, auth.uid());
    
    SELECT jsonb_build_object(
        'voice_inputs', jsonb_build_object(
            'count', COUNT(*) FILTER (WHERE bucket_id = 'voice-inputs'),
            'size_bytes', COALESCE(SUM((metadata->>'size')::BIGINT) FILTER (WHERE bucket_id = 'voice-inputs'), 0),
            'size_human', pg_size_pretty(COALESCE(SUM((metadata->>'size')::BIGINT) FILTER (WHERE bucket_id = 'voice-inputs'), 0))
        ),
        'voice_outputs', jsonb_build_object(
            'count', COUNT(*) FILTER (WHERE bucket_id = 'voice-outputs'),
            'size_bytes', COALESCE(SUM((metadata->>'size')::BIGINT) FILTER (WHERE bucket_id = 'voice-outputs'), 0),
            'size_human', pg_size_pretty(COALESCE(SUM((metadata->>'size')::BIGINT) FILTER (WHERE bucket_id = 'voice-outputs'), 0))
        ),
        'avatars', jsonb_build_object(
            'count', COUNT(*) FILTER (WHERE bucket_id = 'avatars'),
            'size_bytes', COALESCE(SUM((metadata->>'size')::BIGINT) FILTER (WHERE bucket_id = 'avatars'), 0),
            'size_human', pg_size_pretty(COALESCE(SUM((metadata->>'size')::BIGINT) FILTER (WHERE bucket_id = 'avatars'), 0))
        ),
        'exports', jsonb_build_object(
            'count', COUNT(*) FILTER (WHERE bucket_id = 'conversation-exports'),
            'size_bytes', COALESCE(SUM((metadata->>'size')::BIGINT) FILTER (WHERE bucket_id = 'conversation-exports'), 0),
            'size_human', pg_size_pretty(COALESCE(SUM((metadata->>'size')::BIGINT) FILTER (WHERE bucket_id = 'conversation-exports'), 0))
        ),
        'total_size_bytes', COALESCE(SUM((metadata->>'size')::BIGINT), 0),
        'total_size_human', pg_size_pretty(COALESCE(SUM((metadata->>'size')::BIGINT), 0))
    ) INTO v_result
    FROM storage.objects
    WHERE owner = v_user_id;
    
    RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION generate_upload_url TO authenticated;
GRANT EXECUTE ON FUNCTION get_user_storage_usage TO authenticated;
GRANT SELECT ON storage_usage_stats TO authenticated;

-- Schedule cleanup job (to be activated with pg_cron)
INSERT INTO scheduled_jobs (name, schedule, command, active)
VALUES (
    'cleanup_storage',
    '0 3 * * *', -- 3 AM daily
    'SELECT cleanup_old_storage_files()',
    true
);