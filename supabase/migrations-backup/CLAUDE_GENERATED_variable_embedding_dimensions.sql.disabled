-- ========================================
-- CLAUDE GENERATED MIGRATION - Variable Embedding Dimensions
-- ========================================
-- Generated by: Claude (Anthropic AI Assistant)
-- Date: 2025-07-17
-- Purpose: Support both OpenAI (1536) and Ollama (768) embedding dimensions
-- SAFETY: This migration only MODIFIES column types to be more flexible
--         NO existing data is deleted or lost
-- ========================================

-- CLAUDE TAG: COLUMN MODIFICATION - Allow variable embedding dimensions
-- Update ai_memories table to support variable vector dimensions
ALTER TABLE ai_memories 
ALTER COLUMN embedding TYPE vector; -- Remove dimension constraint

-- CLAUDE TAG: COLUMN MODIFICATION - Update semantic_clusters for variable dimensions
-- Update semantic_clusters table to support variable vector dimensions
ALTER TABLE semantic_clusters 
ALTER COLUMN representative_embedding TYPE vector; -- Remove dimension constraint

-- CLAUDE TAG: FUNCTION UPDATE - search_semantic_clusters for variable dimensions
-- Update search_semantic_clusters function to work with variable dimensions
CREATE OR REPLACE FUNCTION search_semantic_clusters(
  query_embedding vector,
  similarity_threshold float DEFAULT 0.7,
  max_clusters int DEFAULT 3,
  agent_filter text DEFAULT NULL,
  category_filter text DEFAULT NULL
)
RETURNS TABLE (
  cluster_id text,
  cluster_label text,
  similarity float,
  memory_count bigint,
  representative_embedding vector,
  avg_importance float
) 
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    sc.cluster_id::text,
    sc.cluster_label,
    (1 - (query_embedding <=> sc.representative_embedding))::float as similarity,
    sc.memory_count,
    sc.representative_embedding,
    sc.avg_importance
  FROM semantic_clusters sc
  WHERE 
    (1 - (query_embedding <=> sc.representative_embedding)) >= similarity_threshold
    AND (agent_filter IS NULL OR sc.dominant_agent = agent_filter)
    AND (category_filter IS NULL OR sc.dominant_category = category_filter)
    AND sc.memory_count > 0
    -- Only compare embeddings with the same dimensions
    AND vector_dims(sc.representative_embedding) = vector_dims(query_embedding)
  ORDER BY (query_embedding <=> sc.representative_embedding) ASC
  LIMIT max_clusters;
END;
$$;

-- CLAUDE TAG: FUNCTION UPDATE - search_within_clusters for variable dimensions
-- Update search_within_clusters function to work with variable dimensions
CREATE OR REPLACE FUNCTION search_within_clusters(
  query_embedding vector,
  cluster_ids text[],
  similarity_threshold float DEFAULT 0.6,
  max_results int DEFAULT 20,
  agent_filter text DEFAULT NULL,
  category_filter text DEFAULT NULL
)
RETURNS TABLE (
  id uuid,
  content text,
  service_id text,
  memory_type text,
  similarity float,
  importance_score float,
  cluster_id text,
  access_count int,
  metadata jsonb
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    m.id,
    m.content,
    m.service_id,
    m.memory_type,
    (1 - (query_embedding <=> m.embedding))::float as similarity,
    m.importance_score,
    sc.cluster_id::text,
    m.access_count,
    m.metadata
  FROM ai_memories m
  JOIN semantic_clusters sc ON sc.cluster_id = ANY(
    SELECT unnest(string_to_array(m.memory_category, ','))::uuid
    WHERE m.memory_category IS NOT NULL
  )
  WHERE 
    sc.cluster_id::text = ANY(cluster_ids)
    AND (1 - (query_embedding <=> m.embedding)) >= similarity_threshold
    AND (agent_filter IS NULL OR m.service_id = agent_filter)
    AND (category_filter IS NULL OR m.memory_category LIKE '%' || category_filter || '%')
    -- Only compare embeddings with the same dimensions
    AND vector_dims(m.embedding) = vector_dims(query_embedding)
  ORDER BY 
    (query_embedding <=> m.embedding) ASC,
    m.importance_score DESC
  LIMIT max_results;
END;
$$;

-- CLAUDE TAG: FUNCTION UPDATE - search_similar_memories for variable dimensions
-- Update search_similar_memories function to work with variable dimensions
CREATE OR REPLACE FUNCTION search_similar_memories(
  query_embedding vector,
  similarity_threshold float DEFAULT 0.7,
  max_results int DEFAULT 20,
  category_filter text DEFAULT NULL,
  agent_filter text DEFAULT NULL,
  exclude_ids uuid[] DEFAULT NULL
)
RETURNS TABLE (
  memory_id uuid,
  content text,
  service_id text,
  memory_type text,
  similarity float,
  importance_score float,
  access_count int,
  metadata jsonb,
  keywords text[],
  related_entities jsonb
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    m.id as memory_id,
    m.content,
    m.service_id,
    m.memory_type,
    (1 - (query_embedding <=> m.embedding))::float as similarity,
    m.importance_score,
    m.access_count,
    m.metadata,
    m.keywords,
    m.related_entities
  FROM ai_memories m
  WHERE 
    (1 - (query_embedding <=> m.embedding)) >= similarity_threshold
    AND (category_filter IS NULL OR m.memory_category LIKE '%' || category_filter || '%')
    AND (agent_filter IS NULL OR m.service_id = agent_filter)
    AND (exclude_ids IS NULL OR NOT (m.id = ANY(exclude_ids)))
    -- Only compare embeddings with the same dimensions
    AND vector_dims(m.embedding) = vector_dims(query_embedding)
  ORDER BY 
    (query_embedding <=> m.embedding) ASC,
    m.importance_score DESC,
    m.access_count DESC
  LIMIT max_results;
END;
$$;

-- CLAUDE TAG: NEW FUNCTION - Utility function to get embedding dimensions
-- Function to check embedding dimensions in the database
CREATE OR REPLACE FUNCTION get_embedding_dimensions_summary()
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
  result jsonb;
  openai_count int;
  ollama_count int;
  total_count int;
BEGIN
  -- Count memories by embedding dimensions
  SELECT COUNT(*) INTO total_count FROM ai_memories WHERE embedding IS NOT NULL;
  
  SELECT COUNT(*) INTO openai_count 
  FROM ai_memories 
  WHERE embedding IS NOT NULL AND vector_dims(embedding) = 1536;
  
  SELECT COUNT(*) INTO ollama_count 
  FROM ai_memories 
  WHERE embedding IS NOT NULL AND vector_dims(embedding) = 768;

  SELECT jsonb_build_object(
    'totalMemories', total_count,
    'openaiEmbeddings', openai_count,
    'ollamaEmbeddings', ollama_count,
    'otherDimensions', total_count - openai_count - ollama_count,
    'supportedDimensions', jsonb_build_array(768, 1536),
    'dimensionBreakdown', (
      SELECT jsonb_object_agg(dims::text, count)
      FROM (
        SELECT vector_dims(embedding) as dims, COUNT(*) as count
        FROM ai_memories 
        WHERE embedding IS NOT NULL
        GROUP BY vector_dims(embedding)
      ) dimension_counts
    )
  ) INTO result;

  RETURN result;
END;
$$;

-- CLAUDE TAG: INDEX UPDATE - Update indexes to work with variable dimensions
-- Drop and recreate HNSW indexes without dimension constraints
DROP INDEX IF EXISTS idx_ai_memories_embedding_hnsw;
DROP INDEX IF EXISTS idx_semantic_clusters_embedding_hnsw;

-- Create new HNSW indexes that work with variable dimensions
CREATE INDEX idx_ai_memories_embedding_hnsw 
ON ai_memories USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

CREATE INDEX idx_semantic_clusters_embedding_hnsw 
ON semantic_clusters USING hnsw (representative_embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- CLAUDE TAG: PERMISSIONS - Grant permissions for new function
-- Grant permissions for the new utility function
GRANT EXECUTE ON FUNCTION get_embedding_dimensions_summary TO authenticated, anon;

-- ========================================
-- END CLAUDE GENERATED MIGRATION
-- ========================================
-- Summary of changes:
-- + Modified embedding columns to support variable dimensions
-- + Updated all search functions to handle dimension compatibility
-- + Added dimension checking to prevent incompatible comparisons
-- + Created utility function to monitor embedding dimensions
-- + Recreated indexes to work with variable dimensions
-- + 0 data loss or destructive operations
-- ========================================