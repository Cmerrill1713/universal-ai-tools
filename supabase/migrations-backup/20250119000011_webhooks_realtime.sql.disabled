-- Configure Database Webhooks and Realtime subscriptions

-- Create table for tracking agent status changes
CREATE TABLE IF NOT EXISTS public.agent_status (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    agent_id TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('idle', 'busy', 'error', 'offline')),
    metadata JSONB DEFAULT '{}',
    changed_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable realtime for agent status
ALTER PUBLICATION supabase_realtime ADD TABLE agent_status;

-- Create webhook function for agent status changes
CREATE OR REPLACE FUNCTION notify_agent_status_change()
RETURNS TRIGGER AS $$
DECLARE
    webhook_url TEXT;
    headers JSONB;
    payload JSONB;
BEGIN
    -- Get active webhook configs for agent status changes
    FOR webhook_url, headers IN 
        SELECT url, headers 
        FROM webhook_configs 
        WHERE 'agent_status_change' = ANY(events) 
        AND active = true
    LOOP
        -- Build payload
        payload := jsonb_build_object(
            'event', 'agent_status_change',
            'agent_id', NEW.agent_id,
            'old_status', OLD.status,
            'new_status', NEW.status,
            'metadata', NEW.metadata,
            'timestamp', NOW()
        );
        
        -- Send webhook using pg_net
        PERFORM net.http_post(
            url := webhook_url,
            headers := headers,
            body := payload
        );
    END LOOP;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for agent status changes
CREATE TRIGGER agent_status_webhook
    AFTER UPDATE OF status ON agent_status
    FOR EACH ROW
    WHEN (OLD.status IS DISTINCT FROM NEW.status)
    EXECUTE FUNCTION notify_agent_status_change();

-- Enable realtime for memories table
ALTER PUBLICATION supabase_realtime ADD TABLE memories;

-- Create webhook for new memories
CREATE OR REPLACE FUNCTION notify_new_memory()
RETURNS TRIGGER AS $$
DECLARE
    webhook_url TEXT;
    headers JSONB;
    payload JSONB;
BEGIN
    -- Get active webhook configs for new memories
    FOR webhook_url, headers IN 
        SELECT url, headers 
        FROM webhook_configs 
        WHERE 'new_memory' = ANY(events) 
        AND active = true
    LOOP
        -- Build payload
        payload := jsonb_build_object(
            'event', 'new_memory',
            'memory_id', NEW.id,
            'user_id', NEW.user_id,
            'content_preview', LEFT(NEW.content, 100),
            'metadata', NEW.metadata,
            'timestamp', NEW.created_at
        );
        
        -- Send webhook
        PERFORM net.http_post(
            url := webhook_url,
            headers := headers,
            body := payload
        );
    END LOOP;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for new memories
CREATE TRIGGER memory_created_webhook
    AFTER INSERT ON memories
    FOR EACH ROW
    EXECUTE FUNCTION notify_new_memory();

-- Create broadcast channel for collaborative AI sessions
CREATE OR REPLACE FUNCTION create_ai_session_channel()
RETURNS TEXT AS $$
DECLARE
    channel_name TEXT;
BEGIN
    channel_name := 'ai_session_' || gen_random_uuid();
    
    -- Log channel creation
    INSERT INTO analytics_events (event_type, metadata)
    VALUES ('ai_session_created', jsonb_build_object('channel', channel_name));
    
    RETURN channel_name;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create presence tracking for AI sessions
CREATE TABLE IF NOT EXISTS public.ai_session_presence (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id TEXT NOT NULL,
    user_id UUID REFERENCES auth.users(id),
    user_name TEXT,
    status TEXT DEFAULT 'active',
    last_seen TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'
);

-- Enable realtime for presence
ALTER PUBLICATION supabase_realtime ADD TABLE ai_session_presence;

-- Auto-update last_seen
CREATE OR REPLACE FUNCTION update_presence_last_seen()
RETURNS TRIGGER AS $$
BEGIN
    NEW.last_seen = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER presence_last_seen
    BEFORE UPDATE ON ai_session_presence
    FOR EACH ROW
    EXECUTE FUNCTION update_presence_last_seen();

-- Create view for active sessions
CREATE OR REPLACE VIEW active_ai_sessions AS
SELECT 
    session_id,
    COUNT(DISTINCT user_id) as participant_count,
    jsonb_agg(jsonb_build_object(
        'user_id', user_id,
        'user_name', user_name,
        'last_seen', last_seen
    )) as participants
FROM ai_session_presence
WHERE last_seen > NOW() - INTERVAL '5 minutes'
GROUP BY session_id;

-- Create function to broadcast AI responses
CREATE OR REPLACE FUNCTION broadcast_ai_response(
    channel_name TEXT,
    message TEXT,
    sender_id UUID DEFAULT NULL,
    metadata JSONB DEFAULT '{}'
) RETURNS VOID AS $$
BEGIN
    -- This would integrate with Supabase Realtime broadcast
    -- For now, we'll log it
    INSERT INTO analytics_events (event_type, user_id, metadata)
    VALUES ('ai_response_broadcast', sender_id, jsonb_build_object(
        'channel', channel_name,
        'message_length', LENGTH(message),
        'metadata', metadata
    ));
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create scheduled cleanup for old presence records
INSERT INTO scheduled_jobs (name, schedule, command, active)
VALUES (
    'cleanup_old_presence',
    '0 * * * *', -- Every hour
    'DELETE FROM ai_session_presence WHERE last_seen < NOW() - INTERVAL ''1 day''',
    true
);

-- Grant necessary permissions
GRANT ALL ON agent_status TO authenticated, service_role;
GRANT ALL ON ai_session_presence TO authenticated;
GRANT SELECT ON active_ai_sessions TO authenticated;
GRANT EXECUTE ON FUNCTION create_ai_session_channel TO authenticated;
GRANT EXECUTE ON FUNCTION broadcast_ai_response TO authenticated;