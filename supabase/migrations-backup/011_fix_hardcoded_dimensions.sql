-- ========================================
-- CLAUDE GENERATED MIGRATION - Fix Hardcoded Vector Dimensions
-- ========================================
-- Generated by: Claude (Anthropic AI Assistant)
-- Date: 2025-07-17
-- Purpose: Remove ALL hardcoded vector(1536) constraints to support variable dimensions
-- SAFETY: This migration only MODIFIES column types to be more flexible
--         NO existing data is deleted or lost
-- ========================================

-- CLAUDE TAG: VIEW MODIFICATION - Drop dependent views first to allow column modification
-- Drop the view that depends on the materialized view
DROP VIEW IF EXISTS vector_search_stats;

-- Drop the materialized view that has hardcoded vector(1536)
DROP MATERIALIZED VIEW IF EXISTS memory_semantic_clusters;

-- CLAUDE TAG: COLUMN MODIFICATION - Remove hardcoded 1536 dimensions from ai_memories
-- Fix the main ai_memories table embedding column
ALTER TABLE ai_memories ALTER COLUMN embedding TYPE vector;

-- CLAUDE TAG: COLUMN MODIFICATION - Remove hardcoded dimensions from memory_clusters
-- Fix memory_clusters table if it exists
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'memory_clusters') THEN
    ALTER TABLE memory_clusters ALTER COLUMN centroid_embedding TYPE vector;
  END IF;
END $$;

-- Recreate without hardcoded dimensions
CREATE MATERIALIZED VIEW memory_semantic_clusters AS
WITH clustered_memories AS (
  SELECT 
    id,
    content,
    embedding,
    importance_score,
    service_id,
    memory_type,
    created_at,
    -- Create clusters using modulo hash (simple clustering)
    (hashtext(content) % 50) as cluster_id
  FROM ai_memories 
  WHERE embedding IS NOT NULL 
    AND importance_score > 0.3
    AND created_at > NOW() - INTERVAL '90 days'
)
SELECT 
  cluster_id,
  COUNT(*) as member_count,
  AVG(importance_score) as avg_importance,
  ARRAY_AGG(id ORDER BY importance_score DESC) as memory_ids,
  ARRAY_AGG(DISTINCT service_id) as agent_types,
  ARRAY_AGG(DISTINCT memory_type) as memory_types,
  MIN(created_at) as oldest_memory,
  MAX(created_at) as newest_memory,
  -- Use first embedding as representative (no hardcoded dimensions)
  (ARRAY_AGG(embedding ORDER BY importance_score DESC))[1] as representative_embedding
FROM clustered_memories
GROUP BY cluster_id
HAVING COUNT(*) >= 2  -- Only clusters with multiple memories
ORDER BY avg_importance DESC, member_count DESC;

-- CLAUDE TAG: FUNCTION UPDATE - Fix all functions with hardcoded vector(1536)
-- Update search_similar_memories function
CREATE OR REPLACE FUNCTION search_similar_memories(
  query_embedding vector,
  similarity_threshold float DEFAULT 0.7,
  max_results int DEFAULT 20,
  category_filter text DEFAULT NULL,
  agent_filter text DEFAULT NULL,
  current_context vector DEFAULT NULL
)
RETURNS TABLE (
  memory_id uuid,
  content text,
  service_id text,
  memory_type text,
  similarity float,
  importance_score float,
  access_count int,
  metadata jsonb,
  keywords text[],
  related_entities jsonb
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    m.id as memory_id,
    m.content,
    m.service_id,
    m.memory_type,
    CASE 
      WHEN m.embedding IS NOT NULL AND query_embedding IS NOT NULL
        AND vector_dims(m.embedding) = vector_dims(query_embedding)
      THEN (1 - (query_embedding <=> m.embedding))::float
      ELSE 0.0
    END as similarity,
    m.importance_score,
    COALESCE(m.access_count, 0) as access_count,
    COALESCE(m.metadata, '{}'::jsonb) as metadata,
    COALESCE(m.keywords, ARRAY[]::text[]) as keywords,
    COALESCE(m.related_entities, '[]'::jsonb) as related_entities
  FROM ai_memories m
  WHERE 
    (category_filter IS NULL OR m.memory_category LIKE '%' || category_filter || '%')
    AND (agent_filter IS NULL OR m.service_id = agent_filter)
    AND (
      m.embedding IS NULL 
      OR query_embedding IS NULL 
      OR vector_dims(m.embedding) = vector_dims(query_embedding)
    )
    AND (
      m.embedding IS NULL 
      OR query_embedding IS NULL 
      OR (1 - (query_embedding <=> m.embedding)) >= similarity_threshold
    )
  ORDER BY 
    similarity DESC,
    m.importance_score DESC,
    COALESCE(m.access_count, 0) DESC
  LIMIT max_results;
END;
$$;

-- Update cross_agent_memory_search function
CREATE OR REPLACE FUNCTION cross_agent_memory_search(
  query_embedding vector,
  similarity_threshold float DEFAULT 0.7,
  max_results int DEFAULT 20,
  excluded_agent text DEFAULT NULL
)
RETURNS TABLE (
  memory_id uuid,
  content text,
  service_id text,
  memory_type text,
  similarity float,
  importance_score float,
  access_count int,
  metadata jsonb
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    m.id as memory_id,
    m.content,
    m.service_id,
    m.memory_type,
    CASE 
      WHEN m.embedding IS NOT NULL AND query_embedding IS NOT NULL
        AND vector_dims(m.embedding) = vector_dims(query_embedding)
      THEN (1 - (query_embedding <=> m.embedding))::float
      ELSE 0.0
    END as similarity,
    m.importance_score,
    COALESCE(m.access_count, 0) as access_count,
    COALESCE(m.metadata, '{}'::jsonb) as metadata
  FROM ai_memories m
  WHERE 
    (excluded_agent IS NULL OR m.service_id != excluded_agent)
    AND (
      m.embedding IS NULL 
      OR query_embedding IS NULL 
      OR vector_dims(m.embedding) = vector_dims(query_embedding)
    )
    AND (
      m.embedding IS NULL 
      OR query_embedding IS NULL 
      OR (1 - (query_embedding <=> m.embedding)) >= similarity_threshold
    )
  ORDER BY 
    similarity DESC,
    m.importance_score DESC,
    COALESCE(m.access_count, 0) DESC
  LIMIT max_results;
END;
$$;

-- Update optimize_vector_search function
CREATE OR REPLACE FUNCTION optimize_vector_search(
  centroid vector,
  radius float DEFAULT 0.3,
  max_results int DEFAULT 50
)
RETURNS TABLE (
  memory_id uuid,
  similarity float,
  distance_from_centroid float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    m.id as memory_id,
    CASE 
      WHEN m.embedding IS NOT NULL AND centroid IS NOT NULL
        AND vector_dims(m.embedding) = vector_dims(centroid)
      THEN (1 - (centroid <=> m.embedding))::float
      ELSE 0.0
    END as similarity,
    CASE 
      WHEN m.embedding IS NOT NULL AND centroid IS NOT NULL
        AND vector_dims(m.embedding) = vector_dims(centroid)
      THEN (centroid <=> m.embedding)::float
      ELSE 1.0
    END as distance_from_centroid
  FROM ai_memories m
  WHERE 
    m.embedding IS NOT NULL
    AND centroid IS NOT NULL
    AND vector_dims(m.embedding) = vector_dims(centroid)
    AND (centroid <=> m.embedding) <= radius
  ORDER BY distance_from_centroid ASC
  LIMIT max_results;
END;
$$;

-- Update adaptive_memory_search function
CREATE OR REPLACE FUNCTION adaptive_memory_search(
  query_embedding vector,
  similarity_threshold float DEFAULT 0.7,
  max_results int DEFAULT 20,
  agent_context text DEFAULT NULL,
  current_context vector DEFAULT NULL
)
RETURNS TABLE (
  memory_id uuid,
  content text,
  service_id text,
  memory_type text,
  similarity float,
  context_relevance float,
  composite_score float,
  importance_score float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    m.id as memory_id,
    m.content,
    m.service_id,
    m.memory_type,
    CASE 
      WHEN m.embedding IS NOT NULL AND query_embedding IS NOT NULL
        AND vector_dims(m.embedding) = vector_dims(query_embedding)
      THEN (1 - (query_embedding <=> m.embedding))::float
      ELSE 0.0
    END as similarity,
    CASE 
      WHEN current_context IS NOT NULL AND m.embedding IS NOT NULL
        AND vector_dims(m.embedding) = vector_dims(current_context)
      THEN (1 - (current_context <=> m.embedding))::float
      ELSE 0.5
    END as context_relevance,
    (
      (CASE 
        WHEN m.embedding IS NOT NULL AND query_embedding IS NOT NULL
          AND vector_dims(m.embedding) = vector_dims(query_embedding)
        THEN (1 - (query_embedding <=> m.embedding))::float
        ELSE 0.0
      END * 0.7) +
      (CASE 
        WHEN current_context IS NOT NULL AND m.embedding IS NOT NULL
          AND vector_dims(m.embedding) = vector_dims(current_context)
        THEN (1 - (current_context <=> m.embedding))::float
        ELSE 0.5
      END * 0.2) +
      (m.importance_score * 0.1)
    ) as composite_score,
    m.importance_score
  FROM ai_memories m
  WHERE 
    (agent_context IS NULL OR m.service_id = agent_context)
    AND (
      m.embedding IS NULL 
      OR query_embedding IS NULL 
      OR vector_dims(m.embedding) = vector_dims(query_embedding)
    )
    AND (
      m.embedding IS NULL 
      OR query_embedding IS NULL 
      OR (1 - (query_embedding <=> m.embedding)) >= similarity_threshold
    )
  ORDER BY composite_score DESC, m.importance_score DESC
  LIMIT max_results;
END;
$$;

-- Update optimized_memory_search function
CREATE OR REPLACE FUNCTION optimized_memory_search(
  query_embedding vector,
  similarity_threshold FLOAT DEFAULT 0.7,
  max_results INTEGER DEFAULT 20,
  use_clusters BOOLEAN DEFAULT true
)
RETURNS TABLE (
  memory_id UUID,
  service_id TEXT,
  content TEXT,
  similarity FLOAT,
  importance_score FLOAT,
  search_method TEXT
) AS $$
BEGIN
  IF use_clusters AND EXISTS (SELECT 1 FROM memory_semantic_clusters LIMIT 1) THEN
    -- Stage 1: Find relevant clusters
    RETURN QUERY
    WITH relevant_clusters AS (
      SELECT 
        c.cluster_id,
        c.memory_ids,
        CASE 
          WHEN c.representative_embedding IS NOT NULL AND query_embedding IS NOT NULL
            AND vector_dims(c.representative_embedding) = vector_dims(query_embedding)
          THEN (1 - (c.representative_embedding <=> query_embedding))::float
          ELSE 0.0
        END as cluster_similarity
      FROM memory_semantic_clusters c
      WHERE 
        c.representative_embedding IS NOT NULL 
        AND query_embedding IS NOT NULL
        AND vector_dims(c.representative_embedding) = vector_dims(query_embedding)
        AND (1 - (c.representative_embedding <=> query_embedding)) > similarity_threshold * 0.6
      ORDER BY c.representative_embedding <=> query_embedding
      LIMIT 10
    ),
    candidate_memories AS (
      SELECT UNNEST(rc.memory_ids) as mid
      FROM relevant_clusters rc
    )
    -- Stage 2: Detailed search within relevant clusters
    SELECT 
      m.id,
      m.service_id,
      m.content,
      CASE 
        WHEN m.embedding IS NOT NULL AND query_embedding IS NOT NULL
          AND vector_dims(m.embedding) = vector_dims(query_embedding)
        THEN (1 - (m.embedding <=> query_embedding))::float
        ELSE 0.0
      END as similarity,
      calculate_importance_decay(m.importance_score, m.last_accessed, m.access_count) as importance_score,
      'clustered' as search_method
    FROM ai_memories m
    JOIN candidate_memories cm ON m.id = cm.mid
    WHERE 
      m.embedding IS NOT NULL
      AND query_embedding IS NOT NULL
      AND vector_dims(m.embedding) = vector_dims(query_embedding)
      AND (1 - (m.embedding <=> query_embedding)) > similarity_threshold
    ORDER BY 
      (1 - (m.embedding <=> query_embedding)) * 
      calculate_importance_decay(m.importance_score, m.last_accessed, m.access_count) DESC
    LIMIT max_results;
  ELSE
    -- Fallback to direct search
    RETURN QUERY
    SELECT 
      m.id,
      m.service_id,
      m.content,
      CASE 
        WHEN m.embedding IS NOT NULL AND query_embedding IS NOT NULL
          AND vector_dims(m.embedding) = vector_dims(query_embedding)
        THEN (1 - (m.embedding <=> query_embedding))::float
        ELSE 0.0
      END as similarity,
      calculate_importance_decay(m.importance_score, m.last_accessed, m.access_count) as importance_score,
      'direct' as search_method
    FROM ai_memories m
    WHERE 
      m.embedding IS NOT NULL
      AND query_embedding IS NOT NULL
      AND vector_dims(m.embedding) = vector_dims(query_embedding)
      AND (1 - (m.embedding <=> query_embedding)) > similarity_threshold
    ORDER BY 
      (1 - (m.embedding <=> query_embedding)) * 
      calculate_importance_decay(m.importance_score, m.last_accessed, m.access_count) DESC
    LIMIT max_results;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- CLAUDE TAG: INDEX RECREATION - Recreate vector indexes without dimension constraints
-- Drop and recreate indexes for the materialized view
DROP INDEX IF EXISTS idx_memory_clusters_representative_embedding;
DROP INDEX IF EXISTS idx_memory_clusters_representative_embedding_ivf;

-- Create new indexes for the materialized view (only if data exists)
DO $$
BEGIN
  -- Only create index if we have embeddings in the materialized view
  IF EXISTS (SELECT 1 FROM memory_semantic_clusters WHERE representative_embedding IS NOT NULL LIMIT 1) THEN
    BEGIN
      CREATE INDEX idx_memory_clusters_representative_embedding_hnsw
      ON memory_semantic_clusters USING hnsw (representative_embedding vector_cosine_ops)
      WITH (m = 16, ef_construction = 64);
      RAISE NOTICE 'HNSW index created for memory clusters';
    EXCEPTION WHEN OTHERS THEN
      CREATE INDEX idx_memory_clusters_representative_embedding_ivf
      ON memory_semantic_clusters USING ivfflat (representative_embedding vector_cosine_ops)
      WITH (lists = 20);
      RAISE NOTICE 'IVFFlat index created for memory clusters (HNSW fallback)';
    END;
  ELSE
    RAISE NOTICE 'No embeddings found in memory clusters - skipping vector index creation';
  END IF;
END $$;

-- CLAUDE TAG: PERMISSIONS - Functions already have permissions from earlier migrations
-- Permissions for updated functions are inherited from previous migrations

-- Grant view access
GRANT SELECT ON memory_semantic_clusters TO authenticated;

-- CLAUDE TAG: VIEW RECREATION - Recreate vector_search_stats view
-- Recreate the monitoring view that was dropped
CREATE OR REPLACE VIEW vector_search_stats AS
SELECT 
  'total_memories' as metric,
  COUNT(*)::TEXT as value
FROM ai_memories
UNION ALL
SELECT 
  'memories_with_embeddings' as metric,
  COUNT(*)::TEXT as value
FROM ai_memories WHERE embedding IS NOT NULL
UNION ALL
SELECT 
  'semantic_clusters' as metric,
  COUNT(*)::TEXT as value
FROM memory_semantic_clusters
UNION ALL
SELECT 
  'avg_importance_score' as metric,
  ROUND(AVG(importance_score)::numeric, 3)::TEXT as value
FROM ai_memories WHERE embedding IS NOT NULL
UNION ALL
SELECT 
  'memories_last_24h' as metric,
  COUNT(*)::TEXT as value
FROM ai_memories 
WHERE created_at > NOW() - INTERVAL '24 hours'
  AND embedding IS NOT NULL;

-- Grant permissions for the monitoring view
GRANT SELECT ON vector_search_stats TO authenticated;

-- ========================================
-- END CLAUDE GENERATED MIGRATION
-- ========================================
-- Summary of changes:
-- + Fixed ai_memories.embedding column to support variable dimensions
-- + Updated materialized view to remove hardcoded vector(1536)
-- + Fixed ALL functions to use dimension checking instead of hardcoded dimensions
-- + Recreated vector indexes without dimension constraints
-- + 0 data loss or destructive operations
-- ========================================