-- Security Audit System Tables
-- Tables for tracking security audits, key rotations, and vulnerabilities

-- Security audits table
CREATE TABLE IF NOT EXISTS security_audits (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    audit_type VARCHAR(50) NOT NULL,
    score INTEGER CHECK (score >= 0 AND score <= 100),
    vulnerabilities_count INTEGER DEFAULT 0,
    findings JSONB,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    created_by UUID REFERENCES auth.users(id)
);

-- Security key rotations table
CREATE TABLE IF NOT EXISTS security_key_rotations (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    key_name VARCHAR(100) NOT NULL,
    key_hash VARCHAR(64) NOT NULL, -- SHA-256 hash
    rotated_by VARCHAR(100) NOT NULL,
    previous_key_id UUID REFERENCES security_key_rotations(id),
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Security incidents table
CREATE TABLE IF NOT EXISTS security_incidents (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    incident_type VARCHAR(50) NOT NULL,
    severity VARCHAR(20) CHECK (severity IN ('critical', 'high', 'moderate', 'low')),
    description TEXT,
    affected_resource VARCHAR(200),
    ip_address INET,
    user_agent TEXT,
    metadata JSONB,
    resolved_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Blocked IPs table
CREATE TABLE IF NOT EXISTS security_blocked_ips (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    ip_address INET NOT NULL UNIQUE,
    reason VARCHAR(200),
    blocked_until TIMESTAMPTZ,
    permanent BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    created_by UUID REFERENCES auth.users(id)
);

-- API rate limit violations table
CREATE TABLE IF NOT EXISTS security_rate_limit_violations (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    ip_address INET NOT NULL,
    endpoint VARCHAR(200) NOT NULL,
    requests_count INTEGER NOT NULL,
    window_start TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_security_audits_created_at ON security_audits(created_at DESC);
CREATE INDEX idx_security_audits_audit_type ON security_audits(audit_type);
CREATE INDEX idx_security_key_rotations_key_name ON security_key_rotations(key_name);
CREATE INDEX idx_security_key_rotations_created_at ON security_key_rotations(created_at DESC);
CREATE INDEX idx_security_incidents_severity ON security_incidents(severity);
CREATE INDEX idx_security_incidents_created_at ON security_incidents(created_at DESC);
CREATE INDEX idx_security_blocked_ips_ip_address ON security_blocked_ips(ip_address);
CREATE INDEX idx_security_rate_limit_violations_ip ON security_rate_limit_violations(ip_address);
CREATE INDEX idx_security_rate_limit_violations_endpoint ON security_rate_limit_violations(endpoint);

-- Row Level Security (RLS)
ALTER TABLE security_audits ENABLE ROW LEVEL SECURITY;
ALTER TABLE security_key_rotations ENABLE ROW LEVEL SECURITY;
ALTER TABLE security_incidents ENABLE ROW LEVEL SECURITY;
ALTER TABLE security_blocked_ips ENABLE ROW LEVEL SECURITY;
ALTER TABLE security_rate_limit_violations ENABLE ROW LEVEL SECURITY;

-- Policies for security_audits
CREATE POLICY "Service users can insert security audits"
    ON security_audits FOR INSERT
    USING (auth.uid() IS NOT NULL);

CREATE POLICY "Service users can view security audits"
    ON security_audits FOR SELECT
    USING (auth.uid() IS NOT NULL);

-- Policies for security_key_rotations
CREATE POLICY "Only admins can manage key rotations"
    ON security_key_rotations FOR ALL
    USING (auth.uid() IN (
        SELECT id FROM auth.users WHERE raw_user_meta_data->>'role' = 'admin'
    ));

-- Policies for security_incidents
CREATE POLICY "Service users can insert incidents"
    ON security_incidents FOR INSERT
    USING (auth.uid() IS NOT NULL);

CREATE POLICY "Service users can view incidents"
    ON security_incidents FOR SELECT
    USING (auth.uid() IS NOT NULL);

CREATE POLICY "Admins can update incidents"
    ON security_incidents FOR UPDATE
    USING (auth.uid() IN (
        SELECT id FROM auth.users WHERE raw_user_meta_data->>'role' = 'admin'
    ));

-- Policies for security_blocked_ips
CREATE POLICY "Only admins can manage blocked IPs"
    ON security_blocked_ips FOR ALL
    USING (auth.uid() IN (
        SELECT id FROM auth.users WHERE raw_user_meta_data->>'role' = 'admin'
    ));

-- Policies for security_rate_limit_violations
CREATE POLICY "Service users can insert rate limit violations"
    ON security_rate_limit_violations FOR INSERT
    USING (auth.uid() IS NOT NULL);

CREATE POLICY "Service users can view rate limit violations"
    ON security_rate_limit_violations FOR SELECT
    USING (auth.uid() IS NOT NULL);

-- Functions for security management

-- Function to check if an IP is blocked
CREATE OR REPLACE FUNCTION is_ip_blocked(check_ip INET)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM security_blocked_ips
        WHERE ip_address = check_ip
        AND (permanent = TRUE OR blocked_until > CURRENT_TIMESTAMP)
    );
END;
$$ LANGUAGE plpgsql;

-- Function to get recent security incidents
CREATE OR REPLACE FUNCTION get_recent_security_incidents(
    p_limit INTEGER DEFAULT 100,
    p_severity VARCHAR DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    incident_type VARCHAR,
    severity VARCHAR,
    description TEXT,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        si.id,
        si.incident_type,
        si.severity,
        si.description,
        si.created_at
    FROM security_incidents si
    WHERE (p_severity IS NULL OR si.severity = p_severity)
    ORDER BY si.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function to rotate a key
CREATE OR REPLACE FUNCTION rotate_security_key(
    p_key_name VARCHAR,
    p_key_hash VARCHAR,
    p_rotated_by VARCHAR,
    p_expires_days INTEGER DEFAULT 90
)
RETURNS UUID AS $$
DECLARE
    v_previous_key_id UUID;
    v_new_key_id UUID;
BEGIN
    -- Get the most recent key for this name
    SELECT id INTO v_previous_key_id
    FROM security_key_rotations
    WHERE key_name = p_key_name
    ORDER BY created_at DESC
    LIMIT 1;
    
    -- Insert new key rotation
    INSERT INTO security_key_rotations (
        key_name,
        key_hash,
        rotated_by,
        previous_key_id,
        expires_at
    ) VALUES (
        p_key_name,
        p_key_hash,
        p_rotated_by,
        v_previous_key_id,
        CURRENT_TIMESTAMP + (p_expires_days || ' days')::INTERVAL
    ) RETURNING id INTO v_new_key_id;
    
    RETURN v_new_key_id;
END;
$$ LANGUAGE plpgsql;

-- Trigger to clean up old audit logs
CREATE OR REPLACE FUNCTION cleanup_old_security_logs()
RETURNS TRIGGER AS $$
BEGIN
    -- Delete audits older than 90 days
    DELETE FROM security_audits
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '90 days';
    
    -- Delete rate limit violations older than 7 days
    DELETE FROM security_rate_limit_violations
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '7 days';
    
    -- Delete resolved incidents older than 30 days
    DELETE FROM security_incidents
    WHERE resolved_at IS NOT NULL
    AND resolved_at < CURRENT_TIMESTAMP - INTERVAL '30 days';
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for cleanup (runs daily)
CREATE OR REPLACE FUNCTION create_cleanup_trigger()
RETURNS void AS $$
BEGIN
    -- This would typically be done with pg_cron, but for compatibility
    -- we'll note that this should be scheduled externally
    RAISE NOTICE 'Security log cleanup should be scheduled to run daily using pg_cron or external scheduler';
END;
$$ LANGUAGE plpgsql;

-- Initial setup
SELECT create_cleanup_trigger();