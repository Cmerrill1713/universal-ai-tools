"""
Base strategy class for implementing trading strategies.
Provides common functionality and interface for all trading strategies.
"""

import uuid
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional

import pandas as pd

from ...domain.order import Order, OrderType
from ...domain.trade import Trade, TradeSide, TradeType
from ...schemas.trade_schemas import TradeSignalSchema


class SignalType(Enum):
    """Types of trading signals."""
    BUY = "buy"
    SELL = "sell"
    STRONG_BUY = "strong_buy"
    STRONG_SELL = "strong_sell"
    HOLD = "hold"


class StrategyState(Enum):
    """Strategy execution states."""
    INACTIVE = "inactive"
    ACTIVE = "active"
    PAUSED = "paused"
    ERROR = "error"


@dataclass
class TradingSignal:
    """
    Represents a trading signal generated by a strategy.

    Attributes:
        signal_type: Type of signal (buy, sell, hold)
        symbol: Trading pair symbol
        strength: Signal strength (0.0 to 1.0)
        confidence: Signal confidence (0.0 to 1.0)
        price_target: Suggested entry price
        stop_loss: Suggested stop loss price
        take_profit: Suggested take profit price
        indicators: Technical indicators that contributed to signal
        metadata: Additional signal data
        timestamp: Signal generation time
    """
    signal_type: SignalType
    symbol: str
    strength: float = field(default=0.5)  # 0.0 to 1.0
    confidence: float = field(default=0.5)  # 0.0 to 1.0
    price_target: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    indicators: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_schema(self, strategy_id: str) -> TradeSignalSchema:
        """Convert to Pydantic schema."""
        return TradeSignalSchema(
            symbol=self.symbol,
            signal_type=self.signal_type.value,
            strength=self.strength,
            price_target=self.price_target,
            stop_loss=self.stop_loss,
            take_profit=self.take_profit,
            confidence=self.confidence,
            strategy_id=strategy_id,
            indicators=self.indicators,
            metadata=self.metadata,
            timestamp=self.timestamp
        )


@dataclass
class StrategyConfig:
    """Base configuration for trading strategies."""

    # Strategy identification
    name: str = ""
    version: str = "1.0.0"
    description: str = ""

    # Risk management
    max_position_size: Decimal = field(
        default_factory=lambda: Decimal('0.1'))  # 10% of portfolio
    stop_loss_percentage: float = 2.0  # 2% stop loss
    take_profit_percentage: float = 6.0  # 6% take profit
    risk_reward_ratio: float = 3.0  # 1:3 risk/reward

    # Position management
    # fixed_percentage, kelly, volatility_adjusted
    position_sizing_method: str = "fixed_percentage"
    max_positions_per_symbol: int = 1
    max_total_positions: int = 5

    # Signal thresholds
    min_signal_strength: float = 0.6
    min_signal_confidence: float = 0.7

    # Time management
    lookback_periods: int = 50  # Historical data periods to analyze
    signal_cooldown_minutes: int = 15  # Minimum time between signals for same symbol
    max_holding_time_hours: int = 24  # Maximum time to hold position

    # Market conditions
    min_volume_threshold: Decimal = field(
        default_factory=lambda: Decimal('10000'))
    max_spread_percentage: float = 0.5  # Maximum bid-ask spread
    trading_hours_only: bool = False

    # Additional parameters
    parameters: Dict[str, Any] = field(default_factory=dict)


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    Provides common functionality and defines the interface that all
    trading strategies must implement.
    """

    def __init__(self, config: StrategyConfig):
        """
        Initialize the strategy.

        Args:
            config: Strategy configuration
        """
        self.config = config
        self.id = str(uuid.uuid4())
        self.state = StrategyState.INACTIVE
        self.created_at = datetime.utcnow()
        # Symbol -> last signal time
        self.last_signal_time: Dict[str, datetime] = {}
        # Symbol -> position data
        self.active_positions: Dict[str, Dict[str, Any]] = {}
        self.performance_metrics: Dict[str, Any] = {
            'total_signals': 0,
            'successful_signals': 0,
            'total_return': Decimal('0'),
            'win_rate': 0.0,
            'max_drawdown': 0.0,
            'sharpe_ratio': 0.0
        }

    @abstractmethod
    def analyze_market(self, data: pd.DataFrame) -> List[TradingSignal]:
        """
        Analyze market data and generate trading signals.

        Args:
            data: Market data DataFrame with OHLCV columns

        Returns:
            List of trading signals
        """
        pass

    @abstractmethod
    def calculate_indicators(self, data: pd.DataFrame) -> Dict[str, Any]:
        """
        Calculate technical indicators for the strategy.

        Args:
            data: Market data DataFrame

        Returns:
            Dictionary of calculated indicators
        """
        pass

    @abstractmethod
    def get_required_columns(self) -> List[str]:
        """
        Get the required columns for this strategy.

        Returns:
            List of required column names
        """
        pass

    def validate_data(self, data: pd.DataFrame) -> bool:
        """
        Validate that the data contains required columns and sufficient history.

        Args:
            data: Market data to validate

        Returns:
            True if data is valid, False otherwise
        """
        required_columns = self.get_required_columns()

        # Check for required columns
        missing_columns = set(required_columns) - set(data.columns)
        if missing_columns:
            return False

        # Check for sufficient data
        if len(data) < self.config.lookback_periods:
            return False

        # Check for recent data (no older than 1 hour)
        if data.index[-1] < datetime.utcnow() - timedelta(hours=1):
            return False

        return True

    def can_generate_signal(self, symbol: str) -> bool:
        """
        Check if enough time has passed since last signal for this symbol.

        Args:
            symbol: Trading pair symbol

        Returns:
            True if signal can be generated, False otherwise
        """
        if symbol not in self.last_signal_time:
            return True

        time_since_last_signal = datetime.utcnow() - \
            self.last_signal_time[symbol]
        cooldown = timedelta(minutes=self.config.signal_cooldown_minutes)

        return time_since_last_signal >= cooldown

    def filter_signals(
            self,
            signals: List[TradingSignal]) -> List[TradingSignal]:
        """
        Filter signals based on strategy configuration and market conditions.

        Args:
            signals: Raw signals from strategy

        Returns:
            Filtered list of signals
        """
        filtered_signals = []

        for signal in signals:
            # Check signal strength and confidence thresholds
            if (signal.strength < self.config.min_signal_strength or
                    signal.confidence < self.config.min_signal_confidence):
                continue

            # Check cooldown period
            if not self.can_generate_signal(signal.symbol):
                continue

            # Check maximum positions
            if (len(self.active_positions) >= self.config.max_total_positions and
                    signal.symbol not in self.active_positions):
                continue

            filtered_signals.append(signal)
            self.last_signal_time[signal.symbol] = signal.timestamp

        return filtered_signals

    def calculate_position_size(self, signal: TradingSignal,
                                portfolio_value: Decimal,
                                current_price: Decimal) -> Decimal:
        """
        Calculate position size based on strategy configuration.

        Args:
            signal: Trading signal
            portfolio_value: Total portfolio value
            current_price: Current market price

        Returns:
            Position size in base currency
        """
        if self.config.position_sizing_method == "fixed_percentage":
            return portfolio_value * self.config.max_position_size

        elif self.config.position_sizing_method == "volatility_adjusted":
            # Use ATR-based position sizing
            volatility = signal.indicators.get(
                'atr', current_price * Decimal('0.02'))
            risk_per_trade = portfolio_value * \
                Decimal('0.02')  # 2% risk per trade
            position_size = risk_per_trade / volatility
            return min(
                position_size,
                portfolio_value *
                self.config.max_position_size)

        elif self.config.position_sizing_method == "kelly":
            # Kelly criterion (requires win rate and avg win/loss)
            win_rate = self.performance_metrics.get('win_rate', 0.5)
            avg_win = Decimal('0.06')  # Assume 6% average win
            avg_loss = Decimal('0.02')  # Assume 2% average loss

            if avg_loss > 0:
                kelly_fraction = (win_rate * avg_win -
                                  (1 - win_rate) * avg_loss) / avg_win
                kelly_fraction = max(
                    0, min(kelly_fraction, 0.25))  # Cap at 25%
                return portfolio_value * Decimal(str(kelly_fraction))

        # Default fallback
        return portfolio_value * self.config.max_position_size

    def calculate_stop_loss(self, entry_price: Decimal,
                            signal_type: SignalType) -> Decimal:
        """
        Calculate stop loss price based on entry price and strategy config.

        Args:
            entry_price: Entry price for the position
            signal_type: Type of signal (buy/sell)

        Returns:
            Stop loss price
        """
        stop_loss_multiplier = Decimal(
            str(1 - self.config.stop_loss_percentage / 100))

        if signal_type in [SignalType.BUY, SignalType.STRONG_BUY]:
            return entry_price * stop_loss_multiplier
        else:
            return entry_price / stop_loss_multiplier

    def calculate_take_profit(self, entry_price: Decimal,
                              signal_type: SignalType) -> Decimal:
        """
        Calculate take profit price based on entry price and strategy config.

        Args:
            entry_price: Entry price for the position
            signal_type: Type of signal (buy/sell)

        Returns:
            Take profit price
        """
        take_profit_multiplier = Decimal(
            str(1 + self.config.take_profit_percentage / 100))

        if signal_type in [SignalType.BUY, SignalType.STRONG_BUY]:
            return entry_price * take_profit_multiplier
        else:
            return entry_price / take_profit_multiplier

    def create_orders_from_signal(self, signal: TradingSignal,
                                  portfolio_value: Decimal,
                                  current_price: Decimal) -> List[Order]:
        """
        Create orders from a trading signal.

        Args:
            signal: Trading signal to execute
            portfolio_value: Total portfolio value
            current_price: Current market price

        Returns:
            List of orders to execute
        """
        orders = []

        # Calculate position size
        position_value = self.calculate_position_size(
            signal, portfolio_value, current_price)
        position_size = position_value / current_price

        # Determine order side
        if signal.signal_type in [SignalType.BUY, SignalType.STRONG_BUY]:
            side = TradeType.BUY
        else:
            side = TradeType.SELL

        # Create main entry order
        entry_order = Order(
            symbol=signal.symbol,
            order_type=OrderType.MARKET,  # Use market order for immediate execution
            side=side,
            amount=position_size,
            strategy_id=self.id,
            metadata={
                'signal_strength': signal.strength,
                'signal_confidence': signal.confidence,
                'entry_type': 'main_entry'
            }
        )
        orders.append(entry_order)

        # Create stop loss order (if configured)
        if self.config.stop_loss_percentage > 0:
            stop_loss_price = signal.stop_loss or self.calculate_stop_loss(
                current_price, signal.signal_type)

            stop_order = Order(
                symbol=signal.symbol,
                order_type=OrderType.STOP,
                side=TradeType.SELL if side == TradeType.BUY else TradeType.BUY,
                amount=position_size,
                stop_price=stop_loss_price,
                strategy_id=self.id,
                metadata={
                    'order_relationship': 'stop_loss',
                    'parent_order_id': entry_order.id})
            orders.append(stop_order)

        # Create take profit order (if configured)
        if self.config.take_profit_percentage > 0:
            take_profit_price = signal.take_profit or self.calculate_take_profit(
                current_price, signal.signal_type)

            take_profit_order = Order(
                symbol=signal.symbol,
                order_type=OrderType.LIMIT,
                side=TradeType.SELL if side == TradeType.BUY else TradeType.BUY,
                amount=position_size,
                price=take_profit_price,
                strategy_id=self.id,
                metadata={
                    'order_relationship': 'take_profit',
                    'parent_order_id': entry_order.id})
            orders.append(take_profit_order)

        return orders

    def update_performance_metrics(self, trade: Trade) -> None:
        """
        Update strategy performance metrics based on completed trade.

        Args:
            trade: Completed trade
        """
        if not trade.is_complete:
            return

        self.performance_metrics['total_signals'] += 1

        # Calculate trade return
        if trade.side == TradeSide.LONG:
            trade_return = (trade.filled_price - trade.price) / trade.price
        else:
            trade_return = (trade.price - trade.filled_price) / trade.price

        self.performance_metrics['total_return'] += Decimal(str(trade_return))

        # Update win rate
        if trade_return > 0:
            self.performance_metrics['successful_signals'] += 1

        total_signals = self.performance_metrics['total_signals']
        successful_signals = self.performance_metrics['successful_signals']
        self.performance_metrics['win_rate'] = successful_signals / \
            total_signals if total_signals > 0 else 0

    def get_status(self) -> Dict[str, Any]:
        """
        Get current strategy status and metrics.

        Returns:
            Dictionary containing strategy status information
        """
        return {
            'id': self.id,
            'name': self.config.name,
            'version': self.config.version,
            'state': self.state.value,
            'created_at': self.created_at.isoformat(),
            'active_positions': len(self.active_positions),
            'performance_metrics': dict(self.performance_metrics),
            'config': {
                'max_position_size': str(self.config.max_position_size),
                'stop_loss_percentage': self.config.stop_loss_percentage,
                'take_profit_percentage': self.config.take_profit_percentage,
                'min_signal_strength': self.config.min_signal_strength,
                'min_signal_confidence': self.config.min_signal_confidence
            }
        }

    def start(self) -> None:
        """Start the strategy."""
        self.state = StrategyState.ACTIVE

    def stop(self) -> None:
        """Stop the strategy."""
        self.state = StrategyState.INACTIVE

    def pause(self) -> None:
        """Pause the strategy."""
        self.state = StrategyState.PAUSED

    def resume(self) -> None:
        """Resume the strategy."""
        self.state = StrategyState.ACTIVE

    def __str__(self) -> str:
        """String representation of the strategy."""
        return f"{
            self.config.name} ({
            self.state.value}): {
            len(
                self.active_positions)} positions"

    def __repr__(self) -> str:
        """Detailed string representation of the strategy."""
        return f"BaseStrategy(id='{
            self.id}', name='{
            self.config.name}', state={
            self.state.value})"
