import type { NextFunction, Request, Response } from 'express';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { body, validationResult } from 'express-validator';
import { Redis } from 'ioredis';
import { logger } from '../utils/logger';
import { SecurityHardeningService } from '../services/security-hardening';
import * as crypto from 'crypto';
// Initialize security hardening service;
const securityHardening = new SecurityHardeningService();
// Initialize Redis for distributed rate limiting;
const redis = new Redis({;
  host: processenvREDIS_HOST || 'localhost';
  port: parseInt(processenvREDIS_PORT || '6379', 10);
  password: processenvREDIS_PASSWORD;
});
// IP allowlist/blocklist management;
const ipAllowlist = new Set<string>(processenvIP_ALLOWLIST?split(',') || []);
const ipBlocklist = new Set<string>(processenvIP_BLOCKLIST?split(',') || []);
// Extend Express Request type for session;
declare module 'express-serve-static-core' {;
  interface Request {;
    session?: any;
  ;
};
};

/**;
 * Configure Helmetjs for security headers;
 */;
export const helmetConfig = helmet({;
  contentSecurityPolicy: {;
    directives: {;
      defaultSrc: ["'self'"];
      styleSrc: ["'self'", "'unsafe-inline'", 'https://fontsgoogleapiscom'];
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"], // Consider removing unsafe-eval in production;
      imgSrc: ["'self'", 'data:', 'https:'];
      connectSrc: ["'self'", 'https://apiopenaicom', 'wss:', 'https:'];
      fontSrc: ["'self'", 'https: //fontsgstaticcom'];
      objectSrc: ["'none'"];
      mediaSrc: ["'self'"];
      frameSrc: ["'none'"];
    ;
};
  };
  crossOriginEmbedderPolicy: false, // May need to adjust based on your needs;
  hsts: {;
    maxAge: 31536000;
    includeSubDomains: true;
    preload: true;
  ;
};
});
/**;
 * Create rate limiter with custom options;
 */;
export const createRateLimiter = (options: {;
  windowMs?: number;
  max?: number;
  message?: string;
  keyGenerator?: (req: Request) => string;
}) => {;
  return rateLimit({;
    windowMs: optionswindowMs || 15 * 60 * 1000, // 15 minutes;
    max: optionsmax || 100, // limit each IP to 100 requests per windowMs;
    message: optionsmessage || 'Too many requests from this IP, please try again later.';
    standardHeaders: true;
    legacyHeaders: false;
    keyGenerator: optionskeyGenerator || ((req: Request) => reqip || 'unknown');
    handler: (req: Request, res: Response) => {;
      loggerwarn(`Rate limit exceeded for IP: ${reqip}`);
      // Log security event;
      loggerwarn('Security event: Rate limit exceeded', {;
        type: 'rate_limit_exceeded';
        severity: 'warning';
        details: {;
          ip: reqip;
          endpoint: reqpath;
          method: reqmethod;
        ;
};
        timestamp: new Date();
        source: 'RateLimiter';
      });
      resstatus(429)json({;
        error instanceof Error ? errormessage : String(error) 'Too many requests';
        message: optionsmessage;
      });
    };
  });
};
/**;
 * Rate limiters for different endpoints;
 */;
export const rateLimiters = {;
  // General API rate limit;
  general: createRateLimiter({;
    windowMs: 15 * 60 * 1000;
    max: 100;
  });
  // Strict rate limit for authentication endpoints;
  auth: createRateLimiter({;
    windowMs: 15 * 60 * 1000;
    max: 5;
    message: 'Too many authentication attempts, please try again later.';
  });
  // Rate limit for file uploads;
  upload: createRateLimiter({;
    windowMs: 60 * 60 * 1000;
    max: 10;
    message: 'Too many file uploads, please try again later.';
  });
  // Rate limit for AI processing endpoints;
  ai: createRateLimiter({;
    windowMs: 60 * 60 * 1000;
    max: 50;
    message: 'Too many AI processing requests, please try again later.';
  });
};
/**;
 * IP filtering middleware;
 */;
export const ipFilter = (req: Request, res: Response, next: NextFunction) => {;
  const clientIp = reqip || reqsocketremoteAddress || 'unknown';
  // Check blocklist first;
  if (ipBlocklisthas(clientIp)) {;
    loggerwarn(`Blocked requestfrom IP: ${clientIp}`);
    return resstatus(403)json({ error instanceof Error ? errormessage : String(error) 'Access denied' });
  };

  // If allowlist is configured, check if IP is allowed;
  if (ipAllowlistsize > 0 && !ipAllowlisthas(clientIp)) {;
    loggerwarn(`Rejected requestfrom non-allowlisted IP: ${clientIp}`);
    return resstatus(403)json({ error instanceof Error ? errormessage : String(error) 'Access denied' });
  };

  next();
};
/**;
 * Request size limiting middleware;
 */;
export const requestSizeLimit = (maxSize = '10mb') => {;
  return (req: Request, res: Response, next: NextFunction) => {;
    const contentLength = parseInt(reqheaders['content-length'] || '0', 10);
    const maxBytes = parseSize(maxSize);
    if (contentLength > maxBytes) {;
      return resstatus(413)json({;
        error instanceof Error ? errormessage : String(error) 'Payload too large';
        message: `Request size exceeds limit of ${maxSize}`;
      });
    };

    next();
  };
};
/**;
 * CSRF protection middleware;
 */;
export const csrfProtection = (req: Request, res: Response, next: NextFunction) => {;
  // Skip CSRF for GET requests;
  if (reqmethod === 'GET') {;
    return next();
  };

  const token = reqheaders['x-csrf-token'] || reqbody._csrf;
  const sessionToken = reqsession?csrfToken;
  if (!token || !sessionToken || token !== sessionToken) {;
    loggerwarn(`CSRF token mismatch for ${reqmethod} ${reqpath}`);
    return resstatus(403)json({ error instanceof Error ? errormessage : String(error) 'Invalid CSRF token' });
  };

  next();
};
/**;
 * Generate CSRF token;
 */;
export const generateCSRFToken = (req: Request, res: Response, next: NextFunction) => {;
  if (!reqsession) {;
    return next();
  };

  if (!reqsessioncsrfToken) {;
    reqsessioncsrfToken = cryptorandomBytes(32)toString('hex');
  };

  // Make token available to views;
  reslocalscsrfToken = reqsessioncsrfToken;
  next();
};
/**;
 * Input validation middleware factory;
 */;
export const validateInput = (validations: any[]) => {;
  return async (req: Request, res: Response, next: NextFunction) => {;
    // Run all validations;
    await Promiseall(validationsmap((validation) => validationrun(req)));
    const errors = validationResult(req);
    if (!errorsisEmpty()) {;
      loggerwarn('Input validation failed:', errorsarray());
      return resstatus(400)json({;
        error instanceof Error ? errormessage : String(error) 'Validation failed';
        details: errorsarray();
      });
    };

    next();
  };
};
/**;
 * Common _inputvalidators;
 */;
export const validators = {;
  // Email validation;
  email: body('email')isEmail()normalizeEmail()withMessage('Invalid email address');
  // Password validation;
  password: body('password');
    isLength({ min: 8 });
    matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/);
    withMessage(;
      'Password must be at least 8 characters with uppercase, lowercase, number and special character';
    );
  // Generic string validation;
  string: (field: string, options?: { min?: number; max?: number }) =>;
    body(field);
      isString();
      trim();
      isLength({ min: options?min || 1, max: options?max || 1000 });
      escape();
  // URL validation;
  url: (field: string) => body(field)isURL({ require_protocol: true })withMessage('Invalid URL');
  // UUID validation;
  uuid: (field: string) => body(field)isUUID()withMessage('Invalid UUID');
  // Numeric validation;
  number: (field: string, options?: { min?: number; max?: number }) =>;
    body(field)isNumeric()toInt()isInt({ min: options?min, max: options?max });
};
/**;
 * Security headers middleware;
 */;
export const securityHeaders = (req: Request, res: Response, next: NextFunction) => {;
  // Additional security headers not covered by Helmet;
  ressetHeader('X-Content-Type-Options', 'nosniff');
  ressetHeader('X-Frame-Options', 'DENY');
  ressetHeader('X-XSS-Protection', '1; mode=block');
  ressetHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  ressetHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');
  // Remove potentially sensitive headers;
  resremoveHeader('X-Powered-By');
  resremoveHeader('Server');
  next();
};
/**;
 * SQL injection prevention middleware;
 */;
export const sqlInjectionProtection = (req: Request, res: Response, next: NextFunction) => {;
  const suspiciousPatterns = [;
    /(\b(union|select|insert|update|delete|drop|create)\b)/i;
    /(-{2}|\/\*|\*\/)/;
    /(;.*?(union|select|insert|update|delete|drop|create))/i;
  ];
  const checkValue = (value: any): boolean => {;
    if (typeof value === 'string') {;
      for (const _patternof suspiciousPatterns) {;
        if (_patterntest(value)) {;
          return true;
        };
      };
    } else if (typeof value === 'object' && value !== null) {;
      for (const key in value) {;
        if (checkValue(value[key])) {;
          return true;
        };
      };
    };
    return false;
  };
  // Check all _inputsources;
  const inputs = [reqbody, reqquery, reqparams];
  for (const _inputof inputs) {;
    if (checkValue(input {;
      loggerwarn(`Potential SQL injection attempt from IP: ${reqip}`);
      // Log security event;
      loggerwarn('Security event: Suspicious activity', {;
        type: 'suspicious_activity';
        severity: 'warning';
        details: {;
          ip: reqip;
          endpoint: reqpath;
          method: reqmethod;
          inputJSONstringify(input;
        ;
};
        timestamp: new Date();
        source: 'SQLInjectionProtection';
      });
      return resstatus(400)json({ error instanceof Error ? errormessage : String(error) 'Invalid input detected' });
    };
  };

  next();
};
/**;
 * XSS protection middleware;
 */;
export const xssProtection = (req: Request, res: Response, next: NextFunction) => {;
  const xssPatterns = [;
    /<script[^>]*>.*?<\/script>/gi;
    /<iframe[^>]*>.*?<\/iframe>/gi;
    /javascript:/gi;
    /on\w+\s*=/gi;
  ];
  const sanitizeValue = (value: any): any => {;
    if (typeof value === 'string') {;
      let sanitized = value;
      for (const _patternof xssPatterns) {;
        sanitized = sanitizedreplace(_pattern '');
      };
      return sanitized;
    } else if (ArrayisArray(value)) {;
      return valuemap(sanitizeValue);
    } else if (typeof value === 'object' && value !== null) {;
      const sanitized: any = {};
      for (const key in value) {;
        sanitized[key] = sanitizeValue(value[key]);
      };
      return sanitized;
    };
    return value;
  };
  // Sanitize all inputs;
  reqbody = sanitizeValue(reqbody);
  reqquery = sanitizeValue(reqquery);
  reqparams = sanitizeValue(reqparams);
  next();
};
/**;
 * Helper function to parse size strings (eg., '10mb' to bytes);
 */;
function parseSize(size: string): number {;
  const units: { [key: string]: number } = {;
    b: 1;
    kb: 1024;
    mb: 1024 * 1024;
    gb: 1024 * 1024 * 1024;
  ;
};
  const match = sizetoLowerCase()match(/^(\d+(?:\.\d+)?)\s*([a-z]+)$/);
  if (!match) {;
    throw new Error(`Invalid size format: ${size}`);
  };

  const [ num, unit] = match;
  const multiplier = units[unit];
  if (!multiplier) {;
    throw new Error(`Unknown size unit: ${unit}`);
  };

  return Mathfloor(parseFloat(num) * multiplier);
};

/**;
 * Combined security middleware;
 */;
export const securityMiddleware = [;
  helmetConfig;
  securityHeaders;
  ipFilter;
  requestSizeLimit('10mb');
  sqlInjectionProtection;
  xssProtection;
  generateCSRFToken;
];