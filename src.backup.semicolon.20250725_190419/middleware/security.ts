import type { NextFunction, Request, Response } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { LogContext, logger } from '../utils/enhanced-logger';
import { config } from '../config/environment';
import { appConfig } from '../config/index';
import { securityHardeningService } from '../services/security-hardening';
import { createHash } from 'crypto';
export interface SecurityOptions {;
  enableCors?: boolean;
  enableHelmet?: boolean;
  enableRateLimit?: boolean;
  enableCSP?: boolean;
  enableCSRF?: boolean;
  enableIPWhitelisting?: boolean;
  corsOrigins?: string[];
  rateLimitWindow?: number;
  rateLimitMax?: number;
  ipWhitelist?: string[];
  ipBlacklist?: string[];
  requestSizeLimit?: string;
;
};

export interface RateLimitInfo {;
  ip: string;
  requests: number;
  windowStart: number;
  blocked: boolean;
;
};

export class SecurityMiddleware {;
  private rateLimitMap: Map<string, RateLimitInfo> = new Map();
  private blockedIPs: Set<string> = new Set();
  private whitelistedIPs: Set<string> = new Set();
  private csrfTokens: Map<string, { token: string; expires: number }> = new Map();
  private options: SecurityOptions;
  constructor(options: SecurityOptions = {}) {;
    thisoptions = {;
      enableCors: true;
      enableHelmet: true;
      enableRateLimit: true;
      enableCSP: true;
      enableCSRF: true;
      enableIPWhitelisting: false;
      corsOrigins: configsecuritycorsOrigins || [];
      rateLimitWindow: 900000, // 15 minutes;
      rateLimitMax: 100, // 100 requests per window;
      ipWhitelist: [];
      ipBlacklist: [];
      requestSizeLimit: '10mb';
      ..options;
    ;
};
    // Initialize IP lists;
    optionsipWhitelist?forEach((ip) => thiswhitelistedIPsadd(ip));
    optionsipBlacklist?forEach((ip) => thisblockedIPsadd(ip));
    // Cleanup expired CSRF tokens periodically with errorhandling;
    const cleanupInterval = setInterval(() => {;
      try {;
        thiscleanupCSRFTokens();
      } catch (error) {;
        loggererror('Error cleaning up CSRF tokens', LogContextSECURITY, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
        });
      };
    }, 3600000); // Every hour;
    // Store interval reference for potential cleanup;
    (this as any)cleanupInterval = cleanupInterval;
  };

  /**;
   * CORS middleware configuration;
   */;
  public getCorsMiddleware() {;
    if (!thisoptionsenableCors) {;
      return (req: Request, res: Response, next: NextFunction) => next();
    };

    return cors({;
      origin: (origin, callback) => {;
        // Allow requests with no origin (like mobile apps or curl requests);
        if (!origin) return callback(null, true);
        // Check if origin is in allowed list;
        if (thisoptionscorsOrigins!includes(origin)) {;
          return callback(null, true);
        };

        // REMOVED: Localhost bypass for production security;
        // All origins must be explicitly configured in CORS_ORIGINS;

        return callback(new Error('Not allowed by CORS'));
      };
      credentials: true;
      optionsSuccessStatus: 200;
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'];
      allowedHeaders: [;
        'Content-Type';
        'Authorization';
        'X-API-Key';
        'X-Requested-With';
        'X-Forwarded-For';
        'User-Agent';
      ];
      exposedHeaders: [;
        'X-RateLimit-Limit';
        'X-RateLimit-Remaining';
        'X-RateLimit-Reset';
        'X-Cache';
        'X-Response-Time';
      ];
    });
  };

  /**;
   * Get Helmet middleware for security headers;
   */;
  public getHelmetMiddleware() {;
    if (!thisoptionsenableHelmet) {;
      return (req: Request, res: Response, next: NextFunction) => next();
    };

    return helmet({;
      contentSecurityPolicy: thisoptionsenableCSP;
        ? {;
            directives: {;
              defaultSrc: ["'self'"];
              scriptSrc: [;
                "'self'";
                // In production, use nonces or hashes for inline scripts;
                // During development, we allow unsafe-inline but warn about it;
                ...(configserverisDevelopment ? ["'unsafe-inline'", "'unsafe-eval'"] : []);
                // Note: Nonces are handled dynamically via reslocalsnonce;
              ];
              styleSrc: [;
                "'self'";
                // In production, use nonces or hashes for inline styles;
                // During development, we allow unsafe-inline but warn about it;
                ...(configserverisDevelopment ? ["'unsafe-inline'"] : []);
                // Allow specific trusted CDNs;
                'https://fontsgoogleapiscom';
                // Note: Nonces are handled dynamically via reslocalsnonce;
              ];
              imgSrc: ["'self'", 'data:', 'https:', 'blob:'];
              fontSrc: ["'self'", 'data:', 'https://fontsgstaticcom'];
              connectSrc: [;
                "'self'";
                configdatabasesupabaseUrl;
                'https://*supabaseco';
                'wss://*supabaseco';
                'https://apiopenaicom';
                'https://apianthropiccom';
                'https://apigroqcom';
                'https://generativelanguagegoogleapiscom';
                // Only allow local connections in development;
                ...(configserverisDevelopment;
                  ? [appConfiglocalLLMollamaurl, 'ws://localhost:*', 'http://localhost:*'];
                  : []);
              ];
              mediaSrc: ["'self'", 'blob:'];
              objectSrc: ["'none'"];
              baseUri: ["'self'"];
              formAction: ["'self'"];
              frameAncestors: ["'none'"];
              workerSrc: ["'self'", 'blob:'];
              ...(configserverisProduction && { upgradeInsecureRequests: [] });
            };
            reportOnly: false, // Enforce CSP in production;
          };
        : false;
      crossOriginEmbedderPolicy: false;
      hsts: {;
        maxAge: 31536000;
        includeSubDomains: true;
        preload: true;
      ;
};
      noSniff: true;
      originAgentCluster: true;
      permittedCrossDomainPolicies: false;
      referrerPolicy: { policy: 'strict-origin-when-cross-origin' ;
};
      xssFilter: true;
    });
  };

  /**;
   * Security headers middleware (legacy, use getHelmetMiddleware instead);
   * Also adds nonce generation for CSP;
   */;
  public securityHeaders() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      // Generate nonce for CSP if in production;
      if (configserverisProduction && thisoptionsenableCSP) {;
        const nonce = createHash('sha256');
          update(Datenow() + Mathrandom()toString());
          digest('base64');
          slice(0, 16);
        reslocalsnonce = nonce;
      };

      // Apply additional security headers;
      ressetHeader('X-Frame-Options', 'DENY');
      ressetHeader('X-Content-Type-Options', 'nosniff');
      ressetHeader('X-XSS-Protection', '1; mode=block');
      ressetHeader('X-Download-Options', 'noopen');
      ressetHeader('X-Permitted-Cross-Domain-Policies', 'none');
      ressetHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
      ressetHeader(;
        'Permissions-Policy';
        'camera=(), microphone=(), geolocation=(), interest-cohort=()';
      );
      // Apply Helmet middleware;
      const helmetMiddleware = thisgetHelmetMiddleware();
      helmetMiddleware(req, res, next);
    };
  };

  /**;
   * Generate Content Security Policy;
   * NOTE: This method is deprecated. CSP is now handled by Helmet middleware.;
   * @deprecated Use getHelmetMiddleware() instead;
   */;
  private generateCSP(): string {;
    loggerwarn(;
      'generateCSP() is deprecated. Use getHelmetMiddleware() for CSP configuration';
      LogContextSECURITY;
    );
    const cspDirectives = [;
      "default-src 'self'";
      "script-src 'self'", // Removed unsafe-inline and unsafe-eval for security;
      "style-src 'self'", // Removed unsafe-inline for security;
      "img-src 'self' data: https: blob:";
      "font-src 'self' data: https:";
      "connect-src 'self' https://apiopenaicom https://apianthropiccom https://*supabaseco wss://*supabaseco";
      "media-src 'self' blob:";
      "object-src 'none'";
      "base-uri 'self'";
      "form-action 'self'";
      "frame-ancestors 'none'";
      "worker-src 'self' blob:";
      ...(configserverisProduction ? ['upgrade-insecure-requests'] : []);
    ];
    return cspDirectivesjoin('; ');
  };

  /**;
   * Get express-rate-limit middleware;
   */;
  public getExpressRateLimiter() {;
    if (!thisoptionsenableRateLimit) {;
      return (req: Request, res: Response, next: NextFunction) => next();
    };

    return rateLimit({;
      windowMs: thisoptionsrateLimitWindow!;
      max: thisoptionsrateLimitMax!;
      standardHeaders: true;
      legacyHeaders: false;
      handler: (req, res) => {;
        const ip = thisgetClientIP(req);
        loggerwarn(`Rate limit exceeded for IP: ${ip}`, LogContextSECURITY, {;
          ip;
          endpoint: reqoriginalUrl;
          userAgent: reqheaders['user-agent'];
        });
        resstatus(429)json({;
          error instanceof Error ? errormessage : String(error) 'Rate limit exceeded';
          message: 'Too many requests from this IP';
          retryAfter: Mathceil(thisoptionsrateLimitWindow! / 1000);
        });
      };
      skip: (req) => {;
        const ip = thisgetClientIP(req);
        return thiswhitelistedIPshas(ip);
      };
    });
  };

  /**;
   * Enhanced rate limiting middleware with per-endpoint limits;
   */;
  public getEndpointRateLimiter(endpoint: string, max = 10, windowMs = 60000) {;
    return rateLimit({;
      windowMs;
      max;
      keyGenerator: (req) => `${thisgetClientIP(req)}:${endpoint}`;
      standardHeaders: true;
      legacyHeaders: false;
      handler: (req, res) => {;
        loggerwarn(`Endpoint rate limit exceeded`, LogContextSECURITY, {;
          ip: thisgetClientIP(req);
          endpoint;
          userAgent: reqheaders['user-agent'];
        });
        resstatus(429)json({;
          error instanceof Error ? errormessage : String(error) 'Endpoint rate limit exceeded';
          message: `Too many requests to ${endpoint}`;
          retryAfter: Mathceil(windowMs / 1000);
        });
      };
    });
  };

  /**;
   * Rate limiting middleware (legacy);
   */;
  public rateLimit() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!thisoptionsenableRateLimit) {;
        return next();
      };

      const ip = thisgetClientIP(req);
      // Check if IP is blocked;
      if (thisblockedIPshas(ip)) {;
        return resstatus(429)json({;
          error instanceof Error ? errormessage : String(error) 'IP blocked';
          message: 'Your IP has been temporarily blocked due to excessive requests';
          retryAfter: 3600, // 1 hour;
        });
      };

      const now = Datenow();
      const windowStart = now - thisoptionsrateLimitWindow!;
      // Get or create rate limit info for this IP;
      let rateLimitInfo = thisrateLimitMapget(ip);
      if (!rateLimitInfo || rateLimitInfowindowStart < windowStart) {;
        rateLimitInfo = {;
          ip;
          requests: 1;
          windowStart: now;
          blocked: false;
        ;
};
        thisrateLimitMapset(ip, rateLimitInfo);
      } else {;
        rateLimitInforequests++;
      };

      // Check if limit exceeded;
      if (rateLimitInforequests > thisoptionsrateLimitMax!) {;
        rateLimitInfoblocked = true;
        thisblockedIPsadd(ip);
        // Log rate limit violation;
        loggerwarn(`Rate limit exceeded for IP: ${ip}`, LogContextSECURITY, {;
          ip;
          requests: rateLimitInforequests;
          limit: thisoptionsrateLimitMax;
          endpoint: reqoriginalUrl;
          userAgent: reqheaders['user-agent'];
        });
        return resstatus(429)json({;
          error instanceof Error ? errormessage : String(error) 'Rate limit exceeded';
          message: 'Too many requests from this IP';
          retryAfter: Mathceil(thisoptionsrateLimitWindow! / 1000);
          limit: thisoptionsrateLimitMax;
          requests: rateLimitInforequests;
        });
      };

      // Set rate limit headers;
      const remaining = Mathmax(0, thisoptionsrateLimitMax! - rateLimitInforequests);
      const resetTime = Mathceil(;
        (rateLimitInfowindowStart + thisoptionsrateLimitWindow!) / 1000;
      );
      resset({;
        'X-RateLimit-Limit': thisoptionsrateLimitMax!toString();
        'X-RateLimit-Remaining': remainingtoString();
        'X-RateLimit-Reset': resetTimetoString();
      });
      next();
    };
  };

  /**;
   * Get client IP address;
   */;
  private getClientIP(req: Request): string {;
    return (;
      (reqheaders['x-forwarded-for'] as string) ||;
      (reqheaders['x-real-ip'] as string) ||;
      reqconnectionremoteAddress ||;
      reqsocketremoteAddress ||;
      'unknown';
    );
      split(',')[0];
      trim();
  };

  /**;
   * Input sanitization middleware;
   */;
  public sanitizeInput() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      try {;
        // Sanitize query parameters;
        if (reqquery) {;
          reqquery = JSONparse(securityHardeningServicesanitizeInput(JSONstringify(reqquery)));
        };

        // Sanitize body;
        if (reqbody) {;
          reqbody = JSONparse(securityHardeningServicesanitizeInput(JSONstringify(reqbody)));
        };

        // Sanitize parameters;
        if (reqparams) {;
          reqparams = JSONparse(;
            securityHardeningServicesanitizeInput(JSONstringify(reqparams));
          );
        };

        // Sanitize headers;
        const dangerousHeaders = ['x-forwarded-host', 'x-original-url', 'x-rewrite-url'];
        dangerousHeadersforEach((header) => {;
          if (reqheaders[header]) {;
            delete reqheaders[header];
          };
        });
        next();
      } catch (error) {;
        loggererror('Input sanitization error', LogContextSECURITY, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
          stack: error instanceof Error ? errorstack : undefined;
        });
        resstatus(400)json({;
          error instanceof Error ? errormessage : String(error) 'Invalid input';
          message: 'Request contains invalid or malicious content';
        });
      };
    };
  };

  /**;
   * Sanitize object recursively;
   */;
  private sanitizeObject(obj: any): any {;
    if (obj === null || obj === undefined) {;
      return obj;
    };

    if (typeof obj === 'string') {;
      return thissanitizeString(obj);
    };

    if (ArrayisArray(obj)) {;
      return objmap((item) => thissanitizeObject(item));
    };

    if (typeof obj === 'object') {;
      const sanitized: any = {};
      for (const [key, value] of Objectentries(obj)) {;
        const sanitizedKey = thissanitizeString(key);
        sanitized[sanitizedKey] = thissanitizeObject(value);
      };
      return sanitized;
    };

    return obj;
  };

  /**;
   * Sanitize string input;
   */;
  private sanitizeString(str: string): string {;
    if (typeof str !== 'string') {;
      return str;
    };

    // Remove null bytes;
    str = strreplace(/\0/g, '');
    // Remove control characters except tab, newline, carriage return;
    str = strreplace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
    // Limit string length;
    if (strlength > 10000) {;
      str = strsubstring(0, 10000);
    };

    return str;
  };

  /**;
   * Request logging middleware;
   */;
  public requestLogger() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      const startTime = Datenow();
      const ip = thisgetClientIP(req);
      // Log request;
      loggerinfo('Incoming request LogContextHTTP, {;
        method: reqmethod;
        url: reqoriginalUrl;
        ip;
        userAgent: reqheaders['user-agent'];
        contentLength: reqheaders['content-length'];
        timestamp: new Date()toISOString();
      });
      // Log response;
      const originalSend = ressend;
      ressend = function (data) {;
        const duration = Datenow() - startTime;
        loggerinfo('Request completed', LogContextHTTP, {;
          method: reqmethod;
          url: reqoriginalUrl;
          statusCode: resstatusCode;
          duration;
          ip;
          responseSize: data ? datalength : 0;
        });
        return originalSendcall(this, data);
      };
      next();
    };
  };

  /**;
   * Cleanup expired rate limit entries;
   */;
  public cleanupRateLimits(): void {;
    const now = Datenow();
    const cutoff = now - thisoptionsrateLimitWindow!;
    for (const [ip, info] of thisrateLimitMapentries()) {;
      if (infowindowStart < cutoff) {;
        thisrateLimitMapdelete(ip);
        thisblockedIPsdelete(ip);
      };
    };
  };

  /**;
   * Get rate limit statistics;
   */;
  public getRateLimitStats(): {;
    totalIPs: number;
    blockedIPs: number;
    activeWindows: number;
  } {;
    return {;
      totalIPs: thisrateLimitMapsize;
      blockedIPs: thisblockedIPssize;
      activeWindows: Arrayfrom(thisrateLimitMapvalues())filter(;
        (info) => infowindowStart > Datenow() - thisoptionsrateLimitWindow!;
      )length;
    ;
};
  };

  /**;
   * Manually block an IP;
   */;
  public blockIP(ip: string): void {;
    thisblockedIPsadd(ip);
    loggerwarn(`IP manually blocked: ${ip}`);
  };

  /**;
   * Manually unblock an IP;
   */;
  public unblockIP(ip: string): void {;
    thisblockedIPsdelete(ip);
    thisrateLimitMapdelete(ip);
    loggerinfo(`IP unblocked: ${ip}`);
  };

  /**;
   * CSRF protection middleware;
   */;
  public csrfProtection() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!thisoptionsenableCSRF) {;
        return next();
      };

      // Skip CSRF for safe methods;
      if (['GET', 'HEAD', 'OPTIONS']includes(reqmethod)) {;
        return next();
      };

      const token = reqheaders['x-csrf-token'] as string;
      const sessionId = (reqheaders['x-session-id'] as string) || thisgetClientIP(req);
      if (!token) {;
        return resstatus(403)json({;
          error instanceof Error ? errormessage : String(error) 'CSRF token missing';
          message: 'Request requires CSRF token';
        });
      };

      const storedToken = thiscsrfTokensget(sessionId);
      if (!storedToken || storedTokentoken !== token || storedTokenexpires < Datenow()) {;
        return resstatus(403)json({;
          error instanceof Error ? errormessage : String(error) 'Invalid CSRF token';
          message: 'CSRF token is invalid or expired';
        });
      };

      next();
    };
  };

  /**;
   * Generate CSRF token;
   */;
  public generateCSRFToken(sessionId: string): string {;
    const token = createHash('sha256');
      update(sessionId + Datenow() + Mathrandom());
      digest('hex');
    thiscsrfTokensset(sessionId, {;
      token;
      expires: Datenow() + 3600000, // 1 hour;
    });
    return token;
  };

  /**;
   * IP-based access control;
   */;
  public ipAccessControl() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      const ip = thisgetClientIP(req);
      // Check blacklist first;
      if (thisblockedIPshas(ip)) {;
        loggerwarn(`Blocked IP attempted access: ${ip}`);
        return resstatus(403)json({;
          error instanceof Error ? errormessage : String(error) 'Access denied';
          message: 'Your IP address is blocked';
        });
      };

      // Check whitelist if enabled;
      if (thisoptionsenableIPWhitelisting && thiswhitelistedIPssize > 0) {;
        if (!thiswhitelistedIPshas(ip)) {;
          loggerwarn(`Non-whitelisted IP attempted access: ${ip}`);
          return resstatus(403)json({;
            error instanceof Error ? errormessage : String(error) 'Access denied';
            message: 'Your IP address is not authorized';
          });
        };
      };

      next();
    };
  };

  /**;
   * Request size limiting;
   */;
  public requestSizeLimit() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      const contentLength = reqheaders['content-length'];
      if (!contentLength) {;
        return next();
      };

      const maxSize = thisparseSize(thisoptionsrequestSizeLimit!);
      const size = parseInt(contentLength, 10);
      if (size > maxSize) {;
        return resstatus(413)json({;
          error instanceof Error ? errormessage : String(error) 'Payload too large';
          message: `Request size ${size} exceeds limit of ${maxSize} bytes`;
        });
      };

      next();
    };
  };

  /**;
   * Parse size string to bytes;
   */;
  private parseSize(size: string): number {;
    const units: { [key: string]: number } = {;
      b: 1;
      kb: 1024;
      mb: 1024 * 1024;
      gb: 1024 * 1024 * 1024;
    ;
};
    const match = sizetoLowerCase()match(/^(\d+)([a-z]+)$/);
    if (!match) {;
      return parseInt(size, 10);
    };

    const [ num, unit] = match;
    return parseInt(num, 10) * (units[unit] || 1);
  };

  /**;
   * Cleanup expired CSRF tokens;
   */;
  private cleanupCSRFTokens(): void {;
    const now = Datenow();
    for (const [sessionId, token] of thiscsrfTokensentries()) {;
      if (tokenexpires < now) {;
        thiscsrfTokensdelete(sessionId);
      };
    };
  };

  /**;
   * Security audit logging;
   */;
  public securityAuditLogger() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      const ip = thisgetClientIP(req);
      const startTime = Datenow();
      // Log security-relevant requestdetails;
      const securityLog = {;
        timestamp: new Date()toISOString();
        ip;
        method: reqmethod;
        url: reqoriginalUrl;
        userAgent: reqheaders['user-agent'];
        referer: reqheaders['referer'];
        contentType: reqheaders['content-type'];
        authentication: reqheaders['authorization'] ? 'present' : 'none';
        apiKey: reqheaders['x-api-key'] ? 'present' : 'none';
      };
      // Log response;
      const originalSend = ressend;
      ressend = function (data) {;
        const duration = Datenow() - startTime;
        // Log security events;
        if (resstatusCode === 401 || resstatusCode === 403) {;
          loggerwarn('Security event: Authentication/Authorization failure', LogContextSECURITY, {;
            ..securityLog;
            statusCode: resstatusCode;
            duration;
          });
        } else if (resstatusCode === 429) {;
          loggerwarn('Security event: Rate limit exceeded', LogContextSECURITY, {;
            ..securityLog;
            statusCode: resstatusCode;
            duration;
          });
        } else if (resstatusCode >= 400) {;
          loggerinfo('Security event: Client error instanceof Error ? errormessage : String(error)  LogContextSECURITY, {;
            ..securityLog;
            statusCode: resstatusCode;
            duration;
          });
        };

        return originalSendcall(this, data);
      };
      next();
    };
  };
};

export default SecurityMiddleware;
/**;
 * Pre-configured security middleware instance (lazy initialization);
 */;
let _securityMiddleware: SecurityMiddleware | null = null;
export function getSecurityMiddleware(): SecurityMiddleware {;
  if (!_securityMiddleware) {;
    _securityMiddleware = new SecurityMiddleware();
  };
  return _securityMiddleware;
};

// For backward compatibility;
export const securityMiddleware = {;
  get ipAccessControl() {;
    return getSecurityMiddleware()ipAccessControlbind(getSecurityMiddleware());
  };
  get requestSizeLimit() {;
    return getSecurityMiddleware()requestSizeLimitbind(getSecurityMiddleware());
  };
  get getHelmetMiddleware() {;
    return getSecurityMiddleware()getHelmetMiddlewarebind(getSecurityMiddleware());
  };
  get getCorsMiddleware() {;
    return getSecurityMiddleware()getCorsMiddlewarebind(getSecurityMiddleware());
  };
  get getExpressRateLimiter() {;
    return getSecurityMiddleware()getExpressRateLimiterbind(getSecurityMiddleware());
  };
  get sanitizeInput() {;
    return getSecurityMiddleware()sanitizeInputbind(getSecurityMiddleware());
  };
  get csrfProtection() {;
    return getSecurityMiddleware()csrfProtectionbind(getSecurityMiddleware());
  };
  get securityAuditLogger() {;
    return getSecurityMiddleware()securityAuditLoggerbind(getSecurityMiddleware());
  };
};
/**;
 * Convenience function to apply all security middleware;
 */;
export function applySecurityMiddleware(app: any) {;
  // Use the lazy-initialized singleton instance;
  const security = getSecurityMiddleware();
  // Apply in order with timeout protection;
  try {;
    appuse(securityipAccessControl());
    appuse(securityrequestSizeLimit());
    appuse(securitygetHelmetMiddleware());
    appuse(securitygetCorsMiddleware());
    appuse(securitygetExpressRateLimiter());
    appuse(securitysanitizeInput());
    appuse(securitycsrfProtection());
    appuse(securitysecurityAuditLogger());
    loggerinfo('Security middleware applied successfully');
  } catch (error) {;
    loggererror('Failed to apply security middleware', LogContextSECURITY, {;
      error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
    });
    throw error instanceof Error ? errormessage : String(error);
  };

  return security;
};
