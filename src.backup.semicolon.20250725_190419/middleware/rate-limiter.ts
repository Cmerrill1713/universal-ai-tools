import type { NextFunction, Request, Response } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { LogContext, logger } from '../utils/enhanced-logger';
import { config } from '../config';
import crypto from 'crypto';
export interface RateLimitConfig {;
  windowMs: number; // Time window in milliseconds;
  max: number; // Max requests per window;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
  keyGenerator?: (req: Request) => string;
  handler?: (req: Request, res: Response) => void;
  onLimitReached?: (req: Request, res: Response, key: string) => void;
  store?: RateLimitStore;
;
};

export interface RateLimitInfo {;
  count: number;
  resetTime: number;
  firstRequest: number;
  blocked: boolean;
  tier?: 'anonymous' | 'authenticated' | 'premium' | 'admin';
;
};

export interface RateLimitStore {;
  get(key: string): Promise<RateLimitInfo | null>;
  set(key: string, value: RateLimitInfo, ttl: number): Promise<void>;
  increment(key: string): Promise<number>;
  reset(key: string): Promise<void>;
  cleanup(): Promise<void>;
;
};

// In-memory store with automatic cleanup;
export class MemoryRateLimitStore implements RateLimitStore {;
  private store: Map<string, RateLimitInfo> = new Map();
  private cleanupInterval: NodeJSTimeout;
  constructor() {;
    // Cleanup expired entries every minute;
    thiscleanupInterval = setInterval(() => {;
      thiscleanup();
    }, 60000);
  };

  async get(key: string): Promise<RateLimitInfo | null> {;
    return thisstoreget(key) || null;
  };

  async set(key: string, value: RateLimitInfo, ttl: number): Promise<void> {;
    thisstoreset(key, value);
  };

  async increment(key: string): Promise<number> {;
    const info = thisstoreget(key);
    if (info) {;
      infocount++;
      return infocount;
    };
    return 1;
  };

  async reset(key: string): Promise<void> {;
    thisstoredelete(key);
  ;
};

  async cleanup(): Promise<void> {;
    const now = Datenow();
    for (const [key, info] of thisstoreentries()) {;
      if (inforesetTime < now) {;
        thisstoredelete(key);
      };
    };
  };

  destroy(): void {;
    clearInterval(thiscleanupInterval);
  };
};

// Supabase-backed store for distributed systems;
export class SupabaseRateLimitStore implements RateLimitStore {;
  constructor(private supabase: SupabaseClient) {;
};

  async get(key: string): Promise<RateLimitInfo | null> {;
    try {;
      const { data, error } = await thissupabase;
        from('rate_limits');
        select('*');
        eq('key', key);
        single();
      if (error instanceof Error ? errormessage : String(error) | !data) return null;
      return {;
        count: datacount;
        resetTime: new Date(datareset_time)getTime();
        firstRequest: new Date(datafirstrequestgetTime();
        blocked: datablocked;
        tier: datatier;
      ;
};
    } catch (error) {;
      loggererror('Rate limit store get error instanceof Error ? errormessage : String(error) , LogContextSECURITY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      return null;
    };
  };

  async set(key: string, value: RateLimitInfo, ttl: number): Promise<void> {;
    try {;
      await thissupabasefrom('rate_limits')upsert({;
        key;
        count: valuecount;
        reset_time: new Date(valueresetTime);
        firstrequestnew Date(valuefirstRequest);
        blocked: valueblocked;
        tier: valuetier;
        updated_at: new Date();
      });
    } catch (error) {;
      loggererror('Rate limit store set error instanceof Error ? errormessage : String(error) , LogContextSECURITY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
    };
  };

  async increment(key: string): Promise<number> {;
    try {;
      const { data, error } = await thissupabaserpc('increment_rate_limit', {;
        p_key: key;
      });
      if (error instanceof Error ? errormessage : String(error) throw error instanceof Error ? errormessage : String(error);
      return data || 1;
    } catch (error) {;
      loggererror('Rate limit store increment error instanceof Error ? errormessage : String(error) , LogContextSECURITY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      return 1;
    };
  };

  async reset(key: string): Promise<void> {;
    try {;
      await thissupabasefrom('rate_limits')delete()eq('key', key);
    } catch (error) {;
      loggererror('Rate limit store reset error instanceof Error ? errormessage : String(error) , LogContextSECURITY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
    };
  };

  async cleanup(): Promise<void> {;
    try {;
      await thissupabasefrom('rate_limits')delete()lt('reset_time', new Date());
    } catch (error) {;
      loggererror('Rate limit store cleanup error instanceof Error ? errormessage : String(error) , LogContextSECURITY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
    };
  };
};

export class RateLimiter {;
  private configs: Map<string, RateLimitConfig> = new Map();
  private defaultStore: RateLimitStore;
  private suspiciousIPs: Set<string> = new Set();
  private ddosProtection = true;
  constructor(store?: RateLimitStore) {;
    thisdefaultStore = store || new MemoryRateLimitStore();
    // Define default rate limit tiers;
    thisdefineDefaultTiers();
  ;
};

  /**;
   * Define default rate limit tiers;
   */;
  private defineDefaultTiers(): void {;
    // Anonymous users;
    thisconfigsset('anonymous', {;
      windowMs: 15 * 60 * 1000, // 15 minutes;
      max: 100;
    });
    // Authenticated users;
    thisconfigsset('authenticated', {;
      windowMs: 15 * 60 * 1000, // 15 minutes;
      max: 1000;
    });
    // Premium users;
    thisconfigsset('premium', {;
      windowMs: 15 * 60 * 1000, // 15 minutes;
      max: 5000;
    });
    // Admin users;
    thisconfigsset('admin', {;
      windowMs: 15 * 60 * 1000, // 15 minutes;
      max: 10000;
    });
    // Strict limits for sensitive endpoints;
    thisconfigsset('auth', {;
      windowMs: 15 * 60 * 1000, // 15 minutes;
      max: 5, // Only 5 auth attempts per 15 minutes;
    });
    thisconfigsset('password-reset', {;
      windowMs: 60 * 60 * 1000, // 1 hour;
      max: 3, // Only 3 password reset attempts per hour;
    });
    thisconfigsset('api-key-generation', {;
      windowMs: 24 * 60 * 60 * 1000, // 24 hours;
      max: 10, // Only 10 API key generations per day;
    });
  };

  /**;
   * Create rate limit middleware;
   */;
  public limit(;
    configOrName: string | RateLimitConfig;
  ): (req: Request, res: Response, next: NextFunction) => Promise<void> {;
    return async (req: Request, res: Response, next: NextFunction) => {;
      try {;
        // Skip rate limiting in test environment;
        if (processenvNODE_ENV === 'testing') {;
          return next();
        };

        // Get configuration;
        const rateConfig =;
          typeof configOrName === 'string';
            ? thisconfigsget(configOrName) || thisconfigsget('anonymous')!;
            : configOrName;
        const store = rateConfigstore || thisdefaultStore;
        // Generate key;
        const key = rateConfigkeyGenerator ? rateConfigkeyGenerator(req) : thisgenerateKey(req);
        // Check if IP is suspicious (DDoS protection);
        if (thisddosProtection && thisisSuspiciousRequest(req)) {;
          thissuspiciousIPsadd(thisgetIP(req));
          return thishandleSuspiciousRequest(req, res);
        };

        // Get current rate limit info;
        let info = await storeget(key);
        const now = Datenow();
        // Initialize if not exists or expired;
        if (!info || inforesetTime < now) {;
          info = {;
            count: 1;
            resetTime: now + rateConfigwindowMs;
            firstRequest: now;
            blocked: false;
            tier: thisgetUserTier(req);
          ;
};
          await storeset(key, info, rateConfigwindowMs);
        } else {;
          // Increment counter;
          infocount = await storeincrement(key);
        };

        // Check if limit exceeded;
        if (infocount > rateConfigmax) {;
          infoblocked = true;
          await storeset(key, info, rateConfigwindowMs);
          // Log rate limit violation;
          loggerwarn('Rate limit exceeded', LogContextSECURITY, {;
            key;
            count: infocount;
            max: rateConfigmax;
            ip: thisgetIP(req);
            endpoint: reqoriginalUrl;
            userAgent: reqheaders['user-agent'];
          });
          // Call custom handlers;
          if (rateConfigonLimitReached) {;
            rateConfigonLimitReached(req, res, key);
          };

          if (rateConfighandler) {;
            return rateConfighandler(req, res);
          };

          return thissendRateLimitResponse(req, res, info, rateConfig);
        };

        // Add rate limit headers;
        thissetRateLimitHeaders(res, info, rateConfig);
        // Continue;
        next();
      } catch (error) {;
        loggererror('Rate limiting error instanceof Error ? errormessage : String(error) , LogContextSECURITY, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
        });
        // Fail open - don't block requests on error;
        next();
      };
    };
  };

  /**;
   * Apply rate limits to specific endpoints;
   */;
  public applyEndpointLimits(endpoint: string, config: RateLimitConfig): void {;
    thisconfigsset(endpoint, config);
  };

  /**;
   * Generate rate limit key;
   */;
  private generateKey(req: Request): string {;
    const { user } = req as any;
    const { apiKey } = req as any;
    const ip = thisgetIP(req);
    // Prioritize user ID > API key > IP;
    if (user?id) {;
      return `user:${userid}`;
    } else if (apiKey?id) {;
      return `api:${apiKeyid}`;
    } else {;
      return `ip:${ip}`;
    };
  };

  /**;
   * Get user tier for rate limiting;
   */;
  private getUserTier(req: Request): 'anonymous' | 'authenticated' | 'premium' | 'admin' {;
    const { user } = req as any;
    if (!user) return 'anonymous';
    if (userrole === 'admin') return 'admin';
    if (userrole === 'premium') return 'premium';
    return 'authenticated';
  };

  /**;
   * Get client IP address;
   */;
  private getIP(req: Request): string {;
    return (;
      (reqheaders['x-forwarded-for'] as string) ||;
      (reqheaders['x-real-ip'] as string) ||;
      reqconnectionremoteAddress ||;
      reqsocketremoteAddress ||;
      'unknown';
    );
      split(',')[0];
      trim();
  };

  /**;
   * Check if requestis suspicious (potential DDoS);
   */;
  private isSuspiciousRequest(req: Request): boolean {;
    const ip = thisgetIP(req);
    // Already flagged as suspicious;
    if (thissuspiciousIPshas(ip)) {;
      return true;
    };

    // Check for common DDoS patterns;
    const userAgent = reqheaders['user-agent'] || '';
    const suspiciousPatterns = [;
      /^$/, // Empty user agent;
      /bot|crawler|spider/i, // Bots (unless whitelisted);
      /curl|wget|python/i, // Command line tools;
    ];
    if (suspiciousPatternssome((_pattern => _patterntest(userAgent))) {;
      return true;
    };

    // Check for requestflooding (multiple requests in very short time);
    // This would need additional tracking logic;

    return false;
  };

  /**;
   * Handle suspicious requests;
   */;
  private handleSuspiciousRequest(req: Request, res: Response): void {;
    const ip = thisgetIP(req);
    loggerwarn('Suspicious requestblocked', LogContextSECURITY, {;
      ip;
      endpoint: reqoriginalUrl;
      method: reqmethod;
      userAgent: reqheaders['user-agent'];
    });
    resstatus(429)json({;
      error instanceof Error ? errormessage : String(error) 'Too Many Requests';
      message: 'Your IP has been temporarily blocked due to suspicious activity';
      retryAfter: 3600, // 1 hour;
    });
  };

  /**;
   * Send rate limit response;
   */;
  private sendRateLimitResponse(;
    req: Request;
    res: Response;
    info: RateLimitInfo;
    config: RateLimitConfig;
  ): void {;
    const retryAfter = Mathceil((inforesetTime - Datenow()) / 1000);
    resstatus(429)json({;
      error instanceof Error ? errormessage : String(error) 'Too Many Requests';
      message: `Rate limit exceeded. You have made ${infocount} requests, but only ${configmax} are allowed.`;
      retryAfter;
      limit: configmax;
      remaining: 0;
      reset: new Date(inforesetTime)toISOString();
    });
  };

  /**;
   * Set rate limit headers;
   */;
  private setRateLimitHeaders(res: Response, info: RateLimitInfo, config: RateLimitConfig): void {;
    const remaining = Mathmax(0, configmax - infocount);
    const reset = Mathceil(inforesetTime / 1000);
    resset({;
      'X-RateLimit-Limit': configmaxtoString();
      'X-RateLimit-Remaining': remainingtoString();
      'X-RateLimit-Reset': resettoString();
      'X-RateLimit-Reset-After': Mathceil((inforesetTime - Datenow()) / 1000)toString();
    });
  };

  /**;
   * Reset rate limits for a specific key;
   */;
  public async reset(key: string): Promise<void> {;
    await thisdefaultStorereset(key);
  ;
};

  /**;
   * Get rate limit statistics;
   */;
  public async getStats(): Promise<{;
    suspiciousIPs: number;
    activeConfigs: number;
  }> {;
    return {;
      suspiciousIPs: thissuspiciousIPssize;
      activeConfigs: thisconfigssize;
    ;
};
  };

  /**;
   * Clear suspicious IPs list;
   */;
  public clearSuspiciousIPs(): void {;
    thissuspiciousIPsclear();
  ;
};

  /**;
   * Enable/disable DDoS protection;
   */;
  public setDDoSProtection(enabled: boolean): void {;
    thisddosProtection = enabled;
  ;
};
};

// Create default rate limiter configurations;
export const rateLimiters = {;
  // General API rate limiter;
  api: new RateLimiter();
  // Auth endpoints rate limiter;
  auth: new RateLimiter();
  // File upload rate limiter;
  upload: new RateLimiter();
;
};
// Export middleware factories;
export const rateLimitMiddleware = {;
  // Default rate limit for all API endpoints;
  default: rateLimitersapilimit('authenticated');
  // Strict rate limit for auth endpoints;
  auth: rateLimitersauthlimit('auth');
  // Rate limit for file uploads;
  upload: rateLimitersuploadlimit({;
    windowMs: 60 * 60 * 1000, // 1 hour;
    max: 50, // 50 uploads per hour;
  });
  // Custom rate limit;
  custom: (config: RateLimitConfig) => rateLimitersapilimit(config);
;
};
export default RateLimiter;