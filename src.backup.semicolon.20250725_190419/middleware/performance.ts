import type { NextFunction, Request, Response } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { performanceMonitor } from '../utils/performance-monitor';
import { ImprovedCacheManager } from '../utils/cache-manager-improved';
import DatabaseOptimizer from '../utils/database-optimizer';
import { LogContext, logger } from '../utils/enhanced-logger';
import { config } from '../config';
export interface PerformanceMiddlewareOptions {;
  enableRequestTiming?: boolean;
  enableMemoryMonitoring?: boolean;
  enableCacheMetrics?: boolean;
  enableDatabaseOptimization?: boolean;
  slowRequestThreshold?: number;
  memoryThreshold?: number;
  requestTimeoutMs?: number;
;
};

export interface RequestMetrics {;
  url: string;
  method: string;
  statusCode: number;
  responseTime: number;
  memoryUsage: number;
  userAgent?: string;
  ip?: string;
  cached?: boolean;
  timestamp: number;
;
};

export class PerformanceMiddleware {;
  private cache: ImprovedCacheManager;
  private dbOptimizer: DatabaseOptimizer;
  private options: PerformanceMiddlewareOptions;
  private requestMetrics: RequestMetrics[] = [];
  private maxMetricsHistory = 10000;
  constructor(supabase: SupabaseClient, options: PerformanceMiddlewareOptions = {}) {;
    thisoptions = {;
      enableRequestTiming: true;
      enableMemoryMonitoring: true;
      enableCacheMetrics: true;
      enableDatabaseOptimization: true;
      slowRequestThreshold: 2000, // 2 seconds;
      memoryThreshold: 1024, // 1GB;
      requestTimeoutMs: 30000, // 30 seconds;
      ..options;
    };
    thiscache = new ImprovedCacheManager(configredis?url || 'redis://localhost:6379');
    thisdbOptimizer = new DatabaseOptimizer(supabase, thiscache);
    thisinitializeMonitoring();
  };

  private initializeMonitoring(): void {;
    if (thisoptionsenableMemoryMonitoring) {;
      performanceMonitorstartMonitoring(10000); // 10 seconds;
      performanceMonitoron('threshold-exceeded', (event) => {;
        loggerwarn('Performance threshold exceeded', LogContextPERFORMANCE, { event });
        thishandleThresholdExceeded(event);
      });
    };
  };

  private handleThresholdExceeded(event: any): void {;
    switch (eventtype) {;
      case 'memory':;
        thishandleMemoryThreshold(event);
        break;
      case 'response-time':;
        thishandleResponseTimeThreshold(event);
        break;
      case 'errorrate':;
        thishandleErrorRateThreshold(event);
        break;
      case 'cache-hit-rate':;
        thishandleCacheHitRateThreshold(event);
        break;
    };
  };

  private handleMemoryThreshold(event: any): void {;
    loggerwarn(`Memory threshold exceeded: ${eventvalue}MB`, LogContextPERFORMANCE);
    // Force garbage collection;
    performanceMonitorforceGarbageCollection();
    // Clear old metrics;
    thiscleanupOldMetrics();
    // Optionally restart workers or clear caches;
    if (eventvalue > thisoptionsmemoryThreshold! * 1.5) {;
      loggererror('Critical memory usage detected, clearing caches', LogContextPERFORMANCE);
      thiscacheflush();
    };
  };

  private handleResponseTimeThreshold(event: any): void {;
    loggerwarn(`Response time threshold exceeded: ${eventvalue}ms`, LogContextPERFORMANCE);
    // Could implement requestqueuing or load balancing here;
  };

  private handleErrorRateThreshold(event: any): void {;
    loggerwarn(`Error rate threshold exceeded: ${eventvalue}%`, LogContextPERFORMANCE);
    // Could implement circuit breaker _patternhere;
  };

  private handleCacheHitRateThreshold(event: any): void {;
    loggerwarn(`Cache hit rate below threshold: ${eventvalue}%`, LogContextPERFORMANCE);
    // Could implement cache warming strategies here;
  };

  private cleanupOldMetrics(): void {;
    const oneHourAgo = Datenow() - 3600000;
    thisrequestMetrics = thisrequestMetricsfilter((m) => mtimestamp > oneHourAgo);
    if (thisrequestMetricslength > thismaxMetricsHistory) {;
      thisrequestMetrics = thisrequestMetricsslice(-thismaxMetricsHistory);
    };
  };

  public requestTimer() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!thisoptionsenableRequestTiming) {;
        return next();
      };

      const startTime = processhrtime();
      const startMemory = processmemoryUsage()heapUsed;
      // Set requesttimeout;
      const timeout = setTimeout(() => {;
        if (!resheadersSent) {;
          resstatus(408)json({ error instanceof Error ? errormessage : String(error) 'Request timeout' });
        };
      }, thisoptionsrequestTimeoutMs);
      // Override resend to capture metrics;
      const originalEnd = resend;
      const self = this;
      resend = function (this: Response, ..args: any[]) {;
        clearTimeout(timeout);
        const [seconds, nanoseconds] = processhrtime(startTime);
        const responseTime = seconds * 1000 + nanoseconds / 1000000;
        const endMemory = processmemoryUsage()heapUsed;
        const memoryUsage = endMemory - startMemory;
        const metrics: RequestMetrics = {;
          url: reqoriginalUrl || requrl;
          method: reqmethod;
          statusCode: resstatusCode;
          responseTime;
          memoryUsage;
          userAgent: reqheaders['user-agent'];
          ip: reqip || reqconnectionremoteAddress;
          timestamp: Datenow();
        ;
};
        // Record metrics;
        const isError = resstatusCode >= 400;
        performanceMonitorrecordRequest(responseTime, isError);
        // Store metrics;
        selfrequestMetricspush(metrics);
        // Log errors with more detail;
        if (isError) {;
          loggererror;
            `Request error instanceof Error ? errormessage : String(error) ${reqmethod} ${requrl} - Status: ${resstatusCode} - Response time: ${responseTime}ms`;
            LogContextPERFORMANCE;
            {;
              method: reqmethod;
              url: requrl;
              statusCode: resstatusCode;
              responseTime;
              headers: reqheaders;
              ip: reqip;
            ;
};
          );
        };

        // Log slow requests;
        if (responseTime > selfoptionsslowRequestThreshold!) {;
          loggerwarn(;
            `Slow requestdetected: ${reqmethod} ${requrl} - ${responseTime}ms`;
            LogContextPERFORMANCE;
          );
        };

        // Log high memory usage;
        if (memoryUsage > 50 * 1024 * 1024) {;
          // 50MB;
          loggerwarn(;
            `High memory usage request${reqmethod} ${requrl} - ${memoryUsage / 1024 / 1024}MB`;
            LogContextPERFORMANCE;
          );
        };

        return originalEndapply(this, args as any);
      };
      next();
    };
  };

  public responseCache(defaultTtl = 3600) {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!thisoptionsenableCacheMetrics) {;
        return next();
      };

      // Only cache GET requests;
      if (reqmethod !== 'GET') {;
        return next();
      };

      const cacheKey = thiscachecreateCacheKey(;
        reqoriginalUrl || requrl;
        JSONstringify(reqquery);
      );
      // Try to get from cache;
      thiscache;
        get(cacheKey);
        then((cached) => {;
          if (cached) {;
            // Mark as cached for metrics;
            (res as any)fromCache = true;
            resset('X-Cache', 'HIT');
            resjson(cached);
            return;
          };

          // Cache miss, continue to handler;
          resset('X-Cache', 'MISS');
          // Override resjson to cache the response;
          const originalJson = resjson;
          const self = this;
          resjson = function (this: Response, body: any) {;
            // Cache successful responses;
            if (resstatusCode < 400) {;
              selfcacheset(cacheKey, body, {;
                ttl: defaultTtl;
                tags: [reqroute?path || reqpath];
              });
            };
;
            return originalJsoncall(this, body);
          };
          next();
        });
        catch((error instanceof Error ? errormessage : String(error)=> {;
          loggererror('Cache middleware error instanceof Error ? errormessage : String(error)  LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error));
          next();
        });
    };
  };

  public databaseOptimizer() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!thisoptionsenableDatabaseOptimization) {;
        return next();
      };

      // Add database optimizer to requestobject;
      (req as any)dbOptimizer = thisdbOptimizer;
      next();
    };
  };

  public rateLimiter(windowMs = 900000, max = 100) {;
    const requests = new Map<string, { count: number; resetTime: number }>();
    return (req: Request, res: Response, next: NextFunction) => {;
      const identifier = reqip || reqconnectionremoteAddress || 'unknown';
      const now = Datenow();
      const userRequests = requestsget(identifier);
      if (!userRequests || now > userRequestsresetTime) {;
        requestsset(identifier, { count: 1, resetTime: now + windowMs });
        return next();
      };

      if (userRequestscount >= max) {;
        return resstatus(429)json({;
          error instanceof Error ? errormessage : String(error) 'Too many requests';
          retryAfter: Mathceil((userRequestsresetTime - now) / 1000);
        });
      };

      userRequestscount++;
      next();
    };
  };

  public compressionMiddleware() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      const acceptEncoding = reqheaders['accept-encoding'] || '';
      if (acceptEncodingincludes('gzip')) {;
        resset('Content-Encoding', 'gzip');
      } else if (acceptEncodingincludes('deflate')) {;
        resset('Content-Encoding', 'deflate');
      };

      next();
    };
  };

  public async getMetrics() {;
    const [performanceStats, cacheStats, dbStats] = await Promiseall([;
      performanceMonitorgetAggregatedMetrics();
      thiscachegetStats();
      thisdbOptimizergetStats();
    ]);
    const requestStats = thisanalyzeRequestMetrics();
    return {;
      performance: performanceStats;
      cache: cacheStats;
      database: dbStats;
      requests: requestStats;
      timestamp: Datenow();
    ;
};
  };

  private analyzeRequestMetrics() {;
    const now = Datenow();
    const last5Minutes = thisrequestMetricsfilter((m) => mtimestamp > now - 300000);
    const last1Hour = thisrequestMetricsfilter((m) => mtimestamp > now - 3600000);
    const calculateStats = (metrics: RequestMetrics[]) => {;
      if (metricslength === 0) return { count: 0, avgResponseTime: 0, errorRate: 0 ;
};
      const totalTime = metricsreduce((sum, m) => sum + mresponseTime, 0);
      const errors = metricsfilter((m) => mstatusCode >= 400)length;
      return {;
        count: metricslength;
        avgResponseTime: totalTime / metricslength;
        errorRate: (errors / metricslength) * 100;
      ;
};
    };
    return {;
      last5Minutes: calculateStats(last5Minutes);
      last1Hour: calculateStats(last1Hour);
      slowRequests: thisrequestMetricsfilter(;
        (m) => mresponseTime > thisoptionsslowRequestThreshold!;
      )length;
      topEndpoints: thisgetTopEndpoints(last1Hour);
    ;
};
  };

  private getTopEndpoints(;
    metrics: RequestMetrics[];
  ): Array<{ endpoint: string; count: number; avgResponseTime: number }> {;
    const endpoints = new Map<string, { count: number; totalTime: number }>();
    metricsforEach((metric) => {;
      const endpoint = `${metricmethod} ${metricurl}`;
      const existing = endpointsget(endpoint) || { count: 0, totalTime: 0 };
      endpointsset(endpoint, {;
        count: existingcount + 1;
        totalTime: existingtotalTime + metricresponseTime;
      });
    });
    return Arrayfrom(endpointsentries());
      map(([endpoint, stats]) => ({;
        endpoint;
        count: statscount;
        avgResponseTime: statstotalTime / statscount;
      }));
      sort((a, b) => bcount - acount);
      slice(0, 10);
  };

  public async generatePerformanceReport(): Promise<string> {;
    const metrics = await thisgetMetrics();
    const healthChecks = await thisrunHealthChecks();
    return ``;
=== Universal AI Tools Performance Report ===;
Generated: ${new Date()toISOString();
};

=== System Health ===;
Overall Health: ${healthChecksoverall ? '✅ HEALTHY' : '❌ UNHEALTHY';
};
Cache Health: ${healthCheckscache ? '✅ HEALTHY' : '❌ UNHEALTHY';
};
Database Health: ${healthChecksdatabase ? '✅ HEALTHY' : '❌ UNHEALTHY';
};

=== Performance Metrics ===;
Average Memory Usage: ${metricsperformanceaverageMemoryUsagetoFixed(2)}MB;
Peak Memory Usage: ${metricsperformancepeakMemoryUsage}MB;
Average Response Time: ${metricsperformanceaverageResponseTimetoFixed(2)}ms;
Peak Response Time: ${metricsperformancepeakResponseTime}ms;
Total Requests: ${metricsperformancetotalRequests;
};
Error Rate: ${metricsperformanceerrorRatetoFixed(2)}%;
=== Cache Performance ===;
Hit Rate: ${metricscachehitRatetoFixed(2)}%;
Total Hits: ${metricscachehits;
};
Total Misses: ${metricscachemisses;
};
Average Response Time: ${metricscacheavgResponseTimetoFixed(2)}ms;
Memory Usage: ${(metricscachememoryUsage / 1024 / 1024)toFixed(2)}MB;
Key Count: ${metricscachekeyCount;
};

=== Database Performance ===;
Total Queries: ${metricsdatabasetotalQueries;
};
Cached Queries: ${metricsdatabasecachedQueries;
};
Average Response Time: ${metricsdatabaseavgResponseTimetoFixed(2)}ms;
Slow Queries: ${metricsdatabaseslowQueries;
};
Error Rate: ${((metricsdatabaseerrors / metricsdatabasetotalQueries) * 100)toFixed(2)}%;
=== Request Analytics ===;
Last 5 Minutes: ${metricsrequestslast5Minutescount} requests;
Last Hour: ${metricsrequestslast1Hourcount} requests;
Slow Requests: ${metricsrequestsslowRequests;
};

=== Top Endpoints ===;
${metricsrequeststopEndpoints;
  map((ep) => `${ependpoint}: ${epcount} requests (${epavgResponseTimetoFixed(2)}ms avg)`);
  join('\n')};

=== Recommendations ===;
${thisgenerateRecommendations(metrics)};
`;`;
  };

  private generateRecommendations(metrics: any): string {;
    const recommendations: string[] = [];
    if (metricsperformanceaverageMemoryUsage > 800) {;
      recommendationspush('• Consider increasing memory limits or optimizing memory usage');
    };

    if (metricsperformanceaverageResponseTime > 1000) {;
      recommendationspush('• Response times are high - consider optimizing slow endpoints');
    };

    if (metricscachehitRate < 70) {;
      recommendationspush('• Cache hit rate is low - review caching strategy');
    };

    if (metricsdatabaseavgResponseTime > 500) {;
      recommendationspush(;
        '• Database queries are slow - consider adding indexes or optimizing queries';
      );
    };

    if (recommendationslength === 0) {;
      recommendationspush('• System is performing well - no immediate optimizations needed');
    };

    return recommendationsjoin('\n');
  };

  private async runHealthChecks() {;
    const [cacheHealth, dbHealth] = await Promiseall([;
      thiscachehealthCheck();
      thisdbOptimizerhealthCheck();
    ]);
    return {;
      overall: cacheHealthhealthy && dbHealthhealthy;
      cache: cacheHealthhealthy;
      database: dbHealthhealthy;
    ;
};
  };

  public async close(): Promise<void> {;
    performanceMonitorstopMonitoring();
    await thiscacheclose();
  ;
};
};

export default PerformanceMiddleware;