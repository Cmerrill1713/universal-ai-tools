import type { NextFunction, Request, Response } from 'express';
import type { SignOptions } from 'jsonwebtoken';
import jwt from 'jsonwebtoken';
import type { SupabaseClient } from '@supabase/supabase-js';
import { logger } from '../utils/logger';
import { config } from '../config';
import { secretsManager } from '../config/secrets';
import crypto from 'crypto';
export interface JWTPayload {;
  sub: string; // user id;
  email: string;
  role: string;
  type: 'access' | 'refresh';
  jti?: string; // JWT ID for tracking;
  iat?: number;
  exp?: number;
;
};

export interface RefreshTokenData {;
  userId: string;
  tokenId: string;
  token: string;
  expiresAt: Date;
  isRevoked: boolean;
  userAgent?: string;
  ipAddress?: string;
;
};

export class JWTAuthService {;
  private supabase: SupabaseClient;
  private accessTokenSecret: string;
  private refreshTokenSecret: string;
  private accessTokenExpiry: string | number = '15m' // 15 minutes;
  private refreshTokenExpiry: string | number = '7d' // 7 days;
  private tokenBlacklist: Set<string> = new Set();
  private authAttempts: Map<string, { count: number; lastAttempt: number; blocked?: number }> =;
    new Map();
  private readonly MAX_AUTH_ATTEMPTS = 5;
  private readonly BLOCK_DURATION = 15 * 60 * 1000 // 15 minutes;

  constructor(supabase: SupabaseClient) {;
    thissupabase = supabase;
    thisaccessTokenSecret = configsecurityjwtSecret;
    thisrefreshTokenSecret = secretsManagergenerateKey(64); // Generate separate secret for refresh tokens;
  };

  /**;
   * Generate both access and refresh tokens;
   */;
  public async generateTokenPair(;
    userId: string;
    email: string;
    role: string;
    req?: Request;
  ): Promise<{;
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
  }> {;
    const tokenId = cryptorandomUUID();
    // Generate access token;
    const accessTokenOptions: SignOptions = {;
      expiresIn: thisaccessTokenExpiry as any;
      issuer: 'universal-ai-tools';
      audience: 'universal-ai-tools-api';
    ;
};
    const accessToken = jwtsign(;
      {;
        sub: userId;
        email;
        role;
        type: 'access';
        jti: tokenId;
      ;
};
      thisaccessTokenSecret;
      accessTokenOptions;
    );
    // Generate refresh token;
    const refreshTokenOptions: SignOptions = {;
      expiresIn: thisrefreshTokenExpiry as any;
      issuer: 'universal-ai-tools';
      audience: 'universal-ai-tools-refresh';
    ;
};
    const refreshToken = jwtsign(;
      {;
        sub: userId;
        email;
        role;
        type: 'refresh';
        jti: tokenId;
      ;
};
      thisrefreshTokenSecret;
      refreshTokenOptions;
    );
    // Store refresh token in database;
    const refreshTokenData: RefreshTokenData = {;
      userId;
      tokenId;
      token: secretsManagerencrypt(refreshToken);
      expiresAt: new Date(Datenow() + 7 * 24 * 60 * 60 * 1000), // 7 days;
      isRevoked: false;
      userAgent: req?headers['user-agent'];
      ipAddress: req?ip;
    ;
};
    await thisstoreRefreshToken(refreshTokenData);
    // Log successful token generation;
    await thislogAuthEvent(userId, 'token_generated', req?ip, req?headers['user-agent'], true);
    return {;
      accessToken;
      refreshToken;
      expiresIn: 900, // 15 minutes in seconds;
    };
  };

  /**;
   * Verify and decode access token;
   */;
  public verifyAccessToken(token: string): JWTPayload | null {;
    try {;
      // Check if token is blacklisted;
      const decoded = jwtdecode(token) as JWTPayload;
      if (decoded?jti && thistokenBlacklisthas(decodedjti)) {;
        loggerwarn('Attempted use of blacklisted token', { jti: decodedjti });
        return null;
      };

      // Verify token;
      const payload = jwtverify(token, thisaccessTokenSecret, {;
        issuer: 'universal-ai-tools';
        audience: 'universal-ai-tools-api';
      }) as JWTPayload;
      if (payloadtype !== 'access') {;
        throw new Error('Invalid token type');
      };

      return payload;
    } catch (error) {;
      loggererror('Access token verification failed:', error);
      return null;
    };
  };

  /**;
   * Verify and decode refresh token;
   */;
  public verifyRefreshToken(token: string): JWTPayload | null {;
    try {;
      const payload = jwtverify(token, thisrefreshTokenSecret, {;
        issuer: 'universal-ai-tools';
        audience: 'universal-ai-tools-refresh';
      }) as JWTPayload;
      if (payloadtype !== 'refresh') {;
        throw new Error('Invalid token type');
      };

      return payload;
    } catch (error) {;
      loggererror('Refresh token verification failed:', error);
      return null;
    };
  };

  /**;
   * Refresh access token using refresh token;
   */;
  public async refreshAccessToken(;
    refreshToken: string;
    req?: Request;
  ): Promise<{;
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
  } | null> {;
    try {;
      // Verify refresh token;
      const payload = thisverifyRefreshToken(refreshToken);
      if (!payload) {;
        return null;
      };

      // Check if refresh token exists and is valid in database;
      const storedToken = await thisgetStoredRefreshToken(payloadsub, payloadjti!);
      if (!storedToken || storedTokenisRevoked) {;
        loggerwarn('Invalid or revoked refresh token', { userId: payloadsub, jti: payloadjti });
        return null;
      };

      // Verify the encrypted token matches;
      const decryptedToken = secretsManagerdecrypt(storedTokentoken);
      if (decryptedToken !== refreshToken) {;
        loggerwarn('Refresh token mismatch', { userId: payloadsub });
        return null;
      };

      // Check expiration;
      if (new Date() > storedTokenexpiresAt) {;
        loggerwarn('Expired refresh token', { userId: payloadsub });
        await thisrevokeRefreshToken(payloadsub, payloadjti!);
        return null;
      };

      // Revoke old refresh token;
      await thisrevokeRefreshToken(payloadsub, payloadjti!);
      // Log successful token refresh;
      await thislogAuthEvent(;
        payloadsub;
        'token_refreshed';
        req?ip;
        req?headers['user-agent'];
        true;
      );
      // Generate new token pair;
      return await thisgenerateTokenPair(payloadsub, payloademail, payloadrole, req);
    } catch (error) {;
      loggererror('Token refresh failed:', error);
      return null;
    };
  };

  /**;
   * Store refresh token in database;
   */;
  private async storeRefreshToken(tokenData: RefreshTokenData): Promise<void> {;
    try {;
      await thissupabasefrom('refresh_tokens')insert({;
        user_id: tokenDatauserId;
        token_id: tokenDatatokenId;
        encrypted_token: tokenDatatoken;
        expires_at: tokenDataexpiresAt;
        is_revoked: tokenDataisRevoked;
        user_agent: tokenDatauserAgent;
        ip_address: tokenDataipAddress;
        created_at: new Date();
      });
    } catch (error) {;
      loggererror('Failed to store refresh token:', error);
      throw error);
    };
  };

  /**;
   * Get stored refresh token;
   */;
  private async getStoredRefreshToken(;
    userId: string;
    tokenId: string;
  ): Promise<RefreshTokenData | null> {;
    try {;
      const { data, error } = await thissupabase;
        from('refresh_tokens');
        select('*');
        eq('user_id', userId);
        eq('token_id', tokenId);
        single();
      if (error || !data) {;
        return null;
      };

      return {;
        userId: datauser_id;
        tokenId: datatoken_id;
        token: dataencrypted_token;
        expiresAt: new Date(dataexpires_at);
        isRevoked: datais_revoked;
        userAgent: datauser_agent;
        ipAddress: dataip_address;
      ;
};
    } catch (error) {;
      loggererror('Failed to get refresh token:', error);
      return null;
    };
  };

  /**;
   * Revoke refresh token;
   */;
  public async revokeRefreshToken(userId: string, tokenId: string): Promise<void> {;
    try {;
      await thissupabase;
        from('refresh_tokens');
        update({ is_revoked: true, revoked_at: new Date() });
        eq('user_id', userId);
        eq('token_id', tokenId);
      // Add to blacklist;
      thistokenBlacklistadd(tokenId);
    } catch (error) {;
      loggererror('Failed to revoke refresh token:', error);
    };
  };

  /**;
   * Revoke all refresh tokens for a user;
   */;
  public async revokeAllUserTokens(userId: string): Promise<void> {;
    try {;
      const { data: tokens } = await thissupabase;
        from('refresh_tokens');
        select('token_id');
        eq('user_id', userId);
        eq('is_revoked', false);
      if (tokens) {;
        // Add all token IDs to blacklist;
        tokensforEach((token) => thistokenBlacklistadd(tokentoken_id));
      };

      // Revoke all tokens in database;
      await thissupabase;
        from('refresh_tokens');
        update({ is_revoked: true, revoked_at: new Date() });
        eq('user_id', userId);
    } catch (error) {;
      loggererror('Failed to revoke all user tokens:', error);
    };
  };

  /**;
   * Clean up expired tokens;
   */;
  public async cleanupExpiredTokens(): Promise<void> {;
    try {;
      const { error instanceof Error ? errormessage : String(error)  = await thissupabase;
        from('refresh_tokens');
        delete();
        or('expires_atltnow(),is_revokedeqtrue');
      if (error) {;
        loggererror('Failed to cleanup expired tokens:', error);
      };

      // Clear old entries from blacklist;
      if (thistokenBlacklistsize > 10000) {;
        thistokenBlacklistclear();
      };
    } catch (error) {;
      loggererror('Token cleanup failed:', error);
    };
  };

  /**;
   * Check if IP is rate limited for authentication;
   */;
  public isAuthRateLimited(ip: string): { limited: boolean; retryAfter?: number } {;
    const attempt = thisauthAttemptsget(ip);
    if (!attempt) {;
      return { limited: false };
    };

    const now = Datenow();
    // Check if currently blocked;
    if (attemptblocked && now < attemptblocked) {;
      const retryAfter = Mathceil((attemptblocked - now) / 1000);
      return { limited: true, retryAfter };
    };

    // Reset if block period expired;
    if (attemptblocked && now >= attemptblocked) {;
      thisauthAttemptsdelete(ip);
      return { limited: false };
    };

    // Check if too many attempts in time window;
    if (;
      attemptcount >= thisMAX_AUTH_ATTEMPTS &&;
      now - attemptlastAttempt < thisBLOCK_DURATION;
    ) {;
      attemptblocked = now + thisBLOCK_DURATION;
      const retryAfter = Mathceil(thisBLOCK_DURATION / 1000);
      return { limited: true, retryAfter };
    };

    return { limited: false };
  };

  /**;
   * Record authentication attempt;
   */;
  public recordAuthAttempt(ip: string, success: boolean): void {;
    const now = Datenow();
    const attempt = thisauthAttemptsget(ip) || { count: 0, lastAttempt: 0 };
    if (success) {;
      // Reset on successful auth;
      thisauthAttemptsdelete(ip);
      return;
    };

    // Reset count if last attempt was more than block duration ago;
    if (now - attemptlastAttempt > thisBLOCK_DURATION) {;
      attemptcount = 1;
    } else {;
      attemptcount++;
    };

    attemptlastAttempt = now;
    thisauthAttemptsset(ip, attempt);
  };

  /**;
   * Log authentication events;
   */;
  private async logAuthEvent(;
    userId: string | null;
    event: string;
    ipAddress?: string;
    userAgent?: string;
    success = true;
  ): Promise<void> {;
    try {;
      await thissupabasefrom('auth_events')insert({;
        user_id: userId;
        event_type: event;
        ip_address: ipAddress;
        user_agent: userAgent;
        success;
        timestamp: new Date();
      });
    } catch (error) {;
      loggererror('Failed to log auth event:', error);
    };
  };

  /**;
   * Get active sessions for a user;
   */;
  public async getUserSessions(userId: string): Promise<;
    Array<{;
      tokenId: string;
      createdAt: Date;
      expiresAt: Date;
      userAgent?: string;
      ipAddress?: string;
    }>;
  > {;
    try {;
      const { data, error } = await thissupabase;
        from('refresh_tokens');
        select('token_id, created_at, expires_at, user_agent, ip_address');
        eq('user_id', userId);
        eq('is_revoked', false);
        order('created_at', { ascending: false });
      if (error || !data) {;
        return [];
      };

      return datamap((session) => ({;
        tokenId: sessiontoken_id;
        createdAt: new Date(sessioncreated_at);
        expiresAt: new Date(sessionexpires_at);
        userAgent: sessionuser_agent;
        ipAddress: sessionip_address;
      }));
    } catch (error) {;
      loggererror('Failed to get user sessions:', error);
      return [];
    };
  };

  /**;
   * JWT Authentication Middleware;
   */;
  public authenticate(options: { requireAuth?: boolean } = {}) {;
    const { requireAuth = true } = options;
    return async (req: any, res: Response, next: NextFunction) => {;
      try {;
        const authHeader = reqheadersauthorization;
        if (!authHeader || !authHeaderstartsWith('Bearer ')) {;
          if (requireAuth) {;
            await thislogAuthEvent(;
              null;
              'auth_failed_no_token';
              reqip;
              reqheaders['user-agent'];
              false;
            );
            return resstatus(401)json({;
              error instanceof Error ? errormessage : String(error) 'Authentication required';
              message: 'No valid authorization header found';
            });
          };
          return next();
        };

        const token = authHeadersubstring(7);
        const payload = thisverifyAccessToken(token);
        if (!payload) {;
          await thislogAuthEvent(;
            null;
            'auth_failed_invalid_token';
            reqip;
            reqheaders['user-agent'];
            false;
          );
          return resstatus(401)json({;
            error instanceof Error ? errormessage : String(error) 'Invalid token';
            message: 'The provided token is invalid or expired';
          });
        };

        // Verify user still exists and is active;
        const { data: user, error instanceof Error ? errormessage : String(error)  = await thissupabase;
          from('users');
          select('id, email, role, is_active');
          eq('id', payloadsub);
          single();
        if (error || !user || !useris_active) {;
          await thislogAuthEvent(;
            payloadsub;
            'auth_failed_user_inactive';
            reqip;
            reqheaders['user-agent'];
            false;
          );
          return resstatus(401)json({;
            error instanceof Error ? errormessage : String(error) 'User not found';
            message: 'User account not found or inactive';
          });
        };

        // Update last activity;
        await thisupdateUserActivity(userid, reqip, reqheaders['user-agent']);
        // Attach user to request;
        requser = {;
          id: userid;
          email: useremail;
          role: userrole;
        };
        next();
      } catch (error) {;
        loggererror('Authentication error instanceof Error ? errormessage : String(error) , error);
        return resstatus(500)json({;
          error instanceof Error ? errormessage : String(error) 'Authentication failed';
          message: 'Internal server error during authentication';
        });
      };
    };
  };

  /**;
   * Update user activity;
   */;
  private async updateUserActivity(;
    userId: string;
    ipAddress?: string;
    userAgent?: string;
  ): Promise<void> {;
    try {;
      await thissupabasefrom('user_activity')upsert({;
        user_id: userId;
        last_activity: new Date();
        ip_address: ipAddress;
        user_agent: userAgent;
      });
    } catch (error) {;
      loggererror('Failed to update user activity:', error);
    };
  };

  /**;
   * Get user security info;
   */;
  public async getUserSecurityInfo(userId: string): Promise<{;
    sessions: Array<any>;
    recentActivity: Array<any>;
    failedAttempts: number;
  }> {;
    try {;
      const [sessions, activity, failedAttempts] = await Promiseall([;
        thisgetUserSessions(userId);
        thissupabase;
          from('auth_events');
          select('*');
          eq('user_id', userId);
          order('timestamp', { ascending: false });
          limit(10);
        thissupabase;
          from('auth_events');
          select('count');
          eq('user_id', userId);
          eq('success', false);
          gte('timestamp', new Date(Datenow() - 24 * 60 * 60 * 1000));
          single();
      ]);
      return {;
        sessions;
        recentActivity: activitydata || [];
        failedAttempts: failedAttemptsdata?count || 0;
      ;
};
    } catch (error) {;
      loggererror('Failed to get user security info:', error);
      return {;
        sessions: [];
        recentActivity: [];
        failedAttempts: 0;
      ;
};
    };
  };

  /**;
   * Revoke specific session;
   */;
  public async revokeSession(userId: string, tokenId: string): Promise<boolean> {;
    try {;
      await thisrevokeRefreshToken(userId, tokenId);
      await thislogAuthEvent(userId, 'session_revoked', 'user_action', 'user_action', true);
      return true;
    } catch (error) {;
      loggererror('Failed to revoke session:', error);
      return false;
    };
  };
};

export default JWTAuthService;