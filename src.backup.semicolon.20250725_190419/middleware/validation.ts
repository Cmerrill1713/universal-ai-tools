import type { NextFunction, Request, Response } from 'express';
import type { ZodError, ZodSchema } from 'zod';
import { z } from 'zod';
import { logger } from '../utils/logger';
export interface ValidationOptions {;
  body?: ZodSchema;
  query?: ZodSchema;
  params?: ZodSchema;
  headers?: ZodSchema;
  stripUnknown?: boolean;
  abortEarly?: boolean;
;
};

export class ValidationMiddleware {;
  /**;
   * Create validation middleware;
   */;
  public static validate(options: ValidationOptions) {;
    return (req: Request, res: Response, next: NextFunction) => {;
      try {;
        const errors: string[] = [];
        // Validate body;
        if (optionsbody && reqbody) {;
          const result = optionsbodysafeParse(reqbody);
          if (!resultsuccess) {;
            errorspush(..thisformatZodErrors(resulterror instanceof Error ? errormessage : String(error) 'body'));
          } else {;
            reqbody = resultdata;
          };
        };

        // Validate query;
        if (optionsquery && reqquery) {;
          const result = optionsquerysafeParse(reqquery);
          if (!resultsuccess) {;
            errorspush(..thisformatZodErrors(resulterror instanceof Error ? errormessage : String(error) 'query'));
          } else {;
            reqquery = resultdata;
          };
        };

        // Validate params;
        if (optionsparams && reqparams) {;
          const result = optionsparamssafeParse(reqparams);
          if (!resultsuccess) {;
            errorspush(..thisformatZodErrors(resulterror instanceof Error ? errormessage : String(error) 'params'));
          } else {;
            reqparams = resultdata;
          };
        };

        // Validate headers;
        if (optionsheaders && reqheaders) {;
          const result = optionsheaderssafeParse(reqheaders);
          if (!resultsuccess) {;
            errorspush(..thisformatZodErrors(resulterror instanceof Error ? errormessage : String(error) 'headers'));
          ;
};
        };

        if (errorslength > 0) {;
          return resstatus(400)json({;
            error instanceof Error ? errormessage : String(error) 'Validation failed';
            message: 'Request validation failed';
            details: errors;
          });
        };

        next();
      } catch (error) {;
        loggererror('Validation middleware error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error);
        return resstatus(500)json({;
          error instanceof Error ? errormessage : String(error) 'Internal server error instanceof Error ? errormessage : String(error);
          message: 'Validation processing failed';
        });
      };
    };
  };

  /**;
   * Format Zod errors;
   */;
  private static formatZodErrors(error instanceof Error ? errormessage : String(error) ZodError, location: string): string[] {;
    return errorerrorsmap((err) => {;
      const path = errpathlength > 0 ? errpathjoin('.') : 'root';
      return `${location}.${path}: ${errmessage}`;
    });
  };
};

// Common validation schemas;
export const CommonSchemas = {;
  // Pagination;
  pagination: zobject({;
    page: zcoercenumber()min(1)default(1);
    limit: zcoercenumber()min(1)max(100)default(10);
    offset: zcoercenumber()min(0)optional();
  });
  // Search;
  search: zobject({;
    query: zstring()min(1)max(1000);
    filters: zrecord(zany())optional();
    sort: zstring()optional();
    order: zenum(['asc', 'desc'])optional();
  });
  // Memory operations;
  memory: zobject({;
    id: zstring()uuid()optional();
    contentzstring()min(1)max(10000);
    metadata: zrecord(zany())optional();
    tags: zarray(zstring())optional();
    importance: znumber()min(0)max(1)optional();
    category: zstring()optional();
  });
  // User feedback;
  feedback: zobject({;
    memory_id: zstring()uuid();
    relevance: znumber()min(1)max(5)optional();
    accuracy: znumber()min(1)max(5)optional();
    helpfulness: znumber()min(1)max(5)optional();
    comment: zstring()max(1000)optional();
  });
  // Agent operations;
  agent: zobject({;
    name: zstring()min(1)max(100);
    type: zenum(['cognitive', 'search', '_analysis, 'generation']);
    config: zrecord(zany())optional();
    active: zboolean()default(true);
  });
  // LLM requests;
  llmRequest: zobject({;
    prompt: zstring()min(1)max(50000);
    model: zstring()optional();
    temperature: znumber()min(0)max(2)optional();
    maxTokens: znumber()min(1)max(4096)optional();
    stream: zboolean()optional();
    systemPrompt: zstring()optional();
  });
  // File operations;
  file: zobject({;
    filename: zstring()min(1)max(255);
    contentType: zstring()optional();
    size: z;
      number();
      min(1);
      max(100 * 1024 * 1024), // 100MB limit;
    contentzstring()optional();
    url: zstring()url()optional();
  });
  // Configuration;
  config: zobject({;
    key: zstring()min(1)max(100);
    value: zunion([zstring(), znumber(), zboolean(), zrecord(zany())]);
    description: zstring()optional();
    category: zstring()optional();
  });
  // Health check;
  health: zobject({;
    component: zstring()optional();
    detailed: zboolean()optional();
  });
  // Analytics;
  analytics: zobject({;
    startDate: zcoercedate()optional();
    endDate: zcoercedate()optional();
    metrics: zarray(zstring())optional();
    groupBy: zstring()optional();
  });
  // Export/Import;
  export: zobject({;
    format: zenum(['json', 'csv', 'xml'])default('json');
    filters: zrecord(zany())optional();
    includeMetadata: zboolean()default(true);
  });
  // Batch operations;
  batch: zobject({;
    operations: z;
      array(;
        zobject({;
          type: zenum(['create', 'update', 'delete']);
          id: zstring()optional();
          data: zrecord(zany())optional();
        });
      );
      min(1);
      max(100);
    transactional: zboolean()default(false);
  });
};
// Route-specific validation schemas;
export const RouteSchemas = {;
  // Memory endpoints;
  'POST /api/memory/store': {;
    body: CommonSchemasmemory;
  ;
};
  'GET /api/memory/search': {;
    query: CommonSchemassearchextend({;
      limit: zcoercenumber()min(1)max(50)default(10);
      category: zstring()optional();
      tags: zarray(zstring())optional();
    });
  };
  'PUT /api/memory/:id': {;
    params: zobject({;
      id: zstring()uuid();
    });
    body: CommonSchemasmemorypartial();
  ;
};
  'DELETE /api/memory/:id': {;
    params: zobject({;
      id: zstring()uuid();
    });
  };
  // Agent endpoints;
  'POST /api/agents': {;
    body: CommonSchemasagent;
  ;
};
  'GET /api/agents': {;
    query: CommonSchemaspaginationextend({;
      type: zenum(['cognitive', 'search', '_analysis, 'generation'])optional();
      active: zcoerceboolean()optional();
    });
  };
  'PUT /api/agents/:id': {;
    params: zobject({;
      id: zstring()uuid();
    });
    body: CommonSchemasagentpartial();
  ;
};
  // LLM endpoints;
  'POST /api/llm/chat': {;
    body: CommonSchemasllmRequest;
  ;
};
  'POST /api/llm/completion': {;
    body: CommonSchemasllmRequest;
  ;
};
  // File endpoints;
  'POST /api/files/upload': {;
    body: CommonSchemasfile;
  ;
};
  'GET /api/files/:id': {;
    params: zobject({;
      id: zstring()uuid();
    });
  };
  // Feedback endpoints;
  'POST /api/feedback': {;
    body: CommonSchemasfeedback;
  ;
};
  // Configuration endpoints;
  'POST /api/config': {;
    body: CommonSchemasconfig;
  ;
};
  'GET /api/config': {;
    query: zobject({;
      category: zstring()optional();
      key: zstring()optional();
    });
  };
  // Analytics endpoints;
  'GET /api/analytics': {;
    query: CommonSchemasanalytics;
  ;
};
  // Export/Import endpoints;
  'POST /api/export': {;
    body: CommonSchemasexport;
  ;
};
  'POST /api/import': {;
    body: zobject({;
      format: zenum(['json', 'csv', 'xml'])default('json');
      data: zstring()min(1);
      overwrite: zboolean()default(false);
    });
  };
  // Batch operations;
  'POST /api/batch': {;
    body: CommonSchemasbatch;
  ;
};
  // Health check;
  'GET /api/health': {;
    query: CommonSchemashealth;
  ;
};
};
// Helper function to get validation middleware for a specific route;
export function getValidationMiddleware(method: string, path: string) {;
  const routeKey = `${methodtoUpperCase()} ${path}`;
  const schema = RouteSchemas[routeKey as keyof typeof RouteSchemas];
  if (!schema) {;
    return (req: Request, res: Response, next: NextFunction) => next();
  };

  return ValidationMiddlewarevalidate(schema);
};

// Custom validation helpers;
export const CustomValidators = {;
  /**;
   * Validate UUID format;
   */;
  uuid: (value: string) => {;
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegextest(value);
  };
  /**;
   * Validate email format;
   */;
  email: (value: string) => {;
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegextest(value);
  };
  /**;
   * Validate URL format;
   */;
  url: (value: string) => {;
    try {;
      new URL(value);
      return true;
    } catch {;
      return false;
    };
  };
  /**;
   * Validate phone number format;
   */;
  phone: (value: string) => {;
    const phoneRegex = /^\+?[\d\s\-\(\)]{10}$/;
    return phoneRegextest(value);
  };
  /**;
   * Validate JSON format;
   */;
  json: (value: string) => {;
    try {;
      JSONparse(value);
      return true;
    } catch {;
      return false;
    };
  };
  /**;
   * Validate date format;
   */;
  date: (value: string) => {;
    const date = new Date(value);
    return !isNaN(dategetTime());
  };
  /**;
   * Validate password strength;
   */;
  password: (value: string) => {;
    // At least 8 characters, 1 uppercase, 1 lowercase, 1 number, 1 special char;
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8}$/;
    return passwordRegextest(value);
  };
  /**;
   * Validate file extension;
   */;
  fileExtension: (filename: string, allowedExtensions: string[]) => {;
    const ext = filenamesplit('.')pop()?toLowerCase();
    return ext ? allowedExtensionsincludes(ext) : false;
  };
  /**;
   * Validate IP address format;
   */;
  ip: (value: string) => {;
    const ipv4Regex =;
      /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    const ipv6Regex = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
    return ipv4Regextest(value) || ipv6Regextest(value);
  };
};
export default ValidationMiddleware;