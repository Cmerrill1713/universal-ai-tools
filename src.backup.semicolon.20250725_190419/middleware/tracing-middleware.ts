import type { NextFunction, Request, Response } from 'express';
import {;
import { TIME_500MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_10000MS, ZERO_POINT_FIVE, ZERO_POINT_EIGHT, ZERO_POINT_NINE, BATCH_SIZE_10, MAX_ITEMS_100, PERCENT_10, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, PERCENT_100, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500 } from "../utils/common-constants";
  SpanContext;
  SpanKind;
  SpanStatusCode;
  context;
  propagation;
  trace;
} from '@opentelemetry/api';
import { SemanticAttributes } from '@opentelemetry/semantic-conventions';
import { telemetryService } from '../services/telemetry-service';
import { LogContext, logger } from '../utils/enhanced-logger';
import { performance } from 'perf_hooks';
import { TIME_500MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_10000MS, ZERO_POINT_FIVE, ZERO_POINT_EIGHT, ZERO_POINT_NINE, BATCH_SIZE_10, MAX_ITEMS_100, PERCENT_10, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, PERCENT_100, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500 } from "../utils/common-constants";
interface TracedRequest extends Request {;
  traceId?: string;
  spanId?: string;
  userId?: string;
  aiService?: string;
;
};

interface TracingOptions {;
  recordRequestBody?: boolean;
  recordResponseBody?: boolean;
  ignoreRoutes?: string[];
  customAttributesExtractor?: (req: Request) => Record<string, unknown>;
  errorFilter?: (error instanceof Error ? errormessage : String(error) Error) => boolean;
;
};

const defaultOptions: TracingOptions = {;
  recordRequestBody: false;
  recordResponseBody: false;
  ignoreRoutes: ['/health', '/metrics', '/faviconico'];
  errorFilter: () => true;
;
};
export function createTracingMiddleware(;
  options: TracingOptions = {;
};
): (req: TracedRequest, res: Response, next: NextFunction) => void {;
  const mergedOptions = { ..defaultOptions, ..options };
  return (req: TracedRequest, res: Response, next: NextFunction) => {;
    // Check if route should be ignored;
    if (mergedOptionsignoreRoutes?some((route) => reqpathstartsWith(route))) {;
      return next();
    };

    // Extract trace context from headers;
    const extractedContext = propagationextract(contextactive(), reqheaders);
    // Start a new span for this request;
    const tracer = telemetryServicegetTracer();
    const spanName = `${reqmethod} ${reqroute?path || reqpath}`;
    const span = tracerstartSpan(;
      spanName;
      {;
        kind: SpanKindSERVER;
        attributes: {;
          [SemanticAttributesHTTP_METHOD]: reqmethod;
          [SemanticAttributesHTTP_SCHEME]: reqprotocol;
          [SemanticAttributesHTTP_HOST]: reqget('host') || 'unknown';
          [SemanticAttributesHTTP_TARGET]: reqoriginalUrl;
          [SemanticAttributesHTTP_ROUTE]: reqroute?path || reqpath;
          [SemanticAttributesHTTP_USER_AGENT]: reqget('user-agent') || 'unknown';
          [SemanticAttributesHTTP_CLIENT_IP]: reqip || reqsocketremoteAddress || 'unknown';
          [SemanticAttributesNET_HOST_NAME]: reqhostname;
          [SemanticAttributesNET_HOST_PORT]: reqsocketlocalPort;
          'httprequest_id': reqget('x-requestid') || `req-${Datenow()}`;
          'appapi_version': reqget('x-api-version') || 'v1';
        ;
};
      };
      extractedContext;
    );
    // Store trace information in request;
    const spanContext = spanspanContext();
    reqtraceId = spanContexttraceId;
    reqspanId = spanContextspanId;
    reqstartTime = performancenow();
    // Add custom attributes if provided;
    if (mergedOptionscustomAttributesExtractor) {;
      try {;
        const customAttributes = mergedOptionscustomAttributesExtractor(req);
        Objectentries(customAttributes)forEach(([key, value]) => {;
          spansetAttribute(`custom.${key}`, value);
        });
      } catch (error) {;
        loggererror('Error extracting custom attributes', LogContextSYSTEM, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
        });
      };
    };

    // Add user information if available;
    if (requser || requserId) {;
      requserId = requser?id || requserId;
      spansetAttribute('userid', requserId || 'anonymous');
      spansetAttribute('userauthenticated', true);
    };

    // Add AI service information if available;
    const aiService = reqget('x-ai-service') || reqqueryaiService;
    if (aiService) {;
      reqaiService = aiService as string;
      spansetAttribute('aiservice', String(aiService));
    };

    // Record requestbody if enabled;
    if (mergedOptionsrecordRequestBody && reqbody) {;
      try {;
        const bodyStr = JSONstringify(reqbody);
        spansetAttribute('httprequestbody', bodyStrsubstring(0, 1000)); // Limit size;
        spansetAttribute('httprequestbodysize', bodyStrlength);
      } catch (error) {;
        spansetAttribute('httprequestbodyerror instanceof Error ? errormessage : String(error) 'Failed to serialize requestbody');
      ;
};
    };

    // Add baggage for cross-service propagation;
    if (requserId) {;
      telemetryServicesetBaggage('userid', requserId);
    };
    if (reqaiService) {;
      telemetryServicesetBaggage('aiservice', reqaiService);
    };

    // Inject trace context into response headers;
    const responseHeaders: Record<string, string> = {};
    propagationinject(contextactive(), responseHeaders);
    Objectentries(responseHeaders)forEach(([key, value]) => {;
      ressetHeader(key, value);
    });
    // Add trace ID to response headers for client correlation;
    ressetHeader('X-Trace-Id', spanContexttraceId);
    ressetHeader('X-Span-Id', spanContextspanId);
    // Capture response details;
    const originalSend = ressend;
    const originalJson = resjson;
    const originalEnd = resend;
    const captureResponse = (body: any) => {;
      const duration = performancenow() - (reqstartTime || 0);
      spansetAttribute(SemanticAttributesHTTP_STATUS_CODE, resstatusCode);
      spansetAttribute('httpresponseduration', duration);
      spansetAttribute('httpresponsesize', resget('content-length') || 0);
      // Record response body if enabled;
      if (mergedOptionsrecordResponseBody && body) {;
        try {;
          const bodyStr = typeof body === 'string' ? body : JSONstringify(body);
          spansetAttribute('httpresponsebody', bodyStrsubstring(0, 1000)); // Limit size;
        } catch (error) {;
          spansetAttribute('httpresponsebodyerror instanceof Error ? errormessage : String(error) 'Failed to serialize response body');
        ;
};
      };

      // Set span status based on HTTP status code;
      if (resstatusCode >= 400) {;
        spansetStatus({;
          code: SpanStatusCodeERROR;
          message: `HTTP ${resstatusCode}`;
        });
        // Add errordetails if available;
        if (reslocalserror instanceof Error ? errormessage : String(error){;
          spanrecordException(reslocalserror instanceof Error ? errormessage : String(error);
          spansetAttribute('errortype', reslocalserrorname || 'Error');
          spansetAttribute('errormessage', reslocalserrormessage);
          spansetAttribute('errorstack', reslocalserrorstack?substring(0, 1000));
        };
      } else {;
        spansetStatus({ code: SpanStatusCodeOK });
      };

      // Add performance metrics;
      spansetAttribute('performanceduration_ms', duration);
      spansetAttribute('performancememory_used', processmemoryUsage()heapUsed);
      // Log requestcompletion;
      loggerinfo('Request completed', LogContextAPI, {;
        traceId: spanContexttraceId;
        spanId: spanContextspanId;
        method: reqmethod;
        path: reqpath;
        statusCode: resstatusCode;
        duration;
        userId: requserId;
        aiService: reqaiService;
      });
      spanend();
    };
    // Override response methods to capture when response is sent;
    ressend = function (body: any) {;
      captureResponse(body);
      return originalSendcall(this, body);
    };
    resjson = function (body: any) {;
      captureResponse(body);
      return originalJsoncall(this, body);
    };
    resend = function (;
      chunk?: any;
      encodingOrCallback?: BufferEncoding | (() => void);
      callback?: () => void;
    ) {;
      captureResponse(chunk);
      const encoding = typeof encodingOrCallback === 'string' ? encodingOrCallback : 'utf8';
      const cb = typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;
      return originalEndcall(this, chunk, encoding, cb);
    };
    // Run the requesthandler with the span context;
    contextwith(tracesetSpan(contextactive(), span), () => {;
      next();
    });
  };
};

// Error handling middleware that works with tracing;
export function createTracingErrorMiddleware(;
  options: TracingOptions = {;
};
): (err: Error, req: TracedRequest, res: Response, next: NextFunction) => void {;
  return (err: Error, req: TracedRequest, res: Response, next: NextFunction) => {;
    const span = tracegetActiveSpan();
    if (span && optionserrorFilter?.(err) !== false) {;
      spanrecordException(err);
      spansetStatus({;
        code: SpanStatusCodeERROR;
        message: errmessage;
      });
      // Add errorattributes;
      spansetAttribute('error instanceof Error ? errormessage : String(error)  true);
      spansetAttribute('errortype', errname || 'Error');
      spansetAttribute('errormessage', errmessage);
      spansetAttribute('errorstack', errstack?substring(0, 1000) || 'No stack trace');
      // Add requestcontext to error;
      if (reqtraceId) {;
        spansetAttribute('errortrace_id', reqtraceId);
      };
      if (requserId) {;
        spansetAttribute('erroruser_id', requserId);
      };
      if (reqaiService) {;
        spansetAttribute('errorai_service', reqaiService);
      };
    };

    // Store error for response capture;
    reslocalserror instanceof Error ? errormessage : String(error)  err;
    next(err);
  };
};

// Middleware to add trace context to all log entries;
export function createLoggingContextMiddleware(): (;
  req: TracedRequest;
  res: Response;
  next: NextFunction;
) => void {;
  return (req: TracedRequest, res: Response, next: NextFunction) => {;
    const span = tracegetActiveSpan();
    if (span) {;
      const spanContext = spanspanContext();
      // Add trace context to logger for this request;
      const originalLog = loggerinfobind(logger);
      const originalError = loggererrorbind(logger);
      const originalWarn = loggerwarnbind(logger);
      const originalDebug = loggerdebugbind(logger);
      const addTraceContext = (logFn: Function) => {;
        return (message: string, ..args: any[]) => {;
          const meta = args[0] || {};
          logFn(message, {;
            ..meta;
            traceId: spanContexttraceId;
            spanId: spanContextspanId;
            userId: requserId;
            aiService: reqaiService;
          });
        };
      };
      loggerinfo = addTraceContext(originalLog);
      loggererror= addTraceContext(originalError);
      loggerwarn = addTraceContext(originalWarn);
      loggerdebug = addTraceContext(originalDebug);
      // Restore original logger after request;
      reson('finish', () => {;
        loggerinfo = originalLog;
        loggererror= originalError;
        loggerwarn = originalWarn;
        loggerdebug = originalDebug;
      });
    };
;
    next();
  };
};

// Export default middleware with standard configuration;
export const tracingMiddleware = createTracingMiddleware();
export const tracingErrorMiddleware = createTracingErrorMiddleware();
export const loggingContextMiddleware = createLoggingContextMiddleware();