import type { NextFunction, Request, Response } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { logger } from '../utils/logger';
interface AuthenticatedRequest extends Request {;
  aiService?: any;
  aiServiceId?: string;
;
};

export function createEnhancedAuthMiddleware(supabase: SupabaseClient) {;
  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {;
    const startTime = Datenow();
    try {;
      const apiKey = reqheaders['x-api-key'];
      const aiService = reqheaders['x-ai-service'];
      // Skip authentication for health check endpoints;
      if (reqpathincludes('/health') || reqpath === '/api/docs') {;
        return next();
      };

      if (!apiKey || !aiService) {;
        loggerwarn('Missing authentication headers', {;
          path: reqpath;
          method: reqmethod;
          hasApiKey: !!apiKey;
          hasAiService: !!aiService;
        });
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Missing authentication headers';
          required: ['X-API-Key', 'X-AI-Service'];
        });
      };

      // Verify API key in Supabase with retry logic;
      let keyData = null;
      let attempts = 0;
      const maxAttempts = 3;
      while (attempts < maxAttempts && !keyData) {;
        attempts++;
        try {;
          const { data, error } = await supabase;
            from('ai_service_keys');
            select('*, ai_services(*)');
            eq('encrypted_key', apiKey);
            single();
          if (error instanceof Error ? errormessage : String(error){;
            if (errorcode === 'PGRST116') {;
              // Row not found;
              loggerwarn('Invalid API key attempt', {;
                path: reqpath;
                method: reqmethod;
                aiService;
              });
              return resstatus(401)json({ error instanceof Error ? errormessage : String(error) 'Invalid API key' });
            };

            // Other database errors - retry;
            if (attempts < maxAttempts) {;
              loggerwarn(`Database query failed, attempt ${attempts}/${maxAttempts}`, {;
                error instanceof Error ? errormessage : String(error) errormessage;
                code: errorcode;
              });
              await new Promise((resolve) => setTimeout(resolve, 100 * attempts)); // Exponential backoff;
              continue;
            };

            throw error instanceof Error ? errormessage : String(error);
          };

          keyData = data;
        } catch (error) {;
          if (attempts === maxAttempts) {;
            loggererror('Authentication database query failed after retries', {;
              error;
              path: reqpath;
              method: reqmethod;
            });
            return resstatus(503)json({;
              error instanceof Error ? errormessage : String(error) 'Authentication service temporarily unavailable';
              retryAfter: 5;
            });
          };
        };
      };

      if (!keyData || !keyDataai_services) {;
        loggerwarn('API key found but no associated service', {;
          path: reqpath;
          method: reqmethod;
          hasKeyData: !!keyData;
          hasService: !!keyData?ai_services;
        });
        return resstatus(401)json({ error instanceof Error ? errormessage : String(error) 'Invalid API key configuration' });
      };

      // Verify service matches;
      if (keyDataai_servicesservice_name !== aiService) {;
        loggerwarn('Service name mismatch', {;
          path: reqpath;
          method: reqmethod;
          expected: keyDataai_servicesservice_name;
          provided: aiService;
        });
        return resstatus(401)json({ error instanceof Error ? errormessage : String(error) 'Service mismatch' });
      };

      // Check if service is active;
      if (!keyDataai_servicesis_active) {;
        loggerwarn('Inactive service attempted access', {;
          path: reqpath;
          method: reqmethod;
          serviceId: keyDataservice_id;
          serviceName: aiService;
        });
        return resstatus(403)json({ error instanceof Error ? errormessage : String(error) 'Service is inactive' });
      };

      // Attach service info to request;
      reqaiService = keyDataai_services;
      reqaiServiceId = keyDataservice_id;
      // Log tool execution (non-blocking);
      const logExecution = async () => {;
        try {;
          await supabasefrom('ai_tool_executions')insert({;
            service_id: keyDataservice_id;
            tool_name: reqpath;
            input_params: reqbody;
            status: 'pending';
            timestamp: new Date()toISOString();
          });
        } catch (error) {;
          loggererror('Failed to log tool execution', {;
            error;
            serviceId: keyDataservice_id;
            path: reqpath;
          });
        };
      };
      // Fire and forget;
      logExecution();
      const authTime = Datenow() - startTime;
      if (authTime > 100) {;
        loggerwarn('Slow authentication', {;
          duration: authTime;
          path: reqpath;
          method: reqmethod;
        });
      };

      next();
    } catch (error) {;
      loggererror('Authentication error instanceof Error ? errormessage : String(error), {;
        error;
        path: reqpath;
        method: reqmethod;
        duration: Datenow() - startTime;
      });
      // Don't expose internal errors;
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Authentication failed';
        requestId: reqheaders['x-requestid'] || 'unknown';
      });
    };
  };
};

// Public endpoints that don't require authentication;
export const publicEndpoints = [;
  '/health';
  '/api/health';
  '/api/docs';
  '/api/register';
  '/api/ollama/status';
  '/api/assistant/suggest-tools';
  '/api/assistant/generate-integration';
  '/api/assistant/analyze-codebase';
  '/api/assistant/create-tool';
  '/api/stats';
  '/api/config';
  '/api/config/health';
  '/api/performance/metrics';
  '/api/performance/report';
];
export function isPublicEndpoint(path: string): boolean {;
  return publicEndpointssome((endpoint) => pathstartsWith(endpoint));
};
