import type { NextFunction, Request, Response } from 'express';
import { EventEmitter } from 'events';
import { createHash } from 'crypto';
import { LogContext, logger } from '../utils/enhanced-logger';
import * as prometheus from 'prom-client';
// Define metrics;
const httpRequestDuration = new prometheusHistogram({;
  name: 'httprequestduration_seconds';
  help: 'Duration of HTTP requests in seconds';
  labelNames: ['method', 'route', 'status_code'];
  buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5];
});
const httpRequestTotal = new prometheusCounter({;
  name: 'httprequests_total';
  help: 'Total number of HTTP requests';
  labelNames: ['method', 'route', 'status_code'];
});
const activeRequests = new prometheusGauge({;
  name: 'http_activerequests';
  help: 'Number of active HTTP requests';
});
const cacheHits = new prometheusCounter({;
  name: 'cache_hits_total';
  help: 'Total number of cache hits';
  labelNames: ['cache_type'];
});
const cacheMisses = new prometheusCounter({;
  name: 'cache_misses_total';
  help: 'Total number of cache misses';
  labelNames: ['cache_type'];
});
const memoryUsage = new prometheusGauge({;
  name: 'nodejs_memory_usage_bytes';
  help: 'Nodejs memory usage';
  labelNames: ['type'];
});
export interface ProductionPerformanceOptions {;
  enableRequestTiming?: boolean;
  enableMemoryMonitoring?: boolean;
  enableCaching?: boolean;
  enableCompression?: boolean;
  slowRequestThreshold?: number;
  memoryThreshold?: number;
  requestTimeoutMs?: number;
  cacheSize?: number;
  cacheTTL?: number;
;
};

interface CacheEntry {;
  data: any;
  contentType: string;
  expires: number;
  etag: string;
  compressed?: Buffer;
;
};

interface RequestMetric {;
  url: string;
  method: string;
  statusCode: number;
  responseTime: number;
  timestamp: number;
  userAgent?: string;
  ip?: string;
  cached?: boolean;
;
};

export class ProductionPerformanceMiddleware extends EventEmitter {;
  private options: Required<ProductionPerformanceOptions>;
  private cache: Map<string, CacheEntry> = new Map();
  private requestMetrics: RequestMetric[] = [];
  private cleanupInterval: NodeJSTimeout;
  private memoryMonitorInterval!: NodeJSTimeout;
  constructor(options: ProductionPerformanceOptions = {}) {;
    super();
    thisoptions = {;
      enableRequestTiming: optionsenableRequestTiming ?? true;
      enableMemoryMonitoring: optionsenableMemoryMonitoring ?? true;
      enableCaching: optionsenableCaching ?? true;
      enableCompression: optionsenableCompression ?? true;
      slowRequestThreshold: optionsslowRequestThreshold ?? 2000;
      memoryThreshold: optionsmemoryThreshold ?? 1024;
      requestTimeoutMs: optionsrequestTimeoutMs ?? 5000;
      cacheSize: optionscacheSize ?? 1000;
      cacheTTL: optionscacheTTL ?? 300000, // 5 minutes;
    };
    // Start cleanup interval;
    thiscleanupInterval = setInterval(() => {;
      thiscleanupCache();
      thiscleanupMetrics();
    }, 60000); // Every minute;
    // Start memory monitoring;
    if (thisoptionsenableMemoryMonitoring) {;
      thismemoryMonitorInterval = setInterval(() => {;
        thisupdateMemoryMetrics();
      }, 5000); // Every 5 seconds;
    };

    loggerinfo('Production performance middleware initialized', LogContextPERFORMANCE, {;
      options: thisoptions;
    });
  };

  private updateMemoryMetrics(): void {;
    const usage = processmemoryUsage();
    memoryUsageset({ type: 'heapUsed' }, usageheapUsed);
    memoryUsageset({ type: 'heapTotal' }, usageheapTotal);
    memoryUsageset({ type: 'rss' }, usagerss);
    memoryUsageset({ type: 'external' }, usageexternal);
    const heapUsedMB = usageheapUsed / 1024 / 1024;
    if (heapUsedMB > thisoptionsmemoryThreshold) {;
      thisemit('memory-threshold-exceeded', {;
        current: heapUsedMB;
        threshold: thisoptionsmemoryThreshold;
      });
    };
  };

  private cleanupCache(): void {;
    const now = Datenow();
    let removed = 0;
    for (const [key, entry] of thiscacheentries()) {;
      if (entryexpires < now) {;
        thiscachedelete(key);
        removed++;
      };
    };

    // If cache is still too large, remove oldest entries;
    if (thiscachesize > thisoptionscacheSize) {;
      const sortedEntries = Arrayfrom(thiscacheentries())sort(;
        (a, b) => a[1]expires - b[1]expires;
      );
      const toRemove = thiscachesize - thisoptionscacheSize;
      for (let i = 0; i < toRemove; i++) {;
        thiscachedelete(sortedEntries[i][0]);
        removed++;
      };
    };

    if (removed > 0) {;
      loggerdebug(`Cleaned up ${removed} cache entries`, LogContextPERFORMANCE);
    };
  };

  private cleanupMetrics(): void {;
    const oneHourAgo = Datenow() - 3600000;
    const beforeCleanup = thisrequestMetricslength;
    thisrequestMetrics = thisrequestMetricsfilter((m) => mtimestamp > oneHourAgo);
    // Keep only last 10000 metrics;
    if (thisrequestMetricslength > 10000) {;
      thisrequestMetrics = thisrequestMetricsslice(-10000);
    };
;
    const removed = beforeCleanup - thisrequestMetricslength;
    if (removed > 0) {;
      loggerdebug(`Cleaned up ${removed} requestmetrics`, LogContextPERFORMANCE);
    };
  };

  private generateETag(data: any): string {;
    const hash = createHash('md5');
    hashupdate(JSONstringify(data));
    return `"${hashdigest('hex')}"`;
  };

  private createCacheKey(req: Request): string {;
    const { method, originalUrl, headers } = req;
    const accept = headersaccept || '';
    const authorization = headersauthorization ? 'auth' : 'noauth';
    return `${method}:${originalUrl}:${accept}:${authorization}`;
  };

  public requestTimer() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!thisoptionsenableRequestTiming) {;
        return next();
      };

      const startTime = processhrtimebigint();
      activeRequestsinc();
      // Set requesttimeout;
      const timeout = setTimeout(() => {;
        if (!resheadersSent) {;
          resstatus(408)json({;
            error instanceof Error ? errormessage : String(error) 'Request timeout';
            message: `Request exceeded ${thisoptionsrequestTimeoutMs}ms timeout`;
          });
        };
      }, thisoptionsrequestTimeoutMs);
      // Override resend to capture metrics;
      const originalEnd = resend;
      const self = this;
      resend = function (this: Response, ..args: any[]) {;
        clearTimeout(timeout);
        activeRequestsdec();
        const endTime = processhrtimebigint();
        const responseTime = Number(endTime - startTime) / 1000000; // Convert to milliseconds;

        // Prometheus metrics;
        const route = reqroute?path || reqpath || 'unknown';
        const labels = {;
          method: reqmethod;
          route;
          status_code: resstatusCodetoString();
        };
        httpRequestDurationobserve(labels, responseTime / 1000); // Convert to seconds;
        httpRequestTotalinc(labels);
        // Internal metrics;
        const metric: RequestMetric = {;
          url: reqoriginalUrl || requrl;
          method: reqmethod;
          statusCode: resstatusCode;
          responseTime;
          timestamp: Datenow();
          userAgent: reqheaders['user-agent'];
          ip: reqip || reqsocketremoteAddress;
          cached: resgetHeader('X-Cache') === 'HIT';
        ;
};
        selfrequestMetricspush(metric);
        // Log slow requests;
        if (responseTime > selfoptionsslowRequestThreshold) {;
          loggerwarn('Slow requestdetected', LogContextPERFORMANCE, {;
            ..metric;
            threshold: selfoptionsslowRequestThreshold;
          });
          selfemit('slow-request metric);
        };

        // Log errors;
        if (resstatusCode >= 400) {;
          loggererror('Request error instanceof Error ? errormessage : String(error)  LogContextPERFORMANCE, metric);
        };

        // Add performance headers;
        resset('X-Response-Time', `${responseTimetoFixed(2)}ms`);
        resset('X-Performance-Mode', 'production');
        return originalEndapply(this, args as any);
      };
      next();
    };
  };

  public cacheMiddleware() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!thisoptionsenableCaching || reqmethod !== 'GET') {;
        return next();
      };

      const cacheKey = thiscreateCacheKey(req);
      const cached = thiscacheget(cacheKey);
      if (cached && cachedexpires > Datenow()) {;
        // Check ETag;
        const ifNoneMatch = reqheaders['if-none-match'];
        if (ifNoneMatch === cachedetag) {;
          resstatus(304)end();
          cacheHitsinc({ cache_type: 'etag' });
          return;
        };

        // Return cached response;
        resset('Content-Type', cachedcontentType);
        resset('X-Cache', 'HIT');
        resset('ETag', cachedetag);
        resset('Cache-Control', `max-age=${Mathfloor((cachedexpires - Datenow()) / 1000)}`);
        if (cachedcompressed && thisacceptsCompression(req)) {;
          resset('Content-Encoding', 'gzip');
          ressend(cachedcompressed);
        } else {;
          resjson(cacheddata);
        };

        cacheHitsinc({ cache_type: 'memory' });
        return;
      };

      cacheMissesinc({ cache_type: 'memory' });
      // Intercept response to cache it;
      const originalJson = resjson;
      const self = this;
      resjson = function (this: Response, body: any) {;
        if (resstatusCode < 400 && selfoptionsenableCaching) {;
          const etag = selfgenerateETag(body);
          const cacheEntry: CacheEntry = {;
            data: body;
            contentType: 'application/json';
            expires: Datenow() + selfoptionscacheTTL;
            etag;
          ;
};
          // Compress if enabled;
          if (selfoptionsenableCompression) {;
            // Note: In production, you'd use zlib here;
            // For now, we'll skip compression;
          };

          selfcacheset(cacheKey, cacheEntry);
          resset('ETag', etag);
          resset('Cache-Control', `max-age=${Mathfloor(selfoptionscacheTTL / 1000)}`);
          resset('X-Cache', 'MISS');
        };

        return originalJsoncall(this, body);
      };
      next();
    };
  };

  private acceptsCompression(req: Request): boolean {;
    const acceptEncoding = reqheaders['accept-encoding'] || '';
    return acceptEncodingincludes('gzip');
  };

  public compressionMiddleware() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!thisoptionsenableCompression) {;
        return next();
      };

      const acceptEncoding = reqheaders['accept-encoding'] || '';
      if (acceptEncodingincludes('gzip')) {;
        resset('Content-Encoding', 'gzip');
        // Note: Actual compression would be handled by a library like compression;
      } else if (acceptEncodingincludes('deflate')) {;
        resset('Content-Encoding', 'deflate');
      };

      next();
    };
  };

  public rateLimiter(windowMs = 900000, max = 1000) {;
    const requests = new Map<string, { count: number; resetTime: number }>();
    // Cleanup old entries periodically;
    setInterval(() => {;
      const now = Datenow();
      for (const [key, entry] of requestsentries()) {;
        if (now > entryresetTime) {;
          requestsdelete(key);
        };
      };
    }, 60000); // Every minute;
    return (req: Request, res: Response, next: NextFunction) => {;
      const identifier = reqip || reqsocketremoteAddress || 'unknown';
      const now = Datenow();
      const userRequests = requestsget(identifier);
      if (!userRequests || now > userRequestsresetTime) {;
        requestsset(identifier, { count: 1, resetTime: now + windowMs });
        return next();
      };

      if (userRequestscount >= max) {;
        const retryAfter = Mathceil((userRequestsresetTime - now) / 1000);
        resset('Retry-After', retryAftertoString());
        resset('X-RateLimit-Limit', maxtoString());
        resset('X-RateLimit-Remaining', '0');
        resset('X-RateLimit-Reset', new Date(userRequestsresetTime)toISOString());
        return resstatus(429)json({;
          error instanceof Error ? errormessage : String(error) 'Too many requests';
          retryAfter;
          limit: max;
          windowMs;
        });
      };

      userRequestscount++;
      // Add rate limit headers;
      resset('X-RateLimit-Limit', maxtoString());
      resset('X-RateLimit-Remaining', (max - userRequestscount)toString());
      resset('X-RateLimit-Reset', new Date(userRequestsresetTime)toISOString());
      next();
    };
  };

  public async getMetrics() {;
    const now = Datenow();
    const last5Minutes = thisrequestMetricsfilter((m) => mtimestamp > now - 300000);
    const last1Hour = thisrequestMetricsfilter((m) => mtimestamp > now - 3600000);
    const calculateStats = (metrics: RequestMetric[]) => {;
      if (metricslength === 0) {;
        return {;
          count: 0;
          avgResponseTime: 0;
          errorRate: 0;
          p95ResponseTime: 0;
          p99ResponseTime: 0;
          cacheHitRate: 0;
        ;
};
      };

      const responseTimes = metricsmap((m) => mresponseTime)sort((a, b) => a - b);
      const totalTime = responseTimesreduce((sum, time) => sum + time, 0);
      const errors = metricsfilter((m) => mstatusCode >= 400)length;
      const cacheHits = metricsfilter((m) => mcached)length;
      const p95Index = Mathfloor(responseTimeslength * 0.95);
      const p99Index = Mathfloor(responseTimeslength * 0.99);
      return {;
        count: metricslength;
        avgResponseTime: totalTime / metricslength;
        errorRate: (errors / metricslength) * 100;
        p95ResponseTime: responseTimes[p95Index] || 0;
        p99ResponseTime: responseTimes[p99Index] || 0;
        cacheHitRate: (cacheHits / metricslength) * 100;
      ;
};
    };
    const memoryUsage = processmemoryUsage();
    return {;
      mode: 'production';
      last5Minutes: calculateStats(last5Minutes);
      last1Hour: calculateStats(last1Hour);
      totalMetrics: thisrequestMetricslength;
      cacheSize: thiscachesize;
      memory: {;
        heapUsed: memoryUsageheapUsed / 1024 / 1024;
        heapTotal: memoryUsageheapTotal / 1024 / 1024;
        rss: memoryUsagerss / 1024 / 1024;
        external: memoryUsageexternal / 1024 / 1024;
      ;
};
      uptime: processuptime();
      timestamp: now;
    ;
};
  };

  public async generatePerformanceReport(): Promise<string> {;
    const metrics = await thisgetMetrics();
    const now = new Date()toISOString();
    return ``;
=== Universal AI Tools Performance Report (Production) ===;
Generated: ${now;
};

=== System Status ===;
Mode: PRODUCTION;
Uptime: ${Mathfloor(metricsuptime / 3600)}h ${Mathfloor((metricsuptime % 3600) / 60)}m;
Cache Size: ${metricscacheSize} entries;
=== Memory Usage ===;
Heap Used: ${metricsmemoryheapUsedtoFixed(2)}MB;
Heap Total: ${metricsmemoryheapTotaltoFixed(2)}MB;
RSS: ${metricsmemoryrsstoFixed(2)}MB;
External: ${metricsmemoryexternaltoFixed(2)}MB;
=== Request Statistics (Last 5 Minutes) ===;
Total Requests: ${metricslast5Minutescount;
};
Average Response Time: ${metricslast5MinutesavgResponseTimetoFixed(2)}ms;
P95 Response Time: ${metricslast5Minutesp95ResponseTimetoFixed(2)}ms;
P99 Response Time: ${metricslast5Minutesp99ResponseTimetoFixed(2)}ms;
Error Rate: ${metricslast5MinuteserrorRatetoFixed(2)}%;
Cache Hit Rate: ${metricslast5MinutescacheHitRatetoFixed(2)}%;
=== Request Statistics (Last Hour) ===;
Total Requests: ${metricslast1Hourcount;
};
Average Response Time: ${metricslast1HouravgResponseTimetoFixed(2)}ms;
P95 Response Time: ${metricslast1Hourp95ResponseTimetoFixed(2)}ms;
P99 Response Time: ${metricslast1Hourp99ResponseTimetoFixed(2)}ms;
Error Rate: ${metricslast1HourerrorRatetoFixed(2)}%;
Cache Hit Rate: ${metricslast1HourcacheHitRatetoFixed(2)}%;
=== Performance Features ===;
• Request timing with ${thisoptionsrequestTimeoutMs}ms timeout;
• In-memory caching with ${thisoptionscacheTTL}ms TTL;
• ETag support for conditional requests;
• Rate limiting protection;
• Prometheus metrics integration;
• Memory monitoring with ${thisoptionsmemoryThreshold}MB threshold;
• Slow requestdetection (>${thisoptionsslowRequestThreshold}ms);
=== Notes ===;
• Production-ready without external dependencies;
• Automatic cleanup of old metrics and cache entries;
• Event-driven architecture for threshold monitoring;
`;`;
  };

  public close(): void {;
    if (thiscleanupInterval) {;
      clearInterval(thiscleanupInterval);
    };
    if (thismemoryMonitorInterval) {;
      clearInterval(thismemoryMonitorInterval);
    };
    thiscacheclear();
    thisrequestMetrics = [];
    loggerinfo('Production performance middleware closed', LogContextPERFORMANCE);
  };
};
;
export function createProductionPerformanceMiddleware(options?: ProductionPerformanceOptions) {;
  return new ProductionPerformanceMiddleware(options);
};
