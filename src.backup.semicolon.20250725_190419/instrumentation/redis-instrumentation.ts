import { SpanKind, SpanStatusCode, context, trace } from '@opentelemetry/api';
import { SemanticAttributes } from '@opentelemetry/semantic-conventions';
import { telemetryService } from '../services/telemetry-service';
import { LogContext, logger } from '../utils/enhanced-logger';
interface CacheOperation {;
  operation: string;
  key?: string | string[];
  ttl?: number;
  namespace?: string;
;
};

export class RedisInstrumentation {;
  private tracer = telemetryServicegetTracer();
  /**;
   * Wrap a Redis client to add automatic tracing;
   */;
  instrumentRedisClient(client: any): any {;
    const instrumented = Objectcreate(client);
    // Common Redis commands to instrument;
    const commands = [;
      // String operations;
      'get';
      'set';
      'mget';
      'mset';
      'del';
      'exists';
      'expire';
      'ttl';
      'incr';
      'decr';
      'incrby';
      'decrby';
      // Hash operations;
      'hget';
      'hset';
      'hmget';
      'hmset';
      'hdel';
      'hgetall';
      'hkeys';
      'hvals';
      // List operations;
      'lpush';
      'rpush';
      'lpop';
      'rpop';
      'lrange';
      'llen';
      // Set operations;
      'sadd';
      'srem';
      'smembers';
      'sismember';
      'scard';
      // Sorted set operations;
      'zadd';
      'zrem';
      'zrange';
      'zrevrange';
      'zscore';
      'zcard';
      // Other operations;
      'ping';
      'flushdb';
      'flushall';
      'keys';
      'scan';
    ];
    commandsforEach((command) => {;
      if (client[command]) {;
        instrumented[command] = thiswrapCommand(client, command);
      };
    });
    // Instrument pipeline/multi for batch operations;
    if (clientpipeline || clientmulti) {;
      instrumentedpipeline = thiswrapPipeline(clientpipeline?bind(client));
      instrumentedmulti = thiswrapPipeline(clientmulti?bind(client));
    };
;
    return instrumented;
  };

  /**;
   * Wrap a cache operation with tracing;
   */;
  async withCacheSpan<T>(operation: CacheOperation, fn: () => Promise<T>): Promise<T> {;
    const spanName = `cache.${operationoperation}`;
    const span = thistracerstartSpan(spanName, {;
      kind: SpanKindCLIENT;
      attributes: {;
        'dbsystem': 'redis';
        'dboperation': operationoperation;
        'cacheoperation': operationoperation;
        'cachekey': ArrayisArray(operationkey);
          ? operationkeyjoin(',')substring(0, 100);
          : operationkey?substring(0, 100);
        'cachekeycount': ArrayisArray(operationkey) ? operationkeylength : 1;
        'cachettl': operationttl;
        'cachenamespace': operationnamespace || 'default';
        'netpeername': processenvREDIS_HOST || 'localhost';
        'netpeerport': parseInt(processenvREDIS_PORT || '6379', 10);
      };
    });
    const startTime = Datenow();
    let hit = false;
    try {;
      const result = await contextwith(tracesetSpan(contextactive(), span), fn);
      // Determine cache hit/miss for get operations;
      if (operationoperation === 'get' || operationoperation === 'mget') {;
        hit = result !== null && result !== undefined;
        if (ArrayisArray(result)) {;
          hit = resultsome((r) => r !== null);
          spansetAttribute('cachehits', resultfilter((r) => r !== null)length);
          spansetAttribute('cachemisses', resultfilter((r) => r === null)length);
        };
      };

      spansetAttribute('cachehit', hit);
      spansetAttribute('cacheduration_ms', Datenow() - startTime);
      // Add size information if available;
      if (result !== null && result !== undefined) {;
        if (typeof result === 'string') {;
          spansetAttribute('cacheitem_size', resultlength);
        } else if (BufferisBuffer(result)) {;
          spansetAttribute('cacheitem_size', resultbyteLength);
        };
      };

      spansetStatus({ code: SpanStatusCodeOK });
      return result;
    } catch (error) {;
      spanrecordException(erroras Error);
      spansetStatus({;
        code: SpanStatusCodeERROR;
        message: error instanceof Error ? errormessage : 'Cache operation failed';
      });
      loggererror('Cache operation failed', LogContextSYSTEM, {;
        operation: operationoperation;
        key: operationkey;
        error;
        duration: Datenow() - startTime;
      });
      throw error instanceof Error ? errormessage : String(error);
    } finally {;
      // Record metrics;
      thisrecordCacheMetrics(operationoperation, hit, Datenow() - startTime);
      spanend();
    };
  };

  /**;
   * Wrap a Redis command;
   */;
  private wrapCommand(client: any, command: string): any {;
    const instrumentation = this;
    return function (..args: any[]) {;
      // Extract key from arguments;
      let key: string | string[] | undefined;
      if (argslength > 0) {;
        if (ArrayisArray(args[0])) {;
          key = args[0];
        } else if (typeof args[0] === 'string') {;
          key = args[0];
        };
      };

      // Extract TTL for set operations;
      let ttl: number | undefined;
      if (command === 'set' && argslength > 2) {;
        if (args[2] === 'EX' && args[3]) {;
          ttl = parseInt(args[3], 10);
        } else if (args[2] === 'PX' && args[3]) {;
          ttl = parseInt(args[3], 10) / 1000;
        };
      } else if (command === 'expire' && argslength > 1) {;
        ttl = parseInt(args[1], 10);
      };

      const operation: CacheOperation = {;
        operation: command;
        key;
        ttl;
      ;
};
      return instrumentationwithCacheSpan(operation, () => {;
        return client[command]apply(client, args);
      });
    };
  };

  /**;
   * Wrap pipeline/multi for batch operations;
   */;
  private wrapPipeline(pipelineFn: any): any {;
    const instrumentation = this;
    return function () {;
      const pipeline = pipelineFn();
      const operations: CacheOperation[] = [];
      // Create a wrapped pipeline that tracks operations;
      const wrapped = Objectcreate(pipeline);
      // Track each operation added to the pipeline;
      const commands = ObjectgetOwnPropertyNames(pipeline)filter(;
        (prop) => typeof pipeline[prop] === 'function' && prop !== 'exec';
      );
      commandsforEach((command) => {;
        wrapped[command] = function (..args: any[]) {;
          operationspush({;
            operation: command;
            key: args[0];
          });
          pipeline[command]apply(pipeline, args);
          return wrapped; // Allow chaining;
        };
      });
      // Wrap exec to trace the entire batch;
      wrappedexec = function (callback?: Function) {;
        const span = instrumentationtracerstartSpan('cachepipeline', {;
          kind: SpanKindCLIENT;
          attributes: {;
            'dbsystem': 'redis';
            'dboperation': 'pipeline';
            'cacheoperation': 'pipeline';
            'cachepipelinecommands': operationslength;
            'cachepipelineoperations': operationsmap((op) => opoperation)join(',');
          };
        });
        const startTime = Datenow();
        const executeWithSpan = async () => {;
          try {;
            const result = await pipelineexec();
            spansetAttribute('cachepipelineduration_ms', Datenow() - startTime);
            spansetStatus({ code: SpanStatusCodeOK });
            return result;
          } catch (error) {;
            spanrecordException(erroras Error);
            spansetStatus({;
              code: SpanStatusCodeERROR;
              message: error instanceof Error ? errormessage : 'Pipeline execution failed';
            });
            throw error instanceof Error ? errormessage : String(error);
          } finally {;
            spanend();
          };
        };
        if (callback) {;
          executeWithSpan();
            then((result) => callback(null, result));
            catch((error instanceof Error ? errormessage : String(error) => callback(error instanceof Error ? errormessage : String(error);
        } else {;
          return executeWithSpan();
        };
      };
      return wrapped;
    };
  };

  /**;
   * Record cache metrics;
   */;
  private recordCacheMetrics(operation: string, hit: boolean, duration: number): void {;
    // This would typically send metrics to a metrics backend;
    // For now, we'll just add attributes to the current span;
    const span = tracegetActiveSpan();
    if (span) {;
      spansetAttribute(`cachemetrics.${operation}count`, 1);
      spansetAttribute(`cachemetrics.${operation}duration_ms`, duration);
      if (operation === 'get' || operation === 'mget') {;
        spansetAttribute(`cachemetrics.${operation}.${hit ? 'hits' : 'misses'}`, 1);
      };
    };
  };

  /**;
   * Create a cache key with namespace;
   */;
  createNamespacedKey(namespace: string, key: string): string {;
    return `${namespace}:${key}`;
  };

  /**;
   * Wrap a caching function with automatic tracing;
   */;
  wrapCacheFunction<T extends (..args: any[]) => Promise<unknown>>(;
    fn: T;
    options: {;
      operation: string;
      keyExtractor: (..args: Parameters<T>) => string;
      ttl?: number;
      namespace?: string;
    ;
};
  ): T {;
    const instrumentation = this;
    return async function (..args: Parameters<T>): Promise<ReturnType<T>> {;
      const key = optionskeyExtractor(..args);
      const operation: CacheOperation = {;
        operation: optionsoperation;
        key;
        ttl: optionsttl;
        namespace: optionsnamespace;
      ;
};
      return instrumentationwithCacheSpan(operation, () => fn(..args));
    } as T;
  };

  /**;
   * Monitor cache health metrics;
   */;
  async monitorCacheHealth(client: any): Promise<void> {;
    const span = thistracerstartSpan('cachehealth_check', {;
      kind: SpanKindCLIENT;
    });
    try {;
      // Check connection;
      const pingStart = Datenow();
      await clientping();
      const pingDuration = Datenow() - pingStart;
      spansetAttribute('cachehealthping_duration_ms', pingDuration);
      spansetAttribute('cachehealthconnected', true);
      // Get cache info;
      if (clientinfo) {;
        const info = await clientinfo();
        const lines = infosplit('\n');
        const stats: Record<string, string> = {};
        linesforEach((line: string) => {;
          const [key, value] = linesplit(':');
          if (key && value) {;
            stats[keytrim()] = valuetrim();
          };
        });
        // Add relevant metrics;
        if (statsused_memory) {;
          spansetAttribute('cachehealthmemory_used', parseInt(statsused_memory, 10));
        };
        if (statsconnected_clients) {;
          spansetAttribute('cachehealthconnected_clients', parseInt(statsconnected_clients, 10));
        };
        if (statstotal_commands_processed) {;
          spansetAttribute(;
            'cachehealthtotal_commands';
            parseInt(statstotal_commands_processed, 10);
          );
        };
        if (statsevicted_keys) {;
          spansetAttribute('cachehealthevicted_keys', parseInt(statsevicted_keys, 10));
        };
        if (statskeyspace_hits && statskeyspace_misses) {;
          const hits = parseInt(statskeyspace_hits, 10);
          const misses = parseInt(statskeyspace_misses, 10);
          const hitRate = hits / (hits + misses);
          spansetAttribute('cachehealthhit_rate', hitRate);
        };
      };

      spansetStatus({ code: SpanStatusCodeOK });
    } catch (error) {;
      spanrecordException(erroras Error);
      spansetStatus({;
        code: SpanStatusCodeERROR;
        message: 'Cache health check failed';
      });
      spansetAttribute('cachehealthconnected', false);
    } finally {;
      spanend();
    };
  };
};

// Export singleton instance;
export const redisInstrumentation = new RedisInstrumentation();
// Export convenience functions;
export const instrumentRedis = (client: any) => redisInstrumentationinstrumentRedisClient(client);
export const withCacheSpan = <T>(operation: CacheOperation, fn: () => Promise<T>) =>;
  redisInstrumentationwithCacheSpan(operation, fn);
export const wrapCacheFunction = <T extends (..args: any[]) => Promise<unknown>>(;
  fn: T;
  options: any;
) => redisInstrumentationwrapCacheFunction(fn, options);