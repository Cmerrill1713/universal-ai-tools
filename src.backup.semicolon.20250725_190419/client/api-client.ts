/* eslint-disable no-undef */;
import type { AxiosInstance, AxiosRequestConfig } from 'axios';
import axios, { AxiosResponse } from 'axios';
import { z } from 'zod';
// WebSocket type for both Nodejs and browser environments;
declare global {;
  var WebSocket: {;
    new (url: string | URL, protocols?: string | string[] | undefined): WebSocket;
    prototype: WebSocket;
    readonly CONNECTING: 0;
    readonly OPEN: 1;
    readonly CLOSING: 2;
    readonly CLOSED: 3;
  ;
};
};

interface WebSocket {;
  send(data: string): void;
  close(): void;
  onopen: ((event: any) => void) | null;
  onmessage: ((event: any) => void) | null;
  onerror instanceof Error ? errormessage : String(error) ((event: any) => void) | null;
  onclose: ((event: any) => void) | null;
;
};

// Response schemas;
const ApiResponseSchema = zobject({;
  success: zboolean();
  data: zany()optional();
  error instanceof Error ? errormessage : String(error) z;
    object({;
      code: zstring();
      message: zstring();
      details: zany()optional();
    });
    optional();
  metadata: z;
    object({;
      apiVersion: zstring();
      timestamp: zstring();
      requestId: zstring()optional();
      deprecationWarning: zstring()optional();
    });
    optional();
});
const VersionInfoSchema = zobject({;
  version: zstring();
  active: zboolean();
  deprecated: zboolean();
  deprecationDate: zstring()optional();
  sunsetDate: zstring()optional();
  changes: zarray(zstring())optional();
});
export interface ApiClientConfig {;
  baseUrl: string;
  apiKey: string;
  aiService: string;
  version?: string;
  autoUpgrade?: boolean;
  onDeprecationWarning?: (warning: string) => void;
  requestTimeout?: number;
  retryAttempts?: number;
  retryDelay?: number;
;
};

export interface ApiResponse<T = any> {;
  success: boolean;
  data?: T;
  error instanceof Error ? errormessage : String(error) {;
    code: string;
    message: string;
    details?: any;
  ;
};
  metadata?: {;
    apiVersion: string;
    timestamp: string;
    requestId?: string;
    deprecationWarning?: string;
  ;
};
};

export class UniversalAIToolsClient {;
  private client: AxiosInstance;
  private config: Required<ApiClientConfig>;
  private currentVersion: string;
  private supportedVersions: Set<string> = new Set(['v1']);
  private deprecationWarnings: Map<string, Date> = new Map();
  constructor(config: ApiClientConfig) {;
    thisconfig = {;
      version: 'v1';
      autoUpgrade: true;
      requestTimeout: 30000;
      retryAttempts: 3;
      retryDelay: 1000;
      onDeprecationWarning: (warning) => consolewarn(`[API Deprecation] ${warning}`);
      ..config;
    };
    thiscurrentVersion = thisconfigversion;
    thisclient = axioscreate({;
      baseURL: thisconfigbaseUrl;
      timeout: thisconfigrequestTimeout;
      headers: {;
        'X-API-Key': thisconfigapiKey;
        'X-AI-Service': thisconfigaiService;
        'X-API-Version': thiscurrentVersion;
        Accept: `application/vnduniversal-ai-tools.${thiscurrentVersion}+json`;
        'Content-Type': 'application/json';
      ;
};
    });
    thissetupInterceptors();
  };

  private setupInterceptors() {;
    // Request interceptor;
    thisclientinterceptorsrequestuse(;
      (config) => {;
        // Add requestID for tracking;
        configheaders['X-Request-ID'] = thisgenerateRequestId();
        // Log requestif in debug mode;
        if (processenvDEBUG) {;
          loggerinfo(`[API Request] ${configmethod?toUpperCase()} ${configurl}`);
        };
;
        return config;
      };
      (error instanceof Error ? errormessage : String(error) => Promisereject(error;
    );
    // Response interceptor;
    thisclientinterceptorsresponseuse(;
      (response) => {;
        // Handle deprecation warnings;
        const deprecationWarning = responseheaders['x-api-deprecation-warning'];
        if (deprecationWarning) {;
          thishandleDeprecationWarning(deprecationWarning);
        };

        // Extract API version from response;
        const apiVersion = responseheaders['x-api-version'];
        if (apiVersion && apiVersion !== thiscurrentVersion) {;
          loggerinfo(;
            `[API] Server returned version ${apiVersion}, client using ${thiscurrentVersion}`;
          );
        };

        return response;
      };
      async (error instanceof Error ? errormessage : String(error)=> {;
        // Handle version-related errors;
        if (;
          errorresponse?status === 400 &&;
          errorresponse?data?error instanceof Error ? errormessage : String(error) code === 'INVALID_API_VERSION';
        ) {;
          return thishandleVersionError(error instanceof Error ? errormessage : String(error);
        };

        // Handle other errors with retry;
        if (thisshouldRetry(error instanceof Error ? errormessage : String(error) {;
          return thisretryRequest(error instanceof Error ? errormessage : String(error);
        };

        return Promisereject(error instanceof Error ? errormessage : String(error);
      };
    );
  };

  private handleDeprecationWarning(warning: string) {;
    const now = new Date();
    const lastWarning = thisdeprecationWarningsget(warning);
    // Only show warning once per hour;
    if (!lastWarning || nowgetTime() - lastWarninggetTime() > 3600000) {;
      thisdeprecationWarningsset(warning, now);
      thisconfigonDeprecationWarning(warning);
    };
  };

  private async handleVersionError(error instanceof Error ? errormessage : String(error) any): Promise<unknown> {;
    const { supportedVersions, latestVersion } = errorresponsedataerror;

    if (thisconfigautoUpgrade && supportedVersionsincludes(latestVersion)) {;
      loggerinfo(`[API] Auto-upgrading from ${thiscurrentVersion} to ${latestVersion}`);
      thiscurrentVersion = latestVersion;
      thisclientdefaultsheaders['X-API-Version'] = latestVersion;
      thisclientdefaultsheaders['Accept'] =;
        `application/vnduniversal-ai-tools.${latestVersion}+json`;
      // Retry the requestwith new version;
      return thisclientrequesterrorconfig);
    };

    return Promisereject(error instanceof Error ? errormessage : String(error);
  };

  private shouldRetry(error instanceof Error ? errormessage : String(error) any): boolean {;
    if (!errorconfig || errorconfig.__retryCount >= thisconfigretryAttempts) {;
      return false;
    };

    const status = errorresponse?status;
    return !status || status >= 500 || status === 429;
  };

  private async retryRequest(error instanceof Error ? errormessage : String(error) any): Promise<unknown> {;
    errorconfig.__retryCount = (errorconfig.__retryCount || 0) + 1;
    const delay = thisconfigretryDelay * Mathpow(2, errorconfig.__retryCount - 1);
    loggerinfo(;
      `[API] Retrying requestattempt ${errorconfig.__retryCount}/${thisconfigretryAttempts}) after ${delay}ms`;
    );
    await new Promise((resolve) => setTimeout(resolve, delay));
    return thisclientrequesterrorconfig);
  };

  private generateRequestId(): string {;
    return `${Datenow()}-${Mathrandom()toString(36)substr(2, 9)}`;
  };

  private async requestT = any>(config: AxiosRequestConfig): Promise<ApiResponse<T>> {;
    try {;
      const response = await thisclientrequestApiResponse<T>>(config);
      return responsedata;
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      if (errorresponse?data) {;
        return errorresponsedata;
      };

      return {;
        success: false;
        error instanceof Error ? errormessage : String(error){;
          code: 'REQUEST_FAILED';
          message: errormessage;
        ;
};
      };
    };
  };

  // Version management methods;
  async getVersions(): Promise<;
    ApiResponse<{;
      currentVersion: string;
      defaultVersion: string;
      latestVersion: string;
      versions: Array<{;
        version: string;
        active: boolean;
        deprecated: boolean;
        deprecationDate?: string;
        sunsetDate?: string;
        changes?: string[];
      }>;
    }>;
  > {;
    return thisrequest;
      method: 'GET';
      url: '/api/versions';
    });
  };

  setVersion(version: string) {;
    thiscurrentVersion = version;
    thisclientdefaultsheaders['X-API-Version'] = version;
    thisclientdefaultsheaders['Accept'] = `application/vnduniversal-ai-tools.${version}+json`;
  };

  getVersion(): string {;
    return thiscurrentVersion;
  };

  // Core API methods;
  async executeTools(tools: any[], inputany): Promise<ApiResponse> {;
    return thisrequest;
      method: 'POST';
      url: `/api/v1/tools/execute`;
      data: { tools, input;
    });
  };

  async storeMemory(contentstring, metadata?: any): Promise<ApiResponse> {;
    return thisrequest;
      method: 'POST';
      url: `/api/v1/memory`;
      data: { contentmetadata ;
};
    });
  };

  async searchMemory(query: string, filters?: any): Promise<ApiResponse> {;
    return thisrequest;
      method: 'POST';
      url: `/api/v1/memory/search`;
      data: { query, filters };
    });
  };

  async chat(message: string, model?: string, conversationId?: string): Promise<ApiResponse> {;
    return thisrequest;
      method: 'POST';
      url: `/api/v1/assistant/chat`;
      data: { message: model, conversation_id: conversationId ;
};
    });
  };

  async synthesizeSpeech(text: string, voiceId?: string, format?: 'mp3' | 'wav'): Promise<Blob> {;
    const response = await thisclientpost(;
      `/api/v1/speech/synthesize/kokoro`;
      { text, voiceId, format: format || 'mp3' ;
};
      { responseType: 'blob' ;
};
    );
    return responsedata;
  };

  async transcribeAudio(audioBlob: Blob, context?: string): Promise<ApiResponse> {;
    const formData = new FormData();
    formDataappend('audio', audioBlob);
    if (context) formDataappend('context', context);
    return thisrequest;
      method: 'POST';
      url: `/api/v1/speech/transcribe`;
      data: formData;
      headers: {;
        'Content-Type': 'multipart/form-data';
      ;
};
    });
  };

  // Utility methods;
  async healthCheck(): Promise<ApiResponse> {;
    return thisrequest;
      method: 'GET';
      url: '/api/health/detailed';
    });
  };

  async getStats(): Promise<ApiResponse> {;
    return thisrequest;
      method: 'GET';
      url: `/api/v1/stats`;
    });
  };

  // WebSocket connection for real-time updates;
  connectWebSocket(onMessage: (data: any) => void): WebSocket {;
    const wsUrl = `${thisconfigbaseUrlreplace(/^http/, 'ws')}/ws/port-status`;
    const ws = new WebSocket(wsUrl);
    wsonopen = () => {;
      loggerinfo('[WebSocket] Connected');
      wssend(;
        JSONstringify({;
          type: 'authenticate';
          apiKey: thisconfigapiKey;
          aiService: thisconfigaiService;
        });
      );
    };
    wsonmessage = (event) => {;
      try {;
        const data = JSONparse(eventdata);
        onMessage(data);
      } catch (error) {;
        consoleerror instanceof Error ? errormessage : String(error) [WebSocket] Failed to parse message:', error instanceof Error ? errormessage : String(error)  ;
};
    };
    wsonerror instanceof Error ? errormessage : String(error)  (error instanceof Error ? errormessage : String(error)=> {;
      consoleerror instanceof Error ? errormessage : String(error) [WebSocket] Error:', error instanceof Error ? errormessage : String(error)  ;
};
    wsonclose = () => {;
      loggerinfo('[WebSocket] Disconnected');
    };
    return ws;
  };
};

// Export convenience function;
export function createClient(config: ApiClientConfig): UniversalAIToolsClient {;
  return new UniversalAIToolsClient(config);
};
