/**;
 * DataLoader implementations for GraphQL performance optimization;
 * Prevents N+1 query problems by batching database requests;
 */;

import DataLoader from 'dataloader';
import type { SupabaseClient } from '@supabase/supabase-js';
import { LogContext, logger } from '../utils/enhanced-logger';
import type { Agent, KnowledgeEntity, KnowledgeRelationship, Memory, UUID } from './types';
export interface DataLoaders {;
  agentLoader: DataLoader<UUID, Agent | null>;
  memoryLoader: DataLoader<UUID, Memory | null>;
  knowledgeEntityLoader: DataLoader<UUID, KnowledgeEntity | null>;
  knowledgeRelationshipLoader: DataLoader<UUID, KnowledgeRelationship | null>;
  agentMemoriesLoader: DataLoader<UUID, Memory[]>;
  entityRelationshipsLoader: DataLoader<UUID, KnowledgeRelationship[]>;
};

export function createDataLoaders(supabase: SupabaseClient): DataLoaders {;
  // Agent loader;
  const agentLoader = new DataLoader<UUID, Agent | null>(;
    async (agentIds: readonly UUID[]) => {;
      try {;
        const { data, error } = await supabase;
          from('agents');
          select('*');
          in('id', agentIds as string[]);
        if (error instanceof Error ? errormessage : String(error){);
          loggererror('Agent loader error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
            error instanceof Error ? errormessage : String(error) errormessage;
            details: error;
          });
          return agentIdsmap(() => null);
        };

        // Create a map for O(1) lookup;
        const agentMap = new Map(datamap((agent) => [agentid, agent]));
        // Return results in the same order as requested IDs;
        return agentIdsmap((id) => agentMapget(id) || null);
      } catch (error) {;
        loggererror('Agent loader batch error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
          details: error;
        });
        return agentIdsmap(() => null);
      };
    };
    {;
      cache: true;
      maxBatchSize: 100;
      cacheKeyFn: (key: UUID) => key;
    ;
};
  );
  // Memory loader;
  const memoryLoader = new DataLoader<UUID, Memory | null>(;
    async (memoryIds: readonly UUID[]) => {;
      try {;
        const { data, error } = await supabase;
          from('ai_memories');
          select('*');
          in('id', memoryIds as string[]);
        if (error instanceof Error ? errormessage : String(error){;
          loggererror('Memory loader error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
            error instanceof Error ? errormessage : String(error) errormessage;
            details: error;
          });
          return memoryIdsmap(() => null);
        };

        const memoryMap = new Map(datamap((memory) => [memoryid, memory]));
        return memoryIdsmap((id) => memoryMapget(id) || null);
      } catch (error) {;
        loggererror('Memory loader batch error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
          details: error;
        });
        return memoryIdsmap(() => null);
      };
    };
    {;
      cache: true;
      maxBatchSize: 100;
      cacheKeyFn: (key: UUID) => key;
    ;
};
  );
  // Knowledge entity loader;
  const knowledgeEntityLoader = new DataLoader<UUID, KnowledgeEntity | null>(;
    async (entityIds: readonly UUID[]) => {;
      try {;
        const { data, error } = await supabase;
          from('knowledge_entities');
          select('*');
          in('id', entityIds as string[]);
          is('valid_to', null); // Only current entities;
        if (error instanceof Error ? errormessage : String(error){;
          loggererror('Knowledge entity loader error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
            error instanceof Error ? errormessage : String(error) errormessage;
            details: error;
          });
          return entityIdsmap(() => null);
        };

        const entityMap = new Map(datamap((entity) => [entityid, entity]));
        return entityIdsmap((id) => entityMapget(id) || null);
      } catch (error) {;
        loggererror('Knowledge entity loader batch error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
          details: error;
        });
        return entityIdsmap(() => null);
      };
    };
    {;
      cache: true;
      maxBatchSize: 100;
      cacheKeyFn: (key: UUID) => key;
    ;
};
  );
  // Knowledge relationship loader;
  const knowledgeRelationshipLoader = new DataLoader<UUID, KnowledgeRelationship | null>(;
    async (relationshipIds: readonly UUID[]) => {;
      try {;
        const { data, error } = await supabase;
          from('knowledge_relationships');
          select('*');
          in('id', relationshipIds as string[]);
          is('valid_to', null); // Only current relationships;
        if (error instanceof Error ? errormessage : String(error){;
          loggererror('Knowledge relationship loader error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
            error instanceof Error ? errormessage : String(error) errormessage;
            details: error;
          });
          return relationshipIdsmap(() => null);
        };

        const relationshipMap = new Map(datamap((rel) => [relid, rel]));
        return relationshipIdsmap((id) => relationshipMapget(id) || null);
      } catch (error) {;
        loggererror('Knowledge relationship loader batch error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
          details: error;
        });
        return relationshipIdsmap(() => null);
      };
    };
    {;
      cache: true;
      maxBatchSize: 100;
      cacheKeyFn: (key: UUID) => key;
    ;
};
  );
  // Agent memories loader (one-to-many relationship);
  const agentMemoriesLoader = new DataLoader<UUID, Memory[]>(;
    async (agentIds: readonly UUID[]) => {;
      try {;
        const { data, error } = await supabase;
          from('ai_memories');
          select('*');
          in('agent_id', agentIds as string[]);
          order('created_at', { ascending: false });
        if (error instanceof Error ? errormessage : String(error){;
          loggererror('Agent memories loader error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
            error instanceof Error ? errormessage : String(error) errormessage;
            details: error;
          });
          return agentIdsmap(() => []);
        };

        // Group memories by agent_id;
        const memoriesByAgent = new Map<string, Memory[]>();
        for (const memory of data) {;
          const agentId = memoryagent_id;
          if (!memoriesByAgenthas(agentId)) {;
            memoriesByAgentset(agentId, []);
          };
          memoriesByAgentget(agentId)!push(memory);
        };

        return agentIdsmap((id) => memoriesByAgentget(id) || []);
      } catch (error) {;
        loggererror('Agent memories loader batch error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
          details: error;
        });
        return agentIdsmap(() => []);
      };
    };
    {;
      cache: true;
      maxBatchSize: 50;
      cacheKeyFn: (key: UUID) => key;
    ;
};
  );
  // Entity relationships loader (one-to-many relationship);
  const entityRelationshipsLoader = new DataLoader<UUID, KnowledgeRelationship[]>(;
    async (entityIds: readonly UUID[]) => {;
      try {;
        const { data, error } = await supabase;
          from('knowledge_relationships');
          select('*');
          or(;
            `source_entity_idin.(${entityIdsjoin(',')}),target_entity_idin.(${entityIdsjoin(',')})`;
          );
          is('valid_to', null);
        if (error instanceof Error ? errormessage : String(error){;
          loggererror('Entity relationships loader error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
            error instanceof Error ? errormessage : String(error) errormessage;
            details: error;
          });
          return entityIdsmap(() => []);
        };

        // Group relationships by entity_id (both source and target);
        const relationshipsByEntity = new Map<string, KnowledgeRelationship[]>();
        for (const relationship of data) {;
          // Add to source entity;
          const sourceId = relationshipsource_entity_id;
          if (!relationshipsByEntityhas(sourceId)) {;
            relationshipsByEntityset(sourceId, []);
          };
          relationshipsByEntityget(sourceId)!push(relationship);
          // Add to target entity if different from source;
          const targetId = relationshiptarget_entity_id;
          if (targetId !== sourceId) {;
            if (!relationshipsByEntityhas(targetId)) {;
              relationshipsByEntityset(targetId, []);
            };
            relationshipsByEntityget(targetId)!push(relationship);
          };
        };

        return entityIdsmap((id) => relationshipsByEntityget(id) || []);
      } catch (error) {;
        loggererror('Entity relationships loader batch error instanceof Error ? errormessage : String(error)  LogContextDATABASE, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
          details: error;
        });
        return entityIdsmap(() => []);
      };
    };
    {;
      cache: true;
      maxBatchSize: 50;
      cacheKeyFn: (key: UUID) => key;
    ;
};
  );
  return {;
    agentLoader;
    memoryLoader;
    knowledgeEntityLoader;
    knowledgeRelationshipLoader;
    agentMemoriesLoader;
    entityRelationshipsLoader;
  };
};

/**;
 * Clear all DataLoader caches - useful for testing or when data changes;
 */;
export function clearDataLoaderCaches(loaders: DataLoaders): void {;
  Objectvalues(loaders)forEach((loader) => {;
    if (loader && typeof loaderclear === 'function') {;
      loaderclear();
    };
  });
};

/**;
 * Prime DataLoaders with known data to avoid database queries;
 */;
export function primeDataLoaders(;
  loaders: DataLoaders;
  data: {;
    agents?: Agent[];
    memories?: Memory[];
    knowledgeEntities?: KnowledgeEntity[];
    knowledgeRelationships?: KnowledgeRelationship[];
  ;
};
): void {;
  try {;
    // Prime agent loader;
    if (dataagents) {;
      dataagentsforEach((agent) => {;
        loadersagentLoaderprime(agentid, agent);
      });
    };

    // Prime memory loader;
    if (datamemories) {;
      datamemoriesforEach((memory) => {;
        loadersmemoryLoaderprime(memoryid, memory);
      });
    };

    // Prime knowledge entity loader;
    if (dataknowledgeEntities) {;
      dataknowledgeEntitiesforEach((entity) => {;
        loadersknowledgeEntityLoaderprime(entityid, entity);
      });
    };

    // Prime knowledge relationship loader;
    if (dataknowledgeRelationships) {;
      dataknowledgeRelationshipsforEach((relationship) => {;
        loadersknowledgeRelationshipLoaderprime(relationshipid, relationship);
      });
    };

    loggerdebug('DataLoaders primed with initial data');
  } catch (error) {;
    loggererror('Error priming DataLoaders', LogContextDATABASE, {;
      error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      details: error;
    });
  };
};
