/**;
 * Async wrapper utility for Express route handlers;
 * Properly handles async errors in Express middleware;
 */;

import type { NextFunction, Request, RequestHandler, Response } from 'express';
import { LogContext, logger } from './enhanced-logger';
/**;
 * Wraps an async route handler to properly catch and forward errors;
 */;
export function wrapAsync(;
  fn: (req: Request, res: Response, next: NextFunction) => Promise<unknown>;
): RequestHandler {;
  return (req: Request, res: Response, next: NextFunction) => {;
    Promiseresolve(fn(req, res, next))catch(next);
  };
};

/**;
 * Type-safe async handler with generic support;
 */;
export function asyncHandler<T = any>(;
  fn: (req: Request, res: Response, next: NextFunction) => Promise<T>;
): RequestHandler {;
  return async (req: Request, res: Response, next: NextFunction) => {;
    try {;
      await fn(req, res, next);
    } catch (error) {;
      next(error);
    };
  };
};

/**;
 * Async middleware wrapper with error handling;
 */;
export function asyncMiddleware(;
  fn: (req: Request, res: Response, next: NextFunction) => Promise<void>;
): RequestHandler {;
  return async (req: Request, res: Response, next: NextFunction) => {;
    try {;
      await fn(req, res, next);
    } catch (error) {;
      // If headers already sent, pass to error handler;
      if (resheadersSent) {;
        return next(error);
      };

      // Otherwise, send error response;
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Internal server error';
      });
    };
  };
};

/**;
 * Create an async route handler with automatic error response;
 */;
export function createAsyncHandler<TBody = any, TQuery = any, TParams = any>(;
  handler: (req: Request<TParams, any, TBody, TQuery>, res: Response) => Promise<void>;
): RequestHandler {;
  return async (req: Request, res: Response, next: NextFunction) => {;
    try {;
      await handler(req as Request<TParams, any, TBody, TQuery>, res);
    } catch (error) {;
      if (!resheadersSent) {;
        const statusCode =;
          error instanceof Error && 'statusCode' in error ? (error as any)statusCode : 500;
        resstatus(statusCode)json({;
          success: false;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Internal server error';
          ...(processenvNODE_ENV === 'development' && {;
            stack: error instanceof Error ? errorstack : undefined;
          });
        });
      } else {;
        next(error);
      };
    };
  };
};

/**;
 * Validates request body against a schema (example with Zod);
 */;
export function validateBody<T>(schema: { parse: (data: unknown) => T }): RequestHandler {;
  return (req: Request, res: Response, next: NextFunction) => {;
    try {;
      reqbody = schemaparse(reqbody);
      next();
    } catch (error) {;
      resstatus(400)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) 'Invalid request body';
        details: error instanceof Error ? errormessage : undefined;
      });
    };
  };
};

/**;
 * Async error handler for Express error middleware;
 */;
export function asyncErrorHandler(;
  fn: (err: Error, req: Request, res: Response, next: NextFunction) => Promise<void>;
) {;
  return async (err: Error, req: Request, res: Response, next: NextFunction) => {;
    try {;
      await fn(err, req, res, next);
    } catch (error) {;
      loggererror('Error in error handler', LogContextSYSTEM, { error });
      if (!resheadersSent) {;
        resstatus(500)json({;
          success: false;
          error instanceof Error ? errormessage : String(error) 'Critical error in error handler';
        });
      };
    };
  };
};
