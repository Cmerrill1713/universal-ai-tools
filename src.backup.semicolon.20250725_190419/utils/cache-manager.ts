import { Redis } from 'ioredis';
import { logger } from './logger';
import { performanceMonitor } from './performance-monitor';
export interface CacheOptions {;
  ttl?: number; // Time to live in seconds;
  compress?: boolean; // Compress large values;
  namespace?: string; // Cache namespace;
  tags?: string[]; // Cache tags for bulk invalidation;
  retry?: number; // Retry attempts;
  fallback?: boolean; // Use fallback cache on Redis failure;
};

export interface CacheStats {;
  hits: number;
  misses: number;
  sets: number;
  deletes: number;
  hitRate: number;
  totalRequests: number;
  avgResponseTime: number;
  memoryUsage: number;
  keyCount: number;
;
};

export class CacheManager {;
  private redis: Redis;
  private fallbackCache: Map<string, { value: any; expires: number; tags: string[] }>;
  private stats: CacheStats = {;
    hits: 0;
    misses: 0;
    sets: 0;
    deletes: 0;
    hitRate: 0;
    totalRequests: 0;
    avgResponseTime: 0;
    memoryUsage: 0;
    keyCount: 0;
  ;
};
  private defaultTtl = 3600; // 1 hour;
  private maxFallbackSize = 1000;
  constructor(redisUrl: string) {;
    thisredis = new Redis(redisUrl, {;
      maxRetriesPerRequest: 3;
      lazyConnect: true;
      keepAlive: 30000;
      connectTimeout: 10000;
      commandTimeout: 5000;
    });
    thisfallbackCache = new Map();
    thissetupEventListeners();
  };

  private setupEventListeners(): void {;
    thisredison('connect', () => {;
      loggerinfo('Redis connected');
    });
    thisredison('error', (error) => {;
      loggererror('Redis error instanceof Error ? errormessage : String(error)', error);
    });
    thisredison('ready', () => {;
      loggerinfo('Redis ready');
    });
    thisredison('close', () => {;
      loggerwarn('Redis connection closed');
    });
  };

  private buildKey(key: string, namespace?: string): string {;
    const prefix = namespace || 'universal-ai';
    return `${prefix}:${key}`;
  };

  private async compress(value: any): Promise<string> {;
    try {;
      const zlib = require('zlib');
      const json = JSONstringify(value);
      const compressed = zlibgzipSync(json);
      return compressedtoString('base64');
    } catch (error) {;
      loggererror('Compression error instanceof Error ? errormessage : String(error)', error);
      return JSONstringify(value);
    };
  };

  private async decompress(value: string): Promise<unknown> {;
    try {;
      const zlib = require('zlib');
      const compressed = Bufferfrom(value, 'base64');
      const decompressed = zlibgunzipSync(compressed);
      return JSONparse(decompressedtoString());
    } catch (error) {;
      loggererror('Decompression error instanceof Error ? errormessage : String(error)', error);
      return JSONparse(value);
    };
  };

  private updateStats(operation: 'hit' | 'miss' | 'set' | 'delete', responseTime: number): void {;
    thisstats[;
      operation === 'hit';
        ? 'hits';
        : operation === 'miss';
          ? 'misses';
          : operation === 'set';
            ? 'sets';
            : 'deletes';
    ]++;
    thisstatstotalRequests++;
    thisstatsavgResponseTime =;
      (thisstatsavgResponseTime * (thisstatstotalRequests - 1) + responseTime) /;
      thisstatstotalRequests;
    thisstatshitRate = (thisstatshits / thisstatstotalRequests) * 100;
    performanceMonitorrecordCacheAccess(operation === 'hit');
  ;
};

  private async useFallback(key: string, value?: any, ttl?: number): Promise<unknown> {;
    const fullKey = thisbuildKey(key);
    if (value !== undefined) {;
      // Set operation;
      if (thisfallbackCachesize >= thismaxFallbackSize) {;
        const firstKey = thisfallbackCachekeys()next()value;
        if (firstKey) {;
          thisfallbackCachedelete(firstKey);
        };
      };

      thisfallbackCacheset(fullKey, {;
        value;
        expires: Datenow() + (ttl || thisdefaultTtl) * 1000;
        tags: [];
      });
      return value;
    } else {;
      // Get operation;
      const cached = thisfallbackCacheget(fullKey);
      if (cached && cachedexpires > Datenow()) {;
        return cachedvalue;
      };

      if (cached) {;
        thisfallbackCachedelete(fullKey);
      };

      return null;
    };
  };

  public async get<T = any>(key: string, options: CacheOptions = {}): Promise<T | null> {;
    const startTime = processhrtime();
    try {;
      const fullKey = thisbuildKey(key, optionsnamespace);
      const value = await thisredisget(fullKey);
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      if (value !== null) {;
        thisupdateStats('hit', responseTime);
        return optionscompress ? await thisdecompress(value) : JSONparse(value);
      } else {;
        thisupdateStats('miss', responseTime);
        return null;
      };
    } catch (error) {;
      loggererror('Cache get error instanceof Error ? errormessage : String(error)', error);
      if (optionsfallback !== false) {;
        const fallbackValue = await thisuseFallback(key);
        if (fallbackValue !== null) {;
          const [seconds, nanoseconds] = processhrtime(startTime);
          const responseTime = seconds * 1000 + nanoseconds / 1000000;
          thisupdateStats('hit', responseTime);
          return fallbackValue;
        };
      };

      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('miss', responseTime);
      return null;
    };
  };

  public async set(key: string, value: any, options: CacheOptions = {}): Promise<boolean> {;
    const startTime = processhrtime();
    try {;
      const fullKey = thisbuildKey(key, optionsnamespace);
      const ttl = optionsttl || thisdefaultTtl;
      const serialized = optionscompress ? await thiscompress(value) : JSONstringify(value);
      const multi = thisredismulti();
      multisetex(fullKey, ttl, serialized);
      // Add tags for bulk invalidation;
      if (optionstags && optionstagslength > 0) {;
        const tagKeys = optionstagsmap((tag) => thisbuildKey(`tag:${tag}`, optionsnamespace));
        tagKeysforEach((tagKey) => {;
          multisadd(tagKey, fullKey);
          multiexpire(tagKey, ttl);
        });
      };

      await multiexec();
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('set', responseTime);
      return true;
    } catch (error) {;
      loggererror('Cache set error instanceof Error ? errormessage : String(error)', error);
      if (optionsfallback !== false) {;
        await thisuseFallback(key, value, optionsttl);
      };

      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('set', responseTime);
      return false;
    };
  };

  public async del(key: string, options: CacheOptions = {}): Promise<boolean> {;
    const startTime = processhrtime();
    try {;
      const fullKey = thisbuildKey(key, optionsnamespace);
      const result = await thisredisdel(fullKey);
      // Remove from fallback cache;
      thisfallbackCachedelete(fullKey);
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('delete', responseTime);
      return result > 0;
    } catch (error) {;
      loggererror('Cache delete error instanceof Error ? errormessage : String(error)', error);
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('delete', responseTime);
      return false;
    };
  };

  public async invalidateByTags(tags: string[], options: CacheOptions = {}): Promise<number> {;
    try {;
      let totalInvalidated = 0;
      for (const tag of tags) {;
        const tagKey = thisbuildKey(`tag:${tag}`, optionsnamespace);
        const keys = await thisredissmembers(tagKey);
        if (keyslength > 0) {;
          const deleted = await thisredisdel(..keys);
          totalInvalidated += deleted;
        };

        await thisredisdel(tagKey);
      };

      return totalInvalidated;
    } catch (error) {;
      loggererror('Cache invalidation error instanceof Error ? errormessage : String(error)', error);
      return 0;
    };
  };

  public async exists(key: string, options: CacheOptions = {}): Promise<boolean> {;
    try {;
      const fullKey = thisbuildKey(key, optionsnamespace);
      const result = await thisredisexists(fullKey);
      return result > 0;
    } catch (error) {;
      loggererror('Cache exists error instanceof Error ? errormessage : String(error)', error);
      return false;
    };
  };

  public async ttl(key: string, options: CacheOptions = {}): Promise<number> {;
    try {;
      const fullKey = thisbuildKey(key, optionsnamespace);
      return await thisredisttl(fullKey);
    } catch (error) {;
      loggererror('Cache TTL error instanceof Error ? errormessage : String(error)', error);
      return -1;
    };
  };

  public async extend(key: string, ttl: number, options: CacheOptions = {}): Promise<boolean> {;
    try {;
      const fullKey = thisbuildKey(key, optionsnamespace);
      const result = await thisredisexpire(fullKey, ttl);
      return result === 1;
    } catch (error) {;
      loggererror('Cache extend error instanceof Error ? errormessage : String(error)', error);
      return false;
    };
  };

  public async getMultiple<T = any>(;
    keys: string[];
    options: CacheOptions = {;
};
  ): Promise<(T | null)[]> {;
    try {;
      const fullKeys = keysmap((key) => thisbuildKey(key, optionsnamespace));
      const values = await thisredismget(..fullKeys);
      return valuesmap((value) => {;
        if (value !== null) {;
          thisupdateStats('hit', 0);
          return optionscompress ? thisdecompress(value) : JSONparse(value);
        } else {;
          thisupdateStats('miss', 0);
          return null;
        };
      });
    } catch (error) {;
      loggererror('Cache getMultiple error instanceof Error ? errormessage : String(error)', error);
      return keysmap(() => null);
    };
  };

  public async setMultiple(;
    pairs: Array<{ key: string; value: any; ttl?: number }>;
    options: CacheOptions = {;
};
  ): Promise<boolean> {;
    try {;
      const multi = thisredismulti();
      for (const { key, value, ttl } of pairs) {;
        const fullKey = thisbuildKey(key, optionsnamespace);
        const serialized = optionscompress ? await thiscompress(value) : JSONstringify(value);
        multisetex(fullKey, ttl || optionsttl || thisdefaultTtl, serialized);
      };

      await multiexec();
      return true;
    } catch (error) {;
      loggererror('Cache setMultiple error instanceof Error ? errormessage : String(error)', error);
      return false;
    };
  };

  public async flush(namespace?: string): Promise<boolean> {;
    try {;
      if (namespace) {;
        const pattern = thisbuildKey('*', namespace);
        const keys = await thisrediskeys(pattern);
        if (keyslength > 0) {;
          await thisredisdel(..keys);
        };
      } else {;
        await thisredisflushdb();
      };

      // Clear fallback cache;
      thisfallbackCacheclear();
      return true;
    } catch (error) {;
      loggererror('Cache flush error instanceof Error ? errormessage : String(error)', error);
      return false;
    };
  };

  public async getStats(): Promise<CacheStats> {;
    try {;
      const info = await thisredisinfo('memory');
      const memoryMatch = infomatch(/used_memory:(\d+)/);
      thisstatsmemoryUsage = memoryMatch ? parseInt(memoryMatch[1], 10) : 0;
      const keyCount = await thisredisdbsize();
      thisstatskeyCount = keyCount;
      return { ..thisstats };
    } catch (error) {;
      loggererror('Cache stats error instanceof Error ? errormessage : String(error)', error);
      return { ..thisstats };
    };
  };

  public async healthCheck(): Promise<{ healthy: boolean; latency: number; error?: string }> {;
    const startTime = processhrtime();
    try {;
      await thisredisping();
      const [seconds, nanoseconds] = processhrtime(startTime);
      const latency = seconds * 1000 + nanoseconds / 1000000;
      return { healthy: true, latency };
    } catch (error) {;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const latency = seconds * 1000 + nanoseconds / 1000000;
      return {;
        healthy: false;
        latency;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error';
      ;
};
    };
  };

  public async close(): Promise<void> {;
    await thisredisquit();
    thisfallbackCacheclear();
  ;
};

  // Utility methods for common caching patterns;
  public async remember<T>(;
    key: string;
    factory: () => Promise<T>;
    options: CacheOptions = {;
};
  ): Promise<T> {;
    const cached = await thisget<T>(key, options);
    if (cached !== null) {;
      return cached;
    };

    const value = await factory();
    await thisset(key, value, options);
    return value;
  };

  public async rememberForever<T>(;
    key: string;
    factory: () => Promise<T>;
    options: CacheOptions = {;
};
  ): Promise<T> {;
    return thisremember(key, factory, { ..options, ttl: 0 });
  };

  public createCacheKey(..parts: (string | number)[]): string {;
    return partsjoin(':');
  };
};

export default CacheManager;