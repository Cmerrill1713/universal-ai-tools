import { Redis } from 'ioredis';
import { LogContext, logger } from './enhanced-logger';
import { performanceMonitor } from './performance-monitor';
export interface CacheOptions {;
  ttl?: number;
  compress?: boolean;
  namespace?: string;
  tags?: string[];
  retry?: number;
  fallback?: boolean;
;
};

export interface CacheStats {;
  hits: number;
  misses: number;
  sets: number;
  deletes: number;
  hitRate: number;
  totalRequests: number;
  avgResponseTime: number;
  memoryUsage: number;
  keyCount: number;
;
};

interface CircuitBreakerState {;
  failures: number;
  lastFailureTime: number;
  state: 'CLOSED' | 'OPEN' | 'HALF_OPEN';
  successCount: number;
;
};

export class ImprovedCacheManager {;
  private redis: Redis;
  private fallbackCache: Map<string, { value: any; expires: number; tags: string[] }>;
  private stats: CacheStats = {;
    hits: 0;
    misses: 0;
    sets: 0;
    deletes: 0;
    hitRate: 0;
    totalRequests: 0;
    avgResponseTime: 0;
    memoryUsage: 0;
    keyCount: 0;
  ;
};
  private defaultTtl = 3600; // 1 hour;
  private maxFallbackSize = 1000;
  private circuitBreaker: CircuitBreakerState = {;
    failures: 0;
    lastFailureTime: 0;
    state: 'CLOSED';
    successCount: 0;
  ;
};
  private readonly circuitBreakerThreshold = 5;
  private readonly circuitBreakerTimeout = 60000; // 1 minute;
  private readonly halfOpenRequests = 3;
  private connectionRetryCount = 0;
  private maxConnectionRetries = 5;
  private isConnected = false;
  constructor(redisUrl: string) {;
    thisfallbackCache = new Map();
    // Create Redis instance with improved configuration;
    thisredis = new Redis(redisUrl, {;
      // Connection pool settings;
      maxRetriesPerRequest: 3;
      enableReadyCheck: true;
      lazyConnect: false, // Connect immediately;
      // Timeouts;
      connectTimeout: 5000, // 5 seconds;
      commandTimeout: 3000, // 3 seconds;
      // Reconnection strategy with exponential backoff;
      retryStrategy: (times: number) => {;
        const maxDelay = 30000; // 30 seconds;
        const baseDelay = 100;
        const delay = Mathmin(baseDelay * Mathpow(2, times), maxDelay);
        if (times > thismaxConnectionRetries) {;
          loggererror(`Redis connection failed after ${times} attempts`, LogContextCACHE);
          // Don't stop retrying, but log the issue;
        };

        loggerwarn(`Redis reconnection attempt ${times}, waiting ${delay}ms`, LogContextCACHE);
        return delay;
      };
      // Connection keep-alive;
      keepAlive: 10000;
      // Enable offline queue;
      enableOfflineQueue: true;
      // Connection pool size;
      connectionName: 'universal-ai-cache';
    });
    thissetupEventListeners();
    thissetupHealthCheck();
  };

  private setupEventListeners(): void {;
    thisredison('connect', () => {;
      loggerinfo('Redis connecting...');
      thisconnectionRetryCount = 0;
    });
    thisredison('ready', () => {;
      loggerinfo('Redis connection ready');
      thisisConnected = true;
      thisresetCircuitBreaker();
    });
    thisredison('error', (error) => {;
      loggererror('Redis error', LogContextCACHE, { error });
      thishandleConnectionError();
    });
    thisredison('close', () => {;
      loggerwarn('Redis connection closed');
      thisisConnected = false;
    });
    thisredison('reconnecting', (delay: number) => {;
      loggerinfo(`Redis reconnecting in ${delay}ms`);
      thisconnectionRetryCount++;
    });
    thisredison('end', () => {;
      loggererror('Redis connection ended');
      thisisConnected = false;
    });
  };

  private setupHealthCheck(): void {;
    // Periodic health check every 30 seconds;
    setInterval(async () => {;
      if (thisisConnected) {;
        try {;
          await thisredisping();
        } catch (error) {;
          loggererror('Redis health check failed:', LogContextCACHE, { error });
          thishandleConnectionError();
        };
      };
    }, 30000);
  };

  private handleConnectionError(): void {;
    thiscircuitBreakerfailures++;
    thiscircuitBreakerlastFailureTime = Datenow();
    if (thiscircuitBreakerfailures >= thiscircuitBreakerThreshold) {;
      thisopenCircuitBreaker();
    ;
};
  };

  private handleError(error instanceof Error ? errormessage : String(error) any): void {;
    thishandleConnectionError();
  ;
};

  private openCircuitBreaker(): void {;
    thiscircuitBreakerstate = 'OPEN';
    loggerwarn('Redis circuit breaker opened due to repeated failures');
    // Schedule circuit breaker half-open after timeout;
    setTimeout(() => {;
      thiscircuitBreakerstate = 'HALF_OPEN';
      thiscircuitBreakersuccessCount = 0;
      loggerinfo('Redis circuit breaker moved to half-open state');
    }, thiscircuitBreakerTimeout);
  };

  private resetCircuitBreaker(): void {;
    thiscircuitBreaker = {;
      failures: 0;
      lastFailureTime: 0;
      state: 'CLOSED';
      successCount: 0;
    ;
};
  };

  private async checkCircuitBreaker(): Promise<boolean> {;
    if (thiscircuitBreakerstate === 'OPEN') {;
      const timeElapsed = Datenow() - thiscircuitBreakerlastFailureTime;
      if (timeElapsed < thiscircuitBreakerTimeout) {;
        return false;
      };
    };

    if (thiscircuitBreakerstate === 'HALF_OPEN') {;
      // Allow limited requests in half-open state;
      return thiscircuitBreakersuccessCount < thishalfOpenRequests;
    };

    return true;
  };

  private handleCircuitBreakerSuccess(): void {;
    if (thiscircuitBreakerstate === 'HALF_OPEN') {;
      thiscircuitBreakersuccessCount++;
      if (thiscircuitBreakersuccessCount >= thishalfOpenRequests) {;
        thisresetCircuitBreaker();
        loggerinfo('Redis circuit breaker closed - connection restored');
      ;
};
    };
  };

  private buildKey(key: string, namespace?: string): string {;
    const prefix = namespace || 'universal-ai';
    return `${prefix}:${key}`;
  };

  private withNamespace(key: string, namespace?: string): string {;
    return thisbuildKey(key, namespace);
  };

  private async compress(value: any): Promise<string> {;
    try {;
      const zlib = require('zlib');
      const json = JSONstringify(value);
      const compressed = zlibgzipSync(json);
      return compressedtoString('base64');
    } catch (error) {;
      loggererror('Compression error', LogContextCACHE, { error });
      return JSONstringify(value);
    };
  };

  private async decompress(value: string): Promise<unknown> {;
    try {;
      const zlib = require('zlib');
      const compressed = Bufferfrom(value, 'base64');
      const decompressed = zlibgunzipSync(compressed);
      return JSONparse(decompressedtoString());
    } catch (error) {;
      // Try parsing as regular JSON if decompression fails;
      try {;
        return JSONparse(value);
      } catch {;
        loggererror('Decompression error', LogContextCACHE, { error });
        throw error;
      };
    };
  };

  private updateStats(operation: 'hit' | 'miss' | 'set' | 'delete', responseTime: number): void {;
    thisstats[;
      operation === 'hit';
        ? 'hits';
        : operation === 'miss';
          ? 'misses';
          : operation === 'set';
            ? 'sets';
            : 'deletes';
    ]++;
    thisstatstotalRequests++;
    thisstatsavgResponseTime =;
      (thisstatsavgResponseTime * (thisstatstotalRequests - 1) + responseTime) /;
      thisstatstotalRequests;
    thisstatshitRate =;
      thisstatstotalRequests > 0 ? (thisstatshits / thisstatstotalRequests) * 100 : 0;
    performanceMonitorrecordCacheAccess(operation === 'hit');
  ;
};

  private async useFallback(key: string, value?: any, ttl?: number): Promise<unknown> {;
    const fullKey = thisbuildKey(key);
    if (value !== undefined) {;
      // Set operation;
      if (thisfallbackCachesize >= thismaxFallbackSize) {;
        // Remove oldest entries;
        const entriesToRemove = Mathfloor(thismaxFallbackSize * 0.1); // Remove 10%;
        const keys = Arrayfrom(thisfallbackCachekeys())slice(0, entriesToRemove);
        keysforEach((k) => thisfallbackCachedelete(k));
      };

      thisfallbackCacheset(fullKey, {;
        value;
        expires: Datenow() + (ttl || thisdefaultTtl) * 1000;
        tags: [];
      });
      return value;
    } else {;
      // Get operation;
      const cached = thisfallbackCacheget(fullKey);
      if (cached && cachedexpires > Datenow()) {;
        return cachedvalue;
      };

      if (cached) {;
        thisfallbackCachedelete(fullKey);
      };

      return null;
    };
  };

  public async get<T = any>(key: string, options: CacheOptions = {}): Promise<T | null> {;
    const startTime = processhrtime();
    try {;
      // Check circuit breaker;
      if (!(await thischeckCircuitBreaker())) {;
        loggerdebug('Redis circuit breaker is open, using fallback cache');
        const fallbackValue = await thisuseFallback(key);
        const [seconds, nanoseconds] = processhrtime(startTime);
        const responseTime = seconds * 1000 + nanoseconds / 1000000;
        thisupdateStats(fallbackValue !== null ? 'hit' : 'miss', responseTime);
        return fallbackValue;
      };

      const fullKey = thisbuildKey(key, optionsnamespace);
      const value = await thisredisget(fullKey);
      thishandleCircuitBreakerSuccess();
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      if (value !== null) {;
        thisupdateStats('hit', responseTime);
        return optionscompress ? await thisdecompress(value) : JSONparse(value);
      } else {;
        thisupdateStats('miss', responseTime);
        return null;
      };
    } catch (error) {;
      loggererror('Cache get error', LogContextCACHE, { error });
      thishandleConnectionError();
      // Always try fallback on error;
      const fallbackValue = await thisuseFallback(key);
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats(fallbackValue !== null ? 'hit' : 'miss', responseTime);
      return fallbackValue;
    };
  };

  public async set(key: string, value: any, options: CacheOptions = {}): Promise<boolean> {;
    const startTime = processhrtime();
    // Always update fallback cache;
    await thisuseFallback(key, value, optionsttl);
    try {;
      // Check circuit breaker;
      if (!(await thischeckCircuitBreaker())) {;
        loggerdebug('Redis circuit breaker is open, only using fallback cache');
        const [seconds, nanoseconds] = processhrtime(startTime);
        const responseTime = seconds * 1000 + nanoseconds / 1000000;
        thisupdateStats('set', responseTime);
        return true; // Return true since fallback succeeded;
      };

      const fullKey = thisbuildKey(key, optionsnamespace);
      const ttl = optionsttl || thisdefaultTtl;
      const serialized = optionscompress ? await thiscompress(value) : JSONstringify(value);
      const multi = thisredismulti();
      multisetex(fullKey, ttl, serialized);
      // Add tags for bulk invalidation;
      if (optionstags && optionstagslength > 0) {;
        const tagKeys = optionstagsmap((tag) => thisbuildKey(`tag:${tag}`, optionsnamespace));
        tagKeysforEach((tagKey) => {;
          multisadd(tagKey, fullKey);
          multiexpire(tagKey, ttl);
        });
      };

      await multiexec();
      thishandleCircuitBreakerSuccess();
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('set', responseTime);
      return true;
    } catch (error) {;
      loggererror('Cache set error', LogContextCACHE, { error });
      thishandleConnectionError();
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('set', responseTime);
      // Return true since fallback succeeded;
      return true;
    };
  };

  public async del(key: string, options: CacheOptions = {}): Promise<boolean> {;
    const startTime = processhrtime();
    // Always remove from fallback cache;
    const fullKey = thisbuildKey(key, optionsnamespace);
    thisfallbackCachedelete(fullKey);
    try {;
      // Check circuit breaker;
      if (!(await thischeckCircuitBreaker())) {;
        const [seconds, nanoseconds] = processhrtime(startTime);
        const responseTime = seconds * 1000 + nanoseconds / 1000000;
        thisupdateStats('delete', responseTime);
        return true;
      };

      const result = await thisredisdel(fullKey);
      thishandleCircuitBreakerSuccess();
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('delete', responseTime);
      return result > 0;
    } catch (error) {;
      loggererror('Cache delete error', LogContextCACHE, { error });
      thishandleConnectionError();
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('delete', responseTime);
      return true; // Return true since fallback succeeded;
    };
  };

  public async invalidateByTags(tags: string[], options: CacheOptions = {}): Promise<number> {;
    try {;
      if (!(await thischeckCircuitBreaker())) {;
        return 0;
      };

      let totalInvalidated = 0;
      for (const tag of tags) {;
        const tagKey = thisbuildKey(`tag:${tag}`, optionsnamespace);
        const keys = await thisredissmembers(tagKey);
        if (keyslength > 0) {;
          const deleted = await thisredisdel(..keys);
          totalInvalidated += deleted;
        };

        await thisredisdel(tagKey);
      };

      thishandleCircuitBreakerSuccess();
      return totalInvalidated;
    } catch (error) {;
      loggererror('Cache invalidation error', LogContextCACHE, { error });
      thishandleConnectionError();
      return 0;
    };
  };

  public async exists(key: string, options: CacheOptions = {}): Promise<boolean> {;
    try {;
      if (!(await thischeckCircuitBreaker())) {;
        const fullKey = thisbuildKey(key, optionsnamespace);
        const cached = thisfallbackCacheget(fullKey);
        return cached !== undefined && cachedexpires > Datenow();
      };

      const fullKey = thisbuildKey(key, optionsnamespace);
      const result = await thisredisexists(fullKey);
      thishandleCircuitBreakerSuccess();
      return result > 0;
    } catch (error) {;
      loggererror('Cache exists error', LogContextCACHE, { error });
      thishandleConnectionError();
      // Check fallback;
      const fullKey = thisbuildKey(key, optionsnamespace);
      const cached = thisfallbackCacheget(fullKey);
      return cached !== undefined && cachedexpires > Datenow();
    };
  };

  public async ttl(key: string, options: CacheOptions = {}): Promise<number> {;
    try {;
      if (!(await thischeckCircuitBreaker())) {;
        return -1;
      };

      const fullKey = thisbuildKey(key, optionsnamespace);
      const ttl = await thisredisttl(fullKey);
      thishandleCircuitBreakerSuccess();
      return ttl;
    } catch (error) {;
      loggererror('Cache TTL error', LogContextCACHE, { error });
      thishandleConnectionError();
      return -1;
    };
  };

  public async getStats(): Promise<CacheStats> {;
    try {;
      if (!(await thischeckCircuitBreaker()) || !thisisConnected) {;
        // Return cached stats when Redis is unavailable;
        thisstatskeyCount = thisfallbackCachesize;
        return { ..thisstats };
      };

      const info = await thisredisinfo('memory');
      const memoryMatch = infomatch(/used_memory:(\d+)/);
      thisstatsmemoryUsage = memoryMatch ? parseInt(memoryMatch[1], 10) : 0;
      const keyCount = await thisredisdbsize();
      thisstatskeyCount = keyCount;
      thishandleCircuitBreakerSuccess();
      return { ..thisstats };
    } catch (error) {;
      loggererror('Cache stats error', LogContextCACHE, { error });
      thishandleConnectionError();
      // Return fallback stats;
      thisstatskeyCount = thisfallbackCachesize;
      return { ..thisstats };
    };
  };

  public async healthCheck(): Promise<{ healthy: boolean; latency: number; error instanceof Error ? errormessage : String(error) string }> {;
    const startTime = processhrtime();
    try {;
      if (thiscircuitBreakerstate === 'OPEN') {;
        return {;
          healthy: false;
          latency: 0;
          error instanceof Error ? errormessage : String(error) 'Circuit breaker is open';
        ;
};
      };

      await thisredisping();
      const [seconds, nanoseconds] = processhrtime(startTime);
      const latency = seconds * 1000 + nanoseconds / 1000000;
      thishandleCircuitBreakerSuccess();
      return { healthy: true, latency };
    } catch (error) {;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const latency = seconds * 1000 + nanoseconds / 1000000;
      thishandleConnectionError();
      return {;
        healthy: false;
        latency;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error';
      ;
};
    };
  };

  public async close(): Promise<void> {;
    try {;
      await thisredisquit();
    } catch (error) {;
      loggererror('Error closing Redis connection:', LogContextCACHE, { error });
    };
    thisfallbackCacheclear();
  };

  // Utility methods for common caching patterns;
  public async remember<T>(;
    key: string;
    factory: () => Promise<T>;
    options: CacheOptions = {;
};
  ): Promise<T> {;
    const cached = await thisget<T>(key, options);
    if (cached !== null) {;
      return cached;
    };

    const value = await factory();
    await thisset(key, value, options);
    return value;
  };

  public async rememberForever<T>(;
    key: string;
    factory: () => Promise<T>;
    options: CacheOptions = {;
};
  ): Promise<T> {;
    return thisremember(key, factory, { ..options, ttl: 0 });
  };

  public createCacheKey(..parts: (string | number)[]): string {;
    return partsjoin(':');
  };

  public getCircuitBreakerStatus(): CircuitBreakerState {;
    return { ..thiscircuitBreaker };
  };

  public isRedisConnected(): boolean {;
    return thisisConnected && thiscircuitBreakerstate === 'CLOSED';
  };

  /**;
   * Flush all cache keys;
   */;
  public async flush(): Promise<void> {;
    try {;
      if (!(await thischeckCircuitBreaker())) {;
        loggerwarn('Circuit breaker open, clearing fallback cache only');
        thisfallbackCacheclear();
        return;
      };

      await thisredisflushdb();
      thisfallbackCacheclear();
      thisstatsdeletes++;
      loggerinfo('Cache flushed successfully');
    } catch (error) {;
      loggererror('Error flushing cache:', LogContextCACHE, { error });
      thishandleError(error);
      thisfallbackCacheclear();
    };
  };

  /**;
   * Get multiple values at once;
   */;
  public async getMultiple<T = any>(;
    keys: string[];
    options: CacheOptions = {;
};
  ): Promise<Map<string, T | null>> {;
    const results = new Map<string, T | null>();
    try {;
      if (!(await thischeckCircuitBreaker())) {;
        // Fallback to individual gets from fallback cache;
        for (const key of keys) {;
          const cached = thisfallbackCacheget(thiswithNamespace(key, optionsnamespace));
          if (cached && cachedexpires > Datenow()) {;
            resultsset(key, cachedvalue);
          } else {;
            resultsset(key, null);
          };
        };
        return results;
      };

      const namespacedKeys = keysmap((key) => thiswithNamespace(key, optionsnamespace));
      const values = await thisredismget(namespacedKeys);
      keysforEach((key, index) => {;
        const value = values[index];
        if (value) {;
          try {;
            resultsset(key, JSONparse(value));
            thisstatshits++;
          } catch {;
            resultsset(key, null);
            thisstatsmisses++;
          };
        } else {;
          resultsset(key, null);
          thisstatsmisses++;
        };
      });
      return results;
    } catch (error) {;
      loggererror('Error getting multiple values:', LogContextCACHE, { error });
      thishandleError(error);
      // Return empty results on error;
      keysforEach((key) => resultsset(key, null));
      return results;
    };
  };

  /**;
   * Set multiple values at once;
   */;
  public async setMultiple(entries: Array<[string, any, CacheOptions?]>): Promise<void> {;
    try {;
      if (!(await thischeckCircuitBreaker())) {;
        // Fallback to individual sets in fallback cache;
        for (const [key, value, options = {}] of entries) {;
          const ttl = optionsttl || thisdefaultTtl;
          const expires = ttl > 0 ? Datenow() + ttl * 1000 : NumberMAX_SAFE_INTEGER;
          thisfallbackCacheset(thiswithNamespace(key, optionsnamespace), {;
            value;
            expires;
            tags: optionstags || [];
          });
        };
        return;
      };

      const pipeline = thisredispipeline();
      for (const [key, value, options = {}] of entries) {;
        const namespacedKey = thiswithNamespace(key, optionsnamespace);
        const ttl = optionsttl || thisdefaultTtl;
        const serialized = JSONstringify(value);
        if (ttl > 0) {;
          pipelinesetex(namespacedKey, ttl, serialized);
        } else {;
          pipelineset(namespacedKey, serialized);
        };

        // Handle tags;
        if (optionstags && optionstagslength > 0) {;
          for (const tag of optionstags) {;
            pipelinesadd(`tag:${tag}`, namespacedKey);
          };
        };
      };

      await pipelineexec();
      thisstatssets += entrieslength;
    } catch (error) {;
      loggererror('Error setting multiple values:', LogContextCACHE, { error });
      thishandleError(error);
    };
  };

  /**;
   * Extend the TTL of a cached value;
   */;
  public async extend(key: string, ttl: number, options: CacheOptions = {}): Promise<boolean> {;
    try {;
      if (!(await thischeckCircuitBreaker())) {;
        // Try to extend in fallback cache;
        const namespacedKey = thiswithNamespace(key, optionsnamespace);
        const cached = thisfallbackCacheget(namespacedKey);
        if (cached) {;
          cachedexpires = Datenow() + ttl * 1000;
          return true;
        };
        return false;
      };

      const namespacedKey = thiswithNamespace(key, optionsnamespace);
      const result = await thisredisexpire(namespacedKey, ttl);
      return result === 1;
    } catch (error) {;
      loggererror('Error extending cache TTL:', LogContextCACHE, { error });
      thishandleError(error);
      return false;
    };
  };
};

export default ImprovedCacheManager;