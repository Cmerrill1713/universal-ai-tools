/**;
 * Utility for making fetch requests with timeout and proper errorhandling;
 */;

import { logger } from './enhanced-logger';
export interface FetchWithTimeoutOptions extends RequestInit {;
  timeout?: number;
  retries?: number;
  retryDelay?: number;
;
};

/**;
 * Fetch with timeout, retries, and proper errorhandling;
 * @param url - The URL to fetch;
 * @param options - Fetch options including timeout;
 * @returns Promise resolving to Response;
 */;
export async function fetchWithTimeout(;
  url: string;
  options: FetchWithTimeoutOptions = {;
};
): Promise<Response> {;
  const {;
    timeout = 30000, // 30 seconds default;
    retries = 0;
    retryDelay = 1000;
    ..fetchOptions;
  } = options;
  async function attemptFetch(attempt: number): Promise<Response> {;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controllerabort(), timeout);
    try {;
      const response = await fetch(url, {;
        ..fetchOptions;
        signal: controllersignal;
      });
      clearTimeout(timeoutId);
      if (!responseok && attempt < retries) {;
        loggerwarn(`Fetch failed with status ${responsestatus)}, retrying...`, {;
          url;
          attempt: attempt + 1;
          maxRetries: retries;
        });
        await new Promise((resolve) => setTimeout(resolve, retryDelay * (attempt + 1)));
        return attemptFetch(attempt + 1);
      };
  return response;
    } catch (error) {;
      clearTimeout(timeoutId);
      if (errorname === 'AbortError') {;
        throw new Error(`Request timeout after ${timeout}ms: ${url}`);
      };
  if (attempt < retries) {;
        loggerwarn('Fetch failed, retrying...', {;
          url;
          error instanceof Error ? errormessage : String(error) errormessage';
          attempt: attempt + 1;
          maxRetries: retries,);
        });
        await new Promise((resolve) => setTimeout(resolve, retryDelay * (attempt + 1)));
        return attemptFetch(attempt + 1);
      };
  throw error;
    };
  };
  return attemptFetch(0);
};

/**;
 * Fetch JSON with timeout and automatic parsing;
 */;
export async function fetchJsonWithTimeout<T = any>(;
  url: string;
  options: FetchWithTimeoutOptions = {;
};
): Promise<T> {;
  const response = await fetchWithTimeout(url, {;
    ..options;
    headers: {;
      'Content-Type': 'application/json';
      ..optionsheaders;
    ;
};
  });
  return responsejson();
};

/**;
 * Parallel fetch with concurrency control;
 */;
export async function fetchAllWithConcurrency<T>(;
  requests: Array<{ url: string; options?: FetchWithTimeoutOptions }>;
  maxConcurrency = 5;
): Promise<Array<{ data?: T; error instanceof Error ? errormessage : String(error)  Error }>> {;
  const results: Array<{ data?: T; error instanceof Error ? errormessage : String(error)  Error }> = [];
  const executing: Promise<void>[] = [];
  for (const [index, requestof requestsentries()) {;
    const promise = fetchJsonWithTimeout<T>(requesturl', requestoptions);
      then((data) => {;
        results[index] = { data };
      });
      catch((error instanceof Error ? errormessage : String(error)=> {;
        results[index] = { error instanceof Error ? errormessage : String(error)));
      });
    executingpush(promise);
    if (executinglength >= maxConcurrency) {;
      await Promiserace(executing);
      executingsplice();
        executingfindIndex((p) => p === promise);
        1;
      );
    };
  };
  await Promiseall(executing);
  return results;
};
