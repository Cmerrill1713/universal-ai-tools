import { LogContext, logger  } from './enhanced-logger';
import { EventEmitter  } from 'events';
export interface PerformanceMetrics {;
  memoryUsage: NodeJSMemoryUsage;
  cpuUsage: NodeJSCpuUsage;
  uptime: number;
  timestamp: number;
  activeConnections: number;
  requestsPerSecond: number;
  responseTime: number;
  errorRate: number;
  cacheHitRate: number;
  databaseConnections: number;
  queueSize: number;
  heapUsedMB: number;
  heapTotalMB: number;
  externalMB: number;
  rss: number;
  gc?: {;
    count: number;
    duration: number;
  ;
};
};
  export interface PerformanceThresholds {;
  memoryThreshold: number; // MB;
  cpuThreshold: number; // percentage;
  responseTimeThreshold: number; // ms;
  errorRateThreshold: number; // percentage;
  cacheHitRateThreshold: number; // percentage;
};
  export class PerformanceMonitor extends EventEmitter {;
  private metrics: PerformanceMetrics[] = [];
  private requestCount = 0;
  private errorCount = 0;
  private responseTimeSum = 0;
  private cacheHits = 0;
  private cacheRequests = 0;
  private activeConnections = 0;
  private databaseConnections = 0;
  private queueSize = 0;
  private gcCount = 0;
  private gcDuration = 0;
  private startTime = processhrtime();
  private lastCpuUsage = processcpuUsage();
  private monitoringInterval?: NodeJSTimeout;
  private readonly thresholds: PerformanceThresholds = {;
    memoryThreshold: 1024, // 1GB;
    cpuThreshold: 80, // 80%;
    responseTimeThreshold: 2000, // 2 seconds;
    errorRateThreshold: 5, // 5%;
    cacheHitRateThreshold: 80, // 80%;
  };
  constructor() {;
    super();
    thissetupGCMonitoring();
  };
  private setupGCMonitoring(): void {;
    try {;
      // GC monitoring is not available in ES modules currently;
      // Will be implemented when Nodejs provides ES module support for perf_hooks;
    } catch (error) {;
      loggerwarn('GC monitoring not available: ', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error)});';
    };
  };
  public startMonitoring(intervalMs = 10000): void {;
    if (thismonitoringInterval) {;
      clearInterval(thismonitoringInterval);
    };

    thismonitoringInterval = setInterval(() => {;
      const metrics = thiscollectMetrics();
      thismetricspush(metrics);
      thischeckThresholds(metrics);
      thiscleanupOldMetrics();
    }, intervalMs);
    loggerinfo('Performance monitoring started');';
  };
  public stopMonitoring(): void {;
    if (thismonitoringInterval) {;
      clearInterval(thismonitoringInterval);
      thismonitoringInterval = undefined;
    };
    loggerinfo('Performance monitoring stopped');';
  };
  private collectMetrics(): PerformanceMetrics {;
    const memoryUsage = processmemoryUsage();
    const cpuUsage = processcpuUsage(thislastCpuUsage);
    thislastCpuUsage = processcpuUsage();
    const metrics: PerformanceMetrics = {;
      memoryUsage;
      cpuUsage;
      uptime: processuptime();
      timestamp: Datenow();
      activeConnections: thisactiveConnections;
      requestsPerSecond: thiscalculateRequestsPerSecond();
      responseTime: thiscalculateAverageResponseTime();
      errorRate: thiscalculateErrorRate();
      cacheHitRate: thiscalculateCacheHitRate();
      databaseConnections: thisdatabaseConnections;
      queueSize: thisqueueSize;
      heapUsedMB: Mathround(memoryUsageheapUsed / 1024 / 1024);
      heapTotalMB: Mathround(memoryUsageheapTotal / 1024 / 1024);
      externalMB: Mathround(memoryUsageexternal / 1024 / 1024);
      rss: Mathround(memoryUsagerss / 1024 / 1024);
      gc: {;
        count: thisgcCount;
        duration: thisgcDuration;
      ;
};
    };
    return metrics;
  };
  private calculateRequestsPerSecond(): number {;
    const now = Datenow();
    const tenSecondsAgo = now - 10000;
    const recentRequests = thismetricsfilter((m) => mtimestamp > tenSecondsAgo);
    return recentRequestslength > 0 ? thisrequestCount / 10: 0;
  };
  private calculateAverageResponseTime(): number {;
    return thisrequestCount > 0 ? thisresponseTimeSum / thisrequestCount: 0;
  };
  private calculateErrorRate(): number {;
    return thisrequestCount > 0 ? (thiserrorCount / thisrequestCount) * 100: 0;
  };
  private calculateCacheHitRate(): number {;
    return thiscacheRequests > 0 ? (thiscacheHits / thiscacheRequests) * 100: 0;
  };
  private checkThresholds(metrics: PerformanceMetrics): void {;
    // Memory threshold;
    if (metricsheapUsedMB > thisthresholdsmemoryThreshold) {;
      thisemit('threshold-exceeded', {');
        type: 'memory',';
        value: metricsheapUsedMB;
        threshold: thisthresholdsmemoryThreshold;
        message: `Memory usage exceeded, threshold: ${metricsheapUsedMB)}MB > ${thisthresholdsmemoryThreshold}MB`;
      });
    };

    // Response time threshold;
    if (metricsresponseTime > thisthresholdsresponseTimeThreshold) {;
      thisemit('threshold-exceeded', {');
        type: 'response-time',';
        value: metricsresponseTime;
        threshold: thisthresholdsresponseTimeThreshold;
        message: `Response time exceeded, threshold: ${metricsresponseTime)}ms > ${thisthresholdsresponseTimeThreshold}ms`;
      });
    };

    // Error rate threshold;
    if (metricserrorRate > thisthresholdserrorRateThreshold) {;
      thisemit('threshold-exceeded', {');
        type: 'error-rate',';
        value: metricserrorRate;
        threshold: thisthresholdserrorRateThreshold;
        message: `Error rate exceeded, threshold: ${metricserrorRate)}% > ${thisthresholdserrorRateThreshold}%`;
      });
    };

    // Cache hit rate threshold (low is bad);
    if (metricscacheHitRate < thisthresholdscacheHitRateThreshold && thiscacheRequests > 100) {;
      thisemit('threshold-exceeded', {');
        type: 'cache-hit-rate',';
        value: metricscacheHitRate;
        threshold: thisthresholdscacheHitRateThreshold;
        message: `Cache hit rate below, threshold: ${metricscacheHitRate)}% < ${thisthresholdscacheHitRateThreshold}%`;
      });
    };
  };
  private cleanupOldMetrics(): void {;
    const oneHourAgo = Datenow() - 3600000;
    thismetrics = thismetricsfilter((m) => mtimestamp > oneHourAgo);
  };

  // Public methods for updating metrics;
  public recordRequest(responseTime: number, isError = false): void {;
    thisrequestCount++;
    thisresponseTimeSum += responseTime;
    if (isError) {;
      thiserrorCount++;
    ;
};
  };
  public recordCacheAccess(hit: boolean): void {;
    thiscacheRequests++;
    if (hit) {;
      thiscacheHits++;
    ;
};
  };
  public updateConnectionCount(count: number): void {;
    thisactiveConnections = count;
  ;
};
  public updateDatabaseConnections(count: number): void {;
    thisdatabaseConnections = count;
  ;
};
  public updateQueueSize(size: number): void {;
    thisqueueSize = size;
  ;
};
  public getMetrics(): PerformanceMetrics[] {;
    return [..thismetrics];
  };
  public getCurrentMetrics(): PerformanceMetrics {;
    return thiscollectMetrics();
  };
  public getAggregatedMetrics(durationMs = 300000): {;
    averageMemoryUsage: number;
    averageResponseTime: number;
    totalRequests: number;
    errorRate: number;
    cacheHitRate: number;
    peakMemoryUsage: number;
    peakResponseTime: number;
  } {;
    const cutoffTime = Datenow() - durationMs;
    const relevantMetrics = thismetricsfilter((m) => mtimestamp > cutoffTime);
    if (relevantMetricslength === 0) {;
      return {;
        averageMemoryUsage: 0;
        averageResponseTime: 0;
        totalRequests: 0;
        errorRate: 0;
        cacheHitRate: 0;
        peakMemoryUsage: 0;
        peakResponseTime: 0;
      ;
};
    };

    const totalMemory = relevantMetricsreduce((sum, m) => sum + mheapUsedMB, 0);
    const totalResponseTime = relevantMetricsreduce((sum, m) => sum + mresponseTime, 0);
    const peakMemory = Mathmax(..relevantMetricsmap((m) => mheapUsedMB));
    const peakResponseTime = Mathmax(..relevantMetricsmap((m) => mresponseTime));
    return {;
      averageMemoryUsage: totalMemory / relevantMetricslength;
      averageResponseTime: totalResponseTime / relevantMetricslength;
      totalRequests: thisrequestCount;
      errorRate: thiscalculateErrorRate();
      cacheHitRate: thiscalculateCacheHitRate();
      peakMemoryUsage: peakMemory;
      peakResponseTime;
    ;
};
  };
  public forceGarbageCollection(): void {;
    try {;
      if (globalgc) {;
        globalgc();
        loggerinfo('Garbage collection forced');';
      } else {;
        loggerwarn('Garbage collection not available (run with --expose-gc)');';
      };
    } catch (error) {;
      loggererror('Error forcing garbage collection: ', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error)});';
    };
  };
  public generateReport(): string {;
    const current = thisgetCurrentMetrics();
    const aggregated = thisgetAggregatedMetrics();
    return `;
=== Performance Report ===;
Current Memory Usage: ${currentheapUsedMB}MB / ${currentheapTotalMB}MB;
Current Response Time: ${currentresponseTime}ms;
Current Error Rate: ${currenterrorRate}%;
Current Cache Hit Rate: ${currentcacheHitRate}%;
Active Connections: ${currentactiveConnections;
};
Database Connections: ${currentdatabaseConnections;
};
Queue Size: ${currentqueueSize;
};
Uptime: ${Mathround(currentuptime / 3600)}h ${Mathround((currentuptime % 3600) / 60)}m;

=== 5-Minute Averages ===;
Average Memory Usage: ${aggregatedaverageMemoryUsagetoFixed(2)}MB;
Average Response Time: ${aggregatedaverageResponseTimetoFixed(2)}ms;
Peak Memory Usage: ${aggregatedpeakMemoryUsage}MB;
Peak Response Time: ${aggregatedpeakResponseTime}ms;
Total Requests: ${aggregatedtotalRequests;
};
Error Rate: ${aggregatederrorRatetoFixed(2)}%;
Cache Hit Rate: ${aggregatedcacheHitRatetoFixed(2)}%;

=== Garbage Collection ===;
GC Count: ${currentgc?count || 0;
};
Total GC Duration: ${currentgc?duration || 0}ms;
`;
  };
};
  export const performanceMonitor = new PerformanceMonitor();