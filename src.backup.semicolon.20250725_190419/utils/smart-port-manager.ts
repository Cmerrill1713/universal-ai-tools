import { Socket, createServer } from 'net';
import { exec } from 'child_process';
import { promisify } from 'util';
import { mkdir, readFile, writeFile } from 'fs/promises';
import { join } from 'path';
import { homedir } from 'os';
import EventEmitter from 'events';
import { LogContext, logger } from './enhanced-logger';
import { BATCH_SIZE_10', HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500, MAX_ITEMS_100, PERCENT_10, PERCENT_100, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, TIME_10000MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_500MS, ZERO_POINT_EIGHT, ZERO_POINT_FIVE, ZERO_POINT_NINE } from "../utils/common-constants";
const execAsync = promisify(exec);
// Service configuration types;
export interface ServiceConfig {;
  name: string;
  defaultPort: number;
  fallbackPorts: number[];
  healthCheckPath?: string;
  isRequired: boolean;
  serviceType: 'web' | 'database' | 'ai' | 'cache';
  protocol?: 'http' | 'https' | 'tcp';
  timeout?: number;
;
};
  export interface PortStatus {;
  port: number;
  available: boolean;
  service?: string;
  pid?: number;
  lastChecked: Date;
  healthStatus?: 'healthy' | 'unhealthy' | 'unknown';
;
};
  export interface PortConfiguration {;
  services: Record<string, number>;
  lastUpdated: Date;
  conflicts: Array<{ service: string; port: number; resolvedTo: number }>;
};

// Port range definitions;
const PORT_RANGES = {;
  web: { start: 3000, end: 3999, secondary: { start: 8000, end: 8999 } };
  database: { start: 5000, end: 5999, secondary: { start: 6000, end: 6999 } };
  ai: { start: 11000, end: 11999 ;
};
  cache: { start: 6300, end: 6399 ;
};
  development: [3000, 5173, 8080, 9999];
};
// Default service configurations;
const DEFAULT_SERVICES: ServiceConfig[] = [;
  {;
    name: 'universal-ai-tools';
    defaultPort: 9999;
    fallbackPorts: [9998, 9997, 9996];
    healthCheckPath: '/health';
    isRequired: true;
    serviceType: 'web';
    protocol: 'http';
  ;
};
  {;
    name: 'ollama';
    defaultPort: 11434;
    fallbackPorts: [11435, 11436, 11437];
    healthCheckPath: '/api/tags';
    isRequired: false;
    serviceType: 'ai';
    protocol: 'http';
  ;
};
  {;
    name: 'lm-studio';
    defaultPort: 1234;
    fallbackPorts: [1235, 1236, 1237];
    healthCheckPath: '/v1/models';
    isRequired: false;
    serviceType: 'ai';
    protocol: 'http';
  ;
};
  {;
    name: 'supabase';
    defaultPort: 54321;
    fallbackPorts: [54322, 54323, 54324];
    healthCheckPath: '/rest/v1/';
    isRequired: false;
    serviceType: 'database';
    protocol: 'http';
  ;
};
  {;
    name: 'redis';
    defaultPort: 6379;
    fallbackPorts: [6380, 6381, 6382];
    isRequired: false;
    serviceType: 'cache';
    protocol: 'tcp';
  ;
};
  {;
    name: 'frontend';
    defaultPort: 3000;
    fallbackPorts: [5173, 3001, 3002];
    healthCheckPath: '/';
    isRequired: false;
    serviceType: 'web';
    protocol: 'http';
  ;
};
];
export class SmartPortManager extends EventEmitter {;
  private services: Map<string, ServiceConfig>;
  private portCache: Map<number, PortStatus>;
  private configPath: string;
  private monitoringInterval?: NodeJSTimeout;
  private platform: NodeJSPlatform;
  constructor(customServices?: ServiceConfig[]) {;
    super();
    thisservices = new Map();
    thisportCache = new Map();
    thisplatform = processplatform;
    thisconfigPath = join(homedir(), 'universal-ai-tools', 'port-configjson');
    // Initialize with default services;
    const allServices = [..DEFAULT_SERVICES, ...(customServices || [])];
    allServicesforEach((service) => {;
      thisservicesset(servicename, service);
    });
  };

  /**;
   * Find an available port starting from preferred port;
   */;
  async findAvailablePort(;
    preferredPort: number;
    range?: { start: number; end: number ;
};
  ): Promise<number> {;
    // First check the preferred port;
    if (await thischeckPortAvailability(preferredPort)) {;
      return preferredPort;
    };

    // If range is provided, scan within range;
    if (range) {;
      const availablePorts = await thisscanPortRange(rangestart, rangeend);
      if (availablePortslength > 0) {;
        return availablePorts[0];
      };
    };

    // Fallback to finding next available port;
    let port = preferredPort + 1;
    const maxPort = range?end || preferredPort + 100;
    while (port <= maxPort) {;
      if (await thischeckPortAvailability(port)) {;
        return port;
      };
      port++;
    };
    throw new Error(`No available ports found starting from ${preferredPort}`);
  };

  /**;
   * Scan a range of ports and return available ones;
   */;
  async scanPortRange(startPort: number, endPort: number): Promise<number[]> {;
    const availablePorts: number[] = [];
    const batchSize = 50; // Process in batches for performance;
    for (let i = startPort; i <= endPort; i += batchSize) {;
      const batch = [];
      const batchEnd = Mathmin(i + batchSize - 1, endPort);
      for (let port = i; port <= batchEnd; port++) {;
        batchpush();
          thischeckPortAvailability(port)then((available) => {;
            if (available) availablePortspush(port);
          });
        );
      };
      await Promiseall(batch);
    };
    return availablePortssort((a, b) => a - b);
  };

  /**;
   * Check if a specific port is available;
   */;
  async checkPortAvailability(port: number): Promise<boolean> {;
    // Check cache first;
    const cached = thisportCacheget(port);
    if (cached && Datenow() - cachedlastCheckedgetTime() < 5000) {;
      return cachedavailable;
    };

    return new Promise((resolve) => {;
      const server = createServer();
      const onError = () => {;
        serverclose();
        thisupdatePortCache(port, false);
        resolve(false);
      };
      const onListening = () => {;
        serverclose();
        thisupdatePortCache(port, true);
        resolve(true);
      };
      serveronce('error', onError);
      serveronce('listening', onListening);
      serverlisten(port, '0.0.0.0');
    });
  };

  /**;
   * Resolve port conflicts automatically;
   */;
  async resolvePortConflict(service: string, requestedPort: number): Promise<number> {;
    const serviceConfig = thisservicesget(service);
    if (!serviceConfig) {;
      throw new Error(`Unknown service: ${service}`);
    };

    // Check if requested port is available;
    if (await thischeckPortAvailability(requestedPort)) {;
      return requestedPort;
    };

    loggerinfo(;
      `Port ${requestedPort} is unavailable for ${service}, finding alternative...`;
      LogContextSYSTEM;
    );
    // Try fallback ports;
    for (const fallbackPort of serviceConfigfallbackPorts) {;
      if (await thischeckPortAvailability(fallbackPort)) {;
        loggerinfo(`Resolved to fallback port ${fallbackPort)} for ${service}`, LogContextSYSTEM);
        thisemit('portConflictResolved', {;
          service;
          original: requestedPort;
          resolved: fallbackPort;
        });
        return fallbackPort;
      };
    };

    // Try to find port in appropriate range;
    const range = thisgetPortRangeForServiceType(serviceConfigserviceType);
    const availablePort = await thisfindAvailablePort(rangestart, range);
    loggerinfo(`Resolved to port ${availablePort)} for ${service}`, LogContextSYSTEM);
    thisemit('portConflictResolved', {;
      service;
      original: requestedPort;
      resolved: availablePort;
    });
    return availablePort;
  };

  /**;
   * Discover running services and their ports;
   */;
  async discoverServices(): Promise<Map<string, PortStatus>> {;
    const discoveredServices = new Map<string, PortStatus>();
    for (const [serviceName, config] of thisservices) {;
      const status = await thisgetServiceStatus(serviceName);
      if (statushealthStatus === 'healthy') {;
        discoveredServicesset(serviceName, status);
      };
    };

    // Platform-specific service discovery;
    if (thisplatform === 'darwin' || thisplatform === 'linux') {;
      await thisdiscoverUnixServices(discoveredServices);
    } else if (thisplatform === 'win32') {;
      await thisdiscoverWindowsServices(discoveredServices);
    };

    return discoveredServices;
  };

  /**;
   * Get status of a specific service;
   */;
  async getServiceStatus(service: string): Promise<PortStatus> {;
    const config = thisservicesget(service);
    if (!config) {;
      throw new Error(`Unknown service: ${service}`);
    };

    // Check default port first;
    const port = configdefaultPort;
    const available = await thischeckPortAvailability(port);
    if (!available) {;
      // Check if service is actually running on this port;
      const isRunning = await thisvalidateServiceConnection(service, port);
      if (isRunning) {;
        const healthStatus = await thischeckServiceHealth(config, port);
        return {;
          port;
          available: false;
          service;
          lastChecked: new Date();
          healthStatus;
        ;
};
      };
    };

    // Check fallback ports;
    for (const fallbackPort of configfallbackPorts) {;
      const isRunning = await thisvalidateServiceConnection(service, fallbackPort);
      if (isRunning) {;
        const healthStatus = await thischeckServiceHealth(config, fallbackPort);
        return {;
          port: fallbackPort;
          available: false;
          service;
          lastChecked: new Date();
          healthStatus;
        ;
};
      };
    };

    return {;
      port;
      available: true;
      service;
      lastChecked: new Date();
      healthStatus: 'unknown';
    ;
};
  };

  /**;
   * Validate service connection;
   */;
  async validateServiceConnection(service: string, port: number): Promise<boolean> {;
    const config = thisservicesget(service);
    if (!config) return false;
    if (configprotocol === 'http' || configprotocol === 'https') {;
      return thisvalidateHttpConnection(port, confighealthCheckPath);
    } else {;
      return thisvalidateTcpConnection(port);
    };
  };

  /**;
   * Health check all configured ports;
   */;
  async healthCheckAllPorts(): Promise<Map<string, PortStatus>> {;
    const results = new Map<string, PortStatus>();
    const checks = Arrayfrom(thisserviceskeys())map(async (service) => {;
      try {;
        const status = await thisgetServiceStatus(service);
        resultsset(service, status);
      } catch (error) {;
        loggererror(`Health check failed for ${service)}`, LogContextSYSTEM, { error });
        const config = thisservicesget(service)!;
        resultsset(service, {;
          port: configdefaultPort;
          available: false;
          service;
          lastChecked: new Date();
          healthStatus: 'unhealthy';
        });
      };
    });
    await Promiseall(checks);
    return results;
  };

  /**;
   * Get detailed port status;
   */;
  async getPortStatus(port: number): Promise<PortStatus> {;
    const available = await thischeckPortAvailability(port);
    const status: PortStatus = {;
      port;
      available;
      lastChecked: new Date();
    ;
};
    if (!available) {;
      // Try to identify what's using the port;
      const serviceInfo = await thisidentifyPortService(port);
      if (serviceInfo) {;
        statusservice = serviceInfoservice;
        statuspid = serviceInfopid;
      };
    };
;
    return status;
  };

  /**;
   * Monitor port changes in real-time;
   */;
  monitorPortChanges(interval = 30000): void {;
    if (thismonitoringInterval) {;
      clearInterval(thismonitoringInterval);
    };

    thismonitoringInterval = setInterval(async () => {;
      const healthStatus = await thishealthCheckAllPorts();
      for (const [service, status] of healthStatus) {;
        const previousStatus = thisportCacheget(statusport);
        if (previousStatus && previousStatushealthStatus !== statushealthStatus) {;
          thisemit('portStatusChanged', {;
            service;
            port: statusport;
            previousStatus: previousStatushealthStatus;
            newStatus: statushealthStatus;
          });
        };
      };
    }, interval);
    loggerinfo(`Port monitoring started with ${interval)}ms interval`, LogContextSYSTEM);
  };

  /**;
   * Stop monitoring port changes;
   */;
  stopMonitoring(): void {;
    if (thismonitoringInterval) {;
      clearInterval(thismonitoringInterval);
      thismonitoringInterval = undefined;
      loggerinfo('Port monitoring stopped', LogContextSYSTEM);
    };
  };

  /**;
   * Generate optimal port configuration;
   */;
  async generateOptimalPortConfig(): Promise<PortConfiguration> {;
    const config: PortConfiguration = {;
      services: {;
};
      lastUpdated: new Date();
      conflicts: [];
    ;
};
    for (const [serviceName, serviceConfig] of thisservices) {;
      try {;
        const assignedPort = await thisresolvePortConflict(serviceName, serviceConfigdefaultPort);
        configservices[serviceName] = assignedPort;
        if (assignedPort !== serviceConfigdefaultPort) {;
          configconflictspush({;
            service: serviceName;
            port: serviceConfigdefaultPort;
            resolvedTo: assignedPort;
          });
        };
      } catch (error) {;
        loggererror(`Failed to assign port for ${serviceName)}`, LogContextSYSTEM, { error });
        // Use default port anyway for configuration;
        configservices[serviceName] = serviceConfigdefaultPort;
      };
    };

    return config;
  };

  /**;
   * Save port configuration;
   */;
  async savePortConfiguration(config: PortConfiguration): Promise<void> {;
    try {;
      const dir = join(homedir(), 'universal-ai-tools');
      await mkdir(dir, { recursive: true });
      await writeFile(thisconfigPath, JSONstringify(config, null, 2));
      loggerinfo('Port configuration saved', LogContextSYSTEM);
    } catch (error) {;
      loggererror('Failed to save port configuration', LogContextSYSTEM, { error });
      throw error;
    };
  };

  /**;
   * Load saved port configuration;
   */;
  async loadPortConfiguration(): Promise<PortConfiguration | null> {;
    try {;
      const data = await readFile(thisconfigPath, 'utf-8');
      return JSONparse(data);
    } catch {;
      loggerdebug('No existing port configuration found', LogContextSYSTEM);
      return null;
    };
  };

  // Private helper methods;

  private updatePortCache(port: number, available: boolean): void {;
    thisportCacheset(port, {;
      port;
      available;
      lastChecked: new Date();
    });
  };

  private getPortRangeForServiceType(serviceType: string): { start: number; end: number } {;
    switch (serviceType) {;
      case 'web':;
        return PORT_RANGESweb;
      case 'database':;
        return PORT_RANGESdatabase;
      case 'ai':;
        return PORT_RANGESai;
      case 'cache':;
        return PORT_RANGEScache;
      default:;
        return { start: 3000, end: 9999 };
    };
  };
  private async validateHttpConnection(port: number, healthPath?: string): Promise<boolean> {;
    try {;
      const url = `http://localhost:${port}${healthPath || '/'}`;
      const response = await fetch(url, {;
        method: 'GET';
        signal: AbortSignaltimeout(3000);
      });
      return responseok;
    } catch {;
      return false;
    };
  };

  private async validateTcpConnection(port: number): Promise<boolean> {;
    return new Promise((resolve) => {;
      const socket = new Socket();
      const timeout = setTimeout(() => {;
        socketdestroy();
        resolve(false);
      }, 3000);
      socketconnect(port, 'localhost', () => {;
        clearTimeout(timeout);
        socketend();
        resolve(true);
      });
      socketon('error', () => {;
        clearTimeout(timeout);
        resolve(false);
      });
    });
  };

  private async checkServiceHealth(;
    config: ServiceConfig;
    port: number;
  ): Promise<'healthy' | 'unhealthy' | 'unknown'> {;
    try {;
      if (configprotocol === 'http' && confighealthCheckPath) {;
        const url = `http://localhost:${port}${confighealthCheckPath}`;
        // Create custom timeout with AbortController;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controllerabort(), TIME_5000MS);
        try {;
          const response = await fetch(url, {;
            method: 'GET';
            signal: controllersignal;
          });
          clearTimeout(timeoutId);
          return responseok ? 'healthy' : 'unhealthy';
        } catch (fetchError: any) {;
          clearTimeout(timeoutId);
          if (fetchErrorname === 'AbortError') {;
            return 'unhealthy'; // Timeout;
          };
          throw fetchError;
        };
      } else if (configprotocol === 'tcp') {;
        const connected = await thisvalidateTcpConnection(port);
        return connected ? 'healthy' : 'unhealthy';
      };
      return 'unknown';
    } catch {;
      return 'unhealthy';
    };
  };

  private async identifyPortService(;
    port: number;
  ): Promise<{ service: string; pid?: number } | null> {;
    try {;
      if (thisplatform === 'darwin' || thisplatform === 'linux') {;
        const { stdout } = await execAsync(`lsof -i :${port} -P -n | grep LISTEN | head -1`);
        if (stdout) {;
          const parts = stdouttrim()split(/\s+/);
          return {;
            service: parts[0];
            pid: parseInt(parts[1], 10);
          };
        };
      } else if (thisplatform === 'win32') {;
        const { stdout } = await execAsync(`netstat -ano | findstr :${port}`);
        if (stdout) {;
          const parts = stdouttrim()split(/\s+/);
          const pid = parseInt(parts[partslength - 1], 10);
          const { stdout: processInfo } = await execAsync(`tasklist /FI "PID eq ${pid}" /FO CSV`);
          const processName = processInfosplit(',')[0]replace(/"/g, '');
          return {;
            service: processName;
            pid;
          ;
};
        };
      };
    } catch {;
      // Command failed, port might be available;
    };
    return null;
  };

  private async discoverUnixServices(discovered: Map<string, PortStatus>): Promise<void> {;
    try {;
      // Get all listening ports;
      const { stdout } = await execAsync('lsof -i -P -n | grep LISTEN');
      const lines = stdoutsplit('\n')filter((line) => linetrim());
      for (const line of lines) {;
        const parts = linesplit(/\s+/);
        const portMatch = parts[8]?match(/:(\d+)$/);
        if (portMatch) {;
          const port = parseInt(portMatch[1], 10);
          const serviceName = parts[0];
          // Check if this matches any of our configured services;
          for (const [name, config] of thisservices) {;
            if (configdefaultPort === port || configfallbackPortsincludes(port)) {;
              const healthStatus = await thischeckServiceHealth(config, port);
              discoveredset(name, {;
                port;
                available: false;
                service: serviceName;
                pid: parseInt(parts[1], 10);
                lastChecked: new Date();
                healthStatus;
              });
            };
          };
        };
      };
    } catch {;
      // lsof might not be available or might fail;
    };
  };

  private async discoverWindowsServices(discovered: Map<string, PortStatus>): Promise<void> {;
    try {;
      const { stdout } = await execAsync('netstat -ano | findstr LISTENING');
      const lines = stdoutsplit('\n')filter((line) => linetrim());
      for (const line of lines) {;
        const parts = linetrim()split(/\s+/);
        const addressParts = parts[1]?split(':');
        if (addressParts && addressPartslength > 1) {;
          const port = parseInt(addressParts[addressPartslength - 1], 10);
          const pid = parseInt(parts[partslength - 1], 10);
          // Get process name;
          try {;
            const { stdout: processInfo } = await execAsync(`tasklist /FI "PID eq ${pid}" /FO CSV`);
            const processName = processInfosplit('\n')[1]?split(',')[0]?replace(/"/g, '');
            // Check if this matches any of our configured services;
            for (const [name, config] of thisservices) {;
              if (configdefaultPort === port || configfallbackPortsincludes(port)) {;
                const healthStatus = await thischeckServiceHealth(config, port);
                discoveredset(name, {;
                  port;
                  available: false;
                  service: processName || 'unknown';
                  pid;
                  lastChecked: new Date();
                  healthStatus;
                });
              };
            };
          } catch {;
            // Process info might fail;
          };
        };
      };
    } catch {;
      // netstat might fail;
    };
  };
};

// Export singleton instance for convenience;
export const portManager = new SmartPortManager();
// Export utility functions;
export async function quickPortCheck(port: number): Promise<boolean> {;
  return portManagercheckPortAvailability(port);
};

export async function findFreePort(startPort = 3000): Promise<number> {;
  return portManagerfindAvailablePort(startPort);
};

export async function autoConfigurePorts(): Promise<PortConfiguration> {;
  const config = await portManagergenerateOptimalPortConfig();
  await portManagersavePortConfiguration(config);
  return config;
};
