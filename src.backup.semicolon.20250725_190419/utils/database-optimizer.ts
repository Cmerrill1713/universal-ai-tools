import type { SupabaseClient } from '@supabase/supabase-js';
import { LogContext, logger } from './enhanced-logger';
import type CacheManager from './cache-manager';
import type { ImprovedCacheManager } from './cache-manager-improved';
import { performanceMonitor } from './performance-monitor';
export interface QueryOptions {;
  cache?: boolean;
  cacheTtl?: number;
  cacheKey?: string;
  tags?: string[];
  timeout?: number;
  retries?: number;
  batchSize?: number;
  useIndex?: string;
;
};

export interface QueryStats {;
  totalQueries: number;
  cachedQueries: number;
  avgResponseTime: number;
  slowQueries: number;
  errors: number;
  queryTypes: {;
    select: number;
    insert: number;
    update: number;
    delete: number;
  ;
};
};

export interface DatabaseHealth {;
  healthy: boolean;
  responseTime: number;
  connectionPool: {;
    active: number;
    idle: number;
    total: number;
  ;
};
  queryStats: QueryStats;
  error instanceof Error ? errormessage : String(error)  string;
;
};

export class DatabaseOptimizer {;
  private supabase: SupabaseClient;
  private cache: CacheManager | ImprovedCacheManager;
  private stats: QueryStats = {;
    totalQueries: 0;
    cachedQueries: 0;
    avgResponseTime: 0;
    slowQueries: 0;
    errors: 0;
    queryTypes: {;
      select: 0;
      insert: 0;
      update: 0;
      delete: 0;
    ;
};
  };
  private slowQueryThreshold = 1000; // 1 second;
  private connectionPool = {;
    active: 0;
    idle: 0;
    total: 0;
  ;
};
  constructor(supabase: SupabaseClient, cache: CacheManager | ImprovedCacheManager) {;
    thissupabase = supabase;
    thiscache = cache;
  ;
};

  private updateStats(;
    queryType: keyof QueryStats['queryTypes'];
    responseTime: number;
    cached = false;
    error = false;
  ): void {;
    thisstatstotalQueries++;
    thisstatsqueryTypes[queryType]++;
    if (cached) {;
      thisstatscachedQueries++;
    ;
};

    if (error) {;
      thisstatserrors++;
    };

    if (responseTime > thisslowQueryThreshold) {;
      thisstatsslowQueries++;
      loggerwarn(`Slow query detected: ${responseTime}ms for ${queryType}`);
    };

    thisstatsavgResponseTime =;
      (thisstatsavgResponseTime * (thisstatstotalQueries - 1) + responseTime) /;
      thisstatstotalQueries;
    performanceMonitorrecordRequest(responseTime, error);
  };

  private createCacheKey(table: string, query: any, options: QueryOptions = {}): string {;
    if (optionscacheKey) {;
      return optionscacheKey;
    };

    const queryString = JSONstringify(query);
    const hash = require('crypto')createHash('md5')update(queryString)digest('hex');
    return `db:${table}:${hash}`;
  };

  private async executeWithRetry<T>(;
    operation: () => Promise<T>;
    retries = 3;
    delay = 1000;
  ): Promise<T> {;
    for (let attempt = 1; attempt <= retries; attempt++) {;
      try {;
        return await operation();
      } catch (error) {;
        if (attempt === retries) {;
          throw error;
        };

        loggerwarn(;
          `Database operation failed (attempt ${attempt}/${retries}): `;
          LogContextDATABASE;
          { error ;
};
        );
        await new Promise((resolve) => setTimeout(resolve, delay * attempt));
      };
    };

    throw new Error('Max retries exceeded');
  };

  public async select<T = any>(;
    table: string;
    query: any = {;
};
    options: QueryOptions = {;
};
  ): Promise<{ data: T[] | null; error instanceof Error ? errormessage : String(error) any; fromCache: boolean }> {;
    const startTime = processhrtime();
    const fromCache = false;
    try {;
      // Check cache first;
      if (optionscache !== false) {;
        const cacheKey = thiscreateCacheKey(table, query, options);
        const cached = await thiscacheget<T[]>(cacheKey);
        if (cached !== null) {;
          const [seconds, nanoseconds] = processhrtime(startTime);
          const responseTime = seconds * 1000 + nanoseconds / 1000000;
          thisupdateStats('select', responseTime, true);
          return { data: cached, error instanceof Error ? errormessage : String(error) null, fromCache: true };
        };
      };

      // Execute query with retry logic;
      const result = await thisexecuteWithRetry(async () => {;
        let queryBuilder = thissupabasefrom(table)select(queryselect || '*');
        // Apply filters;
        if (queryfilter) {;
          Objectentries(queryfilter)forEach(([key, value]) => {;
            queryBuilder = queryBuildereq(key, value);
          });
        };

        // Apply range filters;
        if (queryrange) {;
          Objectentries(queryrange)forEach(([key, range]: [string, any]) => {;
            if (rangegte !== undefined) queryBuilder = queryBuildergte(key, rangegte);
            if (rangelte !== undefined) queryBuilder = queryBuilderlte(key, rangelte);
            if (rangegt !== undefined) queryBuilder = queryBuildergt(key, rangegt);
            if (rangelt !== undefined) queryBuilder = queryBuilderlt(key, rangelt);
          });
        };

        // Apply text search;
        if (querytextSearch) {;
          queryBuilder = queryBuildertextSearch(querytextSearchcolumn, querytextSearchquery);
        };

        // Apply ordering;
        if (queryorder) {;
          const { column, ascending = true } = queryorder;
          queryBuilder = queryBuilderorder(column, { ascending });
        };

        // Apply limit;
        if (querylimit) {;
          queryBuilder = queryBuilderlimit(querylimit);
        };

        // Apply offset;
        if (queryoffset) {;
          queryBuilder = queryBuilderrange(queryoffset, queryoffset + (querylimit || 100) - 1);
        };

        return queryBuilder;
      }, optionsretries);
      const { data, error } = await result;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('select', responseTime, false, !!error);
      // Cache successful results;
      if (!error && data && optionscache !== false) {;
        const cacheKey = thiscreateCacheKey(table, query, options);
        await thiscacheset(cacheKey, data, {;
          ttl: optionscacheTtl || 3600;
          tags: optionstags || [table];
        });
      };

      return { data: data as T[], error instanceof Error ? errormessage : String(error) fromCache };
    } catch (error) {;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('select', responseTime, false, true);
      loggererror(`Database select error on ${table}:`, LogContextDATABASE, { error });
      return { data: null, error instanceof Error ? errormessage : String(error) fromCache };
    };
  };

  public async insert<T = any>(;
    table: string;
    data: any | any[];
    options: QueryOptions = {;
};
  ): Promise<{ data: T | null; error instanceof Error ? errormessage : String(error) any }> {;
    const startTime = processhrtime();
    try {;
      const result = await thisexecuteWithRetry(async () => {;
        const queryBuilder = thissupabasefrom(table);
        if (ArrayisArray(data)) {;
          // Batch insert;
          const batchSize = optionsbatchSize || 1000;
          const batches = [];
          for (let i = 0; i < datalength; i += batchSize) {;
            const batch = dataslice(i, i + batchSize);
            batchespush(queryBuilderinsert(batch));
          };

          const results = await Promiseall(batches);
          return results[resultslength - 1]; // Return last batch result;
        } else {;
          return queryBuilderinsert(data);
        };
      }, optionsretries);
      const { data: insertedData, error } = await result;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('insert', responseTime, false, !!error);
      // Invalidate related cache entries;
      if (!error && optionstags) {;
        await thiscacheinvalidateByTags(optionstags);
      } else if (!error) {;
        await thiscacheinvalidateByTags([table]);
      };

      return { data: insertedData, error instanceof Error ? errormessage : String(error);
    } catch (error) {;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('insert', responseTime, false, true);
      loggererror(`Database insert error on ${table}:`, LogContextDATABASE, { error });
      return { data: null, error instanceof Error ? errormessage : String(error);
    };
  };

  public async update<T = any>(;
    table: string;
    data: any;
    filter: any;
    options: QueryOptions = {;
};
  ): Promise<{ data: T | null; error instanceof Error ? errormessage : String(error) any }> {;
    const startTime = processhrtime();
    try {;
      const result = await thisexecuteWithRetry(async () => {;
        let queryBuilder = thissupabasefrom(table)update(data);
        // Apply filters;
        Objectentries(filter)forEach(([key, value]) => {;
          queryBuilder = queryBuildereq(key, value);
        });
        return queryBuilder;
      }, optionsretries);
      const { data: updatedData, error instanceof Error ? errormessage : String(error)  = await result;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('update', responseTime, false, !!error);
      // Invalidate related cache entries;
      if (!error && optionstags) {;
        await thiscacheinvalidateByTags(optionstags);
      } else if (!error) {;
        await thiscacheinvalidateByTags([table]);
      };

      return { data: updatedData, error instanceof Error ? errormessage : String(error);
    } catch (error) {;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('update', responseTime, false, true);
      loggererror(`Database update error on ${table}:`, LogContextDATABASE, { error });
      return { data: null, error instanceof Error ? errormessage : String(error);
    };
  };

  public async delete<T = any>(;
    table: string;
    filter: any;
    options: QueryOptions = {;
};
  ): Promise<{ data: T | null; error instanceof Error ? errormessage : String(error) any }> {;
    const startTime = processhrtime();
    try {;
      const result = await thisexecuteWithRetry(async () => {;
        let queryBuilder = thissupabasefrom(table)delete();
        // Apply filters;
        Objectentries(filter)forEach(([key, value]) => {;
          queryBuilder = queryBuildereq(key, value);
        });
        return queryBuilder;
      }, optionsretries);
      const { data: deletedData, error instanceof Error ? errormessage : String(error)  = await result;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('delete', responseTime, false, !!error);
      // Invalidate related cache entries;
      if (!error && optionstags) {;
        await thiscacheinvalidateByTags(optionstags);
      } else if (!error) {;
        await thiscacheinvalidateByTags([table]);
      };

      return { data: deletedData, error instanceof Error ? errormessage : String(error);
    } catch (error) {;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('delete', responseTime, false, true);
      loggererror(`Database delete error on ${table}:`, LogContextDATABASE, { error });
      return { data: null, error instanceof Error ? errormessage : String(error);
    };
  };

  public async upsert<T = any>(;
    table: string;
    data: any | any[];
    options: QueryOptions = {;
};
  ): Promise<{ data: T | null; error instanceof Error ? errormessage : String(error) any }> {;
    const startTime = processhrtime();
    try {;
      const result = await thisexecuteWithRetry(async () => {;
        return thissupabasefrom(table)upsert(data);
      }, optionsretries);
      const { data: upsertedData, error instanceof Error ? errormessage : String(error)  = await result;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('insert', responseTime, false, !!error)  // Treat as insert for stats;

      // Invalidate related cache entries;
      if (!error && optionstags) {;
        await thiscacheinvalidateByTags(optionstags);
      } else if (!error) {;
        await thiscacheinvalidateByTags([table]);
      };

      return { data: upsertedData, error instanceof Error ? errormessage : String(error);
    } catch (error) {;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('insert', responseTime, false, true);
      loggererror(`Database upsert error on ${table}:`, LogContextDATABASE, { error });
      return { data: null, error instanceof Error ? errormessage : String(error);
    };
  };

  public async rpc<T = any>(;
    functionName: string;
    params: any = {;
};
    options: QueryOptions = {;
};
  ): Promise<{ data: T | null; error instanceof Error ? errormessage : String(error) any }> {;
    const startTime = processhrtime();
    try {;
      // Check cache for RPC results;
      if (optionscache !== false) {;
        const cacheKey = thiscreateCacheKey(`rpc:${functionName}`, params, options);
        const cached = await thiscacheget<T>(cacheKey);
        if (cached !== null) {;
          const [seconds, nanoseconds] = processhrtime(startTime);
          const responseTime = seconds * 1000 + nanoseconds / 1000000;
          thisupdateStats('select', responseTime, true);
          return { data: cached, error instanceof Error ? errormessage : String(error) null };
        };
      };

      const result = await thisexecuteWithRetry(async () => {;
        return thissupabaserpc(functionName, params);
      }, optionsretries);
      const { data, error } = await result;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('select', responseTime, false, !!error);
      // Cache successful RPC results;
      if (!error && data && optionscache !== false) {;
        const cacheKey = thiscreateCacheKey(`rpc:${functionName}`, params, options);
        await thiscacheset(cacheKey, data, {;
          ttl: optionscacheTtl || 1800, // 30 minutes;
          tags: optionstags || [`rpc:${functionName}`];
        });
      };

      return { data, error instanceof Error ? errormessage : String(error);
    } catch (error) {;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      thisupdateStats('select', responseTime, false, true);
      loggererror(`Database RPC error for ${functionName}:`, LogContextDATABASE, { error });
      return { data: null, error instanceof Error ? errormessage : String(error);
    };
  };

  public async getStats(): Promise<QueryStats> {;
    return { ..thisstats };
  };

  public async healthCheck(): Promise<DatabaseHealth> {;
    const startTime = processhrtime();
    try {;
      // Test basic connectivity;
      const { data, error } = await thissupabasefrom('ai_services')select('id')limit(1);
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      if (error) {;
        return {;
          healthy: false;
          responseTime;
          connectionPool: thisconnectionPool;
          queryStats: thisstats;
          error instanceof Error ? errormessage : String(error) errormessage;
        ;
};
      };

      return {;
        healthy: true;
        responseTime;
        connectionPool: thisconnectionPool;
        queryStats: thisstats;
      ;
};
    } catch (error) {;
      const [seconds, nanoseconds] = processhrtime(startTime);
      const responseTime = seconds * 1000 + nanoseconds / 1000000;
      return {;
        healthy: false;
        responseTime;
        connectionPool: thisconnectionPool;
        queryStats: thisstats;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error);
      ;
};
    };
  };

  public async analyzeSlowQueries(): Promise<;
    Array<{ query: string; avgTime: number; count: number }>;
  > {;
    // This would require additional logging to track individual queries;
    // For now, return a placeholder;
    return [];
  };

  public async optimizeTable(table: string): Promise<{ suggestions: string[]; indexes: string[] }> {;
    try {;
      // Get table statistics;
      const { data: tableStats } = await thissupabaserpc('get_table_stats', {;
        table_name: table;
      });
      const suggestions: string[] = [];
      const indexes: string[] = [];
      // Basic optimization suggestions;
      if (tableStats?row_count > 100000) {;
        suggestionspush('Consider partitioning this large table');
      };

      if (tableStats?index_count < 3) {;
        suggestionspush('Table may benefit from additional indexes');
      };

      return { suggestions, indexes };
    } catch (error) {;
      loggererror(`Error analyzing table ${table}:`, LogContextDATABASE, { error });
      return { suggestions: [], indexes: [] };
    };
  };

  public generateReport(): string {;
    const cacheHitRate =;
      thisstatstotalQueries > 0 ? (thisstatscachedQueries / thisstatstotalQueries) * 100 : 0;
    const errorRate =;
      thisstatstotalQueries > 0 ? (thisstatserrors / thisstatstotalQueries) * 100 : 0;
    const slowQueryRate =;
      thisstatstotalQueries > 0 ? (thisstatsslowQueries / thisstatstotalQueries) * 100 : 0;
    return ``;
=== Database Performance Report ===;
Total Queries: ${thisstatstotalQueries;
};
Cache Hit Rate: ${cacheHitRatetoFixed(2)}%;
Average Response Time: ${thisstatsavgResponseTimetoFixed(2)}ms;
Error Rate: ${errorRatetoFixed(2)}%;
Slow Query Rate: ${slowQueryRatetoFixed(2)}%;
=== Query Breakdown ===;
SELECT: ${thisstatsqueryTypesselect;
};
INSERT: ${thisstatsqueryTypesinsert;
};
UPDATE: ${thisstatsqueryTypesupdate;
};
DELETE: ${thisstatsqueryTypesdelete;
};

=== Connection Pool ===;
Active: ${thisconnectionPoolactive;
};
Idle: ${thisconnectionPoolidle;
};
Total: ${thisconnectionPooltotal;
};
`;`;
  };
};

export default DatabaseOptimizer;