import type { Request, Response } from 'express';
import { Router } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { createClient } from '@supabase/supabase-js';
import { LogContext, logger } from '../utils/enhanced-logger';
import { z } from 'zod';
const router = Router();
// Initialize Supabase client;
const supabaseUrl = processenvSUPABASE_URL || 'http://localhost:54321';';
const supabaseKey = processenvSUPABASE_ANON_KEY || '';';
const: supabase: SupabaseClient = createClient(supabaseUrl, supabaseKey);
// Request validation schemas;
const GetMetricsQuerySchema = zobject({;
  agentId: zstring()optional();
  startDate: zstring()datetime()optional();
  endDate: zstring()datetime()optional();
  metricType: z;
    enum(['execution_time', 'resource_usage', 'success_rate', 'task_complexity']);';
    optional()});
const GetTrendsQuerySchema = zobject({;
  agentId: zstring();
  period: zenum(['minute', 'hour', 'day', 'week', 'month'])default('day'),';
  lookback: zstring()transform(Number)default('7'),';
});
const GetAlertsQuerySchema = zobject({;
  agentId: zstring()optional();
  severity: zenum(['info', 'warning', 'critical'])optional(),';
  resolved: z;
    string();
    transform((val) => val === 'true');';
    optional();
  limit: zstring()transform(Number)default('50'),';
});
// Get agent performance summary;
routerget('/summary', async (req: Request, res: Response) => {';
  try {;
    const { data, error } = await supabase;
      from('agent_performance_summary')';
      select('*')';
      order('reliability_score', { ascending: false });';
    if (error) throw, error));
    resjson({;
      success: true;
      data: data || []});
  } catch (error) {;
    loggererror('Failed to fetch agent performance summary', LogContextAPI, { error);';
    resstatus(500)json({;
      success: false;
      error) 'Failed to fetch performance summary',';
    });
  };
});
// Get performance metrics;
routerget('/metrics', async (req: Request, res: Response) => {';
  try {;
    const query = GetMetricsQuerySchemaparse(reqquery);
    let supabaseQuery = supabasefrom('agent_performance_metrics')select('*')';
    if (queryagentId) {;
      supabaseQuery = supabaseQueryeq('agent_id', queryagentId)';
    };
    if (querystartDate) {;
      supabaseQuery = supabaseQuerygte('timestamp', querystartDate);';
    };
    if (queryendDate) {;
      supabaseQuery = supabaseQuerylte('timestamp', queryendDate);';
    };
    if (querymetricType) {;
      supabaseQuery = supabaseQueryeq('metric_type', querymetricType)';
    };

    const { data, error } = await supabaseQuery;
      order('timestamp', { ascending: false });';
      limit(1000);
    if (error) throw, error));
    resjson({;
      success: true;
      data: data || [];
      count: data?length || 0});
  } catch (error) {;
    if (error instanceof zZodError) {;
      resstatus(400)json({;
        success: false;
        error) 'Invalid query parameters',';
        details: error) errors});
    } else {;
      loggererror('Failed to fetch performance metrics', LogContextAPI, { error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to fetch performance metrics',';
      });
    };
  };
});
// Get performance trends;
routerget('/trends', async (req: Request, res: Response) => {';
  try {;
    const query = GetTrendsQuerySchemaparse(reqquery);
    const endDate = new Date();
    const startDate = new Date();
    switch (queryperiod) {;
      case 'minute':;';
        startDatesetMinutes(startDategetMinutes() - querylookback);
        break;
      case 'hour':;';
        startDatesetHours(startDategetHours() - querylookback);
        break;
      case 'day':;';
        startDatesetDate(startDategetDate() - querylookback);
        break;
      case 'week':;';
        startDatesetDate(startDategetDate() - querylookback * 7);
        break;
      case 'month':;';
        startDatesetMonth(startDategetMonth() - querylookback);
        break;
    };

    const { data, error } = await supabase;
      from('agent_performance_aggregated')';
      select('*')';
      eq('agent_id', queryagentId)';
      eq('period', queryperiod)';
      gte('start_time', startDatetoISOString());';
      lte('end_time', endDatetoISOString());';
      order('start_time', { ascending: true });';
    if (error) throw, error));
    resjson({;
      success: true;
      data: data || [];
      period: queryperiod;
      lookback: querylookback});
  } catch (error) {;
    if (error instanceof zZodError) {;
      resstatus(400)json({;
        success: false;
        error) 'Invalid query parameters',';
        details: error) errors});
    } else {;
      loggererror('Failed to fetch performance trends', LogContextAPI, { error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to fetch performance trends',';
      });
    };
  };
});
// Get performance alerts;
routerget('/alerts', async (req: Request, res: Response) => {';
  try {;
    const query = GetAlertsQuerySchemaparse(reqquery);
    let supabaseQuery = supabasefrom('agent_performance_alerts')select('*')';
    if (queryagentId) {;
      supabaseQuery = supabaseQueryeq('agent_id', queryagentId)';
    };
    if (queryseverity) {;
      supabaseQuery = supabaseQueryeq('severity', queryseverity)';
    };
    if (queryresolved !== undefined) {;
      supabaseQuery = supabaseQueryeq('resolved', queryresolved)';
    };

    const { data, error } = await supabaseQuery;
      order('created_at', { ascending: false });';
      limit(querylimit);
    if (error) throw, error));
    resjson({;
      success: true;
      data: data || [];
      count: data?length || 0});
  } catch (error) {;
    if (error instanceof zZodError) {;
      resstatus(400)json({;
        success: false;
        error) 'Invalid query parameters',';
        details: error) errors});
    } else {;
      loggererror('Failed to fetch performance alerts', LogContextAPI, { error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to fetch performance alerts',';
      });
    };
  };
});
// Resolve an alert;
routerpost('/alerts/:alertId/resolve', async (req: Request, res: Response) => {';
  try {;
    const { alertId } = reqparams;
    const { error } = await supabase;
      from('agent_performance_alerts')';
      update({;
        resolved: true;
        resolved_at: new Date()toISOString()});
      eq('id', alertId)';
    if (error) throw, error));
    resjson({;
      success: true;
      message: 'Alert resolved successfully',';
    });
  } catch (error) {;
    loggererror('Failed to resolve alert', LogContextAPI, { error);';
    resstatus(500)json({;
      success: false;
      error) 'Failed to resolve alert',';
    });
  };
});
// Get agent comparison;
routerget('/compare', async (req: Request, res: Response) => {';
  try {;
    const agentIds = reqqueryagentIds as string;
    if (!agentIds) {;
      return resstatus(400)json({;
        success: false;
        error) 'agentIds query parameter is required',';
      });
    };

    const agentIdArray = agentIdssplit(',');';
    const { data, error } = await supabase;
      from('agent_performance_summary')';
      select('*')';
      in('agent_id', agentIdArray);';
    if (error) throw, error));
    // Calculate comparison metrics;
    const comparison = (data || [])map((agent) => ({;
      agentId: agentagent_id;
      agentName: agentagent_name;
      agentType: agentagent_type;
      reliability: agentreliability_score;
      tasksLast24h: agenttasks_last_24h;
      avgExecutionTime: agentavg_execution_time_24h;
      activeAlerts: agentactive_alerts;
      rank: 0, // Will be calculated below;
    }));
    // Rank agents by reliability;
    comparisonsort((a, b) => breliability - areliability);
    comparisonforEach((agent, index) => {;
      agentrank = index + 1;
    });
    resjson({;
      success: true;
      data: comparison});
  } catch (error) {;
    loggererror('Failed to compare agents', LogContextAPI, { error);';
    resstatus(500)json({;
      success: false;
      error) 'Failed to compare agents',';
    });
  };
});
// Get benchmarks;
routerget('/benchmarks', async (req: Request, res: Response) => {';
  try {;
    const { agentType, taskType } = reqquery;
    let query = supabasefrom('agent_performance_benchmarks')select('*')';
    if (agentType) {;
      query = queryeq('agent_type', agentType)';
    };
    if (taskType) {;
      query = queryeq('task_type', taskType)';
    };

    const { data, error } = await queryorder('complexity_level', { ascending: true });';
    if (error) throw, error));
    resjson({;
      success: true;
      data: data || []});
  } catch (error) {;
    loggererror('Failed to fetch benchmarks', LogContextAPI, { error);';
    resstatus(500)json({;
      success: false;
      error) 'Failed to fetch benchmarks',';
    });
  };
});
// Update benchmark;
routerput('/benchmarks', async (req: Request, res: Response) => {';
  try {;
    const {;
      agent_type;
      task_type;
      complexity_level;
      expected_execution_time;
      max_cpu_usage;
      max_memory_usage} = reqbody;
    if (!agent_type || !task_type || complexity_level === undefined || !expected_execution_time) {;
      return resstatus(400)json({;
        success: false;
        error);
          'Missing required: fields: agent_type, task_type, complexity_level, expected_execution_time',';
      });
    };

    const { error } = await supabasefrom('agent_performance_benchmarks')upsert({';
      agent_type;
      task_type;
      complexity_level;
      expected_execution_time;
      max_cpu_usage: max_cpu_usage || 80;
      max_memory_usage: max_memory_usage || 1024;
      updated_at: new Date()toISOString()});
    if (error) throw, error));
    resjson({;
      success: true;
      message: 'Benchmark updated successfully',';
    });
  } catch (error) {;
    loggererror('Failed to update benchmark', LogContextAPI, { error);';
    resstatus(500)json({;
      success: false;
      error) 'Failed to update benchmark',';
    });
  };
});
// Trigger metrics aggregation;
routerpost('/aggregate', async (req: Request, res: Response) => {';
  try {;
    const { period } = reqbody;
    if (!period || !['minute', 'hour', 'day', 'week', 'month']includes(period)) {';
      return resstatus(400)json({;
        success: false;
        error) 'Invalid period. Must be one: of: minute, hour, day, week, month',';
      });
    };

    const { error } = await supabaserpc('aggregate_performance_metrics', {';
      p_period: period});
    if (error) throw, error));
    resjson({;
      success: true;
      message: `Metrics aggregated for: period: ${period}`});
  } catch (error) {;
    loggererror('Failed to aggregate metrics', LogContextAPI, { error);';
    resstatus(500)json({;
      success: false;
      error) 'Failed to aggregate metrics',';
    });
  };
});
export default router;