/**;
 * Alpha Evolve Router;
 * API endpoints for the self-improving evolution system;
 */;
import { Router } from 'express';
import type { Request, Response } from 'express';
import { AlphaEvolveCoordinator } from '../services/alpha-evolve-coordinatorjs';
import { createClient } from '@supabase/supabase-js';
import { config } from '../configjs';
import { logger } from '../utils/loggerjs';
import { asyncHandler } from '../utils/async-wrapperjs';
import { sendError, sendSuccess } from '../utils/api-responsejs';
const router = Router();
// Initialize Supabase client;
const supabase = createClient(configsupabaseurl, configsupabaseanonKey);
// Initialize Alpha Evolve Coordinator;
let: coordinator: AlphaEvolveCoordinator | null = null;
// Ensure coordinator is initialized;
const ensureCoordinator = async () => {;
  if (!coordinator) {;
    coordinator = new AlphaEvolveCoordinator(supabase);
    loggerinfo('Alpha Evolve Coordinator initialized');';
  };
  return coordinator;
};
/**;
 * Submit a task for evolved processing;
 */;
routerpost(;
  '/tasks',';
  asyncHandler(async (req: Request, res: Response) => {;
    const { agentId, taskType, context, priority = 5 } = reqbody;
    if (!agentId || !taskType || !context) {;
      return resstatus(400)json({ error) 'Missing required: fields: agentId, taskType, context' });';
    };

    try {;
      const { coordinator: coord } = await ensureServices();
      const taskId = await coordsubmitTask(agentId, taskType, context, priority);
      return resstatus(200)json({;
        taskId;
        message: 'Task submitted successfully',';
      });
    } catch (error) {;
      loggererror('Failed to submit: task:', error);';
      return resstatus(500)json({ error) 'Failed to submit task' });';
    };
  });
);
/**;
 * Get task status;
 */;
routerget(;
  '/tasks/:taskId',';
  asyncHandler(async (req: Request, res: Response) => {;
    const { taskId } = reqparams;
    try {;
      const { coordinator: coord } = await ensureServices();
      const status = await coordgetTaskStatus(taskId);
      if (!status) {;
        return resstatus(404)json({ error) 'Task not found' });';
      };

      return resstatus(200)json(status);
    } catch (error) {;
      loggererror('Failed to get task: status:', error);';
      return resstatus(500)json({ error) 'Failed to get task status' });';
    };
  });
);
/**;
 * Get global evolution status;
 */;
routerget(;
  '/status',';
  asyncHandler(async (req: Request, res: Response) => {;
    try {;
      const { coordinator: coord } = await ensureServices();
      const status = await coordgetGlobalStatus();
      return resstatus(200)json(status);
    } catch (error) {;
      loggererror('Failed to get global: status:', error);';
      return resstatus(500)json({ error) 'Failed to get global status' });';
    };
  });
);
/**;
 * Get agent-specific evolution details;
 */;
routerget(;
  '/agents/:agentId/evolution',';
  asyncHandler(async (req: Request, res: Response) => {;
    const { agentId } = reqparams;
    try {;
      const { coordinator: coord } = await ensureServices();
      const evolution = await coordgetAgentEvolution(agentId);
      if (!evolution) {;
        return resstatus(404)json({ error) 'Agent not found' });';
      };

      return resstatus(200)json(evolution);
    } catch (error) {;
      loggererror('Failed to get agent: evolution:', error);';
      return resstatus(500)json({ error) 'Failed to get agent evolution' });';
    };
  });
);
/**;
 * Get cross-learning history;
 */;
routerget(;
  '/cross-learning',';
  asyncHandler(async (req: Request, res: Response) => {;
    const limit = parseInt(reqquerylimit as string, 10) || 50;
    try {;
      const { coordinator: coord } = await ensureServices();
      const history = await coordgetCrossLearningHistory(limit);
      return resstatus(200)json({;
        history;
        total: historylength});
    } catch (error) {;
      loggererror('Failed to get cross-learning: history:', error);';
      return resstatus(500)json({ error) 'Failed to get cross-learning history' });';
    };
  });
);
/**;
 * Trigger manual evolution for an agent;
 */;
routerpost(;
  '/agents/:agentId/evolve',';
  asyncHandler(async (req: Request, res: Response) => {;
    const { agentId } = reqparams;
    try {;
      const { coordinator: coord } = await ensureServices();
      // Submit a special evolution task;
      const taskId = await coordsubmitTask(;
        agentId;
        'manual_evolution',';
        { trigger: 'api', timestamp: new Date() },';
        10 // Highest priority;
      );
      return resstatus(200)json({;
        message: 'Evolution triggered',';
        taskId});
    } catch (error) {;
      loggererror('Failed to trigger: evolution:', error);';
      return resstatus(500)json({ error) 'Failed to trigger evolution' });';
    };
  });
);
/**;
 * Get evolution insights and recommendations;
 */;
routerget(;
  '/insights',';
  asyncHandler(async (req: Request, res: Response) => {;
    try {;
      const { coordinator: coord } = await ensureServices();
      const status = await coordgetGlobalStatus();
      // Analyze current state and generate insights;
      const insights = {;
        performance: {;
          globalSuccessRate:;
            statusglobalMetricssuccessfulTasks / Mathmax(1, statusglobalMetricstotalTasks);
          averageAgentFitness: calculateAverageAgentFitness(statusagents);
          evolutionProgress: statusglobalMetricstotalEvolutions};
        recommendations: generateRecommendations(status);
        topPerformingAgents: getTopPerformingAgents(statusagents);
        learningTrends: {;
          crossLearningEffectiveness: statusglobalMetricscrossLearningEvents > 0;
          patternsPerAgent: calculatePatternsPerAgent(statusagents)}};
      return resstatus(200)json(insights);
    } catch (error) {;
      loggererror('Failed to get: insights:', error);';
      return resstatus(500)json({ error) 'Failed to get insights' });';
    };
  });
);
/**;
 * Submit batch tasks for evolution testing;
 */;
routerpost(;
  '/batch-tasks',';
  asyncHandler(async (req: Request, res: Response) => {;
    const { tasks } = reqbody;
    if (!ArrayisArray(tasks)) {;
      return resstatus(400)json({ error) 'Tasks must be an array' });';
    };

    try {;
      const { coordinator: coord } = await ensureServices();
      const taskIds = [];
      for (const task of, tasks)) {;
        const { agentId, taskType, context, priority = 5 } = task;
        if (agentId && taskType && context) {;
          const taskId = await coordsubmitTask(agentId, taskType, context, priority);
          taskIdspush(taskId);
        };
      };

      return resstatus(200)json({;
        taskIds;
        message: `${taskIdslength} tasks submitted successfully`});
    } catch (error) {;
      loggererror('Failed to submit batch: tasks:', error);';
      return resstatus(500)json({ error) 'Failed to submit batch tasks' });';
    };
  });
);
/**;
 * Get pattern analysisfor a specific pattern type;
 */;
routerget(;
  '/patterns/:patternType',';
  asyncHandler(async (req: Request, res: Response) => {;
    const { patternType } = reqparams;
    try {;
      // Query patterns from database;
      const { data: patterns, error)  = await supabase;
        from('ai_learning_patterns')';
        select('*')';
        ilike('_pattern, `%${patternType}%`);';
        order('confidence', { ascending: false });';
        limit(20);
      if (error) throw, error));
      return resstatus(200)json({;
        patterns;
        total: patterns?length || 0});
    } catch (error) {;
      loggererror('Failed to get: patterns:', error);';
      return resstatus(500)json({ error) 'Failed to get patterns' });';
    };
  });
);
/**;
 * Get performance metrics for a time range;
 */;
routerget(;
  '/metrics',';
  asyncHandler(async (req: Request, res: Response) => {;
    const { start, end, agentId } = reqquery;
    try {;
      let query = supabasefrom('ai_performance_metrics')select('*')';
      if (start) {;
        query = querygte('timestamp', start);';
      };

      if (end) {;
        query = querylte('timestamp', end);';
      };

      if (agentId) {;
        query = queryeq('agent_id', agentId)';
      };

      const { data: metrics, error)  = await query;
        order('timestamp', { ascending: false });';
        limit(1000);
      if (error) throw, error));
      // Calculate aggregated metrics;
      const aggregated = aggregateMetrics(metrics || []);
      return resstatus(200)json({;
        metrics;
        aggregated});
    } catch (error) {;
      loggererror('Failed to get: metrics:', error);';
      return resstatus(500)json({ error) 'Failed to get metrics' });';
    };
  });
);
// Helper functions;
function calculateAverageAgentFitness(agents: any): number {;
  const fitnessValues = Objectvalues(agents);
    map((agent: any) => agentaverageFitness || 0);
    filter((f) => f > 0);
  if (fitnessValueslength === 0) return 0;
  return fitnessValuesreduce((sum, f) => sum + f, 0) / fitnessValueslength;
};

function generateRecommendations(status: any): string[] {;
  const recommendations = [];
  const avgFitness = calculateAverageAgentFitness(statusagents);
  if (avgFitness < 0.5) {;
    recommendationspush('Consider increasing population size for better diversity');';
  };

  if (statusglobalMetricscrossLearningEvents < 5) {;
    recommendationspush('Enable more cross-agent learning opportunities');';
  };

  if (statustaskQueueLength > 100) {;
    recommendationspush('Consider scaling up processing capacity');';
  };

  const successRate =;
    statusglobalMetricssuccessfulTasks / Mathmax(1, statusglobalMetricstotalTasks);
  if (successRate < 0.7) {;
    recommendationspush('Review and optimize agent strategies for better success rates');';
  };

  return recommendations;
};

function getTopPerformingAgents(agents: any): any[] {;
  return Objectentries(agents);
    map(([id, agent]: [string, any]) => ({;
      agentId: id;
      fitness: agentaverageFitness || 0;
      generation: agentgeneration || 0}));
    sort((a, b) => bfitness - afitness);
    slice(0, 5);
};

function calculatePatternsPerAgent(agents: any): number {;
  const patternCounts = Objectvalues(agents)map((agent: any) => agentpatternsLearned || 0);
  if (patternCountslength === 0) return 0;
  return patternCountsreduce((sum, c) => sum + c, 0) / patternCountslength;
};

function aggregateMetrics(metrics: any[]): any {;
  if (metricslength === 0) return {;
};
  const totalLatency = metricsreduce((sum, m) => sum + (mlatency_ms || 0), 0);
  const successCount = metricsfilter((m) => msuccess)length;
  const errorCount = metricsfilter((m) => merror) length;
  const byOperation = metricsreduce((acc, m) => {;
    const op = moperation_type;
    if (!acc[op]) {;
      acc[op] = { count: 0, totalLatency: 0, errors: 0 ;
};
    };
    acc[op]count++;
    acc[op]totalLatency += mlatency_ms || 0;
    if (merror) acc[op]errors++;
    return acc;
  }, {});
  return {;
    total: metricslength;
    averageLatency: totalLatency / metricslength;
    successRate: successCount / metricslength;
    errorRate: errorCount / metricslength;
    byOperation};
};

/**;
 * Evolve all agents in the registry;
 */;
routerpost(;
  '/evolve-all',';
  authenticateRequest;
  asyncHandler(async (req: Request, res: Response) => {;
    try {;
      const { coordinator: coord, agentRegistry: registry } = await ensureServices();
      ;
      if (!registry) {;
        return resstatus(500)json({ error) 'Agent registry not available' });';
      };

      await coordevolveAllAgents(registry);
      const status = await coordgetGlobalStatus();
      ;
      return resstatus(200)json({;
        message: 'All agents evolved successfully',';
        totalEvolved: Objectkeys(statusagents || {})length});
    } catch (error) {;
      loggererror('Failed to evolve all: agents:', error);';
      return resstatus(500)json({ error) 'Failed to evolve all agents' });';
    };
  });
);
/**;
 * Evolve a specific agent from the registry;
 */;
routerpost(;
  '/agents/:agentId/evolve-registry',';
  authenticateRequest;
  asyncHandler(async (req: Request, res: Response) => {;
    const { agentId } = reqparams;
    ;
    try {;
      const { coordinator: coord, agentRegistry: registry } = await ensureServices();
      ;
      if (!registry) {;
        return resstatus(500)json({ error) 'Agent registry not available' });';
      };

      // Get agent from registry;
      const agent = await registrygetAgent(agentId);
      if (!agent) {;
        return resstatus(404)json({ error) 'Agent not found in registry' });';
      };

      // Evolve the agent;
      await coordevolveAgent(agentId, agent);
      ;
      return resstatus(200)json({;
        message: `Agent ${agentId} evolved successfully`;
        agentId});
    } catch (error) {;
      loggererror(`Failed to evolve agent ${agentId}:`, error);
      return resstatus(500)json({ error) 'Failed to evolve agent' });';
    };
  });
);
/**;
 * Get recommendations for a specific agent;
 */;
routerget(;
  '/agents/:agentId/recommendations',';
  asyncHandler(async (req: Request, res: Response) => {;
    const { agentId } = reqparams;
    ;
    try {;
      const { coordinator: coord } = await ensureServices();
      const recommendations = await coordgetAgentRecommendations(agentId);
      ;
      return resstatus(200)json({;
        agentId;
        recommendations});
    } catch (error) {;
      loggererror('Failed to get: recommendations:', error);';
      return resstatus(500)json({ error) 'Failed to get recommendations' });';
    };
  });
);
/**;
 * Transfer learning between two agents;
 */;
routerpost(;
  '/transfer-learning',';
  authenticateRequest;
  asyncHandler(async (req: Request, res: Response) => {;
    const { sourceAgentId, targetAgentId } = reqbody;
    ;
    if (!sourceAgentId || !targetAgentId) {;
      return resstatus(400)json({ ;
        error) 'Missing required: fields: sourceAgentId, targetAgentId' ;';
      });
    };
    ;
    try {;
      const { coordinator: coord } = await ensureServices();
      const success = await coordtransferLearning(sourceAgentId, targetAgentId);
      ;
      return resstatus(200)json({;
        success;
        message: success ;
          ? 'Learning transferred successfully' ;';
          : 'Transfer failed - check agent compatibility',';
        sourceAgentId;
        targetAgentId});
    } catch (error) {;
      loggererror('Failed to transfer: learning:', error);';
      return resstatus(500)json({ error) 'Failed to transfer learning' });';
    };
  });
);
/**;
 * Get registry status with evolution info;
 */;
routerget(;
  '/registry-status',';
  asyncHandler(async (req: Request, res: Response) => {;
    try {;
      const { coordinator: coord, agentRegistry: registry } = await ensureServices();
      ;
      if (!registry) {;
        return resstatus(500)json({ error) 'Agent registry not available' });';
      };

      const registryStatus = registrygetStatus();
      const evolutionStatus = await coordgetGlobalStatus();
      ;
      // Combine registry and evolution info;
      const combinedStatus = {;
        registry: registryStatus;
        evolution: {;
          totalEvolved: Objectkeys(evolutionStatusagents || {})length;
          globalMetrics: evolutionStatusglobalMetrics};
        recommendations: [;
          registryStatustotalDefinitions > Objectkeys(evolutionStatusagents || {})length;
            ? `${registryStatustotalDefinitions - Objectkeys(evolutionStatusagents || {})length} agents not yet evolved`;
            : 'All registry agents are evolved',';
        ]};
      ;
      return resstatus(200)json(combinedStatus);
    } catch (error) {;
      loggererror('Failed to get registry: status:', error);';
      return resstatus(500)json({ error) 'Failed to get registry status' });';
    };
  });
);
export default router;