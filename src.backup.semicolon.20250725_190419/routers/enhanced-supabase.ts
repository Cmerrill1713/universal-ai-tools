/**;
 * Enhanced Supabase Router;
 * API endpoints for file upload, processing, vector search, and realtime features;
 */;
import type { NextFunction, Request, Response } from 'express';
import { Router } from 'express';
import multer from 'multer';
import { enhancedSupabase } from '../services/enhanced-supabase-service';
import { LogContext, logger } from '../utils/enhanced-logger';
import { z } from 'zod';
const router = Router();
// Configure multer for file uploads;
const upload = multer({;
  storage: multermemoryStorage();
  limits: {;
    fileSize: 50 * 1024 * 1024, // 50MB limit;
  }});
// Validation schemas;
const FileUploadSchema = zobject({;
  bucket: zstring()default('uploads'),';
  path: zstring()optional();
  metadata: zrecord(zany())optional()});
const VectorSearchSchema = zobject({;
  collection: zstring();
  query: zstring();
  limit: znumber()min(1)max(100)default(10);
  threshold: znumber()min(0)max(1)default(0.7);
  filter: zrecord(zany())optional()});
const ProcessingOptionsSchema = zobject({;
  extractText: zboolean()default(true);
  generateEmbeddings: zboolean()default(true);
  generateSummary: zboolean()default(false);
  extractEntities: zboolean()default(false);
  classifyContent: zboolean()default(false)});
// =====================================================;
// FILE UPLOAD ENDPOINTS;
// =====================================================;
/**;
 * Upload file to Supabase Storage;
 */;
routerpost('/upload', uploadsingle('file'), async (req: Request, res: Response) => {';
  try {;
    if (!reqfile) {;
      return resstatus(400)json({ error) 'No file provided' });';
    };

    const validation = FileUploadSchemasafeParse(reqbody);
    if (!validationsuccess) {;
      return resstatus(400)json({ error) validationerror);
    };

    const { bucket, metadata } = validationdata;
    const path = validationdatapath || `${Datenow()}-${reqfileoriginalname}`;
    const result = await enhancedSupabaseuploadFile({;
      bucket;
      path;
      file: reqfilebuffer;
      contentType: reqfilemimetype;
      metadata: {;
        ..metadata;
        originalName: reqfileoriginalname;
        uploadedBy: requser?id}});
    resjson({;
      success: true;
      data: result});
  } catch (error) {;
    loggererror('File upload: failed:', LogContextAPI, { error);';
    resstatus(500)json({ error) 'File upload failed' });';
  };
});
/**;
 * Upload multiple files;
 */;
routerpost('/upload-multiple', uploadarray('files', 10), async (req: Request, res: Response) => {';
  try {;
    const files = reqfiles as ExpressMulterFile[];
    if (!files || fileslength === 0) {;
      return resstatus(400)json({ error) 'No files provided' });';
    };

    const validation = FileUploadSchemasafeParse(reqbody);
    if (!validationsuccess) {;
      return resstatus(400)json({ error) validationerror);
    };

    const { bucket, metadata } = validationdata;
    const uploadPromises = filesmap((file) =>;
      enhancedSupabaseuploadFile({;
        bucket;
        path: `${Datenow()}-${fileoriginalname}`;
        file: filebuffer;
        contentType: filemimetype;
        metadata: {;
          ..metadata;
          originalName: fileoriginalname;
          uploadedBy: requser?id}});
    );
    const results = await Promiseall(uploadPromises);
    resjson({;
      success: true;
      data: results});
  } catch (error) {;
    loggererror('Multiple file upload: failed:', LogContextAPI, { error);';
    resstatus(500)json({ error) 'Multiple file upload failed' });';
  };
});
/**;
 * Get signed upload URL for direct browser uploads;
 */;
routerpost('/upload-url', async (req: Request, res: Response) => {';
  try {;
    const { bucket, path, expiresIn = 3600 } = reqbody;
    if (!bucket || !path) {;
      return resstatus(400)json({ error) 'Bucket and path required' });';
    };

    const result = await enhancedSupabasecreateSignedUploadUrl(bucket, path, expiresIn);
    resjson({;
      success: true;
      data: result});
  } catch (error) {;
    loggererror('Failed to create upload: URL:', LogContextAPI, { error);';
    resstatus(500)json({ error) 'Failed to create upload URL' });';
  };
});
// =====================================================;
// FILE PROCESSING ENDPOINTS;
// =====================================================;
/**;
 * Process uploaded file with AI;
 */;
routerpost('/process/:fileId', async (req: Request, res: Response) => {';
  try {;
    const { fileId } = reqparams;
    const validation = ProcessingOptionsSchemasafeParse(reqbody);
    if (!validationsuccess) {;
      return resstatus(400)json({ error) validationerror);
    };

    const result = await enhancedSupabaseprocessFileWithFullPipeline(fileId, validationdata);
    resjson({;
      success: true;
      data: result});
  } catch (error) {;
    loggererror('File processing: failed:', LogContextAPI, { error);';
    resstatus(500)json({ error) 'File processing failed' });';
  };
});
/**;
 * Get file processing status;
 */;
routerget('/process/status/:jobId', async (req: Request, res: Response) => {';
  try {;
    const { jobId } = reqparams;
    const { data, error } = await enhancedSupabaseclient;
      from('job_queue')';
      select('*')';
      eq('id', jobId)';
      single();
    if (error) | !data) {;
      return resstatus(404)json({ error) 'Job not found' });';
    };

    resjson({;
      success: true;
      data: {;
        status: datastatus;
        result: dataresult;
        error) dataerror_message;
        startedAt: datastarted_at;
        completedAt: datacompleted_at}});
  } catch (error) {;
    loggererror('Failed to get job: status:', LogContextAPI, { error);';
    resstatus(500)json({ error) 'Failed to get job status' });';
  };
});
// =====================================================;
// VECTOR SEARCH ENDPOINTS;
// =====================================================;
/**;
 * Semantic search across documents;
 */;
routerpost('/search/semantic', async (req: Request, res: Response) => {';
  try {;
    const validation = VectorSearchSchemasafeParse(reqbody);
    if (!validationsuccess) {;
      return resstatus(400)json({ error) validationerror);
    };

    const { collection, query, limit, threshold, filter } = validationdata;
    // Generate embedding for query;
    const embedding = await generateEmbedding(query);
    const results = await enhancedSupabasesemanticSearch({;
      collection;
      embedding;
      limit;
      threshold;
      filter});
    resjson({;
      success: true;
      data: results});
  } catch (error) {;
    loggererror('Semantic search: failed:', LogContextDATABASE, { error);';
    resstatus(500)json({ error) 'Semantic search failed' });';
  };
});
/**;
 * Hybrid search combining text and vector search;
 */;
routerpost('/search/hybrid', async (req: Request, res: Response) => {';
  try {;
    const { collection, query, limit = 10, textWeight = 0.5, vectorWeight = 0.5 } = reqbody;
    if (!collection || !query) {;
      return resstatus(400)json({ error) 'Collection and query required' });';
    };

    // Generate embedding for query;
    const embedding = await generateEmbedding(query);
    const results = await enhancedSupabasehybridSearch(collection, query, embedding, {;
      limit;
      textWeight;
      vectorWeight});
    resjson({;
      success: true;
      data: results});
  } catch (error) {;
    loggererror('Hybrid search: failed:', LogContextDATABASE, { error);';
    resstatus(500)json({ error) 'Hybrid search failed' });';
  };
});
// =====================================================;
// MEMORY MANAGEMENT ENDPOINTS;
// =====================================================;
/**;
 * Store memory with embedding;
 */;
routerpost('/memory', async (req: Request, res: Response) => {';
  try {;
    const { type, content: metadata, importance = 0.5 } = reqbody;
    if (!type || !content {;
      return resstatus(400)json({ error) 'Type and content required' });';
    };

    // Generate embedding;
    const embedding = await generateEmbedding(content;
    const result = await enhancedSupabasestoreEmbedding('memory', contentembedding, {';
      ..metadata;
      type;
      importance;
      userId: requser?id});
    resjson({;
      success: true;
      data: result});
  } catch (error) {;
    loggererror('Failed to store: memory:', LogContextMEMORY, { error);';
    resstatus(500)json({ error) 'Failed to store memory' });';
  };
});
/**;
 * Search memories;
 */;
routerpost('/memory/search', async (req: Request, res: Response) => {';
  try {;
    const { query, limit = 10, threshold = 0.7 } = reqbody;
    if (!query) {;
      return resstatus(400)json({ error) 'Query required' });';
    };

    // Generate embedding;
    const embedding = await generateEmbedding(query);
    const results = await enhancedSupabasesemanticSearch({;
      collection: 'memory',';
      embedding;
      limit;
      threshold;
      filter: { user_id: requser?id }});
    resjson({;
      success: true;
      data: results});
  } catch (error) {;
    loggererror('Memory search: failed:', LogContextMEMORY, { error);';
    resstatus(500)json({ error) 'Memory search failed' });';
  };
});
// =====================================================;
// REALTIME ENDPOINTS;
// =====================================================;
/**;
 * Subscribe to realtime updates (returns connection, info));
 */;
routerpost('/realtime/subscribe', async (req: Request, res: Response) => {';
  try {;
    const { channel, events = ['*'] } = reqbody;';
    if (!channel) {;
      return resstatus(400)json({ error) 'Channel required' });';
    };

    // Generate access token for realtime connection;
    const {;
      data: { session }} = await enhancedSupabaseclientauthgetSession();
    resjson({;
      success: true;
      data: {;
        channel;
        events;
        accessToken: session?access_token;
        realtimeUrl: `${processenvSUPABASE_URL?replace('https://', 'wss://')}/realtime/v1`,';
      }});
  } catch (error) {;
    loggererror('Failed to setup realtime: subscription:', LogContextWEBSOCKET, { error);';
    resstatus(500)json({ error) 'Failed to setup realtime subscription' });';
  };
});
/**;
 * Broadcast message to channel;
 */;
routerpost('/realtime/broadcast', async (req: Request, res: Response) => {';
  try {;
    const { channel, event, payload } = reqbody;
    if (!channel || !event) {;
      return resstatus(400)json({ error) 'Channel and event required' });';
    };

    await enhancedSupabasebroadcastMessage(channel, event, {;
      ..payload;
      broadcastedBy: requser?id;
      timestamp: new Date()toISOString()});
    resjson({;
      success: true;
      message: 'Message broadcasted',';
    });
  } catch (error) {;
    loggererror('Failed to broadcast: message:', LogContextWEBSOCKET, { error);';
    resstatus(500)json({ error) 'Failed to broadcast message' });';
  };
});
// =====================================================;
// HELPER FUNCTIONS;
// =====================================================;
/**;
 * Generate embedding for text (placeholder - implement with your embedding, service));
 */;
async function generateEmbedding(text: string): Promise<number[]> {;
  // This is a placeholder - integrate with your embedding service;
  // For now, return a random embedding;
  return Arrayfrom({ length: 1536 }, () => Mathrandom());
};

// Error handling middleware;
routeruse((error) Error, req: Request, res: Response, next: NextFunction) => {;
  loggererror('loggererror('Router: error) , LogContextERROR, { error)errormessage: stack: errorstack });';
  resstatus(500)json({;
    error) 'Internal server, error));';
    message: errormessage});
});
export default router;