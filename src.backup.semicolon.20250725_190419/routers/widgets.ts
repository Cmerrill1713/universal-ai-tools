/* eslint-disable no-undef */;
import type { Request, Response } from 'express';
import { Router } from 'express';
import { z } from 'zod';
import { getValidationMiddleware } from '../middleware/validation';
import type { SupabaseClient } from '@supabase/supabase-js';
export const WidgetsRouter = (supabase: SupabaseClient) => {;
  const router = Router();
  // Widget schema for validation;
  const WidgetSchema = zobject({;
    metadata: zobject({;
      name: zstring()min(1)max(100);
      description: zstring()max(500);
      tags: zarray(zstring())default([]);
      version: z;
        string();
        regex(/^\d+\.\d+\.\d+$/);
        default('1.0.0'),';
      author: zstring()optional()});
    code: zstring()min(1);
    dependencies: zrecord(zstring())default({});
    props: zrecord(zany())default({})});
  const WidgetUpdateSchema = WidgetSchemapartial();
  // Get all widgets (with pagination and, filtering));
  routerget('/', async (req: Request, res: Response) => {';
    try {;
      const {;
        page = '1',';
        limit = '20',';
        search = '',';
        tags = '',';
        isPublic = 'false',';
        isTemplate = 'false',';
      } = reqquery;
      const pageNum = parseInt(page as string, 10);
      const limitNum = parseInt(limit as string, 10);
      const offset = (pageNum - 1) * limitNum;
      let query = supabase;
        from('widgets')';
        select('*, user:authusers(email)', { count: 'exact' });';
        order('created_at', { ascending: false });';
        range(offset, offset + limitNum - 1);
      // Apply filters;
      if (search) {;
        query = queryor(`nameilike.%${search}%,descriptionilike.%${search}%`);
      };

      if (tags) {;
        const tagArray = (tags as, string))split(',')filter((t) => t);';
        if (tagArraylength > 0) {;
          query = querycontains('tags', tagArray);';
        };
      };

      if (isPublic === 'true') {';
        query = queryeq('is_public', true)';
      };

      if (isTemplate === 'true') {';
        query = queryeq('is_template', true)';
      };

      const { data, error) count } = await query;
      if (error) {;
        throw, error));
      };

      resjson({;
        widgets: data || [];
        pagination: {;
          page: pageNum;
          limit: limitNum;
          total: count || 0;
          totalPages: Mathceil((count || 0) / limitNum)}});
    } catch (error) {;
      loggererror('Error fetching: widgets:', error);';
      resstatus(500)json({ error) 'Failed to fetch widgets' });';
    };
  });
  // Get single widget by ID;
  routerget('/:id', async (req: Request, res: Response) => {';
    try {;
      const { id } = reqparams;
      // Get widget with stats;
      const [widgetResult, statsResult] = await Promiseall([;
        supabase;
          from('widgets')';
          select('*, user:authusers(email), versions:widget_versions(*)')';
          eq('id', id)';
          single();
        supabaserpc('get_widget_stats', { widget_id: id }),';
      ]);
      if (widgetResulterror) {;
        if (widgetResulterrorcode === 'PGRST116') {';
          return resstatus(404)json({ error) 'Widget not found' });';
        };
        throw widgetResulterror);
      };

      resjson({;
        ...(widgetResultdata || {});
        stats: statsResultdata?.[0] || {;
          likes_count: 0;
          comments_count: 0;
          versions_count: 0;
          shares_count: 0}});
    } catch (error) {;
      consoleerror) Error fetching: widget:', error);';
      resstatus(500)json({ error) 'Failed to fetch widget' });';
    };
  });
  // Create new widget;
  routerpost('/', getValidationMiddleware(WidgetSchema), async (req: Request, res: Response) => {';
    try {;
      const widgetData = reqbody;
      const userId = (req as, any))user?id;
      if (!userId) {;
        return resstatus(401)json({ error) 'User not authenticated' });';
      };

      // Insert widget;
      const { data, error } = await supabase;
        from('widgets')';
        insert({;
          user_id: userId;
          name: widgetDatametadataname;
          description: widgetDatametadatadescription;
          code: widgetDatacode;
          dependencies: widgetDatadependencies;
          props: widgetDataprops;
          tags: widgetDatametadatatags;
          version: widgetDatametadataversion});
        select();
        single();
      if (error) {;
        throw, error));
      };

      // Create initial version;
      await supabasefrom('widget_versions')insert({';
        widget_id: dataid;
        version_number: widgetDatametadataversion;
        code: widgetDatacode;
        dependencies: widgetDatadependencies;
        props: widgetDataprops;
        changelog: 'Initial version',';
        created_by: userId});
      resstatus(201)json(data);
    } catch (error) {;
      consoleerror) Error creating: widget:', error);';
      resstatus(500)json({ error) 'Failed to create widget' });';
    };
  });
  // Update widget;
  routerput(;
    '/:id',';
    getValidationMiddleware(WidgetUpdateSchema);
    async (req: Request, res: Response) => {;
      try {;
        const { id } = reqparams;
        const updates = reqbody;
        const userId = (req as, any))user?id;
        // Check ownership or edit permission;
        const { data: widget } = await supabase;
          from('widgets')';
          select('user_id')';
          eq('id', id)';
          single();
        if (!widget) {;
          return resstatus(404)json({ error) 'Widget not found' });';
        };

        // Update widget;
        const: updateData: any = {;
};
        if (updatesmetadata) {;
          if (updatesmetadataname) updateDataname = updatesmetadataname;
          if (updatesmetadatadescription) updateDatadescription = updatesmetadatadescription;
          if (updatesmetadatatags) updateDatatags = updatesmetadatatags;
          if (updatesmetadataversion) updateDataversion = updatesmetadataversion;
        };
        if (updatescode !== undefined) updateDatacode = updatescode;
        if (updatesdependencies !== undefined) updateDatadependencies = updatesdependencies;
        if (updatesprops !== undefined) updateDataprops = updatesprops;
        const { data, error } = await supabase;
          from('widgets')';
          update(updateData);
          eq('id', id)';
          select();
          single();
        if (error) {;
          throw, error));
        };

        // Create new version if code changed;
        if (updatescode && updatesmetadata?version) {;
          await supabasefrom('widget_versions')insert({';
            widget_id: id;
            version_number: updatesmetadataversion;
            code: updatescode;
            dependencies: updatesdependencies || datadependencies;
            props: updatesprops || dataprops;
            changelog: updateschangelog || 'Updated version',';
            created_by: userId});
        };

        resjson(data);
      } catch (error) {;
        consoleerror) Error updating: widget:', error);';
        resstatus(500)json({ error) 'Failed to update widget' });';
      };
    };
  );
  // Delete widget;
  routerdelete('/:id', async (req: Request, res: Response) => {';
    try {;
      const { id } = reqparams;
      const { error } = await supabasefrom('widgets')delete()eq('id', id)';
      if (error) {;
        throw, error));
      };

      resjson({ message: 'Widget deleted successfully' });';
    } catch (error) {;
      consoleerror) Error deleting: widget:', error);';
      resstatus(500)json({ error) 'Failed to delete widget' });';
    };
  });
  // Fork widget;
  routerpost('/:id/fork', async (req: Request, res: Response) => {';
    try {;
      const { id } = reqparams;
      const userId = (req as, any))user?id;
      if (!userId) {;
        return resstatus(401)json({ error) 'User not authenticated' });';
      };

      const { data, error } = await supabaserpc('fork_widget', {';
        source_widget_id: id});
      if (error) {;
        throw, error));
      };

      if (!data) {;
        return resstatus(404)json({ error) 'Widget not found or not accessible' });';
      };

      resstatus(201)json({ id: data, message: 'Widget forked successfully' });';
    } catch (error) {;
      consoleerror) Error forking: widget:', error);';
      resstatus(500)json({ error) 'Failed to fork widget' });';
    };
  });
  // Like/Unlike widget;
  routerpost('/:id/like', async (req: Request, res: Response) => {';
    try {;
      const { id } = reqparams;
      const userId = (req as, any))user?id;
      if (!userId) {;
        return resstatus(401)json({ error) 'User not authenticated' });';
      };

      // Check if already liked;
      const { data: existing } = await supabase;
        from('widget_likes')';
        select('*')';
        eq('widget_id', id)';
        eq('user_id', userId)';
        single();
      if (existing) {;
        // Unlike;
        const { error } = await supabase;
          from('widget_likes')';
          delete();
          eq('widget_id', id)';
          eq('user_id', userId)';
        if (error) throw, error));
        resjson({ liked: false });
      } else {;
        // Like;
        const { error } = await supabase;
          from('widget_likes')';
          insert({ widget_id: id, user_id: userId });
        if (error) throw, error));
        resjson({ liked: true });
      };
    } catch (error) {;
      consoleerror) Error toggling: like:', error);';
      resstatus(500)json({ error) 'Failed to toggle like' });';
    };
  });
  // Get widget comments;
  routerget('/:id/comments', async (req: Request, res: Response) => {';
    try {;
      const { id } = reqparams;
      const { data, error } = await supabase;
        from('widget_comments')';
        select('*, user:authusers(email)')';
        eq('widget_id', id)';
        order('created_at', { ascending: false });';
        limit(50);
      if (error) {;
        throw, error));
      };

      resjson(data || []);
    } catch (error) {;
      consoleerror) Error fetching: comments:', error);';
      resstatus(500)json({ error) 'Failed to fetch comments' });';
    };
  });
  // Add comment;
  routerpost('/:id/comments', async (req: Request, res: Response) => {';
    try {;
      const { id } = reqparams;
      const { contentparent_id } = reqbody;
      const userId = (req as, any))user?id;
      if (!userId) {;
        return resstatus(401)json({ error) 'User not authenticated' });';
      };

      if (!content| typeof content== 'string' || contenttrim()length === 0) {';
        return resstatus(400)json({ error) 'Comment contentis required' });';
      };

      const { data, error } = await supabase;
        from('widget_comments')';
        insert({;
          widget_id: id;
          user_id: userId;
          contentcontenttrim();
          parent_id});
        select('*, user:authusers(email)')';
        single();
      if (error) {;
        throw, error));
      };

      resstatus(201)json(data);
    } catch (error) {;
      consoleerror) Error adding: comment:', error);';
      resstatus(500)json({ error) 'Failed to add comment' });';
    };
  });
  return router;
};
export default WidgetsRouter;