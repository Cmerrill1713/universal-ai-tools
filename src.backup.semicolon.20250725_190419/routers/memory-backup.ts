import type { NextFunction, Response } from 'express';
import { type Request, Router } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { LogContext, logger } from '../utils/enhanced-logger';
import {;
  apiResponseMiddleware;
  createPaginationMeta;
  sendError;
  sendPaginatedSuccess;
  sendSuccess;
} from '../utils/api-response';
import type { ErrorCode, Memory, MemorySearchRequest, MemorySearchResponse } from '../types';
// Constants;
const GOOD_CONFIDENCE = 0.7;
// Define extended Request interface;
interface AuthenticatedRequest extends Request {;
  user?: { id: string ;
};
  id?: string;
  validatedData?: any;
  aiService?: { service_name: string ;
};
  requestId?: string;
  apiResponse?: any;
;
};

export function MemoryRouter(supabase: SupabaseClient) {;
  const router = Router();
  // Apply API response middleware to all routes;
  routeruse(apiResponseMiddleware);
  // Enhanced validation middleware with proper error responses;
  const validateMemoryStore = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {;
    const { content: metadata, tags } = reqbody;
    if (!content) {;
      return sendError(res, 'MISSING_REQUIRED_FIELD' as ErrorCode, 'Content is required', 400);
    };

    if (typeof content !== 'string' || contentlength === 0) {;
      return sendError(;
        res;
        'INVALID_FORMAT' as ErrorCode;
        'Content must be a non-empty string';
        400;
      );
    };

    if (contentlength > 10000) {;
      return sendError(;
        res;
        'REQUEST_TOO_LARGE' as ErrorCode;
        'Content cannot exceed 10,000 characters';
        413;
      );
    };

    reqvalidatedData = {;
      content: contenttrim();
      metadata: metadata || {;
};
      tags: ArrayisArray(tags) ? tags : [];
    };
    next();
  };
  const validateMemorySearch = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {;
    const { query, limit = 10, filters = {} } = reqbody;
    if (!query) {;
      return sendError(res, 'MISSING_REQUIRED_FIELD' as ErrorCode, 'Query is required', 400);
    };

    if (typeof query !== 'string' || querytrim()length === 0) {;
      return sendError(res, 'INVALID_FORMAT' as ErrorCode, 'Query must be a non-empty string', 400);
    };

    const validatedLimit = Mathmin(Mathmax(1, parseInt(limit, 10) || 10), 100);
    reqvalidatedData = {;
      query: querytrim();
      limit: validatedLimit;
      filters: filters || {;
};
    };
    next();
  };
  // Store memory;
  routerpost('/', validateMemoryStore, async (req: AuthenticatedRequest, res: Response) => {;
    try {;
      const memoryData = reqvalidatedData;
      // Generate embedding if content is provided;
      let embedding: number[] | null = null;
      try {;
        const embeddingResult = await supabaserpc('ai_generate_embedding', {;
          content: memoryDatacontent;
        });
        embedding = embeddingResultdata;
      } catch (embeddingError) {;
        loggerwarn('Failed to generate embedding, storing without it', LogContextAPI, {;
          error instanceof Error ? errormessage : String(error) embeddingError instanceof Error ? embeddingErrormessage : String(embeddingError);
          content: memoryDatacontentsubstring(0, 100);
        });
      };

      const { data, error } = await supabase;
                from('memories');
                insert({;
          content: memoryDatacontent;
          metadata: memoryDatametadata;
          user_id: requser?id || 'anonymous';
          embedding;
          tags: memoryDatatags;
          type: 'semantic';
          importance: 0.5;
          created_at: new Date()toISOString();
        });
                select();
                single());

      if (error) {;
        loggererror('Failed to store memory', LogContextAPI, {;
          error instanceof Error ? errormessage : String(error) errormessage;
          memoryData;
        });
        return sendError(;
          res;
          'MEMORY_STORAGE_ERROR' as ErrorCode;
          'Failed to store memory';
          500;
          errormessage;
        );
      };

      // Transform to our Memory type;
      const memory: Memory = {;
        id: dataid;
        type: datatype || 'semantic';
        content: datacontent;
        metadata: datametadata || {;
};
        tags: datatags || [];
        importance: dataimportance || 0.5;
        timestamp: datacreated_at;
        embedding: dataembedding;
      ;
};
      loggerinfo('Memory stored successfully', LogContextAPI, {;
        memoryId: memoryid;
        contentLength: memorycontentlength;
        hasEmbedding: !!embedding;
      });
      sendSuccess(res, memory, 201);
    } catch (error instanceof Error ? errormessage : String(error) Error | unknown) {;
      loggererror('Store memory error', LogContextAPI, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
        stack: error instanceof Error ? errorstack : undefined;
      });
      sendError(;
        res;
        'INTERNAL_SERVER_ERROR' as ErrorCode;
        'An unexpected error occurred while storing memory';
        500;
        error instanceof Error ? errormessage : String(error);
      );
    };
  });
  // Retrieve memories;
  routerget('/', async (req: AuthenticatedRequest, res) => {;
    try {;
      const { memory_type, limit = 10, offset = 0, page = 1 } = reqquery;
      // Calculate pagination;
      const pageNum = Mathmax(1, parseInt(page as string, 10) || 1);
      const limitNum = Mathmin(100, Mathmax(1, parseInt(limit as string, 10) || 10));
      const offsetNum = (pageNum - 1) * limitNum;
      let query = supabase;
                from('memories');
                select('*', { count: 'exact' });
                order('created_at', { ascending: false });
                range(offsetNum, offsetNum + limitNum - 1));

      if (memory_type) {;
        query = queryeq('type', memory_type);
      };

      const { data, error instanceof Error ? errormessage : String(error) count } = await query;
      if (error) {;
        loggererror('Failed to retrieve memories', LogContextAPI, { error instanceof Error ? errormessage : String(error) errormessage });
        return sendError(;
          res;
          'MEMORY_STORAGE_ERROR' as ErrorCode;
          'Failed to retrieve memories';
          500;
          errormessage;
        );
      };

      // Transform to Memory type format;
      const memories: Memory[] = (data || [])map((item) => ({;
        id: itemid;
        type: itemtype || 'semantic';
        content: itemcontent;
        metadata: itemmetadata || {;
};
        tags: itemtags || [];
        importance: itemimportance || 0.5;
        timestamp: itemcreated_at;
        embedding: itemembedding;
      }));
      // Update access tracking (async, don't wait);
      if (memorieslength > 0) {;
        const memoryIds = memoriesmap((m) => mid);
        // Fire and forget memory access tracking;
        (async () => {;
          try {;
            await supabaserpc('update_memory_access', {;
              memory_ids: memoryIds;
              service_name: reqaiService?service_name || 'unknown';
            });
          } catch (error instanceof Error ? errormessage : String(error) Error | unknown) {;
            loggerwarn('Failed to update memory access tracking', LogContextAPI, {;
              error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
            });
          };
        })();
      };

      const pagination = createPaginationMeta(pageNum, limitNum, count || 0);
      loggerinfo('Memories retrieved successfully', LogContextAPI, {;
        count: memorieslength;
        totalCount: count;
        page: pageNum;
      });
      sendPaginatedSuccess(res, memories, pagination);
    } catch (error instanceof Error ? errormessage : String(error) Error | unknown) {;
      loggererror('Retrieve memories error', LogContextAPI, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
        stack: error instanceof Error ? errorstack : undefined;
      });
      sendError(;
        res;
        'INTERNAL_SERVER_ERROR' as ErrorCode;
        'An unexpected error occurred while retrieving memories';
        500;
        error instanceof Error ? errormessage : String(error);
      );
    };
  });
  // Search memories;
  routerpost('/search', validateMemorySearch, async (req: AuthenticatedRequest, res) => {;
    const startTime = Datenow();
    try {;
      const searchParams = reqvalidatedData;
      // Generate embedding for the query;
      const { data: embedding } = await supabaserpc('ai_generate_embedding', {;
        content: searchParamsquery;
      });
      // Perform vector search;
      const { data, error } = await supabaserpc('search_memories', {;
        query_embedding: embedding;
        match_threshold: GOOD_CONFIDENCE;
        match_count: searchParamslimit;
        filter: searchParamsfilters;
      });
      if (error) throw error;
      resjson({;
        success: true;
        data: {;
          results: data;
          count: datalength;
          query: searchParamsquery;
        ;
};
        metadata: {;
          requestId: reqid;
          timestamp: new Date()toISOString();
          version: '1.0.0';
          processingTime: Datenow() - startTime;
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) Error | unknown) {;
      loggererror('Search memories error', LogContextAPI, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(400)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'MEMORY_SEARCH_ERROR';
          message: error instanceof Error ? errormessage : 'Unknown error';
          details: error;
        ;
};
        metadata: {;
          requestId: reqid;
          timestamp: new Date()toISOString();
          version: '1.0.0';
          processingTime: Datenow() - startTime;
        ;
};
      });
    };
  });
  // Update memory importance;
  routerput('/:id/importance', async (req: AuthenticatedRequest, res) => {;
    try {;
      const { id } = reqparams;
      const { importance } = reqbody;
      const { data, error } = await supabase;
                from('ai_memories'));
                update({ importance }));
                eq('id', id));
                select());
                single());

      if (error) throw error;
      resjson({ success: true, memory: data });
    } catch (error instanceof Error ? errormessage : String(error) Error | unknown) {;
      loggererror('Update memory importance error', LogContextAPI, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(400)json({ error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Failed to update memory importance' });
    };
  });
  return router;
};
