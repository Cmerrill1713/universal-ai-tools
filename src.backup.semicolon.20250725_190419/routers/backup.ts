import { Router } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { z } from 'zod';
import { LogContext, logger } from '../utils/enhanced-logger';
import { validateRequest } from '../schemas/api-schemas';
import { createBackupRecoveryService } from '../services/backup-recovery-service';
// Request schemas;
const CreateBackupSchema = zobject({;
  type: zenum(['full', 'incremental', 'differential'])default('full');
  tables: zarray(zstring())optional();
  compress: zboolean()default(true);
  encrypt: zboolean()default(true);
});
const RestoreBackupSchema = zobject({;
  backupId: zstring()min(1);
  tables: zarray(zstring())optional();
  targetSchema: zstring()optional();
  skipConstraints: zboolean()default(false);
  dryRun: zboolean()default(false);
});
const ListBackupsSchema = zobject({;
  limit: znumber()min(1)max(100)default(10);
  offset: znumber()min(0)default(0);
  status: zenum(['pending', 'in_progress', 'completed', 'failed'])optional();
});
const ScheduleBackupSchema = zobject({;
  name: zstring()min(1)max(255);
  schedule: zstring()min(1), // Cron expression;
  type: zenum(['full', 'incremental', 'differential'])default('full');
  tables: zarray(zstring())optional();
  enabled: zboolean()default(true);
});
export function BackupRouter(supabase: SupabaseClient) {;
  const router = Router();
  const backupService = createBackupRecoveryService(supabase);
  // Self-help endpoint for AWS SDK installation;
  routerget('/help/aws-sdk', async (req: any, res) => {;
    try {;
      // Try to dynamically import AWS SDK;
      let sdkStatus = 'available';
      let installationHelp = null;
      try {;
        await import('@aws-sdk/client-s3');
      } catch (error) {;
        sdkStatus = 'missing';
        installationHelp = {;
          missing_dependency: '@aws-sdk/client-s3';
          installation_command: 'npm install @aws-sdk/client-s3';
          description: 'AWS SDK is required for S3 backup functionality';
          documentation: 'https://docsawsamazoncom/AWSJavaScriptSDK/v3/latest/client/s3/';
          alternatives: [;
            'Use local file system backups (always available)';
            'Use Supabase storage for backups (configured automatically)';
          ];
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Module not found';
        ;
};
      };

      resjson({;
        aws_sdk_status: sdkStatus;
        s3_functionality: sdkStatus === 'available' ? 'enabled' : 'disabled';
        installation_help: installationHelp;
        system_message:;
          sdkStatus === 'available';
            ? 'AWS SDK is properly installed. S3 backup functionality is available.';
            : 'AWS SDK is not installed. S3 backup functionality is disabled. Use the installation command above to enable it.';
      });
    } catch (error) {;
      loggererror('Error checking AWS SDK status:', LogContextSYSTEM, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error;
      });
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Failed to check AWS SDK status';
        timestamp: new Date()toISOString();
      });
    };
  });
  // Create a new backup;
  routerpost('/create', validateRequest(CreateBackupSchema), async (req: any, res) => {;
    try {;
      const { type, tables, compress, encrypt } = reqvalidatedData;
      // Check if backup is already running;
      const status = await backupServicegetBackupStatus();
      if (statusisRunning) {;
        return resstatus(409)json({;
          success: false;
          error instanceof Error ? errormessage : String(error) {;
            code: 'BACKUP_IN_PROGRESS';
            message: 'A backup is already in progress';
          ;
};
        });
      };

      // Start backup;
      const result = await backupServicecreateBackup({;
        type;
        tables;
        compress;
      });
      resjson({;
        success: true;
        data: {;
          backup: result;
        ;
};
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('loggererror('Backup creation error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'BACKUP_ERROR';
          message: 'Failed to create backup';
          details: errormessage;
        ;
};
      });
    };
  });
  // List backups;
  routerget('/list', validateRequest(ListBackupsSchema), async (req: any, res) => {;
    try {;
      const { limit, offset, status } = reqvalidatedData;
      const result = await backupServicelistBackups({;
        limit;
        offset;
        status;
      });
      resjson({;
        success: true;
        data: {;
          backups: resultbackups;
          total: resulttotal;
          limit;
          offset;
        ;
};
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Error listing backups:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'LIST_ERROR';
          message: 'Failed to list backups';
          details: errormessage;
        ;
};
      });
    };
  });
  // Get backup details;
  routerget('/:backupId', async (req, res) => {;
    try {;
      const { backupId } = reqparams;
      const { data, error } = await supabase;
        from('backup_metadata');
        select('*');
        eq('id', backupId);
        single();
      if (error instanceof Error ? errormessage : String(error) | !data) {;
        return resstatus(404)json({;
          success: false;
          error instanceof Error ? errormessage : String(error) {;
            code: 'NOT_FOUND';
            message: 'Backup not found';
          ;
};
        });
      };

      resjson({;
        success: true;
        data: { backup: data ;
};
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Error fetching backup:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'FETCH_ERROR';
          message: 'Failed to fetch backup';
          details: errormessage;
        ;
};
      });
    };
  });
  // Restore from backup;
  routerpost('/restore', validateRequest(RestoreBackupSchema), async (req: any, res) => {;
    try {;
      const restoreOptions = reqvalidatedData;
      // Log restore attempt;
      loggerinfo('Restore requested', LogContextSYSTEM, {;
        backupId: restoreOptionsbackupId;
        dryRun: restoreOptionsdryRun;
        userId: reqaiServiceId;
      });
      const result = await backupServicerestoreBackup(restoreOptions);
      resjson({;
        success: true;
        data: {;
          restore: result;
        ;
};
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('loggererror('Restore error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'RESTORE_ERROR';
          message: 'Failed to restore backup';
          details: errormessage;
        ;
};
      });
    };
  });
  // Delete backup;
  routerdelete('/:backupId', async (req, res) => {;
    try {;
      const { backupId } = reqparams;
      await backupServicedeleteBackup(backupId);
      resjson({;
        success: true;
        message: 'Backup deleted successfully';
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('loggererror('Delete backup error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'DELETE_ERROR';
          message: 'Failed to delete backup';
          details: errormessage;
        ;
};
      });
    };
  });
  // Verify backup;
  routerpost('/:backupId/verify', async (req, res) => {;
    try {;
      const { backupId } = reqparams;
      const result = await backupServiceverifyBackup(backupId);
      resjson({;
        success: true;
        data: {;
          valid: resultvalid;
          errors: resulterrors;
        ;
};
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('loggererror('Verify backup error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'VERIFY_ERROR';
          message: 'Failed to verify backup';
          details: errormessage;
        ;
};
      });
    };
  });
  // Get backup status;
  routerget('/status/summary', async (req, res) => {;
    try {;
      const status = await backupServicegetBackupStatus();
      // Get health status from database;
      const { data: health } = await supabaserpc('check_backup_health');
      resjson({;
        success: true;
        data: {;
          status: {;
            ..status;
            health: health || null;
          ;
};
        };
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Error fetching backup status:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'STATUS_ERROR';
          message: 'Failed to fetch backup status';
          details: errormessage;
        ;
};
      });
    };
  });
  // Cleanup old backups;
  routerpost('/cleanup', async (req, res) => {;
    try {;
      const deletedCount = await backupServicecleanupOldBackups();
      resjson({;
        success: true;
        data: {;
          deletedCount;
          message: `Cleaned up ${deletedCount} old backups`;
        };
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('loggererror('Cleanup error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'CLEANUP_ERROR';
          message: 'Failed to cleanup backups';
          details: errormessage;
        ;
};
      });
    };
  });
  // Schedule management;
  routerget('/schedules', async (req, res) => {;
    try {;
      const { data: schedules, error instanceof Error ? errormessage : String(error)  = await supabase;
        from('backup_schedules');
        select('*');
        order('name');
      if (error) throw error;
      resjson({;
        success: true;
        data: {;
          schedules: schedules || [];
        ;
};
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Error fetching schedules:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'FETCH_ERROR';
          message: 'Failed to fetch schedules';
          details: errormessage;
        ;
};
      });
    };
  });
  // Create schedule;
  routerpost('/schedules', validateRequest(ScheduleBackupSchema), async (req: any, res) => {;
    try {;
      const { name, schedule, type, tables, enabled } = reqvalidatedData;
      const { data, error } = await supabaserpc('schedule_backup', {;
        p_name: name;
        p_schedule: schedule;
        p_type: type;
        p_tables: tables;
      });
      if (error) throw error;
      resjson({;
        success: true;
        data: {;
          scheduleId: data;
          message: 'Backup schedule created successfully';
        ;
};
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Error creating schedule:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'CREATE_ERROR';
          message: 'Failed to create schedule';
          details: errormessage;
        ;
};
      });
    };
  });
  // Update schedule;
  routerput('/schedules/:id', async (req, res) => {;
    try {;
      const { id } = reqparams;
      const updates = reqbody;
      const { data, error } = await supabase;
        from('backup_schedules');
        update({;
          ..updates;
          updated_at: new Date()toISOString();
        });
        eq('id', id);
        select();
        single();
      if (error) throw error;
      resjson({;
        success: true;
        data: {;
          schedule: data;
        ;
};
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Error updating schedule:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'UPDATE_ERROR';
          message: 'Failed to update schedule';
          details: errormessage;
        ;
};
      });
    };
  });
  // Delete schedule;
  routerdelete('/schedules/:id', async (req, res) => {;
    try {;
      const { id } = reqparams;
      // First, unschedule from pg_cron;
      const { data: schedule } = await supabase;
        from('backup_schedules');
        select('name');
        eq('id', id);
        single();
      if (schedule) {;
        try {;
          await supabaserpc('cronunschedule', {;
            name: `backup_${schedulename}`;
          });
        } catch (error) {;
          // Ignore if not found;
        };
      };

      // Delete schedule;
      const { error } = await supabasefrom('backup_schedules')delete()eq('id', id);

      if (error) throw error;
      resjson({;
        success: true;
        message: 'Schedule deleted successfully';
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Error deleting schedule:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'DELETE_ERROR';
          message: 'Failed to delete schedule';
          details: errormessage;
        ;
};
      });
    };
  });
  // Estimate backup size;
  routerpost('/estimate', async (req, res) => {;
    try {;
      const { tables } = reqbody;
      const { data, error } = await supabaserpc('estimate_backup_size', {;
        p_tables: tables;
      });
      if (error) throw error;
      const totalSize =;
        data?reduce((sum: number, t: any) => sum + (testimated_size || 0), 0) || 0;
      const totalRows = data?reduce((sum: number, t: any) => sum + (trow_count || 0), 0) || 0;
      resjson({;
        success: true;
        data: {;
          tables: data || [];
          summary: {;
            totalSize;
            totalRows;
            estimatedDuration: Mathmax(1000, (totalSize / 1024 / 1024) * 100), // Rough estimate;
          };
        };
        metadata: {;
          apiVersion: 'v1';
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Error estimating backup size:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) {;
          code: 'ESTIMATE_ERROR';
          message: 'Failed to estimate backup size';
          details: errormessage;
        ;
};
      });
    };
  });
  return router;
};
