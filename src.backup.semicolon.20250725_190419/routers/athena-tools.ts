/**;
 * Athena Tools API Router;
 *;
 * Unified API for Sweet Athena's conversation and tool creation capabilities;
 */;

import type { Request, Response } from 'express';
import { Router } from 'express';
import { createClient } from '@supabase/supabase-js';
import { logger } from '../utils/logger';
import { AthenaToolIntegrationService } from '../services/athena-tool-integration';
import AuthMiddleware, { type AuthRequest } from '../middleware/auth';
import ValidationMiddleware from '../middleware/validation';
import type { ConversationRequest } from '../services/athena-conversation-engine';
import { z } from 'zod';
const router = Router();
// Initialize services;
let athenaToolService: AthenaToolIntegrationService;
let authMiddleware: AuthMiddleware;
// Initialize auth middleware;
const initAuthMiddleware = () => {;
  if (!authMiddleware) {;
    const supabaseUrl = processenvSUPABASE_URL || '';
    const supabaseServiceKey = processenvSUPABASE_SERVICE_KEY || '';
    const supabase = createClient(supabaseUrl, supabaseServiceKey);
    authMiddleware = new AuthMiddleware(supabase);
  };
  return authMiddleware;
};
// Initialize on first request;
const ensureInitialized = async () => {;
  if (!athenaToolService) {;
    const supabaseUrl = processenvSUPABASE_URL || '';
    const supabaseServiceKey = processenvSUPABASE_SERVICE_KEY || '';
    const supabase = createClient(supabaseUrl, supabaseServiceKey);
    athenaToolService = new AthenaToolIntegrationService(supabase, logger);
    await athenaToolServiceinitialize();
  };
};
/**;
 * Process a conversation message (might lead to tool creation);
 */;
routerpost(;
  '/chat';
  (req, res, next) => initAuthMiddleware()authenticate()(req as AuthRequest, res, next);
  ValidationMiddlewarevalidate({;
    body: zobject({;
      message: zstring()min(1);
      conversationId: zstring()optional();
      context: zobject({})optional();
    });
  });
  async (req: Request, res: Response) => {;
    try {;
      await ensureInitialized();
      const { message: conversationId, context } = reqbody;
      const userId = (req as any)user?id || 'anonymous';
      const requestConversationRequest = {;
        userId;
        conversationId: conversationId || `conv_${Datenow()}`;
        message;
        context;
      };
      const response = await athenaToolServiceprocessMessage(request;

      resjson({;
        success: true;
        response;
      });
    } catch (error) {;
      loggererror('Error processing Athena chat:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) 'Failed to process message';
      });
    };
  };
);
/**;
 * Get active tool creation sessions for a user;
 */;
routerget(;
  '/tool-sessions';
  (req, res, next) => initAuthMiddleware()authenticate()(req as AuthRequest, res, next);
  async (req: Request, res: Response) => {;
    try {;
      await ensureInitialized();
      const userId = (req as any)user?id;
      const supabaseUrl = processenvSUPABASE_URL || '';
      const supabaseServiceKey = processenvSUPABASE_SERVICE_KEY || '';
      const supabase = createClient(supabaseUrl, supabaseServiceKey);
      const { data: sessions, error instanceof Error ? errormessage : String(error)  = await supabase;
        from('athena_tool_sessions');
        select('*');
        eq('user_id', userId);
        eq('status', 'active');
        order('created_at', { ascending: false });
      if (error) {;
        throw error;
      };

      resjson({;
        success: true;
        sessions: sessions || [];
      });
    } catch (error) {;
      loggererror('Error fetching tool sessions:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) 'Failed to fetch tool sessions';
      });
    };
  };
);
/**;
 * Get user's created tools;
 */;
routerget(;
  '/my-tools';
  (req, res, next) => initAuthMiddleware()authenticate()(req as AuthRequest, res, next);
  async (req: Request, res: Response) => {;
    try {;
      const userId = (req as any)user?id;
      const supabaseUrl = processenvSUPABASE_URL || '';
      const supabaseServiceKey = processenvSUPABASE_SERVICE_KEY || '';
      const supabase = createClient(supabaseUrl, supabaseServiceKey);
      const { data: tools, error instanceof Error ? errormessage : String(error)  = await supabase;
        from('ai_custom_tools');
        select('*');
        eq('created_by', userId);
        order('created_at', { ascending: false });
      if (error) {;
        throw error;
      };

      resjson({;
        success: true;
        tools: tools || [];
      });
    } catch (error) {;
      loggererror('Error fetching user tools:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) 'Failed to fetch tools';
      });
    };
  };
);
/**;
 * Get tool templates;
 */;
routerget(;
  '/templates';
  (req, res, next) => initAuthMiddleware()authenticate()(req as AuthRequest, res, next);
  async (req: Request, res: Response) => {;
    try {;
      const supabaseUrl = processenvSUPABASE_URL || '';
      const supabaseServiceKey = processenvSUPABASE_SERVICE_KEY || '';
      const supabase = createClient(supabaseUrl, supabaseServiceKey);
      const { data: templates, error instanceof Error ? errormessage : String(error)  = await supabase;
        from('ai_tool_templates');
        select('*');
        order('category', { ascending: true });
      if (error) {;
        throw error;
      };

      resjson({;
        success: true;
        templates: templates || [];
      });
    } catch (error) {;
      loggererror('Error fetching tool templates:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) 'Failed to fetch templates';
      });
    };
  };
);
/**;
 * Deploy a tool;
 */;
routerpost(;
  '/deploy/:toolId';
  (req, res, next) => initAuthMiddleware()authenticate()(req as AuthRequest, res, next);
  ValidationMiddlewarevalidate({;
    body: zobject({;
      target: zenum(['local', 'api', 'function']);
    });
  });
  async (req: Request, res: Response) => {;
    try {;
      await ensureInitialized();
      const { toolId } = reqparams;
      const { target } = reqbody;
      const userId = (req as any)user?id;
      // Verify tool ownership;
      const supabaseUrl = processenvSUPABASE_URL || '';
      const supabaseServiceKey = processenvSUPABASE_SERVICE_KEY || '';
      const supabase = createClient(supabaseUrl, supabaseServiceKey);
      const { data: tool, error instanceof Error ? errormessage : String(error)  = await supabase;
        from('ai_custom_tools');
        select('*');
        eq('id', toolId);
        eq('created_by', userId);
        single();
      if (error instanceof Error ? errormessage : String(error) | !tool) {;
        return resstatus(404)json({;
          success: false;
          error instanceof Error ? errormessage : String(error) 'Tool not found';
        });
      };

      // Deploy through tool maker agent;
      const deploymentRequest: ConversationRequest = {;
        userId;
        conversationId: `deploy_${toolId}`;
        message: `Deploy tool ${toolId} to ${target}`;
      };
      const response = await athenaToolServiceprocessMessage(deploymentRequest);
      resjson({;
        success: true;
        deployment: response;
      });
    } catch (error) {;
      loggererror('Error deploying tool:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) 'Failed to deploy tool';
      });
    };
  };
);
/**;
 * Get conversation history;
 */;
routerget(;
  '/conversations/:conversationId';
  (req, res, next) => initAuthMiddleware()authenticate()(req as AuthRequest, res, next);
  async (req: Request, res: Response) => {;
    try {;
      const { conversationId } = reqparams;
      const userId = (req as any)user?id;
      const supabaseUrl = processenvSUPABASE_URL || '';
      const supabaseServiceKey = processenvSUPABASE_SERVICE_KEY || '';
      const supabase = createClient(supabaseUrl, supabaseServiceKey);
      const { data: messages, error instanceof Error ? errormessage : String(error)  = await supabase;
        from('athena_conversations');
        select('*');
        eq('user_id', userId);
        eq('conversation_id', conversationId);
        order('created_at', { ascending: true });
      if (error) {;
        throw error;
      };

      resjson({;
        success: true;
        messages: messages || [];
      });
    } catch (error) {;
      loggererror('Error fetching conversation:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) 'Failed to fetch conversation';
      });
    };
  };
);
/**;
 * Cancel a tool creation session;
 */;
routerpost(;
  '/tool-sessions/:sessionId/cancel';
  (req, res, next) => initAuthMiddleware()authenticate()(req as AuthRequest, res, next);
  async (req: Request, res: Response) => {;
    try {;
      const { sessionId } = reqparams;
      const userId = (req as any)user?id;
      const supabaseUrl = processenvSUPABASE_URL || '';
      const supabaseServiceKey = processenvSUPABASE_SERVICE_KEY || '';
      const supabase = createClient(supabaseUrl, supabaseServiceKey);
      const { error } = await supabase;
        from('athena_tool_sessions');
        update({ status: 'cancelled', updated_at: new Date()toISOString() });
        eq('id', sessionId);
        eq('user_id', userId);

      if (error) {;
        throw error;
      };

      resjson({;
        success: true;
        message: 'Tool creation session cancelled';
      });
    } catch (error) {;
      loggererror('Error cancelling session:', error);
      resstatus(500)json({;
        success: false;
        error instanceof Error ? errormessage : String(error) 'Failed to cancel session';
      });
    };
  };
);
export default router;