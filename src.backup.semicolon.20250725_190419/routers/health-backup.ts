/**;
 * Health Monitoring Router;
 * Provides health and performance metrics for frontend monitoring;
 */;

import type { Request, Response } from 'express';
import { Router } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { LogContext, logger } from '../utils/enhanced-logger';
import { apiResponseMiddleware, sendError, sendSuccess } from '../utils/api-response';
import type { ErrorCode, HealthCheckResponse, ServiceHealth, SystemMetrics } from '../types';
export function HealthRouter(supabase: SupabaseClient) {;
  const router = Router();
  // Apply API response middleware;
  routeruse(apiResponseMiddleware);
  /**;
   * GET /health;
   * Basic health check endpoint;
   */;
  routerget('/', async (req: Request, res: Response) => {;
    try {;
      const startTime = Datenow();
      // Check basic system health;
      const memUsage = processmemoryUsage();
      const uptime = processuptime();
      // Test database connectivity;
      const dbHealthy = await checkDatabaseHealth(supabase);
      const responseTime = Datenow() - startTime;
      const health: HealthCheckResponse = {;
        status: dbHealthy ? 'healthy' : 'degraded';
        version: '1.0.0';
        uptime;
        services: {;
          database: dbHealthy;
          memory: getMemoryHealth(memUsage);
          api: { status: 'healthy', responseTime, lastCheck: new Date()toISOString() ;
};
        };
        metrics: {;
          memoryUsage: Mathround((memUsageheapUsed / memUsageheapTotal) * 100);
          cpuUsage: 0, // Would need a CPU monitoring library for real implementation;
          activeConnections: 0, // Would track WebSocket connections;
          requestsPerMinute: 0, // Would need request counting middleware;
        };
      };
      sendSuccess(res, health);
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Health check failed', LogContextSYSTEM, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      sendError(;
        res;
        'INTERNAL_SERVER_ERROR' as ErrorCode;
        'Health check failed';
        500;
        error instanceof Error ? errormessage : String(error);
      );
    };
  });
  /**;
   * GET /health/detailed;
   * Detailed health and performance metrics;
   */;
  routerget('/detailed', async (req: Request, res: Response) => {;
    try {;
      const startTime = Datenow();
      // System metrics;
      const memUsage = processmemoryUsage();
      const cpuUsage = processcpuUsage();
      // Service health checks;
      const [dbHealth, agentCoordinatorHealth] = await Promiseall([;
        checkDatabaseHealth(supabase);
        checkAgentCoordinatorHealth();
      ]);
      const responseTime = Datenow() - startTime;
      const detailedHealth = {;
        status:;
          dbHealthstatus === 'healthy' && agentCoordinatorHealthstatus === 'healthy';
            ? 'healthy';
            : 'degraded';
        version: '1.0.0';
        uptime: processuptime();
        timestamp: new Date()toISOString();
        services: {;
          database: dbHealth;
          agentCoordinator: agentCoordinatorHealth;
          api: {;
            status: 'healthy' as const;
            responseTime;
            lastCheck: new Date()toISOString();
          };
        };
        system: {;
          memory: {;
            rss: memUsagerss;
            heapTotal: memUsageheapTotal;
            heapUsed: memUsageheapUsed;
            external: memUsageexternal;
            usage: Mathround((memUsageheapUsed / memUsageheapTotal) * 100);
          ;
};
          cpu: {;
            user: cpuUsageuser;
            system: cpuUsagesystem;
            // Note: Getting actual CPU % would require more complex monitoring;
            usage: 0;
          ;
};
          process: {;
            pid: processpid;
            version: processversion;
            platform: processplatform;
            arch: processarch;
          ;
};
        };
        metrics: {;
          memoryUsage: Mathround((memUsageheapUsed / memUsageheapTotal) * 100);
          cpuUsage: 0;
          activeConnections: 0;
          requestsPerMinute: 0;
        ;
};
      };
      sendSuccess(res, detailedHealth);
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Detailed health check failed', LogContextSYSTEM, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      sendError(;
        res;
        'INTERNAL_SERVER_ERROR' as ErrorCode;
        'Detailed health check failed';
        500;
        error instanceof Error ? errormessage : String(error);
      );
    };
  });
  /**;
   * GET /health/memory;
   * Memory-specific health and statistics;
   */;
  routerget('/memory', async (req: Request, res: Response) => {;
    try {;
      const memUsage = processmemoryUsage();
      const agentCoordinatorStats = await getAgentCoordinatorMemoryStats();
      const memoryHealth = {;
        process: {;
          rss: memUsagerss;
          heapTotal: memUsageheapTotal;
          heapUsed: memUsageheapUsed;
          heapFree: memUsageheapTotal - memUsageheapUsed;
          external: memUsageexternal;
          usage: Mathround((memUsageheapUsed / memUsageheapTotal) * 100);
        };
        agentCoordinator: agentCoordinatorStats;
        recommendations: generateMemoryRecommendations(memUsage, agentCoordinatorStats);
        status: getMemoryHealthStatus(memUsage);
      ;
};
      sendSuccess(res, memoryHealth);
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Memory health check failed', LogContextSYSTEM, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      sendError(;
        res;
        'INTERNAL_SERVER_ERROR' as ErrorCode;
        'Memory health check failed';
        500;
        error instanceof Error ? errormessage : String(error);
      );
    };
  });
  /**;
   * POST /health/cleanup;
   * Force memory cleanup (useful for frontend to trigger cleanup);
   */;
  routerpost('/cleanup', async (req: Request, res: Response) => {;
    try {;
      const beforeMemory = processmemoryUsage();
      // Force garbage collection if available;
      if (globalgc) {;
        globalgc();
      };

      // Force agent coordinator cleanup;
      await forceAgentCoordinatorCleanup();
      const afterMemory = processmemoryUsage();
      const cleanupResult = {;
        before: beforeMemory;
        after: afterMemory;
        freed: {;
          rss: beforeMemoryrss - afterMemoryrss;
          heapUsed: beforeMemoryheapUsed - afterMemoryheapUsed;
          heapTotal: beforeMemoryheapTotal - afterMemoryheapTotal;
          external: beforeMemoryexternal - afterMemoryexternal;
        };
        timestamp: new Date()toISOString();
      ;
};
      loggerinfo('Manual memory cleanup performed', LogContextSYSTEM, { cleanupResult });
      sendSuccess(res, cleanupResult);
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror('Memory cleanup failed', LogContextSYSTEM, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      sendError(;
        res;
        'INTERNAL_SERVER_ERROR' as ErrorCode;
        'Memory cleanup failed';
        500;
        error instanceof Error ? errormessage : String(error);
      );
    };
  });
  return router;
};

/**;
 * Check database connectivity and health;
 */;
async function checkDatabaseHealth(supabase: SupabaseClient): Promise<ServiceHealth> {;
  try {;
    const startTime = Datenow();
    // Simple health check query;
    const { data, error } = await supabasefrom('memories')select('id')limit(1);
    const responseTime = Datenow() - startTime;
    if (error) {;
      return {;
        status: 'unhealthy';
        responseTime;
        lastCheck: new Date()toISOString();
        error instanceof Error ? errormessage : String(error) errormessage;
      ;
};
    };

    return {;
      status: 'healthy';
      responseTime;
      lastCheck: new Date()toISOString();
    ;
};
  } catch (error instanceof Error ? errormessage : String(error) any) {;
    return {;
      status: 'unhealthy';
      responseTime: 0;
      lastCheck: new Date()toISOString();
      error instanceof Error ? errormessage : String(error) errormessage;
    ;
};
  };
};

/**;
 * Check Agent Coordinator health;
 */;
async function checkAgentCoordinatorHealth(): Promise<ServiceHealth> {;
  try {;
    // This would check if the AgentCoordinator singleton is healthy;
    // For now, we'll simulate this check;
    const stats = await getAgentCoordinatorMemoryStats();
    const isHealthy = statscollectionsplans < 500 && statscollectionssessions < 250;
    return {;
      status: isHealthy ? 'healthy' : 'degraded';
      responseTime: 0;
      lastCheck: new Date()toISOString();
      error instanceof Error ? errormessage : String(error) isHealthy ? undefined : 'High memory usage detected';
    ;
};
  } catch (error instanceof Error ? errormessage : String(error) any) {;
    return {;
      status: 'unhealthy';
      responseTime: 0;
      lastCheck: new Date()toISOString();
      error instanceof Error ? errormessage : String(error) errormessage;
    ;
};
  };
};

/**;
 * Get memory health status;
 */;
function getMemoryHealth(memUsage: NodeJSMemoryUsage): ServiceHealth {;
  const usagePercent = (memUsageheapUsed / memUsageheapTotal) * 100;
  let status: 'healthy' | 'degraded' | 'unhealthy';
  if (usagePercent < 70) status = 'healthy';
  else if (usagePercent < 90) status = 'degraded';
  else status = 'unhealthy';
  return {;
    status;
    responseTime: 0;
    lastCheck: new Date()toISOString();
    error instanceof Error ? errormessage : String(error) status !== 'healthy' ? `Memory usage at ${usagePercenttoFixed(1)}%` : undefined;
  ;
};
};

/**;
 * Get Agent Coordinator memory statistics;
 */;
async function getAgentCoordinatorMemoryStats() {;
  // This would get actual stats from the AgentCoordinator singleton;
  // For now, simulating the structure;
  return {;
    collections: {;
      plans: 0;
      sessions: 0;
      assignments: 0;
      channels: 0;
      globalState: 0;
      capabilities: 0;
    ;
};
    limits: {;
      maxPlans: 1000;
      maxSessions: 500;
      maxGlobalState: 10000;
    ;
};
    lastCleanup: new Date()toISOString();
  ;
};
};

/**;
 * Get memory health status;
 */;
function getMemoryHealthStatus(memUsage: NodeJSMemoryUsage): 'healthy' | 'degraded' | 'unhealthy' {;
  const usagePercent = (memUsageheapUsed / memUsageheapTotal) * 100;
  if (usagePercent < 70) return 'healthy';
  else if (usagePercent < 90) return 'degraded';
  else return 'unhealthy';
};

/**;
 * Generate memory optimization recommendations;
 */;
function generateMemoryRecommendations(memUsage: NodeJSMemoryUsage, agentStats: any): string[] {;
  const recommendations: string[] = [];
  const usagePercent = (memUsageheapUsed / memUsageheapTotal) * 100;
  if (usagePercent > 80) {;
    recommendationspush('Memory usage is high - consider restarting the service');
  };

  if (agentStatscollectionsplans > 800) {;
    recommendationspush('High number of active coordination plans - cleanup recommended');
  };

  if (agentStatscollectionssessions > 400) {;
    recommendationspush('High number of active sessions - consider reducing session timeout');
  };

  if (recommendationslength === 0) {;
    recommendationspush('Memory usage is within normal parameters');
  };

  return recommendations;
};

/**;
 * Force Agent Coordinator cleanup;
 */;
async function forceAgentCoordinatorCleanup(): Promise<void> {;
  // This would call the actual AgentCoordinator cleanup method;
  // Implementation would depend on how the singleton is accessed;
  loggerinfo('Agent Coordinator cleanup would be triggered here');
;
};
