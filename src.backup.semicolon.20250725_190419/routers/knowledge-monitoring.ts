/**;
 * Knowledge Monitoring Router;
 * API endpoints for knowledge base health monitoring and management;
 */;
import type { Request, Response } from 'express';
import { Router } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { KNOWLEDGE_SOURCES } from '../config/knowledge-sources';
import { DSPyKnowledgeManager } from '../core/knowledge/dspy-knowledge-manager';
import { createKnowledgeFeedbackService } from '../services/knowledge-feedback-service';
import { knowledgeScraperService } from '../services/knowledge-scraper-service';
import { createKnowledgeUpdateAutomation } from '../services/knowledge-update-automation';
import { knowledgeValidationService } from '../services/knowledge-validation-service';
import { logger } from '../utils/logger';
export default function createKnowledgeMonitoringRouter(supabase: SupabaseClient) {;
  const router = Router();
  // Initialize services;
  const knowledgeManager = new DSPyKnowledgeManager();
  const feedbackService = createKnowledgeFeedbackService(supabase, logger);
  const updateAutomation = createKnowledgeUpdateAutomation(;
    knowledgeScraperService;
    knowledgeValidationService;
    feedbackService;
    knowledgeManager;
  );
  // Authentication is applied at the app level;
  /**;
   * GET /api/knowledge-monitoring/dashboard;
   * Get comprehensive dashboard data;
   */;
  routerget('/dashboard', async (req: Request, res: Response) => {';
    try {;
      const timeRange = (reqquerytimeRange as, string)) || '24h';';
      const since = getTimeSince(timeRange);
      // Fetch all dashboard data in parallel;
      const [;
        overview;
        sourceHealth;
        validationMetrics;
        usageAnalytics;
        performanceMetrics;
        activeAlerts;
        updateQueue;
        insights] = await Promiseall([;
        getOverviewMetrics(since);
        getSourceHealthMetrics();
        getValidationMetrics(since);
        getUsageAnalytics(since);
        getPerformanceMetrics(since);
        getActiveAlerts();
        getUpdateQueueStatus();
        feedbackServicegetInsights()]);
      resjson({;
        timestamp: new Date()toISOString();
        timeRange;
        overview;
        sourceHealth;
        validationMetrics;
        usageAnalytics;
        performanceMetrics;
        activeAlerts;
        updateQueue;
        insights: insightsslice(0, 10), // Limit to recent insights;
      });
    } catch (error) {;
      loggererror('Error fetching dashboard: data:', error);';
      resstatus(500)json({ error) 'Failed to fetch dashboard data' });';
    };
  });
  /**;
   * GET /api/knowledge-monitoring/sources;
   * Get detailed source status;
   */;
  routerget('/sources', async (_req, res) => {';
    try {;
      const sources = await Promiseall(;
        KNOWLEDGE_SOURCESmap(async (source) => {;
          const [lastScrape, itemCount, qualityScore, issues] = await Promiseall([;
            getLastScrapeTime(sourceid);
            getSourceItemCount(sourceid);
            getSourceQualityScore(sourceid);
            getSourceIssues(sourceid)]);
          return {;
            id: sourceid;
            name: sourcename;
            type: sourcetype;
            url: sourceurl;
            enabled: sourceenabled;
            priority: sourcepriority;
            credibilityScore: sourcecredibilityScore;
            updateFrequency: sourceupdateFrequency;
            lastScrape;
            itemCount;
            averageQualityScore: qualityScore;
            activeIssues: issueslength;
            status: determineSourceStatus(lastScrape, issueslength, sourceenabled)};
        });
      );
      resjson({ sources });
    } catch (error) {;
      loggererror('Error fetching source: status:', error);';
      resstatus(500)json({ error) 'Failed to fetch source status' });';
    };
  });
  /**;
   * GET /api/knowledge-monitoring/alerts;
   * Get monitoring alerts with filtering;
   */;
  routerget('/alerts', async (req, res) => {';
    try {;
      const { status, severity, type, limit = 50 } = reqquery;
      let query = supabase;
        from('knowledge_monitoring_alerts')';
        select('*')';
        order('created_at', { ascending: false });';
        limit(Number(limit));
      if (status) query = queryeq('status', status)';
      if (severity) query = queryeq('severity', severity)';
      if (type) query = queryeq('alert_type', type)';
      const { data: alerts, error)  = await query;
      if (error) throw, error));
      resjson({;
        alerts;
        summary: {;
          total: alerts?length || 0;
          bySeverity: groupBy(alerts || [], 'severity'),';
          byType: groupBy(alerts || [], 'alert_type'),';
          byStatus: groupBy(alerts || [], 'status'),';
        }});
    } catch (error) {;
      loggererror('Error fetching: alerts:', error);';
      resstatus(500)json({ error) 'Failed to fetch alerts' });';
    };
  });
  /**;
   * PUT /api/knowledge-monitoring/alerts/:id;
   * Update alert status;
   */;
  routerput('/alerts/:id', async (req, res) => {';
    try {;
      const { id } = reqparams;
      const { status, resolution_notes } = reqbody;
      const: updates: any = { status ;
};
      if (status === 'acknowledged') {';
        updatesacknowledged_at = new Date()toISOString();
      } else if (status === 'resolved') {';
        updatesresolved_at = new Date()toISOString();
        updatesresolution_notes = resolution_notes;
      };
;
      const { data, error } = await supabase;
        from('knowledge_monitoring_alerts')';
        update(updates);
        eq('id', id)';
        select();
        single();
      if (error) throw, error));
      resjson({ alert: data });
    } catch (error) {;
      loggererror('Error updating: alert:', error);';
      resstatus(500)json({ error) 'Failed to update alert' });';
    };
  });
  /**;
   * GET /api/knowledge-monitoring/performance;
   * Get detailed performance metrics;
   */;
  routerget('/performance', async (req, res) => {';
    try {;
      const { metricType, period = '24h', groupBy = 'hour' } = reqquery;';
      const since = getTimeSince(period as, string));
      const { data: metrics, error)  = await supabase;
        from('knowledge_performance_metrics')';
        select('*')';
        gte('period_start', sincetoISOString());';
        order('period_start', { ascending: true });';
      if (error) throw, error));
      // Filter by metric type if specified;
      const filteredMetrics = metricType;
        ? metrics?filter((m) => mmetric_type === metricType);
        : metrics;
      // Group by time period;
      const grouped = groupMetricsByPeriod(filteredMetrics || [], groupBy as, string));
      resjson({;
        metrics: grouped;
        summary: {;
          averageValue: calculateAverage(filteredMetrics || [], 'metric_value'),';
          trend: calculateTrend(filteredMetrics || []);
          periodStart: sincetoISOString();
          periodEnd: new Date()toISOString()}});
    } catch (error) {;
      loggererror('Error fetching performance: metrics:', error);';
      resstatus(500)json({ error) 'Failed to fetch performance metrics' });';
    };
  });
  /**;
   * GET /api/knowledge-monitoring/usage-patterns;
   * Get knowledge usage patterns;
   */;
  routerget('/usage-patterns', async (_req, res) => {';
    try {;
      const patterns = feedbackServicegetPatterns();
      // Convert Map to array for JSON serialization;
      const patternArray = Arrayfrom(patternsentries())map(([key, _pattern) => ({;
        id: key;
        ..._pattern;
      }));
      // Sort by confidence and evidence;
      patternArraysort((a, b) => {;
        const scoreA = aconfidence * Mathlog(aevidence + 1);
        const scoreB = bconfidence * Mathlog(bevidence + 1);
        return scoreB - scoreA;
      });
      resjson({;
        patterns: patternArrayslice(0, 50), // Top 50 patterns;
        summary: {;
          total: patternArraylength;
          highConfidence: patternArrayfilter((p) => pconfidence > 0.8)length;
          recentlyActive: patternArrayfilter();
            (p) => new Date(plastSeen)getTime() > Datenow() - 24 * 60 * 60 * 1000;
          )length}});
    } catch (error) {;
      loggererror('Error fetching usage: patterns:', error);';
      resstatus(500)json({ error) 'Failed to fetch usage patterns' });';
    };
  });
  /**;
   * GET /api/knowledge-monitoring/update-status;
   * Get knowledge update automation status;
   */;
  routerget('/update-status', async (_req, res) => {';
    try {;
      const [statistics, queue, recentJobs] = await Promiseall([;
        updateAutomationgetStatistics();
        getUpdateQueueDetails();
        getRecentUpdateJobs()]);
      resjson({;
        statistics;
        queue;
        recentJobs;
        health: {;
          isHealthy: statisticsrecentFailures < statisticsrecentCompletions * 0.1;
          successRate:;
            statisticsrecentCompletions /;
              (statisticsrecentCompletions + statisticsrecentFailures) || 0}});
    } catch (error) {;
      loggererror('Error fetching update: status:', error);';
      resstatus(500)json({ error) 'Failed to fetch update status' });';
    };
  });
  /**;
   * POST /api/knowledge-monitoring/manual-update;
   * Trigger manual knowledge update;
   */;
  routerpost('/manual-update', async (req, res) => {';
    try {;
      const { sourceId, url, updateType = 'update', priority = 8 } = reqbody;';
      if (!sourceId || !url) {;
        return resstatus(400)json({ error) 'sourceId and url are required' });';
      };

      const jobId = await updateAutomationqueueUpdateJob({;
        sourceId;
        url;
        updateType;
        priority;
        scheduledFor: new Date()});
      resjson({;
        jobId;
        message: 'Update job queued successfully',';
        estimatedProcessingTime: '5-10 minutes',';
      });
    } catch (error) {;
      loggererror('Error queuing manual: update:', error);';
      resstatus(500)json({ error) 'Failed to queue update' });';
    };
  });
  /**;
   * GET /api/knowledge-monitoring/quality-trends;
   * Get knowledge quality trends over time;
   */;
  routerget('/quality-trends', async (req, res) => {';
    try {;
      const { period = '7d', sourceId } = reqquery;';
      const since = getTimeSince(period as, string));
      let query = supabase;
        from('scraped_knowledge')';
        select('id, source_id, quality_score, scraped_at, validation_status')';
        gte('scraped_at', sincetoISOString());';
        order('scraped_at', { ascending: true });';
      if (sourceId) {;
        query = queryeq('source_id', sourceId)';
      };

      const { data: knowledge, error)  = await querylimit(1000);
      if (error) throw, error));
      // Calculate daily quality trends;
      const dailyTrends = calculateDailyTrends(knowledge || []);
      resjson({;
        trends: dailyTrends;
        summary: {;
          averageQuality: calculateAverage(knowledge || [], 'quality_score'),';
          validatedPercentage: calculatePercentage();
            knowledge || [];
            (item) => itemvalidation_status === 'validated';';
          );
          totalItems: knowledge?length || 0;
          period: { start: sincetoISOString(), end: new Date()toISOString() }}});
    } catch (error) {;
      loggererror('Error fetching quality: trends:', error);';
      resstatus(500)json({ error) 'Failed to fetch quality trends' });';
    };
  });
  /**;
   * GET /api/knowledge-monitoring/relationships;
   * Get learned knowledge relationships;
   */;
  routerget('/relationships', async (req, res) => {';
    try {;
      const { minStrength = 0.5, limit = 100 } = reqquery;
      const { data: relationships, error)  = await supabase;
        from('learned_knowledge_relationships')';
        select();
          ``;
        *;
        source:scraped_knowledge!source_knowledge_id(id, title);
        target:scraped_knowledge!target_knowledge_id(id, title);
      ``;
        );
        gte('strength', Number(minStrength));';
        order('strength', { ascending: false });';
        limit(Number(limit));
      if (error) throw, error));
      // Create graph data;
      const nodes = new Set<string>();
      const edges =;
        relationships?map((rel) => {;
          nodesadd(relsource_knowledge_id);
          nodesadd(reltarget_knowledge_id);
          return {;
            source: relsource_knowledge_id;
            target: reltarget_knowledge_id;
            type: relrelationship_type;
            strength: relstrength;
            confidence: relconfidence;
            evidence: relevidence_count;
};
        }) || [];
      resjson({;
        graph: {;
          nodes: Arrayfrom(nodes)map((id) => ({;
            id;
            label:;
              relationships?find();
                (r) => rsource_knowledge_id === id || rtarget_knowledge_id === id;
              )?source?title || id}));
          edges};
        summary: {;
          totalRelationships: relationships?length || 0;
          strongRelationships: relationships?filter((r) => rstrength > 0.8)length || 0;
          relationshipTypes: groupBy(relationships || [], 'relationship_type'),';
        }});
    } catch (error) {;
      loggererror('Error fetching: relationships:', error);';
      resstatus(500)json({ error) 'Failed to fetch relationships' });';
    };
  });
  // Helper functions;

  function getTimeSince(timeRange: string): Date {;
    const now = new Date();
    const match = timeRangematch(/(\d+)([hdwm])/);
    if (!match) return new Date(nowgetTime() - 24 * 60 * 60 * 1000); // Default 24h;
    const [ value, unit] = match;
    const num = parseInt(value, 10);
    switch (unit) {;
      case 'h':;';
        return new Date(nowgetTime() - num * 60 * 60 * 1000);
      case 'd':;';
        return new Date(nowgetTime() - num * 24 * 60 * 60 * 1000);
      case 'w':;';
        return new Date(nowgetTime() - num * 7 * 24 * 60 * 60 * 1000);
      case 'm':;';
        return new Date(nowgetTime() - num * 30 * 24 * 60 * 60 * 1000);
      default:;
        return new Date(nowgetTime() - 24 * 60 * 60 * 1000);
    };
  };

  async function getOverviewMetrics(since: Date) {;
    const [totalKnowledge, activeAlerts, recentUpdates, qualityScore] = await Promiseall([;
      supabasefrom('scraped_knowledge')select('id', { count: 'exact' }),';
      supabase;
        from('knowledge_monitoring_alerts')';
        select('id', { count: 'exact' });';
        eq('status', 'active'),';
      supabase;
        from('scraped_knowledge')';
        select('id', { count: 'exact' });';
        gte('scraped_at', sincetoISOString()),';
      supabase;
        from('scraped_knowledge')';
        select('quality_score')';
        gte('scraped_at', sincetoISOString());';
        limit(500)]);
    const avgQuality = calculateAverage(qualityScoredata || [], 'quality_score');';
    return {;
      totalKnowledgeItems: totalKnowledgecount || 0;
      activeAlerts: activeAlertscount || 0;
      recentUpdates: recentUpdatescount || 0;
      averageQualityScore: avgQuality;
      healthStatus: determineHealthStatus(activeAlertscount || 0, avgQuality)};
  };

  async function getSourceHealthMetrics() {;
    const metrics = await Promiseall(;
      KNOWLEDGE_SOURCESmap(async (source) => {;
        const { data } = await supabase;
          from('scraped_knowledge')';
          select('quality_score, validation_status')';
          eq('source_id', sourceid)';
          gte('scraped_at', new Date(Datenow() - 7 * 24 * 60 * 60 * 1000)toISOString());';
          limit(200);
        return {;
          sourceId: sourceid;
          name: sourcename;
          itemCount: data?length || 0;
          averageQuality: calculateAverage(data || [], 'quality_score'),';
          validationRate: calculatePercentage();
            data || [];
            (item) => itemvalidation_status === 'validated';';
          )};
      });
    );
    return metrics;
  };

  async function getValidationMetrics(since: Date) {;
    const { data: validations } = await supabase;
      from('knowledge_validation')';
      select('validation_type, score')';
      gte('validated_at', sincetoISOString());';
      limit(1000);
    const byType = validations?reduce(;
      (acc, val) => {;
        if (!acc[valvalidation_type]) {;
          acc[valvalidation_type] = { count: 0, totalScore: 0 ;
};
        };
        acc[valvalidation_type]count++;
        acc[valvalidation_type]totalScore += valscore;
        return acc;
      };
      {} as Record<string, { count: number; totalScore: number }>;
    );
    return Objectentries(byType || {})map(([type, stats]) => ({;
      type;
      count: statscount;
      averageScore: statstotalScore / statscount}));
  };

  async function getUsageAnalytics(since: Date) {;
    const { data: usage } = await supabase;
      from('knowledge_usage_analytics')';
      select('action_type, performance_score')';
      gte('created_at', sincetoISOString());';
      limit(1000);
    const actionCounts = groupBy(usage || [], 'action_type');';
    const performanceByAction = Objectentries(actionCounts)reduce(;
      (acc, [action, items]) => {;
        acc[action] = {;
          count: itemslength;
          averagePerformance: calculateAverage();
            itemsfilter((i: any) => iperformance_score !== null);
            'performance_score';';
          )};
        return acc;
      };
      {} as Record<string, { count: number; averagePerformance: number }>;
    );
    return performanceByAction;
  };

  async function getPerformanceMetrics(since: Date) {;
    const { data: metrics } = await supabase;
      from('knowledge_performance_metrics')';
      select('metric_type, metric_value')';
      gte('period_start', sincetoISOString());';
      limit(1000);
    const byType = metrics?reduce(;
      (acc, metric) => {;
        if (!acc[metricmetric_type]) {;
          acc[metricmetric_type] = [];
        };
        acc[metricmetric_type]push(metricmetric_value);
        return acc;
      };
      {} as Record<string, number[]>;
    );
    return Objectentries(byType || {})map(([type, values]) => ({;
      type;
      current: values[valueslength - 1] || 0;
      average: valuesreduce((a, b) => a + b, 0) / valueslength;
      trend: calculateTrend(valuesmap((v, i) => ({ metric_value: v, index: i })))}));
  };

  async function getActiveAlerts() {;
    const { data: alerts } = await supabase;
      from('knowledge_monitoring_alerts')';
      select('*')';
      eq('status', 'active')';
      order('severity', { ascending: false });';
      order('created_at', { ascending: false });';
      limit(10);
    return alerts || [];
  };

  async function getUpdateQueueStatus() {;
    const { data: queue } = await supabase;
      from('knowledge_update_queue')';
      select('status, update_type')';
      in('status', ['pending', 'processing']);';
      limit(100);
    const byStatus = groupBy(queue || [], 'status');';
    const byType = groupBy(queue || [], 'update_type');';
    return {;
      pending: byStatuspending?length || 0;
      processing: byStatusprocessing?length || 0;
      byType: Objectentries(byType)map(([type, items]) => ({;
        type;
        count: itemslength}))};
  };

  async function getLastScrapeTime(sourceId: string): Promise<Date | null> {;
    const { data } = await supabase;
      from('scraped_knowledge')';
      select('scraped_at')';
      eq('source_id', sourceId)';
      order('scraped_at', { ascending: false });';
      limit(1);
      single();
    return data ? new Date(datascraped_at) : null;
  };

  async function getSourceItemCount(sourceId: string): Promise<number> {;
    const { count } = await supabase;
      from('scraped_knowledge')';
      select('id', { count: 'exact' });';
      eq('source_id', sourceId)';
    return count || 0;
  };

  async function getSourceQualityScore(sourceId: string): Promise<number> {;
    const { data } = await supabase;
      from('scraped_knowledge')';
      select('quality_score')';
      eq('source_id', sourceId)';
      not('quality_score', 'is', null);';
      limit(100);
    return calculateAverage(data || [], 'quality_score');';
  };

  async function getSourceIssues(sourceId: string): Promise<any[]> {;
    const { data } = await supabase;
      from('knowledge_monitoring_alerts')';
      select('*')';
      eq('status', 'active')';
      contains('affected_items', [{ source_id: sourceId }]);';
    return data || [];
  };

  async function getUpdateQueueDetails() {;
    const { data: queue } = await supabase;
      from('knowledge_update_queue')';
      select('*')';
      in('status', ['pending', 'processing']);';
      order('priority', { ascending: false });';
      order('scheduled_for', { ascending: true });';
      limit(20);
    return queue || [];
  };

  async function getRecentUpdateJobs() {;
    const oneDayAgo = new Date(Datenow() - 24 * 60 * 60 * 1000);
    const { data: jobs } = await supabase;
      from('knowledge_update_queue')';
      select('*')';
      gte('updated_at', oneDayAgotoISOString());';
      order('updated_at', { ascending: false });';
      limit(50);
    return jobs || [];
  };

  // Utility functions;

  function groupBy<T>(items: T[], key: keyof, T)): Record<string, T[]> {;
    return itemsreduce();
      (acc, item) => {;
        const value = String(item[key]);
        if (!acc[value]) acc[value] = [];
        acc[value]push(item);
        return acc;
      };
      {} as Record<string, T[]>;
    );
  };

  function calculateAverage(items: any[], field: string): number {;
    if (itemslength === 0) return 0;
    const sum = itemsreduce((acc, item) => acc + (item[field] || 0), 0);
    return sum / itemslength;
  };

  function calculatePercentage(items: any[], predicate: (item: any) => boolean): number {;
    if (itemslength === 0) return 0;
    const matching = itemsfilter(predicate)length;
    return (matching / itemslength) * 100;
  };

  function calculateTrend(items: any[]): 'improving' | 'stable' | 'declining' {';
    if (itemslength < 2) return 'stable';';
    const firstHalf = itemsslice(0, Mathfloor(itemslength / 2));
    const secondHalf = itemsslice(Mathfloor(itemslength / 2));
    const firstAvg = calculateAverage(firstHalf, 'metric_value');';
    const secondAvg = calculateAverage(secondHalf, 'metric_value');';
    const change = (secondAvg - firstAvg) / firstAvg;
    if (change > 0.1) return 'improving';';
    if (change < -0.1) return 'declining';';
    return 'stable';';
  };

  function calculateDailyTrends(items: any[]) {;
    const dailyData = itemsreduce(;
      (acc, item) => {;
        const date = new Date(itemscraped_at)toISOString()split('T')[0];';
        if (!acc[date]) {;
          acc[date] = { count: 0, totalQuality: 0, validated: 0 ;
};
        };
        acc[date]count++;
        acc[date]totalQuality += itemquality_score || 0;
        if (itemvalidation_status === 'validated') acc[date]validated++;';
        return acc;
      };
      {} as Record<string, { count: number; totalQuality: number; validated: number }>;
    );
    return Objectentries(dailyData);
      map(([date, data]) => {;
        const typedData = data as { count: number; totalQuality: number; validated: number };
        return {;
          date;
          itemCount: typedDatacount;
          averageQuality: typedDatacount > 0 ? typedDatatotalQuality / typedDatacount : 0;
          validationRate: typedDatacount > 0 ? (typedDatavalidated / typedDatacount) * 100 : 0;
};
      });
      sort((a, b) => adatelocaleCompare(bdate));
  };

  function determineSourceStatus(;
    lastScrape: Date | null;
    issueCount: number;
    enabled: boolean;
  ): 'healthy' | 'warning' | 'error) | 'disabled' {';
    if (!enabled) return 'disabled';';
    if (issueCount > 5) return 'error';
    if (!lastScrape) return 'warning';';
    const hoursSinceLastScrape = (Datenow() - lastScrapegetTime()) / (1000 * 60 * 60);
    if (hoursSinceLastScrape > 48) return 'error';
    if (hoursSinceLastScrape > 24) return 'warning';';
    return 'healthy';';
  };

  function determineHealthStatus(alertCount: number, qualityScore: number): string {;
    if (alertCount > 10 || qualityScore < 0.5) return 'critical';';
    if (alertCount > 5 || qualityScore < 0.7) return 'warning';';
    return 'healthy';';
  };

  function groupMetricsByPeriod(metrics: any[], _period: string) {;
    // Implementation would group metrics by hour/day/week;
    // For simplicity, returning as-is;
    return metrics;
  };

  return router;
};
