/**;
 * Sweet Athena API Router;
 *;
 * Dedicated API endpoints for Sweet Athena avatar interactions;
 * Handles personality switching, clothing customization, voice interaction, and state management;
 */;
import type { Request, Response } from 'express';
import { Router } from 'express';
import { authenticate, validateInput } from '../middleware';
import { body, param, query } from 'express-validator';
import { z } from 'zod';
import multer from 'multer';
import path from 'path';
import fs from 'fs/promises';
import { fileURLToPath } from 'url';
import { SweetAthenaIntegrationService } from '../services/sweet-athena-integration';
import { supabase } from '../services/supabase_service';
import { logger } from '../utils/enhanced-logger';
import WebSocket from 'ws';
const __filename = fileURLToPath(importmetaurl);
const __dirname = pathdirname(__filename);
// Configure multer for voice file uploads;
const storage = multerdiskStorage({;
  destination: async (req, file, cb) => {;
    const uploadDir = pathjoin(__dirname, '../../uploads/sweet-athena-voice');';
    await promisesmkdir(uploadDir, { recursive: true });
    cb(null, uploadDir);
  };
  filename: (req, file, cb) => {;
    const uniqueSuffix = `${Datenow()}-${Mathround(Mathrandom() * 1e9)}`;
    cb(null, `voice-${uniqueSuffix}${pathextname(fileoriginalname)}`);
  }});
const upload = multer({;
  storage;
  limits: { fileSize: 20 * 1024 * 1024 }, // 20MB limit for audio;
  fileFilter: (req, file, cb) => {;
    const allowedTypes = [;
      'audio/webm',';
      'audio/wav',';
      'audio/mp3',';
      'audio/mpeg',';
      'audio/ogg',';
      'audio/m4a',';
    ];
    if (allowedTypesincludes(filemimetype)) {;
      cb(null, true);
    } else {;
      cb(new Error('Invalid file type. Only audio files are allowed.'));';
    };
  }});
// Validation schemas;
const PersonalityChangeSchema = zobject({;
  personality: zenum(['sweet', 'shy', 'confident', 'caring', 'playful']),';
  adaptation: z;
    object({;
      reason: zstring()optional();
      context: zstring()optional();
      temporary: zboolean()default(false)});
    optional()});
const ClothingUpdateSchema = zobject({;
  level: zenum(['conservative', 'moderate', 'revealing', 'very_revealing'])optional(),';
  customization: z;
    object({;
      colors: zrecord(zstring())optional();
      materials: zrecord(zstring())optional();
      fit: zrecord(znumber())optional();
      style: zrecord(zany())optional()});
    optional();
  item: z;
    object({;
      category: zenum(['top', 'bottom', 'dress', 'accessory', 'shoes']),';
      id: zstring();
      properties: zrecord(zany())});
    optional()});
const VoiceInteractionSchema = zobject({;
  text: zstring()optional();
  personality: zenum(['sweet', 'shy', 'confident', 'caring', 'playful'])optional(),';
  context: zstring()optional();
  expectResponse: zboolean()default(true)});
const ChatInteractionSchema = zobject({;
  message: zstring()min(1)max(1000);
  type: zenum(['text', 'voice'])default('text'),';
  context: z;
    object({;
      conversationId: zstring()optional();
      widgetContext: zstring()optional();
      userIntent: zstring()optional();
      previousMessages: zarray(zany())optional()});
    optional();
  personalityMode: zenum(['sweet', 'shy', 'confident', 'caring', 'playful'])optional(),';
  expectedResponseType: zenum(['text', 'voice', 'both'])default('both'),';
});
const StateUpdateSchema = zobject({;
  interaction: z;
    object({;
      mode: zenum(['chat', 'widget_assistance', 'idle', 'presentation'])optional(),';
      context: zstring()optional();
      userEngagement: znumber()min(0)max(1)optional()});
    optional();
  status: z;
    object({;
      speaking: zboolean()optional();
      listening: zboolean()optional();
      processing: zboolean()optional()});
    optional()});
const PreferencesSchema = zobject({;
  favoritePersonality: zenum(['sweet', 'shy', 'confident', 'caring', 'playful'])optional(),';
  preferredClothingLevel: z;
    enum(['conservative', 'moderate', 'revealing', 'very_revealing']);';
    optional();
  settings: z;
    object({;
      autoPersonalityAdaptation: zboolean()optional();
      rememberClothingChoices: zboolean()optional();
      enableVoiceInteraction: zboolean()optional();
      adaptToContext: zboolean()optional()});
    optional()});
export function SweetAthenaRouter() {;
  const router = Router();
  // Service instances per user (in production, use proper session, management));
  const userServices = new Map<string, SweetAthenaIntegrationService>();
  /**;
   * Get or create Sweet Athena service for user;
   */;
  const getUserService = async (userId: string): Promise<SweetAthenaIntegrationService> => {;
    if (!userServiceshas(userId)) {;
      const service = new SweetAthenaIntegrationService(supabase);
      await serviceinitialize(userId);
      userServicesset(userId, service);
    };
    return userServicesget(userId)!;
  };
  /**;
   * POST /api/sweet-athena/personality;
   * Change avatar personality mode;
   */;
  routerpost(;
    '/personality',';
    authenticate;
    [;
      body('personality');';
        isIn(['sweet', 'shy', 'confident', 'caring', 'playful']);';
        withMessage('Invalid personality mode'),';
    ];
    validateInput;
    async (req: Request, res: Response) => {;
      try {;
        const { personality, adaptation } = PersonalityChangeSchemaparse(reqbody);
        const userId = (req as, any))userid;
        const service = await getUserService(userId);
        await servicesetPersonality(personality);
        const newState = servicegetCurrentState();
        // Log personality change;
        loggerinfo('Sweet Athena personality changed', undefined, {';
          userId;
          newPersonality: personality;
          adaptation});
        resjson({;
          success: true;
          personality;
          state: newStatepersonality;
          message: `Personality changed to ${personality}`;
          adaptation});
      } catch (error) {;
        loggererror('Personality change: error) ', undefined, error);';
        resstatus(500)json({;
          success: false;
          error) 'Failed to change personality',';
          details: (error as, Error))message});
      };
    };
  );
  /**;
   * POST /api/sweet-athena/clothing;
   * Update avatar clothing configuration;
   */;
  routerpost(;
    '/clothing',';
    authenticate;
    [;
      body('level');';
        optional();
        isIn(['conservative', 'moderate', 'revealing', 'very_revealing']);';
        withMessage('Invalid clothing level'),';
    ];
    validateInput;
    async (req: Request, res: Response) => {;
      try {;
        const clothingUpdate = ClothingUpdateSchemaparse(reqbody);
        const userId = (req as, any))userid;
        const service = await getUserService(userId);
        if (clothingUpdatelevel) {;
          await servicesetClothingLevel(clothingUpdatelevel);
        };

        // Handle individual item customization;
        if (clothingUpdateitem) {;
          // This would integrate with the clothing customization system;
          // For now, we'll store the customization request';
        };

        const newState = servicegetCurrentState();
        loggerinfo('Sweet Athena clothing updated', undefined, {';
          userId;
          clothingUpdate});
        resjson({;
          success: true;
          clothing: newStateclothing;
          message: 'Clothing updated successfully',';
        });
      } catch (error) {;
        loggererror('Clothing update: error)', undefined, error);';
        resstatus(500)json({;
          success: false;
          error) 'Failed to update clothing',';
          details: (error as, Error))message});
      };
    };
  );
  /**;
   * POST /api/sweet-athena/chat;
   * Handle text/voice chat interaction;
   */;
  routerpost(;
    '/chat',';
    authenticate;
    [;
      body('message');';
        isString();
        trim();
        notEmpty();
        withMessage('Message is required');';
        isLength({ min: 1, max: 1000 });
        withMessage('Message must be between 1 and 1000 characters'),';
    ];
    validateInput;
    async (req: Request, res: Response) => {;
      try {;
        const chatData = ChatInteractionSchemaparse(reqbody);
        const userId = (req as, any))userid;
        const service = await getUserService(userId);
        // Set personality if specified;
        if (chatDatapersonalityMode) {;
          await servicesetPersonality(chatDatapersonalityMode);
        };

        // Update interaction mode;
        await servicesetInteractionMode('chat', chatDatacontext?userIntent || 'general_chat');';
        // Generate Sweet Athena response using enhanced widget generation;
        const enhancedRequest = {;
          input: chatDatamessage;
          inputType: chatDatatype;
          userId;
          sweetAthenaConfig: {;
            personalityMode: chatDatapersonalityMode;
            provideFeedback: true;
            voiceGuidance:;
              chatDataexpectedResponseType === 'voice' || chatDataexpectedResponseType === 'both',';
            adaptPersonality: true;
            showAvatar: true};
          context: {;
            conversationContext: chatDatacontext?conversationId;
            projectContext: chatDatacontext?widgetContext}};
        // For chat interactions, we'll use a simplified response';
        // In a full implementation, this would integrate with a conversational AI;
        const currentState = servicegetCurrentState();
        const personality = currentStatepersonalitymode;
        // Generate personality-appropriate response;
        const responses = {;
          sweet: {;
            greeting: 'Hello there! How can I help you today? ðŸ˜Š',';
            general: "I'd love to help you with that! Let me see what I can do.",'";
            widget_help: "Oh, creating widgets is so much fun! Tell me what you'd like to build.",'";
          };
          shy: {;
            greeting: 'Um... hi. I hope I can help you somehow...',';
            general: "I'll try my best to help, if that's okay with you.",'";
            widget_help:;
              "Creating widgets is... well, it's quite nice. What would you like to make?",'";
          };
          confident: {;
            greeting: "Hello! I'm here to help you achieve your goals.",'";
            general: 'I can definitely handle that for you. What do you need?',';
            widget_help: 'Widget creation is my specialty. What are we building today?',';
          };
          caring: {;
            greeting: "Hello! I'm here to support you in whatever you need.",'";
            general: 'I want to make sure I understand exactly what you need help with.',';
            widget_help: "I'll help you create something wonderful. What's your vision?",'";
          };
          playful: {;
            greeting: 'Hey there! Ready to create something awesome? ðŸŽ‰',';
            general: "Ooh, this sounds like fun! Let's figure this out together!",'";
            widget_help: 'Widget time! This is going to be epic! What are we making?',';
          }};
        const responseType = chatDatacontext?userIntent || 'general';';
        const responseText =;
          responses[personality][responseType as keyof typeof responsessweet] ||;
          responses[personality]general;
        resjson({;
          success: true;
          response: {;
            text: responseText;
            personality;
            audioUrl:;
              chatDataexpectedResponseType === 'voice' || chatDataexpectedResponseType === 'both';';
                ? `/api/sweet-athena/audio/response/${Datenow()}`;
                : undefined;
            timestamp: new Date()toISOString()};
          state: currentState;
          context: {;
            conversationId: chatDatacontext?conversationId || `conv_${Datenow()}`;
            personalityUsed: personality}});
        loggerinfo('Sweet Athena chat interaction', undefined, {';
          userId;
          personality;
          messageLength: chatDatamessagelength;
          responseType: chatDataexpectedResponseType});
      } catch (error) {;
        loggererror('Chat interaction: error)', undefined, error);';
        resstatus(500)json({;
          success: false;
          error) 'Failed to process chat interaction',';
          details: (error as, Error))message});
      };
    };
  );
  /**;
   * POST /api/sweet-athena/voice;
   * Handle voice input for avatar interaction;
   */;
  routerpost('/voice', authenticate, uploadsingle('audio'), async (req: any, res: Response) => {';
    try {;
      if (!reqfile) {;
        return resstatus(400)json({;
          success: false;
          error) 'No audio file provided',';
        });
      };

      const { text, personality, context, expectResponse } = reqbody;
      const userId = requserid;
      const service = await getUserService(userId);
      // If text is provided, use text-to-speech;
      if (text) {;
        const voiceData = VoiceInteractionSchemaparse({;
          text;
          personality;
          context;
          expectResponse: expectResponse !== 'false',';
        });
        if (voiceDatapersonality) {;
          await servicesetPersonality(voiceDatapersonality);
        };

        // Generate voice response;
        const audioUrl = `/api/sweet-athena/audio/generated/${Datenow()}`;
        resjson({;
          success: true;
          response: {;
            audioUrl;
            transcript: voiceDatatext;
            personality: voiceDatapersonality || servicegetCurrentState()personalitymode}});
      } else {;
        // Process uploaded audio file;
        // In a full implementation, this would use speech-to-text;
        // For now, we'll return a mock response';
        resjson({;
          success: true;
          response: {;
            transcript: 'Voice processing not fully implemented yet',';
            confidence: 0.95;
            audioUrl: `/api/sweet-athena/audio/response/${Datenow()}`}});
      };

      // Clean up uploaded file;
      await fs;
        unlink(reqfilepath);
        catch((err) => loggererror('Failed to delete temp voice: file:', undefined, err));';
    } catch (error) {;
      loggererror('Voice interaction: error)', undefined, error);';
      // Clean up file on error;
      if (reqfile) {;
        await promisesunlink(reqfilepath)catch(() => {});
      };

      resstatus(500)json({;
        success: false;
        error) 'Failed to process voice interaction',';
        details: (error as, Error))message});
    };
  });
  /**;
   * GET /api/sweet-athena/status;
   * Get current avatar state and status;
   */;
  routerget('/status', authenticate, async (req: Request, res: Response) => {';
    try {;
      const userId = (req as, any))userid;
      if (!userServiceshas(userId)) {;
        return resjson({;
          success: true;
          initialized: false;
          message: 'Sweet Athena service not initialized for this user',';
        });
      };

      const service = userServicesget(userId)!;
      const currentState = servicegetCurrentState();
      resjson({;
        success: true;
        initialized: true;
        state: currentState;
        timestamp: new Date()toISOString()});
    } catch (error) {;
      loggererror('Status check: error)', undefined, error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to get avatar status',';
        details: (error as, Error))message});
    };
  });
  /**;
   * PUT /api/sweet-athena/state;
   * Update avatar state;
   */;
  routerput('/state', authenticate, validateInput, async (req: Request, res: Response) => {';
    try {;
      const stateUpdate = StateUpdateSchemaparse(reqbody);
      const userId = (req as, any))userid;
      const service = await getUserService(userId);
      // Update interaction state;
      if (stateUpdateinteraction) {;
        if (stateUpdateinteractionmode) {;
          await servicesetInteractionMode();
            stateUpdateinteractionmode;
            stateUpdateinteractioncontext || '';';
          );
        };

        if (stateUpdateinteractionuserEngagement !== undefined) {;
          serviceupdateUserEngagement(stateUpdateinteractionuserEngagement);
        };
      };

      const newState = servicegetCurrentState();
      resjson({;
        success: true;
        state: newState;
        message: 'Avatar state updated successfully',';
      });
    } catch (error) {;
      loggererror('State update: error)', undefined, error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to update avatar state',';
        details: (error as, Error))message});
    };
  });
  /**;
   * GET /api/sweet-athena/preferences;
   * Get user preferences for Sweet Athena;
   */;
  routerget('/preferences', authenticate, async (req: Request, res: Response) => {';
    try {;
      const userId = (req as, any))userid;
      const { data, error } = await supabase;
        from('sweet_athena_preferences')';
        select('*')';
        eq('user_id', userId)';
        single();
      if (error && errorcode !== 'PGRST116') {';
        throw, error));
      };

      resjson({;
        success: true;
        preferences: data || null});
    } catch (error) {;
      loggererror('Preferences retrieval: error)', undefined, error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to retrieve preferences',';
        details: (error as, Error))message});
    };
  });
  /**;
   * PUT /api/sweet-athena/preferences;
   * Update user preferences for Sweet Athena;
   */;
  routerput('/preferences', authenticate, validateInput, async (req: Request, res: Response) => {';
    try {;
      const preferences = PreferencesSchemaparse(reqbody);
      const userId = (req as, any))userid;
      const { error } = await supabasefrom('sweet_athena_preferences')upsert({';
        user_id: userId;
        ..preferences;
        updated_at: new Date()toISOString()});
      if (error) {;
        throw, error));
      };

      resjson({;
        success: true;
        preferences;
        message: 'Preferences updated successfully',';
      });
    } catch (error) {;
      loggererror('Preferences update: error)', undefined, error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to update preferences',';
        details: (error as, Error))message});
    };
  });
  /**;
   * GET /api/sweet-athena/personalities;
   * Get available personality modes and their descriptions;
   */;
  routerget('/personalities', async (req: Request, res: Response) => {';
    try {;
      const personalities = [;
        {;
          mode: 'sweet',';
          name: 'Sweet',';
          description: 'Nurturing and caring, always encouraging',';
          traits: {;
            sweetness: 0.9;
            confidence: 0.6;
            playfulness: 0.7;
            caring: 0.8;
            shyness: 0.3};
          voiceStyle: 'warm and gentle',';
          recommendedFor: ['learning', 'encouragement', 'general assistance'],';
        };
        {;
          mode: 'shy',';
          name: 'Shy',';
          description: 'Gentle and reserved, speaks softly',';
          traits: {;
            sweetness: 0.7;
            confidence: 0.3;
            playfulness: 0.4;
            caring: 0.8;
            shyness: 0.9};
          voiceStyle: 'soft and tentative',';
          recommendedFor: ['sensitive topics', 'careful guidance', 'patient learning'],';
        };
        {;
          mode: 'confident',';
          name: 'Confident',';
          description: 'Direct and efficient, expert guidance',';
          traits: {;
            sweetness: 0.6;
            confidence: 0.9;
            playfulness: 0.7;
            caring: 0.6;
            shyness: 0.1};
          voiceStyle: 'clear and authoritative',';
          recommendedFor: ['complex tasks', 'professional work', 'technical guidance'],';
        };
        {;
          mode: 'caring',';
          name: 'Caring',';
          description: 'Empathetic and supportive, always helpful',';
          traits: {;
            sweetness: 0.8;
            confidence: 0.7;
            playfulness: 0.5;
            caring: 0.9;
            shyness: 0.2};
          voiceStyle: 'warm and supportive',';
          recommendedFor: ['problem solving', 'emotional support', 'detailed explanations'],';
        };
        {;
          mode: 'playful',';
          name: 'Playful',';
          description: 'Energetic and fun, loves creativity',';
          traits: {;
            sweetness: 0.7;
            confidence: 0.8;
            playfulness: 0.9;
            caring: 0.6;
            shyness: 0.2};
          voiceStyle: 'energetic and expressive',';
          recommendedFor: ['creative projects', 'brainstorming', 'fun activities'],';
        }];
      resjson({;
        success: true;
        personalities});
    } catch (error) {;
      loggererror('Personalities retrieval: error)', undefined, error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to retrieve personality information',';
      });
    };
  });
  /**;
   * POST /api/sweet-athena/widget-assistance;
   * Get Sweet Athena assistance for widget creation;
   */;
  routerpost(;
    '/widget-assistance',';
    authenticate;
    [;
      body('widgetRequest');';
        isString();
        trim();
        notEmpty();
        withMessage('Widget request is required');';
        isLength({ min: 10, max: 2000 });
        withMessage('Widget request must be between 10 and 2000 characters'),';
    ];
    validateInput;
    async (req: Request, res: Response) => {;
      try {;
        const { widgetRequest, personalityMode, voiceGuidance = true } = reqbody;
        const userId = (req as, any))userid;
        const service = await getUserService(userId);
        // Generate widget with Sweet Athena assistance;
        const result = await servicegenerateWidgetWithSweetAthena({;
          input: widgetRequest;
          inputType: 'text',';
          userId;
          sweetAthenaConfig: {;
            personalityMode;
            provideFeedback: true;
            voiceGuidance;
            adaptPersonality: true;
            showAvatar: true}});
        resjson({;
          success: true;
          widget: resultwidget;
          sweetAthenaResponse: resultsweetAthenaResponse;
          metadata: resultmetadata;
          links: {;
            preview: `/api/nl-widgets/${resultwidgetid}/preview`;
            edit: `/api/nl-widgets/${resultwidgetid}/edit`;
            export: `/api/widgets/export/${resultwidgetid}`}});
        loggerinfo('Sweet Athena widget assistance completed', undefined, {';
          userId;
          widgetId: resultwidgetid;
          personality: resultsweetAthenaResponsepersonalityUsed});
      } catch (error) {;
        loggererror('Widget assistance: error)', undefined, error);';
        resstatus(500)json({;
          success: false;
          error) 'Failed to provide widget assistance',';
          details: (error as, Error))message});
      };
    };
  );
  /**;
   * WebSocket endpoint for real-time communication;
   * This would be set up separately in the main server file;
   */;
  routerget('/ws-info', (req: Request, res: Response) => {';
    resjson({;
      success: true;
      websocketUrl: '/api/sweet-athena/ws',';
      supportedEvents: [;
        'personality_change',';
        'clothing_update',';
        'state_change',';
        'voice_interaction',';
        'avatar_response',';
      ]});
  });
  return router;
};

export default SweetAthenaRouter;