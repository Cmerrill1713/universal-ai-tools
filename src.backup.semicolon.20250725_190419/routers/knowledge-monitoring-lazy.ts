/**;
 * Knowledge Monitoring Router with Lazy Initialization;
 * API endpoints for knowledge base health monitoring and management;
 */;

import type { Request, Response } from 'express';
import { Router } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { logger } from '../utils/logger';
import { initializeWithTimeout } from '../utils/timeout-utils';
// Lazy-loaded services;
let knowledgeManager: any = null;
let feedbackService: any = null;
let updateAutomation: any = null;
let knowledgeScraperService: any = null;
let knowledgeValidationService: any = null;
let servicesInitialized = false;
let initializationPromise: Promise<boolean> | null = null;
async function initializeServices(supabase: SupabaseClient): Promise<boolean> {;
  if (servicesInitialized) return true;
  // Return existing promise if initialization is already in progress;
  if (initializationPromise) return initializationPromise;
  initializationPromise = (async () => {;
    try {;
      loggerinfo('Lazy loading knowledge monitoring services...');
      // Import services;
      const [;
        { DSPyKnowledgeManager };
        { createKnowledgeFeedbackService };
        knowledgeScraperModule;
        { createKnowledgeUpdateAutomation };
        knowledgeValidationModule;
      ] = await Promiseall([;
        import('../core/knowledge/dspy-knowledge-manager');
        import('../services/knowledge-feedback-service');
        import('../services/knowledge-scraper-service');
        import('../services/knowledge-update-automation');
        import('../services/knowledge-validation-service');
      ]);
      knowledgeScraperService = knowledgeScraperModuleknowledgeScraperService;
      knowledgeValidationService = knowledgeValidationModuleknowledgeValidationService;
      // Initialize services with timeout protection;
      knowledgeManager = await initializeWithTimeout(;
        async () => new DSPyKnowledgeManager({});
        'DSPyKnowledgeManager';
        5000;
      );
      feedbackService = await initializeWithTimeout(;
        async () => createKnowledgeFeedbackService(supabase, logger);
        'KnowledgeFeedbackService';
        5000;
      );
      if (knowledgeManager && feedbackService) {;
        updateAutomation = await initializeWithTimeout(;
          async () =>;
            createKnowledgeUpdateAutomation(;
              knowledgeScraperService;
              knowledgeValidationService;
              feedbackService;
              knowledgeManager;
            );
          'KnowledgeUpdateAutomation';
          5000;
        );
      };

      servicesInitialized = !!(knowledgeManager && feedbackService && updateAutomation);
      return servicesInitialized;
    } catch (error) {;
      loggererror('Failed to initialize knowledge monitoring services:', {;
        error instanceof Error ? errormessage : String(error)  error instanceof Error ? errormessage : String(error);
      });
      return false;
    };
  })();
  return initializationPromise;
};

// Helper function to ensure services are initialized;
async function ensureServicesInitialized(;
  supabase: SupabaseClient;
  res: Response;
): Promise<boolean> {;
  if (!servicesInitialized) {;
    const initialized = await initializeServices(supabase);
    if (!initialized) {;
      resstatus(503)json({;
        error instanceof Error ? errormessage : String(error) 'Knowledge monitoring services are not available';
        message: 'The service is still initializing or failed to start';
      });
      return false;
    };
  };
  return true;
};

// Time range helper;
function getTimeSince(timeRange: string): Date {;
  const now = new Date();
  const ranges: Record<string, number> = {;
    '1h': 60 * 60 * 1000;
    '6h': 6 * 60 * 60 * 1000;
    '24h': 24 * 60 * 60 * 1000;
    '7d': 7 * 24 * 60 * 60 * 1000;
    '30d': 30 * 24 * 60 * 60 * 1000;
  ;
};
  const offset = ranges[timeRange] || ranges['24h'];
  return new Date(nowgetTime() - offset);
};

export default function createKnowledgeMonitoringRouter(supabase: SupabaseClient) {;
  const router = Router();
  /**;
   * GET /api/knowledge-monitoring/status;
   * Get service initialization status;
   */;
  routerget('/status', async (req: Request, res: Response) => {;
    resjson({;
      initialized: servicesInitialized;
      services: {;
        knowledgeManager: !!knowledgeManager;
        feedbackService: !!feedbackService;
        updateAutomation: !!updateAutomation;
      ;
};
    });
  });
  /**;
   * GET /api/knowledge-monitoring/dashboard;
   * Get comprehensive dashboard data;
   */;
  routerget('/dashboard', async (req: Request, res: Response) => {;
    if (!(await ensureServicesInitialized(supabase, res))) return;
    try {;
      const timeRange = (reqquerytimeRange as string) || '24h';
      const since = getTimeSince(timeRange);
      // Fetch all dashboard data in parallel;
      const [;
        overview;
        sourceHealth;
        validationMetrics;
        usageAnalytics;
        performanceMetrics;
        activeAlerts;
        updateQueue;
        insights;
      ] = await Promiseall([;
        feedbackServicegetSystemOverview(since);
        feedbackServicegetSourceHealthMetrics(since);
        knowledgeValidationServicegetValidationMetrics(since);
        feedbackServicegetUsageAnalytics(since);
        knowledgeManagergetPerformanceMetrics();
        knowledgeValidationServicegetActiveAlerts();
        updateAutomationgetUpdateQueue();
        feedbackServicegenerateInsights();
      ]);
      resjson({;
        timestamp: new Date()toISOString();
        timeRange;
        overview;
        sourceHealth;
        validationMetrics;
        usageAnalytics;
        performanceMetrics;
        activeAlerts;
        updateQueue;
        insights;
      });
    } catch (error) {;
      loggererror('Dashboard data fetch failed:', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Failed to fetch dashboard data';
        details: error instanceof Error ? errormessage : 'Unknown error';
      });
    };
  });
  // Add other routes similarly with lazy initialization checks...;
  // (Keeping the router small for this example, but all routes should follow this pattern;

  return router;
};
