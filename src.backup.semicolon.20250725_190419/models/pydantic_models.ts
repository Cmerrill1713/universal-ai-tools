/**;
 * Pydantic-style Models for Universal AI Tools Memory System;
 * Provides structured data validation, serialization, and type safety;
 */;

import { z } from 'zod';
// ============================================;
// ENUMS AND CONSTANTS;
// ============================================;

export enum MemoryType {;
  USER_INTERACTION = 'user_interaction';
  TECHNICAL_NOTE = 'technical_note';
  PROJECT_UPDATE = 'project_update';
  ANALYSIS_RESULT = 'analysis_result';
  SYSTEM_EVENT = 'system_event';
  LEARNING_INSIGHT = 'learning_insight';
  ERROR_LOG = 'error_log';
  PERFORMANCE_METRIC = 'performance_metric';
};

export enum SearchStrategy {;
  BALANCED = 'balanced';
  PRECISION = 'precision';
  RECALL = 'recall';
  SPEED = 'speed';
  PRIORITY = 'priority';
};

export enum ImportanceLevel {;
  CRITICAL = 'critical';
  HIGH = 'high';
  MEDIUM = 'medium';
  LOW = 'low';
  MINIMAL = 'minimal';
};

export enum EmbeddingProvider {;
  OPENAI = 'openai';
  OLLAMA = 'ollama';
  MOCK = 'mock';
};

// ============================================;
// BASE MODELS;
// ============================================;

export class BaseModel {;
  id?: string;
  createdAt?: Date;
  updatedAt?: Date;
  /**;
   * Convert to plain object for JSON serialization;
   */;
  toDict(): Record<string, unknown> {;
    const obj: Record<string, unknown> = {};
    Objectkeys(this)forEach((key) => {;
      const value = (this as any)[key];
      if (value !== undefined) {;
        obj[key] = value;
      };
    });
    return obj;
  };

  /**;
   * Create from plain object with validation;
   */;
  static fromDict<T extends BaseModel>(this: new () => T, data: Record<string, unknown>): T {;
    const instance = new this();
    Objectassign(instance, data);
    return instance;
  };
};

// ============================================;
// MEMORY MODELS;
// ============================================;

export class MemoryMetadata {;
  priority?: string;
  category?: string;
  tags?: string[];
  source?: string;
  confidence?: number;
  additionalData?: Record<string, unknown>;
  test?: boolean;
;
};

export class EntityExtraction {;
  text: string;
  type: string;
  confidence: number;
  startIndex?: number;
  endIndex?: number;
  metadata?: Record<string, unknown>;
  constructor(text?: string, type?: string, confidence?: number) {;
    thistext = text || '';
    thistype = type || '';
    thisconfidence = confidence || 0;
  ;
};
};
;
export class ConceptAnalysis {;
  concept: string;
  relevance: number;
  relatedConcepts?: string[];
  category?: string;
  constructor(concept?: string, relevance?: number) {;
    thisconcept = concept || '';
    thisrelevance = relevance || 0;
  ;
};
};
;
export class ContextualEnrichment {;
  entities: EntityExtraction[];
  concepts: ConceptAnalysis[];
  intent?: string;
  sentiment?: string;
  urgency?: string;
  temporalContext?: {;
    timeReferences?: string[];
    timeframe?: string;
    deadline?: Date;
  ;
};
  spatialContext?: {;
    locations?: string[];
    geography?: string;
  ;
};
  constructor() {;
    thisentities = [];
    thisconcepts = [];
  };
};
;
export class MemoryModel extends BaseModel {;
  contentstring;
  serviceId: string;
  memoryType: MemoryType;
  memoryCategory?: string;
  importanceScore: number;
  embedding?: number[];
  keywords?: string[];
  relatedEntities?: Record<string, unknown>;
  metadata?: MemoryMetadata;
  enrichment?: ContextualEnrichment;
  accessCount?: number;
  lastAccessed?: Date;
  constructor(;
    content string;
    serviceId?: string;
    memoryType?: MemoryType;
    importanceScore?: number;
  ) {;
    super();
    thiscontent content| '';
    thisserviceId = serviceId || '';
    thismemoryType = memoryType || MemoryTypeUSER_INTERACTION;
    thisimportanceScore = importanceScore || 0.5;
  };

  /**;
   * Get importance level based on score;
   */;
  get importanceLevel(): ImportanceLevel {;
    if (thisimportanceScore >= 0.9) return ImportanceLevelCRITICAL;
    if (thisimportanceScore >= 0.7) return ImportanceLevelHIGH;
    if (thisimportanceScore >= 0.5) return ImportanceLevelMEDIUM;
    if (thisimportanceScore >= 0.3) return ImportanceLevelLOW;
    return ImportanceLevelMINIMAL;
  };

  /**;
   * Check if memory contains specific entities;
   */;
  hasEntity(entityType: string): boolean {;
    return thisenrichment?entitiessome((e) => etype === entityType) ?? false;
  };

  /**;
   * Get entities of specific type;
   */;
  getEntitiesByType(entityType: string): EntityExtraction[] {;
    return thisenrichment?entitiesfilter((e) => etype === entityType) ?? [];
  };
};

// ============================================;
// SEARCH MODELS;
// ============================================;

export class SearchOptions {;
  query: string;
  similarityThreshold?: number = 0.7;
  maxResults?: number = 20;
  agentFilter?: string;
  categoryFilter?: string;
  excludeIds?: string[];
  searchStrategy?: SearchStrategy = SearchStrategyBALANCED;
  enableContextualEnrichment?: boolean = true;
  enableMultiStage?: boolean = true;
  enableUtilityRanking?: boolean = true;
  contextualFactors?: {;
    urgency?: string;
    sessionContext?: string;
    userPreferences?: Record<string, unknown>;
  };
  constructor(query?: string) {;
    thisquery = query || '';
  ;
};
};
;
export class SearchResult {;
  memory: MemoryModel;
  similarity: number;
  utilityScore?: number;
  contextualRelevance?: number;
  searchMethod?: string;
  rankingFactors?: {;
    recency: number;
    frequency: number;
    importance: number;
    similarity: number;
  ;
};
  constructor(memory?: MemoryModel, similarity?: number) {;
    thismemory = memory || new MemoryModel();
    thissimilarity = similarity || 0;
  ;
};

  /**;
   * Get composite score combining similarity and utility;
   */;
  get compositeScore(): number {;
    if (thisutilityScore !== undefined) {;
      return thissimilarity * 0.7 + thisutilityScore * 0.3;
    };
    return thissimilarity;
  };
};

export class SearchMetrics {;
  totalSearchTime: number;
  clusterSearchTime?: number;
  detailSearchTime?: number;
  clustersEvaluated?: number;
  memoriesEvaluated?: number;
  cacheHit?: boolean;
  searchStrategy?: string;
  constructor(totalSearchTime?: number) {;
    thistotalSearchTime = totalSearchTime || 0;
  ;
};
};
;
export class SearchResponse {;
  results: SearchResult[];
  metrics: SearchMetrics;
  queryEnrichment?: ContextualEnrichment;
  searchStrategy?: string;
  utilityRankingApplied?: boolean;
  constructor(results?: SearchResult[], metrics?: SearchMetrics) {;
    thisresults = results || [];
    thismetrics = metrics || new SearchMetrics();
  ;
};
};

// ============================================;
// EMBEDDING MODELS;
// ============================================;
;
export class EmbeddingConfig {;
  provider: EmbeddingProvider;
  model?: string;
  dimensions?: number;
  baseUrl?: string;
  apiKey?: string;
  maxBatchSize?: number;
  timeout?: number;
  constructor(provider?: EmbeddingProvider) {;
    thisprovider = provider || EmbeddingProviderMOCK;
  ;
};
};
;
export class EmbeddingResponse {;
  embedding: number[];
  dimensions: number;
  model: string;
  processingTime?: number;
  fromCache?: boolean;
  constructor(embedding?: number[], dimensions?: number, model?: string) {;
    thisembedding = embedding || [];
    thisdimensions = dimensions || 0;
    thismodel = model || '';
  ;
};
};

// ============================================;
// SYSTEM MODELS;
// ============================================;
;
export class SystemHealth {;
  healthy: boolean;
  service: string;
  version?: string;
  details?: {;
    database?: boolean;
    embeddings?: boolean;
    cache?: boolean;
    [key: string]: any;
  ;
};
  warnings?: string[];
  errors?: string[];
  timestamp: Date;
  constructor(healthy?: boolean, service?: string) {;
    thishealthy = healthy || false;
    thisservice = service || '';
    thistimestamp = new Date();
  ;
};
};
;
export class PerformanceMetrics {;
  totalMemories: number;
  memoriesWithEmbeddings: number;
  averageSearchTime?: number;
  cacheHitRate?: number;
  totalClusters?: number;
  resourceUsage?: {;
    memoryMB?: number;
    cpuPercent?: number;
    diskMB?: number;
  ;
};
  constructor(totalMemories?: number, memoriesWithEmbeddings?: number) {;
    thistotalMemories = totalMemories || 0;
    thismemoriesWithEmbeddings = memoriesWithEmbeddings || 0;
  ;
};
};

// ============================================;
// USER FEEDBACK MODELS;
// ============================================;
;
export class UserFeedback {;
  memoryId: string;
  agentName: string;
  relevance?: number;
  helpfulness?: number;
  accuracy?: number;
  tags?: string[];
  comments?: string;
  timestamp: Date;
  constructor(memoryId?: string, agentName?: string) {;
    thismemoryId = memoryId || '';
    thisagentName = agentName || '';
    thistimestamp = new Date();
  ;
};
};

// ============================================;
// ZOD SCHEMAS (for runtime validation);
// ============================================;
;
export const MemorySchema = zobject({;
  id: zstring()uuid()optional();
  contentzstring()min(1)max(10000);
  serviceId: zstring()min(1);
  memoryType: znativeEnum(MemoryType);
  memoryCategory: zstring()optional();
  importanceScore: znumber()min(0)max(1);
  embedding: zarray(znumber())optional();
  keywords: zarray(zstring())optional();
  relatedEntities: zrecord(zany())optional();
  metadata: z;
    object({;
      priority: zstring()optional();
      category: zstring()optional();
      tags: zarray(zstring())optional();
      source: zstring()optional();
      confidence: znumber()optional();
      additionalData: zrecord(zany())optional();
      test: zboolean()optional();
    });
    optional();
  accessCount: znumber()min(0)optional();
  lastAccessed: zdate()optional();
  createdAt: zdate()optional();
  updatedAt: zdate()optional();
});
export const SearchOptionsSchema = zobject({;
  query: zstring()min(1);
  similarityThreshold: znumber()min(0)max(1)default(0.7);
  maxResults: znumber()min(1)max(100)default(20);
  agentFilter: zstring()optional();
  categoryFilter: zstring()optional();
  excludeIds: zarray(zstring()uuid())optional();
  searchStrategy: znativeEnum(SearchStrategy)default(SearchStrategyBALANCED);
  enableContextualEnrichment: zboolean()default(true);
  enableMultiStage: zboolean()default(true);
  enableUtilityRanking: zboolean()default(true);
  contextualFactors: z;
    object({;
      urgency: zstring()optional();
      sessionContext: zstring()optional();
      userPreferences: zrecord(zany())optional();
    });
    optional();
});
export const EntityExtractionSchema = zobject({;
  text: zstring()min(1);
  type: zstring()min(1);
  confidence: znumber()min(0)max(1);
  startIndex: znumber()optional();
  endIndex: znumber()optional();
  metadata: zrecord(zany())optional();
});
export const ConceptAnalysisSchema = zobject({;
  concept: zstring()min(1);
  relevance: znumber()min(0)max(1);
  relatedConcepts: zarray(zstring())optional();
  category: zstring()optional();
});
export const ContextualEnrichmentSchema = zobject({;
  entities: zarray(EntityExtractionSchema);
  concepts: zarray(ConceptAnalysisSchema);
  intent: zstring()optional();
  sentiment: zstring()optional();
  urgency: zstring()optional();
  temporalContext: z;
    object({;
      timeReferences: zarray(zstring())optional();
      timeframe: zstring()optional();
      deadline: zdate()optional();
    });
    optional();
  spatialContext: z;
    object({;
      locations: zarray(zstring())optional();
      geography: zstring()optional();
    });
    optional();
});
export const SearchResultSchema = zobject({;
  memory: MemorySchema;
  similarity: znumber()min(0)max(1);
  utilityScore: znumber()min(0)max(1)optional();
  contextualRelevance: znumber()min(0)max(1)optional();
  searchMethod: zstring()optional();
  rankingFactors: z;
    object({;
      recency: znumber();
      frequency: znumber();
      importance: znumber();
      similarity: znumber();
    });
    optional();
});
export const SearchMetricsSchema = zobject({;
  totalSearchTime: znumber()min(0);
  clusterSearchTime: znumber()min(0)optional();
  detailSearchTime: znumber()min(0)optional();
  clustersEvaluated: znumber()min(0)optional();
  memoriesEvaluated: znumber()min(0)optional();
  cacheHit: zboolean()optional();
  searchStrategy: zstring()optional();
});
export const SearchResponseSchema = zobject({;
  results: zarray(SearchResultSchema);
  metrics: SearchMetricsSchema;
  queryEnrichment: ContextualEnrichmentSchemaoptional();
  searchStrategy: zstring()optional();
  utilityRankingApplied: zboolean()optional();
});
export const EmbeddingConfigSchema = zobject({;
  provider: znativeEnum(EmbeddingProvider);
  model: zstring()optional();
  dimensions: znumber()min(1)max(4096)optional();
  baseUrl: zstring()url()optional();
  apiKey: zstring()optional();
  maxBatchSize: znumber()min(1)max(100)optional();
  timeout: znumber()min(0)optional();
});
export const EmbeddingResponseSchema = zobject({;
  embedding: zarray(znumber());
  dimensions: znumber()min(1);
  model: zstring();
  processingTime: znumber()min(0)optional();
  fromCache: zboolean()optional();
});
export const SystemHealthSchema = zobject({;
  healthy: zboolean();
  service: zstring()min(1);
  version: zstring()optional();
  details: z;
    object({;
      database: zboolean()optional();
      embeddings: zboolean()optional();
      cache: zboolean()optional();
    });
    catchall(zany());
    optional();
  warnings: zarray(zstring())optional();
  errors: zarray(zstring())optional();
  timestamp: zdate();
});
export const PerformanceMetricsSchema = zobject({;
  totalMemories: znumber()min(0);
  memoriesWithEmbeddings: znumber()min(0);
  averageSearchTime: znumber()min(0)optional();
  cacheHitRate: znumber()min(0)max(1)optional();
  totalClusters: znumber()min(0)optional();
  resourceUsage: z;
    object({;
      memoryMB: znumber()optional();
      cpuPercent: znumber()optional();
      diskMB: znumber()optional();
    });
    optional();
});
export const UserFeedbackSchema = zobject({;
  memoryId: zstring()uuid();
  agentName: zstring()min(1);
  relevance: znumber()min(1)max(5)optional();
  helpfulness: znumber()min(1)max(5)optional();
  accuracy: znumber()min(1)max(5)optional();
  tags: zarray(zstring())optional();
  comments: zstring()max(1000)optional();
  timestamp: zdate();
});
// ============================================;
// TYPE EXPORTS;
// ============================================;

export type MemoryData = zinfer<typeof MemorySchema>;
export type SearchOptionsData = zinfer<typeof SearchOptionsSchema>;
export type EntityExtractionData = zinfer<typeof EntityExtractionSchema>;
export type ConceptAnalysisData = zinfer<typeof ConceptAnalysisSchema>;
export type ContextualEnrichmentData = zinfer<typeof ContextualEnrichmentSchema>;
export type SearchResultData = zinfer<typeof SearchResultSchema>;
export type SearchMetricsData = zinfer<typeof SearchMetricsSchema>;
export type SearchResponseData = zinfer<typeof SearchResponseSchema>;
export type EmbeddingConfigData = zinfer<typeof EmbeddingConfigSchema>;
export type EmbeddingResponseData = zinfer<typeof EmbeddingResponseSchema>;
export type SystemHealthData = zinfer<typeof SystemHealthSchema>;
export type PerformanceMetricsData = zinfer<typeof PerformanceMetricsSchema>;
export type UserFeedbackData = zinfer<typeof UserFeedbackSchema>;
/**;
 * Utility functions for model validation and transformation;
 */;
export class ModelUtils {;
  /**;
   * Validate object against Zod schema;
   */;
  static validateWithZod<T>(;
    schema: zZodSchema<T>;
    data: unknown;
  ): { success: boolean; data?: T; error instanceof Error ? errormessage : String(error)  string } {;
    try {;
      const result = schemaparse(data);
      return { success: true, data: result };
    } catch (error) {;
      return {;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof zZodError ? errormessage : 'Validation failed';
      ;
};
    };
  };

  /**;
   * Create memory model with validation;
   */;
  static createMemory(data: Partial<MemoryData>): MemoryModel {;
    const validation = thisvalidateWithZod(MemorySchema, data);
    if (!validationsuccess) {;
      throw new Error(`Invalid memory data: ${validationerror instanceof Error ? errormessage : String(error));`;
    };

    const memory = new MemoryModel(;
      validationdata!content;
      validationdata!serviceId;
      validationdata!memoryType;
      validationdata!importanceScore;
    );
    Objectassign(memory, validationdata);
    return memory;
  };

  /**;
   * Create search options with validation;
   */;
  static createSearchOptions(data: Partial<SearchOptionsData>): SearchOptions {;
    const validation = thisvalidateWithZod(SearchOptionsSchema, data);
    if (!validationsuccess) {;
      throw new Error(`Invalid search options: ${validationerror instanceof Error ? errormessage : String(error));`;
    };

    const options = new SearchOptions(validationdata!query);
    Objectassign(options, validationdata);
    return options;
  };

  /**;
   * Create entity extraction with validation;
   */;
  static createEntityExtraction(data: Partial<EntityExtractionData>): EntityExtraction {;
    const validation = thisvalidateWithZod(EntityExtractionSchema, data);
    if (!validationsuccess) {;
      throw new Error(`Invalid entity extraction data: ${validationerror instanceof Error ? errormessage : String(error));`;
    };

    const entity = new EntityExtraction(;
      validationdata!text;
      validationdata!type;
      validationdata!confidence;
    );
    Objectassign(entity, validationdata);
    return entity;
  };

  /**;
   * Create concept _analysiswith validation;
   */;
  static createConceptAnalysis(data: Partial<ConceptAnalysisData>): ConceptAnalysis {;
    const validation = thisvalidateWithZod(ConceptAnalysisSchema, data);
    if (!validationsuccess) {;
      throw new Error(`Invalid concept _analysisdata: ${validationerror instanceof Error ? errormessage : String(error));`;
    };

    const concept = new ConceptAnalysis(validationdata!concept, validationdata!relevance);
    Objectassign(concept, validationdata);
    return concept;
  };

  /**;
   * Create search result with validation;
   */;
  static createSearchResult(data: Partial<SearchResultData>): SearchResult {;
    const validation = thisvalidateWithZod(SearchResultSchema, data);
    if (!validationsuccess) {;
      throw new Error(`Invalid search result data: ${validationerror instanceof Error ? errormessage : String(error));`;
    };

    const memoryData = validationdata!memory;
    const memory = thiscreateMemory(memoryData);
    const result = new SearchResult(memory, validationdata!similarity);
    Objectassign(result, validationdata);
    return result;
  };

  /**;
   * Create embedding config with validation;
   */;
  static createEmbeddingConfig(data: Partial<EmbeddingConfigData>): EmbeddingConfig {;
    const validation = thisvalidateWithZod(EmbeddingConfigSchema, data);
    if (!validationsuccess) {;
      throw new Error(`Invalid embedding config data: ${validationerror instanceof Error ? errormessage : String(error));`;
    };

    const config = new EmbeddingConfig(validationdata!provider);
    Objectassign(config, validationdata);
    return config;
  };

  /**;
   * Create system health with validation;
   */;
  static createSystemHealth(data: Partial<SystemHealthData>): SystemHealth {;
    const validation = thisvalidateWithZod(SystemHealthSchema, data);
    if (!validationsuccess) {;
      throw new Error(`Invalid system health data: ${validationerror instanceof Error ? errormessage : String(error));`;
    };

    const health = new SystemHealth(validationdata!healthy, validationdata!service);
    Objectassign(health, validationdata);
    return health;
  };

  /**;
   * Create user feedback with validation;
   */;
  static createUserFeedback(data: Partial<UserFeedbackData>): UserFeedback {;
    const validation = thisvalidateWithZod(UserFeedbackSchema, data);
    if (!validationsuccess) {;
      throw new Error(`Invalid user feedback data: ${validationerror instanceof Error ? errormessage : String(error));`;
    };

    const feedback = new UserFeedback(validationdata!memoryId, validationdata!agentName);
    Objectassign(feedback, validationdata);
    return feedback;
  };
};
