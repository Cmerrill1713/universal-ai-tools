/**;
 * Universal Agent Registry - Lazy Loading System;
 * Adapted from the trading platform's sophisticated agent management;
 */;

import type { BaseAgent } from './base_agent';
import { EventEmitter } from 'events';
import { agentCollaborationWS } from '../services/agent-collaboration-websocket';
export interface AgentDefinition {;
  name: string;
  category: AgentCategory;
  description: string;
  priority: number;
  className: string;
  modulePath: string;
  dependencies: string[];
  capabilities: string[];
  memoryEnabled: boolean;
  maxLatencyMs: number;
  retryAttempts: number;
;
};

export enum AgentCategory {;
  CORE = 'core';
  COGNITIVE = 'cognitive';
  UTILITY = 'utility';
  SPECIALIZED = 'specialized';
  PERSONAL = 'personal';
};

export interface AgentLoadingLock {;
  [agentName: string]: Promise<BaseAgent | null>;
;
};

export class UniversalAgentRegistry extends EventEmitter {;
  private agentDefinitions: Map<string, AgentDefinition> = new Map();
  private loadedAgents: Map<string, BaseAgent> = new Map();
  private agentUsage: Map<string, Date> = new Map();
  private loadingLocks: Map<string, Promise<BaseAgent | null>> = new Map();
  private memoryCoordinator: any;
  private supabase: any;
  private logger: any = console;
  constructor(memoryCoordinator?: any, supabase?: any) {;
    super();
    thismemoryCoordinator = memoryCoordinator;
    thissupabase = supabase;
    thisregisterCognitiveAgents();
    thisregisterPersonalAgents();
    thisloggerinfo(;
      `✅ Universal Agent Registry initialized with ${thisagentDefinitionssize} agent definitions`;
    );
  };

  /**;
   * Register the 10 cognitive agents for Universal AI Tools;
   */;
  private registerCognitiveAgents(): void {;
    const cognitiveAgents: AgentDefinition[] = [;
      {;
        name: 'planner';
        category: AgentCategoryCORE;
        description: 'Strategic task planning and decomposition with memory integration';
        priority: 1;
        className: 'EnhancedPlannerAgent';
        modulePath: './cognitive/enhanced_planner_agent';
        dependencies: [];
        capabilities: [;
          'task_planning';
          'goal_decomposition';
          'strategy_design';
          'memory_based_optimization';
        ];
        memoryEnabled: true;
        maxLatencyMs: 100;
        retryAttempts: 3;
      ;
};
      {;
        name: 'retriever';
        category: AgentCategoryCORE;
        description: 'Information gathering and context retrieval';
        priority: 1;
        className: 'RetrieverAgent';
        modulePath: './cognitive/retriever_agent';
        dependencies: [];
        capabilities: ['information_search', 'context_retrieval', 'knowledge_lookup'];
        memoryEnabled: true;
        maxLatencyMs: 200;
        retryAttempts: 2;
      ;
};
      {;
        name: 'devils_advocate';
        category: AgentCategoryCOGNITIVE;
        description: 'Critical analysis and risk assessment';
        priority: 2;
        className: 'DevilsAdvocateAgent';
        modulePath: './cognitive/devils_advocate_agent';
        dependencies: ['retriever'];
        capabilities: ['critical_analysis', 'risk_assessment', 'stress_testing'];
        memoryEnabled: true;
        maxLatencyMs: 150;
        retryAttempts: 2;
      ;
};
      {;
        name: 'evaluation_agent';
        category: AgentCategoryCOGNITIVE;
        description: 'Comprehensive quality assessment and performance validation';
        priority: 9;
        className: 'EvaluationAgent';
        modulePath: './cognitive/evaluation_agent';
        dependencies: ['retriever'];
        capabilities: ['evaluate_response', 'benchmark_agent', 'validate_output', 'compare_agents'];
        memoryEnabled: true;
        maxLatencyMs: 5000;
        retryAttempts: 2;
      ;
};
      {;
        name: 'synthesizer';
        category: AgentCategoryCOGNITIVE;
        description: 'Information integration and solution synthesis';
        priority: 2;
        className: 'SynthesizerAgent';
        modulePath: './cognitive/synthesizer_agent';
        dependencies: ['retriever', 'planner'];
        capabilities: ['information_synthesis', 'solution_integration', 'pattern_matching'];
        memoryEnabled: true;
        maxLatencyMs: 120;
        retryAttempts: 2;
      ;
};
      {;
        name: 'reflector';
        category: AgentCategoryCOGNITIVE;
        description: 'Self-assessment and learning optimization';
        priority: 3;
        className: 'ReflectorAgent';
        modulePath: './cognitive/reflector_agent';
        dependencies: ['synthesizer'];
        capabilities: ['self_assessment', 'learning_optimization', 'performance_analysis'];
        memoryEnabled: true;
        maxLatencyMs: 100;
        retryAttempts: 1;
      ;
};
      {;
        name: 'user_intent';
        category: AgentCategoryCORE;
        description: 'Understanding user goals and context';
        priority: 1;
        className: 'UserIntentAgent';
        modulePath: './cognitive/user_intent_agent';
        dependencies: [];
        capabilities: ['intent_recognition', 'goal_inference', 'context_understanding'];
        memoryEnabled: true;
        maxLatencyMs: 80;
        retryAttempts: 3;
      ;
};
      {;
        name: 'tool_maker';
        category: AgentCategorySPECIALIZED;
        description: 'Dynamic tool creation and customization';
        priority: 2;
        className: 'ToolMakerAgent';
        modulePath: './cognitive/tool_maker_agent';
        dependencies: ['planner', 'user_intent'];
        capabilities: ['tool_creation', 'code_generation', 'customization'];
        memoryEnabled: true;
        maxLatencyMs: 300;
        retryAttempts: 2;
      ;
};
      {;
        name: 'ethics';
        category: AgentCategoryCORE;
        description: 'Safety validation and compliance checking';
        priority: 2;
        className: 'EthicsAgent';
        modulePath: './cognitive/ethics_agent';
        dependencies: [];
        capabilities: ['safety_validation', 'compliance_checking', 'ethical_analysis'];
        memoryEnabled: true;
        maxLatencyMs: 100;
        retryAttempts: 3;
      ;
};
      {;
        name: 'resource_manager';
        category: AgentCategoryUTILITY;
        description: 'System resource optimization and monitoring';
        priority: 3;
        className: 'ResourceManagerAgent';
        modulePath: './cognitive/resource_manager_agent';
        dependencies: [];
        capabilities: ['resource_optimization', 'performance_monitoring', 'system_health'];
        memoryEnabled: false;
        maxLatencyMs: 50;
        retryAttempts: 1;
      ;
};
      {;
        name: 'orchestrator';
        category: AgentCategoryCORE;
        description: 'Central coordination and decision making';
        priority: 1;
        className: 'OrchestratorAgent';
        modulePath: './cognitive/orchestrator_agent';
        dependencies: ['planner', 'synthesizer', 'ethics'];
        capabilities: ['coordination', 'decision_making', 'consensus_building'];
        memoryEnabled: true;
        maxLatencyMs: 150;
        retryAttempts: 3;
      ;
};
      {;
        name: 'pydantic_ai';
        category: AgentCategoryCOGNITIVE;
        description: 'Type-safe AI interactions with structured validation';
        priority: 2;
        className: 'PydanticAIAgent';
        modulePath: './cognitive/pydantic_ai_agent';
        dependencies: ['user_intent'];
        capabilities: [;
          'structured_response';
          'validate_data';
          'cognitive_analysis';
          'task_planning';
          'code_generation';
        ];
        memoryEnabled: true;
        maxLatencyMs: 200;
        retryAttempts: 2;
      ;
};
    ];
    cognitiveAgentsforEach((agent) => {;
      thisagentDefinitionsset(agentname, agent);
    });
  };

  /**;
   * Register the personal productivity agents;
   */;
  private registerPersonalAgents(): void {;
    const personalAgents: AgentDefinition[] = [;
      {;
        name: 'personal_assistant';
        category: AgentCategoryPERSONAL;
        description:;
          'High-level personal AI assistant with vector memory for intelligent coordination';
        priority: 1;
        className: 'EnhancedPersonalAssistantAgent';
        modulePath: './personal/enhanced_personal_assistant_agent';
        dependencies: [;
          'calendar_agent';
          'photo_organizer';
          'file_manager';
          'code_assistant';
          'system_control';
          'web_scraper';
          'tool_maker';
        ];
        capabilities: [;
          'comprehensive_assistance';
          'smart_planning';
          'proactive_assistance';
          'memory_driven_intelligence';
        ];
        memoryEnabled: true;
        maxLatencyMs: 10000;
        retryAttempts: 3;
      ;
};
      {;
        name: 'calendar_agent';
        category: AgentCategoryPERSONAL;
        description: 'Intelligent calendar management and scheduling assistant';
        priority: 2;
        className: 'CalendarAgent';
        modulePath: './personal/calendar_agent';
        dependencies: ['ollama_assistant'];
        capabilities: ['create_event', 'find_free_time', 'analyze_schedule'];
        memoryEnabled: true;
        maxLatencyMs: 3000;
        retryAttempts: 2;
      ;
};
      {;
        name: 'photo_organizer';
        category: AgentCategoryPERSONAL;
        description:;
          'Intelligent photo organization with face recognition and ML-powered categorization';
        priority: 3;
        className: 'PhotoOrganizerAgent';
        modulePath: './personal/photo_organizer_agent';
        dependencies: ['ollama_assistant'];
        capabilities: ['organize_photos', 'detect_faces', 'find_duplicates', 'create_smart_albums'];
        memoryEnabled: true;
        maxLatencyMs: 10000;
        retryAttempts: 2;
      ;
};
      {;
        name: 'file_manager';
        category: AgentCategoryPERSONAL;
        description: 'Intelligent file and document management with automated organization';
        priority: 3;
        className: 'FileManagerAgent';
        modulePath: './personal/file_manager_agent';
        dependencies: ['ollama_assistant'];
        capabilities: ['organize_files', 'find_duplicates', 'analyzecontent', 'smart_search'];
        memoryEnabled: true;
        maxLatencyMs: 5000;
        retryAttempts: 2;
      ;
};
      {;
        name: 'code_assistant';
        category: AgentCategoryPERSONAL;
        description: 'Intelligent development workflow automation and code generation';
        priority: 2;
        className: 'CodeAssistantAgent';
        modulePath: './personal/code_assistant_agent';
        dependencies: ['ollama_assistant'];
        capabilities: ['generate_code', 'analyze_project', 'refactor_code', 'git_operations'];
        memoryEnabled: true;
        maxLatencyMs: 15000;
        retryAttempts: 2;
      ;
};
      {;
        name: 'system_control';
        category: AgentCategoryPERSONAL;
        description: 'macOS system integration and intelligent automation';
        priority: 3;
        className: 'SystemControlAgent';
        modulePath: './personal/system_control_agent';
        dependencies: ['ollama_assistant'];
        capabilities: ['system_status', 'app_control', 'system_preferences', 'automation'];
        memoryEnabled: true;
        maxLatencyMs: 5000;
        retryAttempts: 2;
      ;
};
      {;
        name: 'web_scraper';
        category: AgentCategoryPERSONAL;
        description: 'Intelligent web scraping, monitoring, and data extraction';
        priority: 4;
        className: 'WebScraperAgent';
        modulePath: './personal/web_scraper_agent';
        dependencies: ['ollama_assistant'];
        capabilities: ['scrape_website', 'monitor_website', 'apirequest'];
        memoryEnabled: true;
        maxLatencyMs: 10000;
        retryAttempts: 3;
      ;
};
      {;
        name: 'tool_maker';
        category: AgentCategoryPERSONAL;
        description: 'Dynamic tool creation and customization engine';
        priority: 4;
        className: 'ToolMakerAgent';
        modulePath: './personal/tool_maker_agent';
        dependencies: ['ollama_assistant'];
        capabilities: ['create_tool', 'generate_integration', 'create_workflow'];
        memoryEnabled: true;
        maxLatencyMs: 20000;
        retryAttempts: 2;
      ;
};
    ];
    personalAgentsforEach((agent) => {;
      thisagentDefinitionsset(agentname, agent);
    });
  };

  /**;
   * Get an agent, loading it lazily if needed;
   */;
  async getAgent(agentName: string): Promise<BaseAgent | null> {;
    // Return already loaded agent;
    if (thisloadedAgentshas(agentName)) {;
      thisagentUsageset(agentName, new Date());
      return thisloadedAgentsget(agentName)!;
    };

    // Check if agent definition exists;
    if (!thisagentDefinitionshas(agentName)) {;
      thisloggerwarn(`⚠️ Agent '${agentName}' not found in registry`);
      return null;
    };

    // Handle concurrent loading attempts;
    if (thisloadingLockshas(agentName)) {;
      return await thisloadingLocksget(agentName)!;
    };

    // Start loading process;
    const loadingPromise = thisloadAgent(agentName);
    thisloadingLocksset(agentName, loadingPromise);
    try {;
      const agent = await loadingPromise;
      if (agent) {;
        thisloadedAgentsset(agentName, agent);
        thisagentUsageset(agentName, new Date());
        thisloggerinfo(`✅ Lazy-loaded agent: ${agentName}`);
        thisemit('agent_loaded', { agentName, agent });
      };
      return agent;
    } finally {;
      thisloadingLocksdelete(agentName);
    };
  };

  /**;
   * Load a specific agent and its dependencies;
   */;
  private async loadAgent(agentName: string): Promise<BaseAgent | null> {;
    try {;
      const definition = thisagentDefinitionsget(agentName)!;
      // Load dependencies first;
      for (const depName of definitiondependencies) {;
        if (!thisloadedAgentshas(depName)) {;
          const depAgent = await thisgetAgent(depName);
          if (!depAgent) {;
            thisloggerwarn(`⚠️ Failed to load dependency '${depName}' for '${agentName}'`);
          };
        };
      };

      // Import and instantiate the agent;
      const AgentClass = await thisimportAgentClass(definition);
      if (!AgentClass) {;
        throw new Error(`Failed to import agent class: ${definitionclassName}`);
      };

      // Create agent configuration with autoLearn enabled;
      const config: any = {;
        name: definitionname;
        description: definitiondescription;
        priority: definitionpriority;
        capabilities: definitioncapabilitiesmap((cap) => ({;
          name: cap;
          description: `${cap} capability`;
          inputSchema: {;
};
          outputSchema: {;
};
        }));
        maxLatencyMs: definitionmaxLatencyMs;
        retryAttempts: definitionretryAttempts;
        dependencies: definitiondependencies;
        memoryEnabled: definitionmemoryEnabled;
        // Enable autoLearn for all agents to store conversations;
        autoLearn: true;
        useVectorMemory: true;
        memorySearchThreshold: 0.7;
        maxMemoryResults: 10;
      ;
};
      // Instantiate and initialize agent;
      let agent;
      if (definitioncategory === AgentCategoryPERSONAL) {;
        // Personal agents need supabase client;
        agent = new AgentClass(thissupabase);
      } else {;
        // Other agents use config;
        agent = new AgentClass(config);
      };
      await agentinitialize(thismemoryCoordinator);
      return agent;
    } catch (error) {;
      thisloggererror(`❌ Failed to load agent '${agentName}':`, error);
      return null;
    };
  };

  /**;
   * Dynamically import agent class;
   */;
  private async importAgentClass(definition: AgentDefinition): Promise<unknown> {;
    try {;
      // Import based on category and module path;
      if (definitioncategory === AgentCategoryPERSONAL) {;
        switch (definitionname) {;
          case 'personal_assistant': {;
            const { default: PersonalAssistantAgent } = await import(;
              './personal/personal_assistant_agent';
            );
            return PersonalAssistantAgent;
          };
          case 'calendar_agent': {;
            const { default: CalendarAgent } = await import('./personal/calendar_agent');
            return CalendarAgent;
          };
          case 'photo_organizer': {;
            const { default: PhotoOrganizerAgent } = await import(;
              './personal/photo_organizer_agent';
            );
            return PhotoOrganizerAgent;
          };
          case 'file_manager': {;
            const { default: FileManagerAgent } = await import('./personal/file_manager_agent');
            return FileManagerAgent;
          };
          case 'code_assistant': {;
            const { default: CodeAssistantAgent } = await import('./personal/code_assistant_agent');
            return CodeAssistantAgent;
          };
          case 'system_control': {;
            const { default: SystemControlAgent } = await import('./personal/system_control_agent');
            return SystemControlAgent;
          };
          case 'web_scraper': {;
            const { default: WebScraperAgent } = await import('./personal/web_scraper_agent');
            return WebScraperAgent;
          };
          case 'tool_maker': {;
            const { default: ToolMakerAgent } = await import('./personal/tool_maker_agent');
            return ToolMakerAgent;
          };
        };
      } else {;
        // Import cognitive agents;
        switch (definitionname) {;
          case 'planner': {;
            const { default: EnhancedPlannerAgent } = await import(;
              './cognitive/enhanced_planner_agent';
            );
            return EnhancedPlannerAgent;
          };
          case 'retriever': {;
            const { default: RetrieverAgent } = await import('./cognitive/retriever_agent');
            return RetrieverAgent;
          };
          case 'devils_advocate': {;
            const { default: DevilsAdvocateAgent } = await import(;
              './cognitive/devils_advocate_agent';
            );
            return DevilsAdvocateAgent;
          };
          case 'synthesizer': {;
            const { default: SynthesizerAgent } = await import('./cognitive/synthesizer_agent');
            return SynthesizerAgent;
          };
          case 'reflector': {;
            const { default: ReflectorAgent } = await import('./cognitive/reflector_agent');
            return ReflectorAgent;
          };
          case 'user_intent': {;
            const { default: UserIntentAgent } = await import('./cognitive/user_intent_agent');
            return UserIntentAgent;
          };
          case 'tool_maker': {;
            const { default: ToolMakerAgent } = await import('./cognitive/tool_maker_agent');
            return ToolMakerAgent;
          };
          case 'ethics': {;
            const { default: EthicsAgent } = await import('./cognitive/ethics_agent');
            return EthicsAgent;
          };
          case 'resource_manager': {;
            const { default: ResourceManagerAgent } = await import(;
              './cognitive/resource_manager_agent';
            );
            return ResourceManagerAgent;
          };
          case 'orchestrator': {;
            const { default: OrchestratorAgent } = await import('./cognitive/orchestrator_agent');
            return OrchestratorAgent;
          };
          case 'pydantic_ai': {;
            const { PydanticAIAgent } = await import('./cognitive/pydantic_ai_agent');
            return PydanticAIAgent;
          };
          default:;
            throw new Error(`Unknown cognitive agent: ${definitionname}`);
        };
      };
    } catch (error) {;
      thisloggererror(`❌ Failed to import agent class ${definitionclassName}:`, error);
      return null;
    };
  };

  /**;
   * Initialize the registry;
   */;
  async initialize(): Promise<void> {;
    thisloggerinfo('Initializing Universal Agent Registry...');
    // Registry is already initialized in constructor;
    thisloggerinfo('✅ Universal Agent Registry initialized');
  ;
};

  /**;
   * Process a request through the appropriate agent;
   */;
  async processRequest(agentName: string, context: any): Promise<unknown> {;
    const agent = await thisloadAgent(agentName);
    if (!agent) {;
      throw new Error(`Agent ${agentName} not found or failed to load`);
    };

    // Mark agent as used;
    thisagentUsageset(agentName, new Date());
    // Notify UI about agent activation;
    const definition = thisagentDefinitionsget(agentName);
    if (definition) {;
      agentCollaborationWSupdateAgentStatus({;
        agentId: agentName;
        agentName: definitionclassNamereplace('Agent', ' Agent');
        status: 'thinking';
        currentTask: `Processing: ${contexttask || 'request'}`;
        timestamp: new Date();
        metadata: {;
          participatingIn: contextrequestId || 'direct';
        ;
};
      });
    };

    try {;
      // Process the request;
      const result = await agentexecute(context);
      // Notify completion;
      agentCollaborationWScompleteAgentTask(agentName, result);
      return result;
    } catch (error) {;
      // Notify error;
      agentCollaborationWSupdateAgentStatus({;
        agentId: agentName;
        agentName: definition?classNamereplace('Agent', ' Agent') || agentName;
        status: 'error';
        currentTask: 'Task failed';
        timestamp: new Date();
      });
      throw error;
    };
  };

  /**;
   * Get core agents that should be preloaded;
   */;
  getCoreAgents(): string[] {;
    return Arrayfrom(thisagentDefinitionsvalues());
      filter((def) => defcategory === AgentCategoryCORE);
      sort((a, b) => apriority - bpriority);
      map((def) => defname);
  };

  /**;
   * Get all cognitive agents;
   */;
  getCognitiveAgents(): string[] {;
    return Arrayfrom(thisagentDefinitionsvalues());
      filter((def) => defcategory === AgentCategoryCOGNITIVE);
      sort((a, b) => apriority - bpriority);
      map((def) => defname);
  };

  /**;
   * Get all personal agents;
   */;
  getPersonalAgents(): string[] {;
    return Arrayfrom(thisagentDefinitionsvalues());
      filter((def) => defcategory === AgentCategoryPERSONAL);
      sort((a, b) => apriority - bpriority);
      map((def) => defname);
  };

  /**;
   * Preload core agents for better performance;
   */;
  async preloadCoreAgents(): Promise<void> {;
    const coreAgents = thisgetCoreAgents();
    thisloggerinfo(`🚀 Preloading ${coreAgentslength} core agents...`);
    const loadPromises = coreAgentsmap((agentName) => thisgetAgent(agentName));
    const results = await PromiseallSettled(loadPromises);
    const loaded = resultsfilter((r) => rstatus === 'fulfilled')length;
    const failed = resultsfilter((r) => rstatus === 'rejected')length;
    thisloggerinfo(`✅ Preloaded ${loaded} core agents (${failed} failed)`);
  };

  /**;
   * Get registry status and metrics;
   */;
  getStatus(): any {;
    const definitions = Arrayfrom(thisagentDefinitionsvalues());
    const loaded = Arrayfrom(thisloadedAgentskeys());
    return {;
      totalDefinitions: definitionslength;
      loadedAgents: loadedlength;
      agentsByCategory: {;
        core: definitionsfilter((d) => dcategory === AgentCategoryCORE)length;
        cognitive: definitionsfilter((d) => dcategory === AgentCategoryCOGNITIVE)length;
        utility: definitionsfilter((d) => dcategory === AgentCategoryUTILITY)length;
        specialized: definitionsfilter((d) => dcategory === AgentCategorySPECIALIZED)length;
        personal: definitionsfilter((d) => dcategory === AgentCategoryPERSONAL)length;
      ;
};
      loadedAgentsList: loaded;
      coreAgents: thisgetCoreAgents();
      cognitiveAgents: thisgetCognitiveAgents();
      personalAgents: thisgetPersonalAgents();
    ;
};
  };

  /**;
   * Unload agents that haven't been used recently;
   */;
  async unloadUnusedAgents(maxIdleMinutes = 30): Promise<void> {;
    const currentTime = new Date();
    const toUnload: string[] = [];
    for (const [agentName, lastUsed] of thisagentUsageentries()) {;
      if (thisloadedAgentshas(agentName)) {;
        const idleTimeMs = currentTimegetTime() - lastUsedgetTime();
        const idleMinutes = idleTimeMs / (1000 * 60);
        const definition = thisagentDefinitionsget(agentName);
        if (;
          definition &&;
          definitioncategory !== AgentCategoryCORE &&;
          idleMinutes > maxIdleMinutes;
        ) {;
          toUnloadpush(agentName);
        };
      };
    };

    for (const agentName of toUnload) {;
      const agent = thisloadedAgentsget(agentName);
      if (agent) {;
        await agentshutdown();
        thisloadedAgentsdelete(agentName);
        thisagentUsagedelete(agentName);
        thisloggerinfo(`♻️ Unloaded idle agent: ${agentName}`);
        thisemit('agent_unloaded', { agentName });
      };
    };

    if (toUnloadlength > 0) {;
      thisloggerinfo(`♻️ Unloaded ${toUnloadlength} idle agents`);
    };
  };

  /**;
   * Get agent information;
   */;
  getAgentInfo(agentName: string): any {;
    const definition = thisagentDefinitionsget(agentName);
    if (!definition) return null;
    const isLoaded = thisloadedAgentshas(agentName);
    const lastUsed = thisagentUsageget(agentName);
    const agent = thisloadedAgentsget(agentName);
    return {;
      ..definition;
      isLoaded;
      lastUsed: lastUsed?toISOString();
      status: agent?getStatus();
    ;
};
  };

  /**;
   * Gracefully shutdown all agents;
   */;
  async shutdown(): Promise<void> {;
    thisloggerinfo('🔄 Shutting down Universal Agent Registry...');
    const shutdownPromises = Arrayfrom(thisloadedAgentsvalues())map((agent) =>;
      agentshutdown()catch((error) => thisloggererror(`Error shutting down agent:`, error));
    );
    await PromiseallSettled(shutdownPromises);
    thisloadedAgentsclear();
    thisagentUsageclear();
    thisloadingLocksclear();
    thisremoveAllListeners();
    thisloggerinfo('✅ Universal Agent Registry shutdown complete');
  };
};

export default UniversalAgentRegistry;