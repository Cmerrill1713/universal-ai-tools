/**;
 * PhotoOrganizerAgent - Intelligent photo organization with local ML;
 * Uses local models for face recognition, smart categorization, and privacy-first processing;
 */;

import type { AgentConfig, AgentContext, AgentResponse } from '../base_agent';
import { BaseAgent } from '../base_agent';
import type { SupabaseClient } from '@supabase/supabase-js';
import { execSync, spawn } from 'child_process';
import { promises as fs } from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import axios from 'axios';
interface PhotoMetadata {;
  path: string;
  filename: string;
  size: number;
  dateCreated: Date;
  dateTaken?: Date;
  location?: {;
    latitude: number;
    longitude: number;
    address?: string;
  ;
};
  camera?: {;
    make: string;
    model: string;
    settings?: any;
  ;
};
  hash: string;
  width?: number;
  height?: number;
;
};

interface FaceDetection {;
  photoPath: string;
  faces: Array<{;
    id: string;
    confidence: number;
    boundingBox: {;
      x: number;
      y: number;
      width: number;
      height: number;
    ;
};
    encoding?: number[];
    personId?: string;
    personName?: string;
  }>;
};

interface Person {;
  id: string;
  name?: string;
  faceEncodings: number[][];
  photoCount: number;
  firstSeen: Date;
  lastSeen: Date;
  confidence: number;
;
};

interface PhotoCollection {;
  id: string;
  name: string;
  type: 'auto' | 'manual';
  criteria: any;
  photoCount: number;
  thumbnail?: string;
  created: Date;
  updated: Date;
;
};

export class PhotoOrganizerAgent extends BaseAgent {;
  private supabase: SupabaseClient;
  private photosDirectory: string;
  private faceModelLoaded = false;
  private duplicateThreshold = 0.95;
  private faceRecognitionThreshold = 0.6;
  constructor(supabase: SupabaseClient) {;
    const config: AgentConfig = {;
      name: 'photo_organizer';
      description:;
        'Intelligent photo organization with face recognition and ML-powered categorization';
      priority: 7;
      capabilities: [;
        {;
          name: 'organize_photos';
          description: 'Automatically organize photos by date, location, people, and content';
          inputSchema: {;
            type: 'object';
            properties: {;
              directory: { type: 'string' ;
};
              strategy: { type: 'string', enum: ['date', 'people', 'location', 'content };
              preserveOriginal: { type: 'boolean' ;
};
            };
            required: ['directory'];
          ;
};
          outputSchema: {;
            type: 'object';
            properties: {;
              organized: { type: 'number' ;
};
              collections: { type: 'array' ;
};
              duplicates: { type: 'array' ;
};
            };
          };
        };
        {;
          name: 'detect_faces';
          description: 'Detect and recognize faces in photos using local ML models';
          inputSchema: {;
            type: 'object';
            properties: {;
              photos: { type: 'array' ;
};
              createNewPersons: { type: 'boolean' ;
};
            };
            required: ['photos'];
          ;
};
          outputSchema: {;
            type: 'object';
            properties: {;
              detections: { type: 'array' ;
};
              newPersons: { type: 'array' ;
};
              totalFaces: { type: 'number' ;
};
            };
          };
        };
        {;
          name: 'find_duplicates';
          description: 'Find duplicate and similar photos using perceptual hashing';
          inputSchema: {;
            type: 'object';
            properties: {;
              directory: { type: 'string' ;
};
              threshold: { type: 'number' ;
};
            };
            required: ['directory'];
          ;
};
          outputSchema: {;
            type: 'object';
            properties: {;
              duplicateGroups: { type: 'array' ;
};
              totalDuplicates: { type: 'number' ;
};
              spaceSaved: { type: 'number' ;
};
            };
          };
        };
        {;
          name: 'create_smart_albums';
          description: 'Create smart photo albums based on ML _analysis;
          inputSchema: {;
            type: 'object';
            properties: {;
              criteria: { type: 'object' ;
};
              autoUpdate: { type: 'boolean' ;
};
            };
          };
          outputSchema: {;
            type: 'object';
            properties: {;
              albums: { type: 'array' ;
};
              totalPhotos: { type: 'number' ;
};
            };
          };
        };
      ];
      maxLatencyMs: 10000, // Photo processing can take longer;
      retryAttempts: 2;
      dependencies: ['ollama_assistant'];
      memoryEnabled: true;
    ;
};
    super(config);
    thissupabase = supabase;
    thisphotosDirectory =;
      processenvPHOTOS_DIRECTORY || pathjoin(processenvHOME || '', 'Pictures');
  };

  protected async onInitialize(): Promise<void> {;
    // Initialize local ML models for face detection;
    await thisinitializeFaceRecognition();
    // Check Photos app integration on macOS;
    await thischeckPhotosAppAccess();
    // Load existing person database;
    await thisloadPersonDatabase();
    thisloggerinfo('✅ PhotoOrganizerAgent initialized with local ML capabilities');
  ;
};

  protected async process(_context: AgentContext & { memoryContext?: any }): Promise<AgentResponse> {;
    const { userRequest } = context;
    const startTime = Datenow();
    try {;
      // Parse the user request to determine photo operation;
      const intent = await thisparsePhotoIntent(userRequest);
      let result: any;
      switch (intentaction) {;
        case 'organize':;
          result = await thisorganizePhotos(intent);
          break;
        case 'find_people':;
          result = await thisfindPhotosByPerson(intent);
          break;
        case 'detect_faces':;
          result = await thisdetectFacesInPhotos(intent);
          break;
        case 'find_duplicates':;
          result = await thisfindDuplicatesInPhotos(intent);
          break;
        case 'create_album':;
          result = await thiscreateSmartAlbum(intent);
          break;
        case 'analyze_photo':;
          result = await thisanalyzePhotoContent(intent);
          break;
        default:;
          result = await thishandleGeneralPhotoQuery(userRequest);
      };

      const confidence = thiscalculateConfidence(intent, result);
      return {;
        success: true;
        data: result;
        reasoning: thisbuildPhotoReasoning(intent, result);
        confidence;
        latencyMs: Datenow() - startTime;
        agentId: thisconfigname;
        nextActions: thissuggestPhotoActions(intent, result);
      };
    } catch (error) {;
      thisloggererror('PhotoOrganizerAgent processing error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error);
      return {;
        success: false;
        data: null;
        reasoning: `Photo operation failed: ${(erroras Error)message}`;
        confidence: 0.1;
        latencyMs: Datenow() - startTime;
        agentId: thisconfigname;
        error instanceof Error ? errormessage : String(error) (erroras Error)message;
      ;
};
    };
  };

  protected async onShutdown(): Promise<void> {;
    // Clean up ML models and temporary files;
    thisloggerinfo('PhotoOrganizerAgent shutting down');
  ;
};

  /**;
   * Initialize face recognition using local ML models;
   */;
  private async initializeFaceRecognition(): Promise<void> {;
    try {;
      // Check if Python and required libraries are available;
      const pythonScript = ``;
import sys;
try:;
    import face_recognition;
    import cv2;
    import numpy as np;
    print("Face recognition libraries available");
    sysexit(0);
except ImportError as e:;
    print(f"Missing library: {e}");
    sysexit(1);
`;`;
      const tempScript = pathjoin('/tmp', 'check_face_recognitionpy');
      await fswriteFile(tempScript, pythonScript);
      try {;
        execSync(`python3 ${tempScript}`, { stdio: 'pipe' });
        thisfaceModelLoaded = true;
        thisloggerinfo('✅ Face recognition models loaded successfully');
      } catch (error) {;
        thisloggerwarn('⚠️ Face recognition libraries not available, using fallback methods');
        await thisinstallFaceRecognitionFallback();
      };

      await fsunlink(tempScript);
    } catch (error) {;
      thisloggererror('Failed to initialize face recognition:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Install face recognition fallback using Ollama vision models;
   */;
  private async installFaceRecognitionFallback(): Promise<void> {;
    try {;
      // Check if Ollama has vision models available;
      const response = await axiosget('http://localhost:11434/api/tags');
      const models = responsedatamodels || [];
      const visionModels = modelsfilter(;
        (m: any) => mnameincludes('llava') || mnameincludes('vision');
      );
      if (visionModelslength > 0) {;
        thisfaceModelLoaded = true;
        thisloggerinfo('✅ Using Ollama vision models for face detection');
      } else {;
        thisloggerwarn('⚠️ No face recognition capabilities available');
      };
    } catch (error) {;
      thisloggerwarn('Ollama not available for vision tasks:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Parse photo-related intent from natural language;
   */;
  private async parsePhotoIntent(requeststring): Promise<unknown> {;
    const prompt = `Parse this photo organization request`;

Request: "${request;
Determine:;
1. Action (organize, find_people, detect_faces, find_duplicates, create_album, analyze_photo);
2. Target (specific directory, person name, photo types);
3. Criteria (date range, location, organization strategy);
4. Preferences (preserve originals, create copies, etc.);
Respond with JSON: {;
  "action": "...";
  "target": "...";
  "criteria": {...;
};
  "preferences": {...;
};
}`;`;
    try {;
      const response = await axiospost('http://localhost:11434/api/generate', {;
        model: 'llama3.2:3b';
        prompt;
        stream: false;
        format: 'json';
      });
      return JSONparse(responsedataresponse);
    } catch (error) {;
      return thisfallbackPhotoIntentParsing(request;
    };
  };

  /**;
   * Organize photos based on different strategies;
   */;
  private async organizePhotos(intent: any): Promise<unknown> {;
    const directory = intenttarget || thisphotosDirectory;
    const strategy = intentcriteria?strategy || 'date';
    // Scan directory for photos;
    const photos = await thisscanForPhotos(directory);
    let organized = 0;
    const collections: PhotoCollection[] = [];
    const duplicates: string[] = [];
    switch (strategy) {;
      case 'date':;
        const dateCollections = await thisorganizeByDate(photos);
        collectionspush(..dateCollections);
        organized = dateCollectionsreduce((sum, c) => sum + cphotoCount, 0);
        break;
      case 'people':;
        if (thisfaceModelLoaded) {;
          const peopleCollections = await thisorganizeByPeople(photos);
          collectionspush(..peopleCollections);
          organized = peopleCollectionsreduce((sum, c) => sum + cphotoCount, 0);
        };
        break;
      case 'location':;
        const locationCollections = await thisorganizeByLocation(photos);
        collectionspush(..locationCollections);
        organized = locationCollectionsreduce((sum, c) => sum + cphotoCount, 0);
        break;
      case 'content;
        const contentCollections = await thisorganizeByContent(photos);
        collectionspush(..contentCollections);
        organized = contentCollectionsreduce((sum, c) => sum + cphotoCount, 0);
        break;
    };

    // Find duplicates during organization;
    const duplicateResult = await thisfindDuplicatesInPhotos({ target: [directory] });
    const duplicateGroups = duplicateResultduplicateGroups || [];
    duplicatespush(..duplicateGroupsmap((g: any) => gfiles)flat());
    // Store organization results in memory;
    await thisstoreOrganizationMemory(collections, duplicates, strategy);
    return {;
      organized;
      collections;
      duplicates: duplicateGroups;
      strategy;
      totalPhotos: photoslength;
    ;
};
  };

  /**;
   * Detect faces in photos using local ML;
   */;
  private async detectFacesInPhotos(intent: any): Promise<unknown> {;
    const photos = intenttarget || [];
    const detections: FaceDetection[] = [];
    const newPersons: Person[] = [];
    let totalFaces = 0;
    for (const photoPath of photos) {;
      try {;
        const faceData = await thisdetectFacesInSinglePhoto(photoPath);
        if (faceData) {;
          detectionspush(faceData);
          totalFaces += faceDatafaceslength;
          // Check for new persons;
          for (const face of faceDatafaces) {;
            if (!facepersonId && intentcriteria?createNewPersons) {;
              const newPerson = await thiscreateNewPerson(face);
              if (newPerson) {;
                newPersonspush(newPerson);
                facepersonId = newPersonid;
              };
            };
          };
        };
      } catch (error) {;
        thisloggererror`Face detection failed for ${photoPath}:`, error instanceof Error ? errormessage : String(error)  ;
};
    };

    // Store face detection results;
    await thisstoreFaceDetections(detections);
    return {;
      detections;
      newPersons;
      totalFaces;
      photosProcessed: photoslength;
    ;
};
  };

  /**;
   * Detect faces in a single photo;
   */;
  private async detectFacesInSinglePhoto(photoPath: string): Promise<FaceDetection | null> {;
    if (!thisfaceModelLoaded) {;
      return thisfallbackFaceDetection(photoPath);
    };

    try {;
      const pythonScript = ``;
import face_recognition;
import cv2;
import json;
import sys;

def detect_faces(image_path):;
    try:;
        # Load image;
        image = face_recognitionload_image_file(image_path);
        # Find face locations and encodings;
        face_locations = face_recognitionface_locations(image);
        face_encodings = face_recognitionface_encodings(image, face_locations);
        faces = [];
        for i, (encoding, location) in enumerate(zip(face_encodings, face_locations)):;
            facesappend({;
                "id": f"face_{i}";
                "confidence": 0.9,  # face_recognition doesn't provide confidence;
                "boundingBox": {;
                    "x": location[3];
                    "y": location[0];
                    "width": location[1] - location[3];
                    "height": location[2] - location[0];
                ;
};
                "encoding": encodingtolist();
            });
        return {;
            "photoPath": image_path;
            "faces": faces;
        ;
};
        ;
    except Exception as e:;
        print(f"Error: {e}", file=sysstderr);
        return None;
if __name__ == "__main__":;
    result = detect_faces("${photoPath}");
    if result:;
        print(jsondumps(result));
`;`;
      const tempScript = pathjoin('/tmp', `face_detect_${Datenow()}py`);
      await fswriteFile(tempScript, pythonScript);
      const output = execSync(`python3 ${tempScript}`, { encoding: 'utf8' });
      await fsunlink(tempScript);
      const result = JSONparse(output);
      // Match faces with known persons;
      for (const face of resultfaces) {;
        const matchedPerson = await thismatchFaceToKnownPerson(faceencoding);
        if (matchedPerson) {;
          facepersonId = matchedPersonid;
          facepersonName = matchedPersonname;
        };
      };
;
      return result;
    } catch (error) {;
      thisloggererror('Face detection script failed:', error instanceof Error ? errormessage : String(error);
      return null;
    };
  };

  /**;
   * Fallback face detection using Ollama vision models;
   */;
  private async fallbackFaceDetection(photoPath: string): Promise<FaceDetection | null> {;
    try {;
      // Convert image to base64 for Ollama;
      const imageBuffer = await fsreadFile(photoPath);
      const base64Image = imageBuffertoString('base64');
      const response = await axiospost('http://localhost:11434/api/generate', {;
        model: 'llava:7b';
        prompt:;
          'Analyze this image and identify any faces. Describe the number of people and their approximate positions.';
        images: [base64Image];
        stream: false;
      });
      // Parse Ollama response to extract face information;
      const description = responsedataresponse;
      const faceCount = thisextractFaceCountFromDescription(description);
      return {;
        photoPath;
        faces: Arrayfrom({ length: faceCount }, (_, i) => ({;
          id: `face_${i}`;
          confidence: 0.7;
          boundingBox: { x: 0, y: 0, width: 100, height: 100 }, // Placeholder;
        }));
      };
    } catch (error) {;
      thisloggererror('Ollama face detection failed:', error instanceof Error ? errormessage : String(error);
      return null;
    };
  };

  /**;
   * Scan directory for photo files;
   */;
  private async scanForPhotos(directory: string): Promise<PhotoMetadata[]> {;
    const photos: PhotoMetadata[] = [];
    const photoExtensions = ['jpg', 'jpeg', 'png', 'tiff', 'raw', 'heic', 'webp'];
    try {;
      const files = await fsreaddir(directory, { withFileTypes: true });
      for (const file of files) {;
        if (fileisDirectory()) {;
          // Recursively scan subdirectories;
          const subPhotos = await thisscanForPhotos(pathjoin(directory, filename));
          photospush(..subPhotos);
        } else if (photoExtensionsincludes(pathextname(filename)toLowerCase())) {;
          const filePath = pathjoin(directory, filename);
          const metadata = await thisextractPhotoMetadata(filePath);
          if (metadata) {;
            photospush(metadata);
          };
        };
      };
    } catch (error) {;
      thisloggererror`Failed to scan directory ${directory}:`, error instanceof Error ? errormessage : String(error)  ;
};

    return photos;
  };

  /**;
   * Extract metadata from photo file;
   */;
  private async extractPhotoMetadata(filePath: string): Promise<PhotoMetadata | null> {;
    try {;
      const stats = await fsstat(filePath);
      const fileBuffer = await fsreadFile(filePath);
      const hash = cryptocreateHash('sha256')update(fileBuffer)digest('hex');
      // Try to extract EXIF data using exiftool if available;
      let exifData: any = {};
      try {;
        const exifOutput = execSync(`exiftool -json "${filePath}"`, { encoding: 'utf8' });
        exifData = JSONparse(exifOutput)[0] || {};
      } catch (error) {;
        // exiftool not available, use basic metadata;
      };

      return {;
        path: filePath;
        filename: pathbasename(filePath);
        size: statssize;
        dateCreated: statsbirthtime;
        dateTaken: exifDataDateTimeOriginal ? new Date(exifDataDateTimeOriginal) : undefined;
        location:;
          exifDataGPSLatitude && exifDataGPSLongitude;
            ? {;
                latitude: exifDataGPSLatitude;
                longitude: exifDataGPSLongitude;
              ;
};
            : undefined;
        camera: exifDataMake;
          ? {;
              make: exifDataMake;
              model: exifDataModel;
              settings: {;
                fNumber: exifDataFNumber;
                exposureTime: exifDataExposureTime;
                iso: exifDataISO;
              ;
};
            };
          : undefined;
        hash;
        width: exifDataImageWidth;
        height: exifDataImageHeight;
      ;
};
    } catch (error) {;
      thisloggererror`Failed to extract metadata from ${filePath}:`, error instanceof Error ? errormessage : String(error);
      return null;
    };
  };

  /**;
   * Check macOS Photos app access;
   */;
  private async checkPhotosAppAccess(): Promise<boolean> {;
    try {;
      // Try to access Photos library via AppleScript;
      execSync(`osascript -e 'tell application "Photos" to get name of albums'`);
      thisloggerinfo('✅ Photos app access available');
      return true;
    } catch (error) {;
      thisloggerwarn('⚠️ Photos app access may be restricted');
      return false;
    };
  };

  // Placeholder implementations for complex methods;
  private async loadPersonDatabase(): Promise<void> {;
    // Load known persons from database;
  ;
};

  private fallbackPhotoIntentParsing(requeststring): any {;
    const requestLower = request toLowerCase();
    if (requestLowerincludes('organize') || requestLowerincludes('sort')) {;
      return { action: 'organize', criteria: { strategy: 'date' } };
    };

    if (requestLowerincludes('face') || requestLowerincludes('people')) {;
      return { action: 'detect_faces' };
    };

    if (requestLowerincludes('duplicate')) {;
      return { action: 'find_duplicates' };
    };

    return { action: 'organize' };
  };

  private async organizeByDate(photos: PhotoMetadata[]): Promise<PhotoCollection[]> {;
    // Group photos by date and create collections;
    return [];
  };

  private async organizeByPeople(photos: PhotoMetadata[]): Promise<PhotoCollection[]> {;
    // Organize photos by detected people;
    return [];
  };

  private async organizeByLocation(photos: PhotoMetadata[]): Promise<PhotoCollection[]> {;
    // Organize photos by location metadata;
    return [];
  };

  private async organizeByContent(photos: PhotoMetadata[]): Promise<PhotoCollection[]> {;
    // Use ML to analyze contentand organize;
    return [];
  };

  /**;
   * Find duplicate photos in a collection;
   */;
  private async findDuplicatesInPhotos(intent: any): Promise<unknown> {;
    const directories = intenttarget || [thisphotosDirectory];
    const threshold = intentparameters?threshold || thisduplicateThreshold;
    const duplicateGroups: any[] = [];
    let totalDuplicates = 0;
    let spaceSavings = 0;
    // Collect all photos from directories;
    const allPhotos: PhotoMetadata[] = [];
    for (const dir of directories) {;
      const photos = await thisscanForPhotos(dir);
      allPhotospush(..photos);
    };

    // Group by hash for exact duplicates;
    const hashGroups = new Map<string, PhotoMetadata[]>();
    for (const photo of allPhotos) {;
      const { hash } = photo;
      if (!hashGroupshas(hash)) {;
        hashGroupsset(hash, []);
      };
      hashGroupsget(hash)!push(photo);
    };

    // Find duplicate groups;
    for (const [hash, photos] of hashGroups) {;
      if (photoslength > 1) {;
        const totalSize = photosreduce((sum, p) => sum + psize, 0);
        const spaceSaving = totalSize - photos[0]size;
        duplicateGroupspush({;
          files: photos;
          duplicateType: 'exact';
          confidence: 1.0;
          potentialSpaceSaving: spaceSaving;
        });
        totalDuplicates += photoslength - 1;
        spaceSavings += spaceSaving;
      };
    };

    return {;
      duplicateGroups;
      totalDuplicates;
      spaceSavings;
      totalFilesScanned: allPhotoslength;
    ;
};
  };

  private async findDuplicatesInPhotosHelper(photos: PhotoMetadata[]): Promise<string[][]> {;
    // Helper method for finding duplicates;
    return [];
  };

  private async matchFaceToKnownPerson(encoding: number[]): Promise<Person | null> {;
    // Match face encoding to known person;
    return null;
  };

  private async createNewPerson(face: any): Promise<Person | null> {;
    // Create new person entry;
    return null;
  };

  private extractFaceCountFromDescription(description: string): number {;
    // Extract number of faces from Ollama description;
    const matches = descriptionmatch(/(\d+)\s+(people|person|face)/i);
    return matches ? parseInt(matches[1], 10) : 0;
  };

  private async storeOrganizationMemory(;
    collections: PhotoCollection[];
    duplicates: string[];
    strategy: string;
  ): Promise<void> {;
    // Store organization results in memory;
  ;
};

  private async storeFaceDetections(detections: FaceDetection[]): Promise<void> {;
    // Store face detection results;
  ;
};

  private calculateConfidence(intent: any, result: any): number {;
    return 0.8;
  };

  private buildPhotoReasoning(intent: any, result: any): string {;
    return `Processed photo ${intentaction} operation`;
  };

  private suggestPhotoActions(intent: any, result: any): string[] {;
    return ['Review organized collections', 'Verify face identifications'];
  };

  private async findPhotosByPerson(intent: any): Promise<unknown> {;
    return { photos: [] };
  };

  private async createSmartAlbum(intent: any): Promise<unknown> {;
    return { album: null };
  };

  private async analyzePhotoContent(intent: any): Promise<unknown> {;
    return { _analysis 'Photo contentanalyzed' };
  };

  private async handleGeneralPhotoQuery(requeststring): Promise<unknown> {;
    return { response: 'General photo query processed' };
  };
};

export default PhotoOrganizerAgent;