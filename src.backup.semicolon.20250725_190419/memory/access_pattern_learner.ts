/**;
 * Memory Access Pattern Learning System;
 * Learns from user behavior to improve search relevance and memory importance;
 * Implements utility-based re-ranking and adaptive scoring;
 */;

import type { SupabaseClient } from '@supabase/supabase-js';
import type { Logger } from 'winston';
export interface AccessPattern {;
  id: string;
  memoryId: string;
  agentName: string;
  accessType: 'search' | 'direct' | 'related' | 'contextual';
  queryEmbedding?: number[];
  similarityScore?: number;
  responseUseful?: boolean;
  interactionDuration?: number;
  followUpQueries?: string[];
  timestamp: Date;
  userFeedback?: {;
    relevance: number; // 1-5 scale;
    helpfulness: number; // 1-5 scale;
    accuracy: number; // 1-5 scale;
  };
  contextualFactors?: {;
    timeOfDay: number; // 0-23;
    sessionLength: number; // minutes;
    taskType?: string;
    urgency?: 'low' | 'medium' | 'high' | 'critical';
  ;
};
};

export interface UtilityScore {;
  baseScore: number;
  recencyBoost: number;
  frequencyBoost: number;
  userPreferenceBoost: number;
  contextualRelevanceBoost: number;
  finalScore: number;
  explanation: string[];
;
};

export interface LearningInsights {;
  userPreferences: {;
    preferredMemoryTypes: Array<{ type: string, weight: number }>;
    preferredAgents: Array<{ agent: string, weight: number }>;
    timeOfDayPatterns: Array<{ hour: number, activity: number }>;
    averageSessionLength: number;
  ;
};
  searchPatterns: {;
    commonQueries: Array<{ query: string, frequency: number }>;
    failurePatterns: Array<{ _pattern string, reason: string }>;
    successFactors: Array<{ factor: string, impact: number }>;
  };
  adaptiveWeights: {;
    recencyWeight: number;
    frequencyWeight: number;
    similarityWeight: number;
    importanceWeight: number;
    userFeedbackWeight: number;
  ;
};
  recommendations: string[];
;
};

/**;
 * Advanced access _patternlearning system;
 */;
export class AccessPatternLearner {;
  private supabase: SupabaseClient;
  private logger: Logger;
  private learningCache = new Map<string, any>();
  private readonly CACHE_TTL = 30 * 60 * 1000; // 30 minutes;
  // Learning parameters;
  private adaptiveWeights = {;
    recencyWeight: 0.2;
    frequencyWeight: 0.25;
    similarityWeight: 0.3;
    importanceWeight: 0.15;
    userFeedbackWeight: 0.1;
  ;
};
  constructor(supabase: SupabaseClient, logger: Logger) {;
    thissupabase = supabase;
    thislogger = logger;
  ;
};

  /**;
   * Record memory access pattern;
   */;
  async recordAccess(;
    memoryId: string;
    agentName: string;
    accessType: AccessPattern['accessType'];
    options: {;
      queryEmbedding?: number[];
      similarityScore?: number;
      responseUseful?: boolean;
      interactionDuration?: number;
      contextualFactors?: AccessPattern['contextualFactors'];
    } = {};
  ): Promise<void> {;
    try {;
      const accessPattern: Omit<AccessPattern, 'id'> = {;
        memoryId;
        agentName;
        accessType;
        queryEmbedding: optionsqueryEmbedding;
        similarityScore: optionssimilarityScore;
        responseUseful: optionsresponseUseful;
        interactionDuration: optionsinteractionDuration;
        timestamp: new Date();
        contextualFactors: {;
          timeOfDay: new Date()getHours();
          sessionLength: optionscontextualFactors?sessionLength || 0;
          taskType: optionscontextualFactors?taskType;
          urgency: optionscontextualFactors?urgency;
        ;
};
      };
      const { error instanceof Error ? errormessage : String(error)  = await thissupabasefrom('memory_access_patterns')insert(accessPattern);
      if (error instanceof Error ? errormessage : String(error) throw error instanceof Error ? errormessage : String(error);

      // Update memory access count and last accessed time;
      await thisupdateMemoryStats(memoryId, optionsresponseUseful);
      // Invalidate learning cache for this agent;
      thislearningCachedelete(`insights:${agentName}`);
    } catch (error) {;
      thisloggererror('Failed to record access _pattern', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Record user feedback for a memory interaction;
   */;
  async recordUserFeedback(;
    memoryId: string;
    agentName: string;
    feedback: AccessPattern['userFeedback'];
    followUpQueries?: string[];
  ): Promise<void> {;
    try {;
      // Find the most recent access _patternfor this memory and agent;
      const { data: recentAccess, error instanceof Error ? errormessage : String(error)  = await thissupabase;
        from('memory_access_patterns');
        select('*');
        eq('memory_id', memoryId);
        eq('agent_name', agentName);
        order('created_at', { ascending: false });
        limit(1);
        single();
      if (error instanceof Error ? errormessage : String(error) throw error instanceof Error ? errormessage : String(error);

      // Update the access _patternwith feedback;
      await thissupabase;
        from('memory_access_patterns');
        update({;
          user_feedback: feedback;
          follow_up_queries: followUpQueries;
          response_useful: feedback?relevance ? feedbackrelevance >= 3 : null, // 3+ out of 5 is considered useful;
        });
        eq('id', recentAccessid);
      // Update adaptive weights based on feedback;
      await thisupdateAdaptiveWeights(agentName, feedback);
      thisloggerinfo(;
        `Recorded user feedback for memory ${memoryId}: relevance=${feedback?relevance}, helpfulness=${feedback?helpfulness}`;
      );
    } catch (error) {;
      thisloggererror('Failed to record user feedback:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Calculate utility-based score for memory re-ranking;
   */;
  async calculateUtilityScore(;
    memoryId: string;
    agentName: string;
    baseScore: number;
    contextualFactors?: {;
      currentTime?: Date;
      queryEmbedding?: number[];
      sessionContext?: string;
      urgency?: string;
    ;
};
  ): Promise<UtilityScore> {;
    try {;
      const currentTime = contextualFactors?currentTime || new Date();
      const explanation: string[] = [];
      // Get memory access history;
      const { data: accessHistory } = await thissupabase;
        from('memory_access_patterns');
        select('*');
        eq('memory_id', memoryId);
        eq('agent_name', agentName);
        order('created_at', { ascending: false });
        limit(50);
      const accessCount = accessHistory?length || 0;
      const recentAccesses =;
        accessHistory?filter(;
          (a) => new Date(acreated_at)getTime() > currentTimegetTime() - 7 * 24 * 60 * 60 * 1000;
        ) || [];
      // Calculate recency boost;
      let recencyBoost = 0;
      if (recentAccesseslength > 0) {;
        const lastAccess = new Date(recentAccesses[0]created_at);
        const daysSinceAccess =;
          (currentTimegetTime() - lastAccessgetTime()) / (24 * 60 * 60 * 1000);
        recencyBoost = Mathmax(0, (7 - daysSinceAccess) / 7) * thisadaptiveWeightsrecencyWeight;
        explanationpush(;
          `Recency: +${(recencyBoost * 100)toFixed(1)}% (last accessed ${daysSinceAccesstoFixed(1)} days ago)`;
        );
      };

      // Calculate frequency boost;
      let frequencyBoost = 0;
      if (accessCount > 0) {;
        const frequencyScore = Mathmin(accessCount / 10, 1); // Normalize to 0-1;
        frequencyBoost = frequencyScore * thisadaptiveWeightsfrequencyWeight;
        explanationpush(;
          `Frequency: +${(frequencyBoost * 100)toFixed(1)}% (${accessCount} accesses)`;
        );
      };

      // Calculate user preference boost;
      let userPreferenceBoost = 0;
      const positiveInteractions =;
        accessHistory?filter((a) => aresponse_useful === true)length || 0;
      if (accessCount > 0) {;
        const successRate = positiveInteractions / accessCount;
        userPreferenceBoost = successRate * thisadaptiveWeightsuserFeedbackWeight;
        explanationpush(;
          `User preference: +${(userPreferenceBoost * 100)toFixed(1)}% (${(successRate * 100)toFixed(1)}% success rate)`;
        );
      };

      // Calculate contextual relevance boost;
      let contextualRelevanceBoost = 0;
      if (contextualFactors?urgency) {;
        const urgencyMultipliers = { low: 0.8, medium: 1.0, high: 1.2, critical: 1.5 };
        const urgencyMultiplier =;
          urgencyMultipliers[contextualFactorsurgency as keyof typeof urgencyMultipliers] || 1.0;
        contextualRelevanceBoost = (urgencyMultiplier - 1) * 0.1;
        explanationpush(;
          `Urgency (${contextualFactorsurgency}): ${contextualRelevanceBoost >= 0 ? '+' : ''}${(contextualRelevanceBoost * 100)toFixed(1)}%`;
        );
      };

      // Time-of-day patterns;
      const currentHour = currentTimegetHours();
      const hourlyAccesses =;
        accessHistory?filter((a) => new Date(acreated_at)getHours() === currentHour)length || 0;
      if (hourlyAccesses > 0) {;
        const timeBoost = Mathmin(hourlyAccesses / accessCount, 0.2);
        contextualRelevanceBoost += timeBoost;
        explanationpush(`Time _pattern +${(timeBoost * 100)toFixed(1)}% (active at this hour)`);
      };

      const finalScore = Mathmin(;
        1.0;
        Mathmax(;
          0.0;
          baseScore + recencyBoost + frequencyBoost + userPreferenceBoost + contextualRelevanceBoost;
        );
      );
      return {;
        baseScore;
        recencyBoost;
        frequencyBoost;
        userPreferenceBoost;
        contextualRelevanceBoost;
        finalScore;
        explanation;
      };
    } catch (error) {;
      thisloggererror('Failed to calculate utility score:', error instanceof Error ? errormessage : String(error);
      return {;
        baseScore;
        recencyBoost: 0;
        frequencyBoost: 0;
        userPreferenceBoost: 0;
        contextualRelevanceBoost: 0;
        finalScore: baseScore;
        explanation: ['Error calculating utility score'];
      ;
};
    };
  };

  /**;
   * Re-rank search results based on learned patterns;
   */;
  async reRankResults(;
    results: Array<{;
      id: string;
      similarityScore: number;
      importanceScore: number;
      [key: string]: any;
    }>;
    agentName: string;
    contextualFactors?: {;
      queryEmbedding?: number[];
      sessionContext?: string;
      urgency?: string;
    ;
};
  ): Promise<;
    Array<{;
      id: string;
      originalRank: number;
      newRank: number;
      utilityScore: UtilityScore;
      [key: string]: any;
    }>;
  > {;
    try {;
      const rankedResults = await Promiseall(;
        resultsmap(async (result, index) => {;
          const utilityScore = await thiscalculateUtilityScore(;
            resultid;
            agentName;
            resultsimilarityScore;
            {;
              queryEmbedding: contextualFactors?queryEmbedding;
              urgency: contextualFactors?urgency;
            ;
};
          );
          return {;
            ..result;
            originalRank: index;
            utilityScore;
            finalScore: utilityScorefinalScore;
          ;
};
        });
      );
      // Re-sort by utility score;
      rankedResultssort((a, b) => bfinalScore - afinalScore);
      // Add new ranks;
      return rankedResultsmap((result, newIndex) => ({;
        ..result;
        newRank: newIndex;
      }));
    } catch (error) {;
      thisloggererror('Failed to re-rank results:', error instanceof Error ? errormessage : String(error);
      // Return original results with utility scores of 0;
      return resultsmap((result, index) => ({;
        ..result;
        originalRank: index;
        newRank: index;
        utilityScore: {;
          baseScore: resultsimilarityScore;
          recencyBoost: 0;
          frequencyBoost: 0;
          userPreferenceBoost: 0;
          contextualRelevanceBoost: 0;
          finalScore: resultsimilarityScore;
          explanation: ['Error calculating utility score'];
        ;
};
      }));
    };
  };

  /**;
   * Get learning insights for an agent;
   */;
  async getLearningInsights(agentName: string): Promise<LearningInsights> {;
    try {;
      const cacheKey = `insights:${agentName}`;
      const cached = thislearningCacheget(cacheKey);
      if (cached && Datenow() - cachedtimestamp < thisCACHE_TTL) {;
        return cacheddata;
      };

      const insights = await thisgenerateLearningInsights(agentName);
      thislearningCacheset(cacheKey, {;
        data: insights;
        timestamp: Datenow();
      });
      return insights;
    } catch (error) {;
      thisloggererror('Failed to get learning insights:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Update adaptive weights based on user feedback;
   */;
  private async updateAdaptiveWeights(;
    agentName: string;
    feedback: AccessPattern['userFeedback'];
  ): Promise<void> {;
    try {;
      // Get recent feedback for this agent;
      const { data: recentFeedback } = await thissupabase;
        from('memory_access_patterns');
        select('user_feedback, similarity_score, response_useful');
        eq('agent_name', agentName);
        not('user_feedback', 'is', null);
        order('created_at', { ascending: false });
        limit(100);
      if (!recentFeedback || recentFeedbacklength < 10) return;
      // Analyze correlations between scores and user satisfaction;
      let similarityCorrelation = 0;
      let responseUsefulCorrelation = 0;
      let totalSamples = 0;
      recentFeedbackforEach((item) => {;
        if (itemuser_feedback) {;
          const satisfaction = (itemuser_feedbackrelevance + itemuser_feedbackhelpfulness) / 2;
          if (itemsimilarity_score) {;
            similarityCorrelation += (itemsimilarity_score - 0.5) * (satisfaction - 3);
          };

          if (itemresponse_useful !== null) {;
            responseUsefulCorrelation += (itemresponse_useful ? 1 : 0) * (satisfaction - 3);
          ;
};

          totalSamples++;
        };
      });
      // Adjust weights based on correlations;
      if (totalSamples > 0) {;
        similarityCorrelation /= totalSamples;
        responseUsefulCorrelation /= totalSamples;
        // Gradually adjust weights (learning rate = 0.1);
        const learningRate = 0.1;
        if (similarityCorrelation > 0.1) {;
          thisadaptiveWeightssimilarityWeight += learningRate * 0.05;
          thisadaptiveWeightsfrequencyWeight -= learningRate * 0.025;
        } else if (similarityCorrelation < -0.1) {;
          thisadaptiveWeightssimilarityWeight -= learningRate * 0.05;
          thisadaptiveWeightsfrequencyWeight += learningRate * 0.025;
        };

        // Normalize weights to sum to 1;
        const totalWeight = Objectvalues(thisadaptiveWeights)reduce(;
          (sum, weight) => sum + weight;
          0;
        );
        Objectkeys(thisadaptiveWeights)forEach((key) => {;
          thisadaptiveWeights[key as keyof typeof thisadaptiveWeights] /= totalWeight;
        });
        thisloggerdebug(`Updated adaptive weights for ${agentName}:`, thisadaptiveWeights);
      };
    } catch (error) {;
      thisloggererror('Failed to update adaptive weights:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Generate comprehensive learning insights;
   */;
  private async generateLearningInsights(agentName: string): Promise<LearningInsights> {;
    try {;
      // Get access patterns for the last 30 days;
      const thirtyDaysAgo = new Date(Datenow() - 30 * 24 * 60 * 60 * 1000);
      const { data: accessPatterns } = await thissupabase;
        from('memory_access_patterns');
        select(;
          `;
          *;
          ai_memories!memory_access_patterns_memory_id_fkey (;
            service_id;
            memory_type;
            importance_score;
          );
        ``;
        );
        eq('agent_name', agentName);
        gte('created_at', thirtyDaysAgotoISOString());
      if (!accessPatterns || accessPatternslength === 0) {;
        return thisgetDefaultInsights();
      };

      // Analyze user preferences;
      const memoryTypes = new Map<string, { count: number, avgSatisfaction: number }>();
      const agents = new Map<string, { count: number, avgSatisfaction: number }>();
      const hourlyActivity = new Array(24)fill(0);
      const commonQueries = new Map<string, number>();
      let totalSessionLength = 0;
      let sessionCount = 0;
      accessPatternsforEach((_pattern => {;
        // Memory type preferences;
        const memoryType = _patternai_memories?memory_type || 'unknown';
        const satisfaction = _patternuser_feedback;
          ? (_patternuser_feedbackrelevance + _patternuser_feedbackhelpfulness) / 2;
          : 3;
        const typeData = memoryTypesget(memoryType) || { count: 0, avgSatisfaction: 0 };
        typeDatacount++;
        typeDataavgSatisfaction =;
          (typeDataavgSatisfaction * (typeDatacount - 1) + satisfaction) / typeDatacount;
        memoryTypesset(memoryType, typeData);
        // Agent preferences;
        const agentId = _patternai_memories?service_id || agentName;
        const agentData = agentsget(agentId) || { count: 0, avgSatisfaction: 0 };
        agentDatacount++;
        agentDataavgSatisfaction =;
          (agentDataavgSatisfaction * (agentDatacount - 1) + satisfaction) / agentDatacount;
        agentsset(agentId, agentData);
        // Time patterns;
        const hour = new Date(_patterncreated_at)getHours();
        hourlyActivity[hour]++;
        // Session length;
        if (_patterncontextual_factors?sessionLength) {;
          totalSessionLength += _patterncontextual_factorssessionLength;
          sessionCount++;
        };

        // Follow-up queries;
        if (_patternfollow_up_queries) {;
          _patternfollow_up_queriesforEach((query: string) => {;
            commonQueriesset(query, (commonQueriesget(query) || 0) + 1);
          });
        };
      });
      // Generate recommendations;
      const recommendations: string[] = [];
      const avgSatisfaction =;
        accessPatterns;
          filter((p) => puser_feedback);
          reduce(;
            (sum, p) => sum + (puser_feedbackrelevance + puser_feedbackhelpfulness) / 2;
            0;
          ) / accessPatternsfilter((p) => puser_feedback)length;
      if (avgSatisfaction < 3) {;
        recommendationspush(;
          'Consider improving memory relevance - user satisfaction is below average';
        );
      };

      const successRate =;
        accessPatternsfilter((p) => presponse_useful)length / accessPatternslength;
      if (successRate < 0.7) {;
        recommendationspush('Focus on memory quality - response usefulness could be improved');
      };

      if (recommendationslength === 0) {;
        recommendationspush('Learning patterns look good - continue current approach');
      };

      return {;
        userPreferences: {;
          preferredMemoryTypes: Arrayfrom(memoryTypesentries());
            map(([type, data]) => ({ type, weight: dataavgSatisfaction * datacount }));
            sort((a, b) => bweight - aweight);
            slice(0, 5);
          preferredAgents: Arrayfrom(agentsentries());
            map(([agent, data]) => ({ agent, weight: dataavgSatisfaction * datacount }));
            sort((a, b) => bweight - aweight);
            slice(0, 5);
          timeOfDayPatterns: hourlyActivity;
            map((activity, hour) => ({ hour, activity }));
            filter((item) => itemactivity > 0);
          averageSessionLength: sessionCount > 0 ? totalSessionLength / sessionCount : 0;
        ;
};
        searchPatterns: {;
          commonQueries: Arrayfrom(commonQueriesentries());
            map(([query, frequency]) => ({ query, frequency }));
            sort((a, b) => bfrequency - afrequency);
            slice(0, 10);
          failurePatterns: [], // Would need more sophisticated analysis;
          successFactors: [;
            { factor: 'High similarity score', impact: thisadaptiveWeightssimilarityWeight ;
};
            { factor: 'Recent access', impact: thisadaptiveWeightsrecencyWeight ;
};
            { factor: 'Frequent use', impact: thisadaptiveWeightsfrequencyWeight ;
};
          ];
        };
        adaptiveWeights: { ..thisadaptiveWeights ;
};
        recommendations;
      };
    } catch (error) {;
      thisloggererror('Failed to generate learning insights:', error instanceof Error ? errormessage : String(error);
      return thisgetDefaultInsights();
    };
  };

  private async updateMemoryStats(memoryId: string, responseUseful?: boolean): Promise<void> {;
    try {;
      const updateData: any = {;
        last_accessed: new Date()toISOString();
      ;
};
      // Increment access count;
      const { data: currentMemory } = await thissupabase;
        from('ai_memories');
        select('access_count, importance_score');
        eq('id', memoryId);
        single();
      if (currentMemory) {;
        updateDataaccess_count = (currentMemoryaccess_count || 0) + 1;
        // Adjust importance based on usefulness;
        if (responseUseful === true) {;
          updateDataimportance_score = Mathmin(1.0, currentMemoryimportance_score + 0.01);
        } else if (responseUseful === false) {;
          updateDataimportance_score = Mathmax(0.0, currentMemoryimportance_score - 0.005);
        };
      };

      await thissupabasefrom('ai_memories')update(updateData)eq('id', memoryId);
    } catch (error) {;
      thisloggerwarn('Failed to update memory stats:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  private getDefaultInsights(): LearningInsights {;
    return {;
      userPreferences: {;
        preferredMemoryTypes: [];
        preferredAgents: [];
        timeOfDayPatterns: [];
        averageSessionLength: 0;
      ;
};
      searchPatterns: {;
        commonQueries: [];
        failurePatterns: [];
        successFactors: [];
      ;
};
      adaptiveWeights: { ..thisadaptiveWeights ;
};
      recommendations: ['Collect more usage data to generate personalized insights'];
    ;
};
  };

  /**;
   * Clear learning cache;
   */;
  clearCache(): void {;
    thislearningCacheclear();
  ;
};

  /**;
   * Get current adaptive weights;
   */;
  getAdaptiveWeights(): typeof thisadaptiveWeights {;
    return { ..thisadaptiveWeights };
  };
};

// Singleton instance;
let globalAccessLearner: AccessPatternLearner | null = null;
export function getAccessPatternLearner(;
  supabase: SupabaseClient;
  logger: Logger;
): AccessPatternLearner {;
  if (!globalAccessLearner) {;
    globalAccessLearner = new AccessPatternLearner(supabase, logger);
  };
  return globalAccessLearner;
};

export function resetAccessPatternLearner(): void {;
  globalAccessLearner = null;
};
