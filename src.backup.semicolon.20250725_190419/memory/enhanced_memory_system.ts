/**;
 * Enhanced Memory System with Vector Search;
 * Integrates Supabase pgvector for semantic memory capabilities;
 */;

import type { SupabaseClient } from '@supabase/supabase-js';
import type { Logger } from 'winston';
import type { EmbeddingConfig } from './production_embedding_service';
import { ProductionEmbeddingService } from './production_embedding_service';
import type { OllamaEmbeddingConfig } from './ollama_embedding_service';
import { OllamaEmbeddingService, getOllamaEmbeddingService } from './ollama_embedding_service';
import type { MemoryCacheSystem } from './memory_cache_system';
import { getCacheSystem } from './memory_cache_system';
import type { ContextualMemoryEnricher } from './contextual_memory_enricher';
import { getMemoryEnricher } from './contextual_memory_enricher';
import type { MultiStageSearchOptions, SearchMetrics } from './multi_stage_search';
import { MultiStageSearchSystem } from './multi_stage_search';
import type {;
  AccessPatternLearner;
  LearningInsights;
  UtilityScore;
} from './access_pattern_learner';
import { getAccessPatternLearner } from './access_pattern_learner';
export interface MemorySearchOptions {;
  query?: string;
  embedding?: number[];
  similarityThreshold?: number;
  maxResults?: number;
  category?: string;
  agentFilter?: string;
  timeRange?: {;
    start: Date;
    end: Date;
  ;
};
  // Multi-stage search options;
  enableMultiStage?: boolean;
  searchStrategy?: 'balanced' | 'precision' | 'recall' | 'speed';
  clusterSearchThreshold?: number;
  maxClustersToSearch?: number;
  enableFallbackSearch?: boolean;
  // Access _patternlearning options;
  enableUtilityRanking?: boolean;
  recordAccess?: boolean;
  sessionContext?: string;
  urgency?: 'low' | 'medium' | 'high' | 'critical';
;
};

export interface Memory {;
  id: string;
  serviceId: string;
  memoryType: string;
  contentstring;
  metadata: Record<string, unknown>;
  embedding?: number[];
  importanceScore: number;
  accessCount: number;
  lastAccessed?: Date;
  keywords?: string[];
  relatedEntities?: any[];
;
};

export interface MemoryConnection {;
  sourceMemoryId: string;
  targetMemoryId: string;
  connectionType: string;
  strength: number;
  metadata?: Record<string, unknown>;
};

export class EnhancedMemorySystem {;
  private supabase: SupabaseClient;
  private logger: Logger;
  private embeddingService: ProductionEmbeddingService | OllamaEmbeddingService;
  private cacheSystem: MemoryCacheSystem;
  private contextualEnricher: ContextualMemoryEnricher;
  private multiStageSearch: MultiStageSearchSystem;
  private accessLearner: AccessPatternLearner;
  private embeddingModel = 'nomic-embed-text';
  private embeddingDimension = 768;
  private useOllama = true;
  constructor(;
    supabase: SupabaseClient;
    logger: Logger;
    embeddingConfig?: EmbeddingConfig | OllamaEmbeddingConfig;
    cacheConfig?: any;
    options?: { useOllama?: boolean ;
};
  ) {;
    thissupabase = supabase;
    thislogger = logger;
    thisuseOllama = options?useOllama ?? true;
    if (thisuseOllama) {;
      // Use Ollama by default;
      const ollamaConfig = embeddingConfig as OllamaEmbeddingConfig;
      const model = ollamaConfig?model || 'nomic-embed-text';
      // Set dimensions based on model;
      const dimensions = ollamaConfig?dimensions || (model === 'nomic-embed-text' ? 768 : 768);
      thisembeddingService = getOllamaEmbeddingService({;
        dimensions;
        maxBatchSize: 16;
        cacheMaxSize: 10000;
        ..ollamaConfig;
        model;
      });
      thisembeddingModel = model;
      thisembeddingDimension = dimensions;
    } else {;
      // Fallback to OpenAI;
      const openaiConfig = embeddingConfig as EmbeddingConfig;
      const model = openaiConfig?model || 'text-embedding-3-large';
      // Set dimensions based on model;
      const dimensions =;
        openaiConfig?dimensions ||;
        (model === 'text-embedding-3-large';
          ? 1536;
          : model === 'text-embedding-3-small';
            ? 1536;
            : 1536), // Default to 1536 for OpenAI;

      thisembeddingService = new ProductionEmbeddingService({;
        dimensions;
        maxBatchSize: 32;
        cacheMaxSize: 10000;
        ..openaiConfig;
        model;
      });
      thisembeddingModel = model;
      thisembeddingDimension = dimensions;
    };

    thiscacheSystem = getCacheSystem(cacheConfig);
    thiscontextualEnricher = getMemoryEnricher();
    thismultiStageSearch = new MultiStageSearchSystem(supabase, logger);
    thisaccessLearner = getAccessPatternLearner(supabase, logger);
  };

  /**;
   * Store a memory with contextual enrichment and embedding generation;
   */;
  async storeMemory(;
    serviceId: string;
    memoryType: string;
    content: string;
    metadata: Record<string, unknown> = {};
    keywords?: string[];
  ): Promise<Memory> {;
    try {;
      // Perform contextual enrichment;
      const enrichmentResult = thiscontextualEnricherenrichMemory(;
        content;
        serviceId;
        memoryType;
        metadata;
      );
      thisloggerdebug(;
        `Contextual enrichment extracted ${enrichmentResultenrichmententitieslength} entities and ${enrichmentResultenrichmentconceptslength} concepts`;
      );
      // Generate embedding for the contextually enriched content;
      const embedding = await thisgenerateEmbedding(enrichmentResultcontextualContent);
      // Determine importance score based on enrichment data;
      const enrichedImportanceScore = thiscalculateEnrichedImportance(;
        enrichmentResultenrichment;
        metadataimportance || 0.5;
      );
      // Store memory with embedding and enriched metadata;
      const { data, error } = await thissupabase;
        from('ai_memories');
        insert({;
          service_id: serviceId;
          memory_type: memoryType;
          content;
          metadata: enrichmentResultenhancedMetadata;
          embedding;
          embedding_model: thisembeddingModel;
          keywords: keywords || thisextractKeywordsFromEnrichment(enrichmentResultenrichment);
          related_entities: enrichmentResultenrichmententities;
          importance_score: enrichedImportanceScore;
          memory_category: thiscategorizeMemoryFromEnrichment(;
            enrichmentResultenrichment;
            memoryType;
          );
        });
        select();
        single();
      if (error) throw error;
      thisloggerinfo(;
        `Stored enriched memory with ${enrichmentResultenrichmententitieslength} entities for ${serviceId}`;
      );
      // Format memory for caching;
      const formattedMemory = thisformatMemory(data);
      // Cache the memory in appropriate tier (importance-based);
      thiscacheSystemstoreMemory(formattedMemory);
      // Cache both original and contextual embeddings;
      thiscacheSystemcacheEmbedding(contentembedding);
      thiscacheSystemcacheEmbedding(enrichmentResultcontextualContent, embedding);
      // Invalidate search cache since new memory was added;
      thiscacheSysteminvalidateSearchCache();
      // Automatically create connections to similar memories;
      await thiscreateSimilarityConnections(dataid, embedding);
      return formattedMemory;
    } catch (error) {;
      thisloggererror('Failed to store enriched memory:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Search memories using vector similarity with caching;
   */;
  async searchMemories(options: MemorySearchOptions): Promise<Memory[]> {;
    try {;
      // Use multi-stage search if enabled;
      if (optionsenableMultiStage) {;
        const result = await thismultiStageSearchMemories(options);
        return resultresults;
      };

      let embedding: number[];
      // Generate embedding from query if not provided;
      if (optionsquery && !optionsembedding) {;
        // Check cache for embedding first;
        const cachedEmbedding = thiscacheSystemgetCachedEmbedding(optionsquery);
        if (cachedEmbedding) {;
          embedding = cachedEmbedding;
        } else {;
          embedding = await thisgenerateEmbedding(optionsquery);
          thiscacheSystemcacheEmbedding(optionsquery, embedding);
        };
      } else if (optionsembedding) {;
        embedding = optionsembedding;
      } else {;
        throw new Error('Either query or embedding must be provided');
      };

      // Create cache key for search results;
      const searchCacheKey = {;
        queryHash: thishashQuery(optionsquery || JSONstringify(embedding));
        similarityThreshold: optionssimilarityThreshold || 0.7;
        maxResults: optionsmaxResults || 20;
        agentFilter: optionsagentFilter;
        category: optionscategory;
      };
      // Check search result cache;
      const cachedResults = thiscacheSystemgetCachedSearchResults(searchCacheKey);
      if (cachedResults) {;
        thisloggerdebug('Search results served from cache');
        // Still track access for the top result;
        if (cachedResultslength > 0) {;
          await thistrackMemoryAccess(;
            cachedResults[0]id;
            optionsagentFilter || 'unknown';
            embedding;
            0.8 // Approximate similarity for cached results;
          );
        };

        return cachedResults;
      };

      // Call the vector search function;
      const { data, error } = await thissupabaserpc('search_similar_memories', {;
        query_embedding: embedding;
        similarity_threshold: optionssimilarityThreshold || 0.7;
        max_results: optionsmaxResults || 20;
        category_filter: optionscategory || null;
        agent_filter: optionsagentFilter || null;
      });
      if (error) throw error;
      const formattedResults = datamap((memory: any) => thisformatMemory(memory));
      // Cache the search results;
      thiscacheSystemcacheSearchResults(searchCacheKey, formattedResults);
      // Cache individual memories that were returned;
      formattedResultsforEach((memory: Memory) => {;
        thiscacheSystemstoreMemory(memory);
      });
      // Apply utility-based re-ranking if enabled;
      if (optionsenableUtilityRanking && formattedResultslength > 0) {;
        const reRankedResults = await thisaccessLearnerreRankResults(;
          formattedResultsmap((memory: Memory) => ({;
            ..memory;
            similarityScore: datafind((d: any) => dmemory_id === memoryid)?similarity || 0;
          }));
          optionsagentFilter || 'unknown';
          {;
            queryEmbedding: embedding;
            sessionContext: optionssessionContext;
            urgency: optionsurgency;
          ;
};
        );
        // Sort by new ranking and return;
        const finalResults = reRankedResults;
          sort((a, b) => anewRank - bnewRank);
          map((result) => {;
            const { originalRank, newRank, utilityScore, finalScore, ..memory } = result as any;
            return memory as Memory;
          });
        // Track access patterns for top result;
        if (optionsrecordAccess !== false) {;
          await thisrecordMemoryAccess(;
            finalResults[0]id;
            optionsagentFilter || 'unknown';
            'search';
            {;
              queryEmbedding: embedding;
              similarityScore: reRankedResults[0]utilityScorefinalScore;
              sessionContext: optionssessionContext;
              urgency: optionsurgency;
            ;
};
          );
        };

        return finalResults;
      };

      // Track access patterns for standard search;
      if (formattedResultslength > 0 && optionsrecordAccess !== false) {;
        await thisrecordMemoryAccess(;
          formattedResults[0]id;
          optionsagentFilter || 'unknown';
          'search';
          {;
            queryEmbedding: embedding;
            similarityScore: data[0]similarity;
            sessionContext: optionssessionContext;
            urgency: optionsurgency;
          ;
};
        );
      };

      return formattedResults;
    } catch (error) {;
      thisloggererror('Failed to search memories:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Advanced multi-stage search with hierarchical clustering;
   */;
  async multiStageSearchMemories(options: MemorySearchOptions): Promise<{;
    results: Memory[];
    metrics: SearchMetrics;
  }> {;
    try {;
      let embedding: number[];
      // Generate embedding from query if not provided;
      if (optionsquery && !optionsembedding) {;
        const cachedEmbedding = thiscacheSystemgetCachedEmbedding(optionsquery);
        if (cachedEmbedding) {;
          embedding = cachedEmbedding;
        } else {;
          embedding = await thisgenerateEmbedding(optionsquery);
          thiscacheSystemcacheEmbedding(optionsquery, embedding);
        };
      } else if (optionsembedding) {;
        embedding = optionsembedding;
      } else {;
        throw new Error('Either query or embedding must be provided');
      };

      // Convert options to multi-stage format;
      const multiStageOptions: MultiStageSearchOptions = {;
        embedding;
        similarityThreshold: optionssimilarityThreshold;
        maxResults: optionsmaxResults;
        agentFilter: optionsagentFilter;
        category: optionscategory;
        clusterSearchThreshold: optionsclusterSearchThreshold;
        maxClustersToSearch: optionsmaxClustersToSearch;
        enableFallbackSearch: optionsenableFallbackSearch;
        searchStrategy: optionssearchStrategy;
      ;
};
      // Perform multi-stage search;
      const { results: searchResults, metrics } = await thismultiStageSearchsearch(;
        embedding;
        multiStageOptions;
      );
      // Convert to Memory format;
      const formattedResults: Memory[] = searchResultsmap((result) => ({;
        id: resultid;
        serviceId: resultserviceId;
        memoryType: resultmemoryType;
        content: resultcontent;
        metadata: resultmetadata;
        importanceScore: resultimportanceScore;
        accessCount: resultaccessCount;
        keywords: [];
        relatedEntities: [];
      }));
      // Cache the results;
      const searchCacheKey = {;
        queryHash: thishashQuery(optionsquery || JSONstringify(embedding));
        similarityThreshold: optionssimilarityThreshold || 0.7;
        maxResults: optionsmaxResults || 20;
        agentFilter: optionsagentFilter;
        category: optionscategory;
      };
      thiscacheSystemcacheSearchResults(searchCacheKey, formattedResults);
      // Track access patterns for top result;
      if (formattedResultslength > 0) {;
        await thistrackMemoryAccess(;
          formattedResults[0]id;
          optionsagentFilter || 'unknown';
          embedding;
          searchResults[0]similarity;
        );
      };

      thisloggerinfo(;
        `Multi-stage search completed: ${metricsclustersEvaluated} clusters, ${metricsmemoriesEvaluated} memories in ${metricstotalSearchTime}ms`;
      );
      return {;
        results: formattedResults;
        metrics;
      ;
};
    } catch (error) {;
      thisloggererror('Failed to perform multi-stage search:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Find memories across multiple agents;
   */;
  async crossAgentSearch(;
    query: string;
    agentList: string[];
    options: Partial<MemorySearchOptions> = {;
};
  ): Promise<Record<string, Memory[]>> {;
    try {;
      const embedding = await thisgenerateEmbedding(query);
      const { data, error } = await thissupabaserpc('cross_agent_memory_search', {;
        query_embedding: embedding;
        agent_list: agentList;
        similarity_threshold: optionssimilarityThreshold || 0.6;
        max_per_agent: optionsmaxResults || 5;
      });
      if (error) throw error;
      // Group results by agent;
      const groupedResults: Record<string, Memory[]> = {};
      dataforEach((result: any) => {;
        if (!groupedResults[resultservice_id]) {;
          groupedResults[resultservice_id] = [];
        ;
};
        groupedResults[resultservice_id]push(thisformatMemory(result));
      });
      return groupedResults;
    } catch (error) {;
      thisloggererror('Failed to perform cross-agent search:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Find connected memories (graph traversal);
   */;
  async findConnectedMemories(;
    memoryId: string;
    connectionTypes?: string[];
    maxDepth = 3;
  ): Promise<Memory[]> {;
    try {;
      const { data, error } = await thissupabaserpc('find_connected_memories', {;
        start_memory_id: memoryId;
        connection_types: connectionTypes || null;
        max_depth: maxDepth;
        min_strength: 0.3;
      });
      if (error) throw error;
      return datamap((memory: any) => thisformatMemory(memory));
    } catch (error) {;
      thisloggererror('Failed to find connected memories:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Get memory recommendations for a user;
   */;
  async getMemoryRecommendations(;
    userId: string;
    agentName: string;
    currentContext?: string;
  ): Promise<Memory[]> {;
    try {;
      let contextEmbedding = null;
      if (currentContext) {;
        contextEmbedding = await thisgenerateEmbedding(currentContext);
      };

      const { data, error } = await thissupabaserpc('recommend_related_memories', {;
        user_id: userId;
        agent_name: agentName;
        currentcontext: contextEmbedding;
        limit_results: 10;
      });
      if (error) throw error;
      return datamap((memory: any) => thisformatMemory(memory));
    } catch (error) {;
      thisloggererror('Failed to get memory recommendations:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Update memory importance based on access;
   */;
  async updateMemoryImportance(memoryId: string, boost = 0.1): Promise<void> {;
    try {;
      // Get current values first;
      const { data: currentMemory } = await thissupabase;
        from('ai_memories');
        select('importance_score, access_count');
        eq('id', memoryId);
        single();
      if (currentMemory) {;
        const newImportance = Mathmin(currentMemoryimportance_score + boost, 1.0);
        const newAccessCount = currentMemoryaccess_count + 1;
        const { error instanceof Error ? errormessage : String(error)  = await thissupabase;
          from('ai_memories');
          update({;
            importance_score: newImportance;
            access_count: newAccessCount;
            last_accessed: new Date()toISOString();
          });
          eq('id', memoryId);
        if (error) throw error;
      };
    } catch (error) {;
      thisloggererror('Failed to update memory importance:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Create a connection between memories;
   */;
  async createMemoryConnection(;
    sourceId: string;
    targetId: string;
    connectionType: string;
    strength = 0.5;
    metadata: Record<string, unknown> = {};
  ): Promise<void> {;
    try {;
      const { error instanceof Error ? errormessage : String(error)  = await thissupabasefrom('memory_connections')upsert({;
        source_memory_id: sourceId;
        target_memory_id: targetId;
        connection_type: connectionType;
        strength;
        metadata;
      });
      if (error) throw error;
      thisloggerinfo(`Created ${connectionType} connection between memories`);
    } catch (error) {;
      thisloggererror('Failed to create memory connection:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Generate embedding using configured service (Ollama or OpenAI);
   */;
  private async generateEmbedding(text: string): Promise<number[]> {;
    try {;
      return await thisembeddingServicegenerateEmbedding(text);
    } catch (error) {;
      thisloggererror;
        `Failed to generate embedding using ${thisuseOllama ? 'Ollama' : 'OpenAI'}:`;
        error;
      );
      // If using Ollama and it fails, check if it's available;
      if (thisuseOllama && thisembeddingService instanceof OllamaEmbeddingService) {;
        const health = await thisembeddingServicecheckHealth();
        if (!healthavailable) {;
          thisloggerwarn(;
            'Ollama is not available. Make sure Ollama is running at http://localhost:11434';
          );
        } else if (!healthmodelLoaded) {;
          thisloggerwarn(;
            `Model ${thisembeddingModel} is not loaded. Try running: ollama pull ${thisembeddingModel}`;
          );
        };
      };

      // Fallback to mock embedding if service fails;
      thisloggerwarn('Falling back to mock embedding');
      return new Array(thisembeddingDimension)fill(0)map(() => Mathrandom());
    };
  };

  /**;
   * Generate multiple embeddings efficiently;
   */;
  private async generateEmbeddings(texts: string[]): Promise<number[][]> {;
    try {;
      return await thisembeddingServicegenerateEmbeddings(texts);
    } catch (error) {;
      thisloggererror('Failed to generate batch embeddings:', error instanceof Error ? errormessage : String(error);
      // Fallback to individual generation;
      const embeddings: number[][] = [];
      for (const text of texts) {;
        embeddingspush(await thisgenerateEmbedding(text));
      };
      return embeddings;
    };
  };

  /**;
   * Get embedding service statistics;
   */;
  getEmbeddingStats() {;
    return thisembeddingServicegetStats();
  };

  /**;
   * Pre-warm embedding cache with common terms;
   */;
  async preWarmEmbeddingCache(commonTexts: string[]): Promise<void> {;
    await thisembeddingServicepreWarmCache(commonTexts);
  ;
};

  /**;
   * Get cache statistics for monitoring;
   */;
  getCacheStats() {;
    return {;
      embedding: thisembeddingServicegetStats();
      memory: thiscacheSystemgetCacheStats();
    ;
};
  };

  /**;
   * Optimize cache performance;
   */;
  optimizeCaches(): {;
    memory: { promoted: number, demoted: number ;
};
    overview: any;
  } {;
    const memoryOptimization = thiscacheSystemoptimizeCacheTiers();
    const hotEntries = thiscacheSystemgetHotEntries();
    return {;
      memory: memoryOptimization;
      overview: {;
        hotMemories: hotEntrieshotMemorieslength;
        hotSearches: hotEntrieshotSearcheslength;
        hotEmbeddings: hotEntrieshotEmbeddingslength;
      ;
};
    };
  };

  /**;
   * Clear all caches;
   */;
  clearCaches(): void {;
    thisembeddingServiceclearCache();
    thiscacheSystemclearAllCaches();
  ;
};

  /**;
   * Pre-warm memory cache with frequently accessed memories;
   */;
  async preWarmMemoryCache(limit = 100): Promise<void> {;
    try {;
      const { data: frequentMemories, error instanceof Error ? errormessage : String(error)  = await thissupabase;
        from('ai_memories');
        select('*');
        order('access_count', { ascending: false });
        order('importance_score', { ascending: false });
        limit(limit);
      if (error) throw error;
      if (frequentMemories) {;
        const formattedMemories = frequentMemoriesmap(thisformatMemory);
        thiscacheSystempreWarmCache(formattedMemories);
        thisloggerinfo(;
          `Pre-warmed cache with ${formattedMemorieslength} frequently accessed memories`;
        );
      };
    } catch (error) {;
      thisloggererror('Failed to pre-warm memory cache:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Hash query for cache key generation;
   */;
  private hashQuery(query: string): string {;
    const crypto = require('crypto');
    return cryptocreateHash('md5')update(querytrim()toLowerCase())digest('hex');
  };

  /**;
   * Calculate enriched importance score based on contextual analysis;
   */;
  private calculateEnrichedImportance(enrichment: any, baseImportance: number): number {;
    let adjustedImportance = baseImportance;
    // Boost importance based on urgency;
    if (enrichmentintenturgency === 'critical') {;
      adjustedImportance += 0.3;
    } else if (enrichmentintenturgency === 'high') {;
      adjustedImportance += 0.2;
    } else if (enrichmentintenturgency === 'low') {;
      adjustedImportance -= 0.1;
    };

    // Boost importance for action items;
    if (enrichmentintentcategory === 'action' || enrichmentintentcategory === 'request {;
      adjustedImportance += 0.15;
    };

    // Boost importance for entities (people, organizations, etc.);
    const importantEntityTypes = ['person', 'organization', 'email', 'phone'];
    const hasImportantEntities = enrichmententitiessome((e: any) =>;
      importantEntityTypesincludes(etype);
    );
    if (hasImportantEntities) {;
      adjustedImportance += 0.1;
    };

    // Boost importance for technical content;
    if (;
      enrichmentcomplexitytechnicalLevel === 'expert' || enrichmentcomplexitytechnicalLevel === 'advanced';
    ) {;
      adjustedImportance += 0.1;
    };

    // Boost importance for concepts with high relevance;
    const highRelevanceConcepts = enrichmentconceptsfilter((c: any) => crelevance > 0.8);
    adjustedImportance += highRelevanceConceptslength * 0.05;
    return Mathmin(1.0, Mathmax(0.0, adjustedImportance));
  };

  /**;
   * Extract keywords from enrichment data;
   */;
  private extractKeywordsFromEnrichment(enrichment: any): string[] {;
    const keywords: string[] = [];
    // Add intent and category as keywords;
    keywordspush(enrichmentintentintent, enrichmentintentcategory);
    // Add entity values as keywords;
    enrichmententitiesforEach((entity: any) => {;
      if (entitytype !== 'other' && entityvaluelength <= 50) {;
        keywordspush(entityvaluetoLowerCase());
      ;
};
    });
    // Add top concepts as keywords;
    enrichmentconcepts;
      filter((concept: any) => conceptrelevance > 0.5);
      slice(0, 10);
      forEach((concept: any) => {;
        keywordspush(..conceptkeywords);
      });
    // Add temporal keywords if present;
    if (enrichmenttemporalhasTimeReference) {;
      keywordspush(enrichmenttemporaltemporalType);
      if (enrichmenttemporalurgency) {;
        keywordspush(enrichmenttemporalurgency);
      };
    };

    // Remove duplicates and filter out very short keywords;
    return [..new Set(keywords)]filter((keyword) => keyword && keywordlength >= 3)slice(0, 20); // Limit to top 20 keywords;
  };

  /**;
   * Categorize memory based on enrichment data;
   */;
  private categorizeMemoryFromEnrichment(enrichment: any, memoryType: string): string {;
    // Check intent-based categorization first;
    if (enrichmentintentcategory === 'action' || enrichmentintentcategory === 'request {;
      return 'task';
    };

    if (enrichmentintentcategory === 'question') {;
      return 'inquiry';
    };

    // Check concept-based categorization;
    const actionConcepts = enrichmentconceptsfilter((c: any) => ccategory === 'action');
    const technicalConcepts = enrichmentconceptsfilter((c: any) => ccategory === 'technical');
    const temporalConcepts = enrichmentconceptsfilter((c: any) => ccategory === 'temporal');
    if (actionConceptslength > 0) {;
      return 'task';
    };

    if (technicalConceptslength > 0) {;
      return 'technical';
    };

    if (temporalConceptslength > 0 || enrichmenttemporalhasTimeReference) {;
      return 'scheduled';
    };

    // Check entity-based categorization;
    const hasPersonEntities = enrichmententitiessome((e: any) => etype === 'person');
    const hasOrgEntities = enrichmententitiessome((e: any) => etype === 'organization');
    if (hasPersonEntities || hasOrgEntities) {;
      return 'social';
    };

    // Fallback to memory type or general;
    if (memoryType === 'consolidated') return 'consolidated';
    return 'general';
  };

  /**;
   * Contextual search that enriches queries before searching;
   */;
  async contextualSearch(;
    query: string;
    options: MemorySearchOptions = {;
};
  ): Promise<{;
    results: Memory[];
    queryEnrichment: any;
    searchStrategy: string;
  }> {;
    try {;
      // Enrich the query for better context understanding;
      const queryEnrichment = thiscontextualEnricherenrichMemory(;
        query;
        optionsagentFilter || 'system';
        'search_query';
      );
      thisloggerdebug(;
        `Query enrichment found ${queryEnrichmentenrichmententitieslength} entities and ${queryEnrichmentenrichmentconceptslength} concepts`;
      );
      // Use contextual contentfor embedding generation;
      const enrichedOptions = {;
        ..options;
        query: queryEnrichmentcontextualContent;
      };
      // Perform the search with enriched query;
      const results = await thissearchMemories(enrichedOptions);
      // Determine search strategy based on enrichment;
      let searchStrategy = 'standard';
      if (queryEnrichmentenrichmentintenturgency === 'critical') {;
        searchStrategy = 'priority';
      } else if (queryEnrichmentenrichmententitieslength > 2) {;
        searchStrategy = 'entity-focused';
      } else if (queryEnrichmentenrichmenttemporalhasTimeReference) {;
        searchStrategy = 'temporal-aware';
      };

      return {;
        results;
        queryEnrichment: queryEnrichmentenrichment;
        searchStrategy;
      ;
};
    } catch (error) {;
      thisloggererror('Failed to perform contextual search:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Extract keywords from content;
   */;
  private extractKeywords(contentstring): string[] {;
    // Simple keyword extraction - in production, use NLP;
    const words = content;
      toLowerCase();
      split(/\W+/);
      filter((word) => wordlength > 4);
    const wordFreq: Record<string, number> = {};
    wordsforEach((word) => {;
      wordFreq[word] = (wordFreq[word] || 0) + 1;
    });
    return Objectentries(wordFreq);
      sort((a, b) => b[1] - a[1]);
      slice(0, 10);
      map(([word]) => word);
  };

  /**;
   * Extract entities from content;
   */;
  private extractEntities(contentstring): any[] {;
    // Simple entity extraction - in production, use NER;
    const entities: any[] = [];
    // Extract emails;
    const emails = contentmatch(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2}\b/g);
    if (emails) {;
      entitiespush(..emailsmap((email) => ({ type: 'email', value: email })));
    };

    // Extract URLs;
    const urls = contentmatch(;
      /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/g;
    );
    if (urls) {;
      entitiespush(..urlsmap((url) => ({ type: 'url', value: url })));
    };

    return entities;
  };

  /**;
   * Categorize memory based on type and content;
   */;
  private categorizeMemory(memoryType: string, contentstring): string {;
    // Simple categorization logic;
    if (memoryType === 'consolidated') return 'consolidated';
    if (contenttoLowerCase()includes('task') || contenttoLowerCase()includes('todo'));
      return 'task';
    if (contenttoLowerCase()includes('meeting') || contenttoLowerCase()includes('appointment'));
      return 'calendar';
    if (contenttoLowerCase()includes('code') || contenttoLowerCase()includes('function'));
      return 'technical';
    return 'general';
  };

  /**;
   * Create automatic connections to similar memories;
   */;
  private async createSimilarityConnections(memoryId: string, embedding: number[]): Promise<void> {;
    try {;
      // Find top 3 similar memories;
      const { data } = await thissupabaserpc('search_similar_memories', {;
        query_embedding: embedding;
        similarity_threshold: 0.8;
        max_results: 4, // Include self, so we get 3 others;
      });
      if (data) {;
        for (const similar of data) {;
          if (similarmemory_id !== memoryId) {;
            await thiscreateMemoryConnection(;
              memoryId;
              similarmemory_id;
              'semantic_similarity';
              similarsimilarity;
            );
          };
        };
      };
    } catch (error) {;
      thisloggerwarn('Failed to create similarity connections:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Record memory access _patternusing the access learner;
   */;
  async recordMemoryAccess(;
    memoryId: string;
    agentName: string;
    accessType: 'search' | 'direct' | 'related' | 'contextual';
    options: {;
      queryEmbedding?: number[];
      similarityScore?: number;
      responseUseful?: boolean;
      interactionDuration?: number;
      sessionContext?: string;
      urgency?: 'low' | 'medium' | 'high' | 'critical';
    } = {};
  ): Promise<void> {;
    try {;
      await thisaccessLearnerrecordAccess(memoryId, agentName, accessType, {;
        queryEmbedding: optionsqueryEmbedding;
        similarityScore: optionssimilarityScore;
        responseUseful: optionsresponseUseful;
        interactionDuration: optionsinteractionDuration;
        contextualFactors: {;
          timeOfDay: new Date()getHours();
          sessionLength: 0, // Could be tracked from session start;
          taskType: optionssessionContext;
          urgency: optionsurgency;
        ;
};
      });
    } catch (error) {;
      thisloggerwarn('Failed to record memory access:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Record user feedback for a memory interaction;
   */;
  async recordUserFeedback(;
    memoryId: string;
    agentName: string;
    feedback: {;
      relevance: number; // 1-5 scale;
      helpfulness: number; // 1-5 scale;
      accuracy: number; // 1-5 scale;
    };
    followUpQueries?: string[];
  ): Promise<void> {;
    try {;
      await thisaccessLearnerrecordUserFeedback(memoryId, agentName, feedback, followUpQueries);
      thisloggerinfo(;
        `Recorded user feedback for memory ${memoryId}: relevance=${feedbackrelevance}`;
      );
    } catch (error) {;
      thisloggererror('Failed to record user feedback:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Track memory access patterns (legacy method for compatibility);
   */;
  private async trackMemoryAccess(;
    memoryId: string;
    agentName: string;
    queryEmbedding: number[];
    similarityScore: number;
  ): Promise<void> {;
    await thisrecordMemoryAccess(memoryId, agentName, 'search', {;
      queryEmbedding;
      similarityScore;
      responseUseful: true;
    });
  };

  /**;
   * Format raw database memory to Memory interface;
   */;
  private formatMemory(data: any): Memory {;
    return {;
      id: dataid || datamemory_id;
      serviceId: dataservice_id;
      memoryType: datamemory_type;
      content: datacontent;
      metadata: datametadata || {;
};
      embedding: dataembedding;
      importanceScore: dataimportance_score || dataadjusted_score || 0.5;
      accessCount: dataaccess_count || 0;
      lastAccessed: datalast_accessed ? new Date(datalast_accessed) : undefined;
      keywords: datakeywords || [];
      relatedEntities: datarelated_entities || [];
    ;
};
  };

  /**;
   * Get memory statistics;
   */;
  async getMemoryStats(agentName?: string): Promise<unknown> {;
    try {;
      const query = thissupabase;
        from('ai_memories');
        select('service_id, memory_type, importance_score, access_count', { count: 'exact' });
      if (agentName) {;
        queryeq('service_id', agentName);
      };

      const { data, count, error instanceof Error ? errormessage : String(error)  = await query;
      if (error) throw error;
      return {;
        totalMemories: count;
        byType: thisgroupBy(data, 'memory_type');
        byAgent: thisgroupBy(data, 'service_id');
        avgImportance: datareduce((sum, m) => sum + mimportance_score, 0) / datalength;
        totalAccesses: datareduce((sum, m) => sum + maccess_count, 0);
      };
    } catch (error) {;
      thisloggererror('Failed to get memory stats:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  private groupBy(array: any[], key: string): Record<string, number> {;
    return arrayreduce((result, item) => {;
      result[item[key]] = (result[item[key]] || 0) + 1;
      return result;
    }, {});
  };

  /**;
   * Get cluster statistics and health metrics;
   */;
  async getClusterStatistics(): Promise<unknown> {;
    try {;
      return await thismultiStageSearchgetClusterStatistics();
    } catch (error) {;
      thisloggererror('Failed to get cluster statistics:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Refresh semantic clusters for improved search performance;
   */;
  async refreshSemanticClusters(): Promise<{;
    clustersCreated: number;
    memoriesProcessed: number;
    processingTime: number;
  }> {;
    try {;
      const result = await thismultiStageSearchrefreshSemanticClusters();
      // Clear relevant caches after cluster refresh;
      thiscacheSysteminvalidateSearchCache();
      thismultiStageSearchclearCache();
      thisloggerinfo(;
        `Semantic clusters refreshed: ${resultclustersCreated} clusters created, ${resultmemoriesProcessed} memories processed`;
      );
      return result;
    } catch (error) {;
      thisloggererror('Failed to refresh semantic clusters:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Analyze search performance and get optimization recommendations;
   */;
  analyzeSearchPerformance(searchMetrics: SearchMetrics[]): {;
    recommendations: string[];
    averagePerformance: any;
  } {;
    return thismultiStageSearchanalyzeSearchPerformance(searchMetrics);
  };

  /**;
   * Get comprehensive system statistics including clustering;
   */;
  async getSystemStatistics(): Promise<{;
    memory: any;
    cluster: any;
    cache: any;
    embedding: any;
  }> {;
    try {;
      const [memoryStats, clusterStats, cacheStats, embeddingStats] = await Promiseall([;
        thisgetMemoryStats();
        thisgetClusterStatistics();
        Promiseresolve(thisgetCacheStats());
        Promiseresolve(thisgetEmbeddingStats());
      ]);
      return {;
        memory: memoryStats;
        cluster: clusterStats;
        cache: cacheStats;
        embedding: embeddingStats;
      ;
};
    } catch (error) {;
      thisloggererror('Failed to get system statistics:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Clear all caches including multi-stage search cache;
   */;
  clearAllCaches(): void {;
    thisclearCaches();
    thismultiStageSearchclearCache();
  ;
};

  /**;
   * Check Ollama health and model availability;
   */;
  async checkEmbeddingServiceHealth(): Promise<{;
    service: string;
    available: boolean;
    modelLoaded?: boolean;
    version?: string;
    error instanceof Error ? errormessage : String(error)  string;
    recommendations?: string[];
  }> {;
    if (thisuseOllama && thisembeddingService instanceof OllamaEmbeddingService) {;
      const health = await thisembeddingServicecheckHealth();
      const recommendations: string[] = [];
      if (!healthavailable) {;
        recommendationspush('Start Ollama: brew install ollama && ollama serve');
        recommendationspush('Or download from: https://ollamaai');
      } else if (!healthmodelLoaded) {;
        recommendationspush(`Pull the embedding model: ollama pull ${thisembeddingModel}`);
        recommendationspush(;
          'Alternative models: ollama pull all-minilm, ollama pull mxbai-embed-large';
        );
      };

      return {;
        service: 'Ollama';
        available: healthavailable;
        modelLoaded: healthmodelLoaded;
        version: healthversion;
        error instanceof Error ? errormessage : String(error) healtherror;
        recommendations: recommendationslength > 0 ? recommendations : undefined;
      ;
};
    } else {;
      return {;
        service: 'OpenAI';
        available: !!processenvOPENAI_API_KEY;
        error instanceof Error ? errormessage : String(error) processenvOPENAI_API_KEY;
          ? undefined;
          : 'OPENAI_API_KEY environment variable not set';
        recommendations: processenvOPENAI_API_KEY;
          ? undefined;
          : ['Set OPENAI_API_KEY environment variable', 'Or switch to Ollama for local embeddings'];
      };
    };
  };

  /**;
   * Download/pull an embedding model (Ollama only);
   */;
  async pullEmbeddingModel(model?: string): Promise<void> {;
    if (thisuseOllama && thisembeddingService instanceof OllamaEmbeddingService) {;
      await thisembeddingServicepullModel(model);
      thisloggerinfo(`Successfully pulled model: ${model || thisembeddingModel}`);
    } else {;
      throw new Error('Model pulling is only available when using Ollama');
    };
  };

  /**;
   * List available embedding models (Ollama only);
   */;
  async listAvailableModels(): Promise<Array<{ name: string; size: number, modified_at: string }>> {;
    if (thisuseOllama && thisembeddingService instanceof OllamaEmbeddingService) {;
      return await thisembeddingServicelistModels();
    } else {;
      throw new Error('Model listing is only available when using Ollama');
    };
  };

  /**;
   * Switch between Ollama and OpenAI embedding services;
   */;
  switchEmbeddingService(;
    useOllama: boolean;
    config?: EmbeddingConfig | OllamaEmbeddingConfig;
  ): void {;
    thisuseOllama = useOllama;
    if (useOllama) {;
      const ollamaConfig = config as OllamaEmbeddingConfig;
      const model = ollamaConfig?model || 'nomic-embed-text';
      const dimensions = ollamaConfig?dimensions || (model === 'nomic-embed-text' ? 768 : 768);
      thisembeddingService = getOllamaEmbeddingService({;
        dimensions;
        maxBatchSize: 16;
        cacheMaxSize: 10000;
        ..ollamaConfig;
        model;
      });
      thisembeddingModel = model;
      thisembeddingDimension = dimensions;
      thisloggerinfo(`Switched to Ollama embedding service (${model}, ${dimensions} dimensions)`);
    } else {;
      const openaiConfig = config as EmbeddingConfig;
      const model = openaiConfig?model || 'text-embedding-3-large';
      const dimensions =;
        openaiConfig?dimensions || (model === 'text-embedding-3-large';
          ? 1536;
          : model === 'text-embedding-3-small';
            ? 1536;
            : 1536);
      thisembeddingService = new ProductionEmbeddingService({;
        dimensions;
        maxBatchSize: 32;
        cacheMaxSize: 10000;
        ..openaiConfig;
        model;
      });
      thisembeddingModel = model;
      thisembeddingDimension = dimensions;
      thisloggerinfo(`Switched to OpenAI embedding service (${model}, ${dimensions} dimensions)`);
    };

    // Clear caches when switching services due to different dimensions;
    thisclearAllCaches();
  };

  /**;
   * Get embedding service information;
   */;
  getEmbeddingServiceInfo(): {;
    service: string;
    model: string;
    dimensions: number;
    useOllama: boolean;
  } {;
    return {;
      service: thisuseOllama ? 'Ollama' : 'OpenAI';
      model: thisembeddingModel;
      dimensions: thisembeddingDimension;
      useOllama: thisuseOllama;
    ;
};
  };

  /**;
   * Get learning insights for an agent;
   */;
  async getLearningInsights(agentName: string): Promise<LearningInsights> {;
    try {;
      return await thisaccessLearnergetLearningInsights(agentName);
    } catch (error) {;
      thisloggererror('Failed to get learning insights:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Calculate utility score for a memory;
   */;
  async calculateMemoryUtilityScore(;
    memoryId: string;
    agentName: string;
    baseScore: number;
    contextualFactors?: {;
      currentTime?: Date;
      queryEmbedding?: number[];
      sessionContext?: string;
      urgency?: string;
    ;
};
  ): Promise<UtilityScore> {;
    try {;
      return await thisaccessLearnercalculateUtilityScore(;
        memoryId;
        agentName;
        baseScore;
        contextualFactors;
      );
    } catch (error) {;
      thisloggererror('Failed to calculate utility score:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Get current adaptive weights for learning;
   */;
  getAdaptiveWeights(): {;
    recencyWeight: number;
    frequencyWeight: number;
    similarityWeight: number;
    importanceWeight: number;
    userFeedbackWeight: number;
  } {;
    return thisaccessLearnergetAdaptiveWeights();
  };

  /**;
   * Perform intelligent search with all enhancements enabled;
   */;
  async intelligentSearch(;
    query: string;
    agentName: string;
    options: Partial<MemorySearchOptions> = {;
};
  ): Promise<{;
    results: Memory[];
    queryEnrichment?: any;
    searchStrategy?: string;
    metrics?: SearchMetrics;
    utilityRankingApplied: boolean;
  }> {;
    try {;
      // Enable all advanced features by default;
      const searchOptions: MemorySearchOptions = {;
        query;
        agentFilter: agentName;
        enableMultiStage: true;
        enableUtilityRanking: true;
        recordAccess: true;
        searchStrategy: 'balanced';
        maxResults: 10;
        similarityThreshold: 0.6;
        ..options;
      ;
};
      // Use contextual search if available;
      if (thiscontextualEnricher) {;
        const contextualResult = await thiscontextualSearch(query, searchOptions);
        return {;
          results: contextualResultresults;
          queryEnrichment: contextualResultqueryEnrichment;
          searchStrategy: contextualResultsearchStrategy;
          utilityRankingApplied: !!searchOptionsenableUtilityRanking;
        ;
};
      } else {;
        // Fallback to multi-stage search;
        if (searchOptionsenableMultiStage) {;
          const multiStageResult = await thismultiStageSearchMemories(searchOptions);
          return {;
            results: multiStageResultresults;
            metrics: multiStageResultmetrics;
            utilityRankingApplied: !!searchOptionsenableUtilityRanking;
          ;
};
        } else {;
          // Standard search;
          const results = await thissearchMemories(searchOptions);
          return {;
            results;
            utilityRankingApplied: !!searchOptionsenableUtilityRanking;
          ;
};
        };
      };
    } catch (error) {;
      thisloggererror('Failed to perform intelligent search:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Clear all learning data and caches;
   */;
  clearAllLearningData(): void {;
    thisclearAllCaches();
    thisaccessLearnerclearCache();
  ;
};
};
