import type { SupabaseClient } from '@supabase/supabase-js';
import type { Logger } from 'winston';
import { EnhancedMemorySystem } from './enhanced_memory_system';
import type { EmbeddingConfig } from './production_embedding_service';
import type { OllamaEmbeddingConfig } from './ollama_embedding_service';
export interface MemorySystemConfig {;
  supabase: SupabaseClient;
  logger: Logger;
  embeddingConfig?: EmbeddingConfig | OllamaEmbeddingConfig;
  cacheConfig?: any;
  useOllama?: boolean;
  enableRetry?: boolean;
  maxRetries?: number;
;
};

export class SafeMemorySystemWrapper {;
  private memorySystem: EnhancedMemorySystem | null = null;
  private config: MemorySystemConfig;
  private initializationAttempts = 0;
  private isInitialized = false;
  private initializationError: Error | null = null;
  constructor(config: MemorySystemConfig) {;
    thisconfig = {;
      enableRetry: true;
      maxRetries: 3;
      useOllama: true;
      ..config;
    ;
};
  };

  async initialize(): Promise<boolean> {;
    if (thisisInitialized && thismemorySystem) {;
      return true;
    };

    while (thisinitializationAttempts < (thisconfigmaxRetries || 3)) {;
      try {;
        thisinitializationAttempts++;
        thisconfigloggerinfo(,);
          `Initializing memory system (attempt ${thisinitializationAttempts})`;
        );
        // Validate Supabase connection first;
        const { data, error } = await thisconfigsupabase;
          from('ai_memories');
          select('count');
          limit(1);
        if (error instanceof Error ? errormessage : String(error){;
          throw new Error(`Supabase connection test failed: ${errormessage}`);
        };

        // Create memory system with safe defaults;
        thismemorySystem = new EnhancedMemorySystem(;
          thisconfigsupabase;
          thisconfiglogger;
          thisconfigembeddingConfig || {;
            model: 'nomic-embed-text';
            dimensions: 768;
            maxBatchSize: 16;
            cacheMaxSize: 10000;
          ;
};
          thisconfigcacheConfig || {;
            redisUrl: 'redis://localhost:6379';
            enableFallback: true;
          ;
};
          {;
            useOllama: thisconfiguseOllama !== false;
          ;
};
        );
        thisisInitialized = true;
        thisinitializationError = null;
        thisconfigloggerinfo('Memory system initialized successfully');
        return true;
      } catch (error) {;
        thisinitializationError = erroras Error;
        thisconfigloggererror;
          `Memory system initialization failed (attempt ${thisinitializationAttempts}):`;
          error;
        );
        if (thisinitializationAttempts < (thisconfigmaxRetries || 3)) {;
          // Wait before retry with exponential backoff;
          const delay = Mathmin(1000 * Mathpow(2, thisinitializationAttempts - 1), 10000);
          thisconfigloggerinfo(`Retrying memory system initialization in ${delay}ms`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        };
      };
    };

    thisconfigloggererror('Memory system initialization failed after all retries');
    return false;
  };

  async storeMemory(;
    serviceId: string;
    memoryType: string;
    contentstring;
    metadata: Record<string, unknown> = {};
    keywords?: string[];
  ): Promise<unknown> {;
    if (!thisisInitialized) {;
      const initialized = await thisinitialize();
      if (!initialized) {;
        throw new Error('Memory system not available');
      };
    };

    try {;
      return await thismemorySystem!storeMemory(;
        serviceId;
        memoryType;
        content;
        metadata;
        keywords;
      );
    } catch (error) {;
      thisconfigloggererror('Failed to store memory:', error instanceof Error ? errormessage : String(error);
      // If it's a connection error instanceof Error ? errormessage : String(error) try to reinitialize;
      if (thisshouldReinitialize(error instanceof Error ? errormessage : String(error) {;
        thisisInitialized = false;
        thisinitializationAttempts = 0;
        const reinitialized = await thisinitialize();
        if (reinitialized) {;
          return await thismemorySystem!storeMemory(;
            serviceId;
            memoryType;
            content;
            metadata;
            keywords;
          );
        };
      };

      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async searchMemories(options: any): Promise<any[]> {;
    if (!thisisInitialized) {;
      const initialized = await thisinitialize();
      if (!initialized) {;
        thisconfigloggerwarn('Memory system not available, returning empty results');
        return [];
      };
    };

    try {;
      return await thismemorySystem!searchMemories(options);
    } catch (error) {;
      thisconfigloggererror('Failed to search memories:', error instanceof Error ? errormessage : String(error);
      // If it's a connection error instanceof Error ? errormessage : String(error) try to reinitialize;
      if (thisshouldReinitialize(error instanceof Error ? errormessage : String(error) {;
        thisisInitialized = false;
        thisinitializationAttempts = 0;
        const reinitialized = await thisinitialize();
        if (reinitialized) {;
          return await thismemorySystem!searchMemories(options);
        };
      };

      // Return empty results instead of throwing;
      return [];
    };
  };

  async updateMemory(memoryId: string, updates: any): Promise<unknown> {;
    if (!thisisInitialized) {;
      const initialized = await thisinitialize();
      if (!initialized) {;
        throw new Error('Memory system not available');
      };
    };

    try {;
      // Use Supabase directly to update memory;
      const { data, error } = await thisconfigsupabase;
        from('ai_memories');
        update(updates);
        eq('id', memoryId);
        select();
        single();
      if (error instanceof Error ? errormessage : String(error) throw error instanceof Error ? errormessage : String(error);

      // Update importance if needed;
      if (updatesimportanceBoost) {;
        await thismemorySystem!updateMemoryImportance(memoryId, updatesimportanceBoost);
      };

      return data;
    } catch (error) {;
      thisconfigloggererror('Failed to update memory:', error instanceof Error ? errormessage : String(error);
      if (thisshouldReinitialize(error instanceof Error ? errormessage : String(error) {;
        thisisInitialized = false;
        thisinitializationAttempts = 0;
        const reinitialized = await thisinitialize();
        if (reinitialized) {;
          return await thisupdateMemory(memoryId, updates);
        };
      };

      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async deleteMemory(memoryId: string): Promise<boolean> {;
    if (!thisisInitialized) {;
      const initialized = await thisinitialize();
      if (!initialized) {;
        throw new Error('Memory system not available');
      };
    };

    try {;
      // Use Supabase directly to delete memory;
      const { error instanceof Error ? errormessage : String(error)  = await thisconfigsupabasefrom('ai_memories')delete()eq('id', memoryId);
      if (error instanceof Error ? errormessage : String(error) throw error instanceof Error ? errormessage : String(error);

      // Also delete from memory connections;
      await thisconfigsupabase;
        from('memory_connections');
        delete();
        or(`source_memory_ideq.${memoryId},target_memory_ideq.${memoryId}`);
      return true;
    } catch (error) {;
      thisconfigloggererror('Failed to delete memory:', error instanceof Error ? errormessage : String(error);
      if (thisshouldReinitialize(error instanceof Error ? errormessage : String(error) {;
        thisisInitialized = false;
        thisinitializationAttempts = 0;
        const reinitialized = await thisinitialize();
        if (reinitialized) {;
          return await thisdeleteMemory(memoryId);
        };
      };

      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async generateEmbedding(text: string): Promise<number[]> {;
    if (!thisisInitialized) {;
      const initialized = await thisinitialize();
      if (!initialized) {;
        // Return a dummy embedding if system is not available;
        return new Array(768)fill(0);
      };
    };

    try {;
      // Use the memory system's search functionality to generate embeddings;
      // by searching with the text and extracting the embedding;
      const tempMemory = await thismemorySystem!storeMemory(;
        'temp-embedding-service';
        'embedding-generation';
        text;
        { temporary: true ;
};
        [];
      );
      // Get the embedding from the stored memory;
      const { data } = await thisconfigsupabase;
        from('ai_memories');
        select('embedding');
        eq('id', tempMemoryid);
        single();
      // Delete the temporary memory;
      await thisconfigsupabasefrom('ai_memories')delete()eq('id', tempMemoryid);
      return data?embedding || new Array(768)fill(0);
    } catch (error) {;
      thisconfigloggererror('Failed to generate embedding:', error instanceof Error ? errormessage : String(error);
      if (thisshouldReinitialize(error instanceof Error ? errormessage : String(error) {;
        thisisInitialized = false;
        thisinitializationAttempts = 0;
        const reinitialized = await thisinitialize();
        if (reinitialized) {;
          return await thisgenerateEmbedding(text);
        };
      };

      // Return a dummy embedding as fallback;
      return new Array(768)fill(0)map(() => Mathrandom());
    };
  };

  private shouldReinitialize(error instanceof Error ? errormessage : String(error) any): boolean {;
    const errorMessage = error instanceof Error ? errormessage : String(error) message || '';
    const connectionErrors = [;
      'ECONNREFUSED';
      'ETIMEDOUT';
      'ENOTFOUND';
      'connection';
      'timeout';
      'Cannot read';
      'undefined';
    ];
    return connectionErrorssome((keyword) => errorMessageincludes(keyword));
  };

  getStatus(): {;
    initialized: boolean;
    attempts: number;
    error instanceof Error ? errormessage : String(error) string | null;
  } {;
    return {;
      initialized: thisisInitialized;
      attempts: thisinitializationAttempts;
      error instanceof Error ? errormessage : String(error) thisinitializationError?message || null;
    ;
};
  };

  isReady(): boolean {;
    return thisisInitialized && thismemorySystem !== null;
  };
};
