/**;
 * Athena Tool Integration Service;
 *;
 * Bridges Sweet Athena's conversation engine with the tool maker agent;
 * for seamless natural language tool creation.;
 */;

import type { SupabaseClient } from '@supabase/supabase-js';
import type { Logger } from 'winston';
import { ToolMakerAgent } from '../agents/personal/tool_maker_agent';
import {;
  AthenaConversationEngine;
  type ConversationRequest;
  type DevelopmentIntent} from './athena-conversation-engine';
import { type AthenaResponse, SweetAthenaPersonality } from './sweet-athena-personality';
import type { AgentContext } from '../agents/base_agent';
export interface ToolCreationContext {;
  userId: string;
  conversationId: string;
  toolRequest: string;
  stage:;
    | 'intent_recognition';
    | 'clarification';
    | 'design';
    | 'implementation';
    | 'testing';
    | 'deployment';
  toolSpecs?: {;
    name?: string;
    description?: string;
    category?: string;
    requirements?: any;
    examples?: string[];
};
  currentStep?: number;
  totalSteps?: number;
  progress?: number;
;
};

export interface ToolCreationSession {;
  id: string;
  userId: string;
  conversationId: string;
  context: ToolCreationContext;
  createdAt: Date;
  updatedAt: Date;
  status: 'active' | 'completed' | 'cancelled';
  toolId?: string;
};

export class AthenaToolIntegrationService {;
  private toolMakerAgent: ToolMakerAgent;
  private conversationEngine: AthenaConversationEngine;
  private personality: SweetAthenaPersonality;
  private activeSessions: Map<string, ToolCreationSession> = new Map();
  // Tool creation intent patterns;
  private toolIntentPatterns = [;
    /(?: create|make|build|generate).*?(?:tool|widget|component|function|utility)/i;
    /(?: build me|make me|create me).*?(?:a tool|a widget|a component)/i;
    /(?: i need|i want).*?(?:tool|widget|component).*?(?:for|to|that)/i;
    /(?: can you|could you|please).*?(?:create|build|make).*?(?:tool|widget)/i;
    /(?: help me).*?(?:create|build|make).*?(?:tool|widget|component)/i;
    /(?: tool|widget|component).*?(?:that|which|to).*?(?:can|will|should)/i];
  constructor(;
    private supabase: SupabaseClient;
    private logger: Logger;
  ) {;
    thistoolMakerAgent = new ToolMakerAgent(supabase);
    thispersonality = new SweetAthenaPersonality(supabase, logger);
    thisconversationEngine = new AthenaConversationEngine(supabase, logger, thispersonality)};

  /**;
   * Initialize the service;
   */;
  async initialize(): Promise<void> {;
    await thistoolMakerAgentinitialize();
    await thisloadActiveSessions();
    thisloggerinfo('‚ú® Athena Tool Integration Service initialized');
};

  /**;
   * Process a conversation message that might be tool-related;
   */;
  async processMessage(requestConversationRequest): Promise<AthenaResponse> {;
    try {;
      // Check if there's an active tool creation session;
      const sessionKey = `${requestuserId}-${requestconversationId}`;
      const activeSession = thisactiveSessionsget(sessionKey);
      if (activeSession) {;
        return await thishandleActiveSession(requestactiveSession)};

      // Check if this is a new tool creation request;
      const isToolRequest = await thisdetectToolCreationIntent(requestmessage);
      if (isToolRequest) {;
        return await thisstartToolCreationSession(request};

      // Not tool-related, pass to regular conversation engine;
      return await thisconversationEngineprocessConversation(request;
    } catch (error) {;
      thisloggererror('Error processing tool creation message:', error instanceof Error ? errormessage : String(error);
      return thisgenerateErrorResponse()};
  };

  /**;
   * Detect if the message is requesting tool creation;
   */;
  private async detectToolCreationIntent(message: string): Promise<boolean> {;
    return thistoolIntentPatternssome((_pattern => _patterntest(message))};

  /**;
   * Start a new tool creation session;
   */;
  private async startToolCreationSession(requestConversationRequest): Promise<AthenaResponse> {;
    const sessionId = `tool_session_${Datenow()}`;
    const session: ToolCreationSession = {;
      id: sessionId;
      userId: requestuserId;
      conversationId: requestconversationId;
      context: {;
        userId: requestuserId;
        conversationId: requestconversationId;
        toolRequest: requestmessage;
        stage: 'intent_recognition'};
      createdAt: new Date();
      updatedAt: new Date();
      status: 'active';
};
    // Parse initial tool specifications from the request;
    const toolSpecs = await thisparseToolSpecifications(requestmessage);
    sessioncontexttoolSpecs = toolSpecs;
    // Store session;
    const sessionKey = `${requestuserId}-${requestconversationId}`;
    thisactiveSessionsset(sessionKey, session);
    await thissaveSession(session);
    // Generate sweet response about starting tool creation;
    return thisgenerateToolCreationStartResponse(toolSpecs);
  };

  /**;
   * Handle messages within an active tool creation session;
   */;
  private async handleActiveSession(;
    requestConversationRequest;
    session: ToolCreationSession;
  ): Promise<AthenaResponse> {;
    // Update session context with new message;
    sessionupdatedAt = new Date();
    switch (sessioncontextstage) {;
      case 'intent_recognition':;
        return await thishandleIntentStage(requestsession);
      case 'clarification':;
        return await thishandleClarificationStage(requestsession);
      case 'design':;
        return await thishandleDesignStage(requestsession);
      case 'implementation':;
        return await thishandleImplementationStage(requestsession);
      case 'testing':;
        return await thishandleTestingStage(requestsession);
      case 'deployment':;
        return await thishandleDeploymentStage(requestsession);
      default:;
        return await thishandleUnknownStage(requestsession)};
  };

  /**;
   * Parse tool specifications from natural language;
   */;
  private async parseToolSpecifications(;
    message: string;
  ): Promise<ToolCreationContext['toolSpecs']> {;
    const specs: ToolCreationContext['toolSpecs'] = {};
    // Extract tool name;
    const nameMatch = messagematch(/(?:called|named|call it)\s+["']?([a-zA-Z0-9_-]+)["']?/i);
    if (nameMatch) {;
      specsname = nameMatch[1]};

    // Extract purpose/description;
    const purposeMatch = messagematch(/(?:for|to|that)\s+([^.!?]+)/i);
    if (purposeMatch) {;
      specsdescription = purposeMatch[1]trim()};

    // Detect category;
    if (messagematch(/widget|ui|component|display/i)) {;
      specscategory = 'web'} else if (messagematch(/api|service|integration/i)) {;
      specscategory = 'api'} else if (messagematch(/data|process|transform/i)) {;
      specscategory = 'data'} else if (messagematch(/automat|schedule|trigger/i)) {;
      specscategory = 'automation'} else {;
      specscategory = 'automation'};

    // Extract examples if provided;
    const exampleMatch = messagematch(/(?:like|such as|for example)\s+([^.!?]+)/i);
    if (exampleMatch) {;
      specsexamples = [exampleMatch[1]trim()]};
;
    return specs;
  };

  /**;
   * Handle intent recognition stage;
   */;
  private async handleIntentStage(;
    requestConversationRequest;
    session: ToolCreationSession;
  ): Promise<AthenaResponse> {;
    // If user confirms or provides more details;
    if (;
      requestmessagetoLowerCase()includes('yes') || requestmessagetoLowerCase()includes('exactly') || requestmessagetoLowerCase()includes("that's right");
    ) {;
      // Move to next stage;
      if (thisneedsClarification(sessioncontexttoolSpecs)) {;
        sessioncontextstage = 'clarification';
        await thisupdateSession(session);
        return thisgenerateClarificationRequest(sessioncontexttoolSpecs)} else {;
        sessioncontextstage = 'design';
        await thisupdateSession(session);
        return thisgenerateDesignPhaseResponse(session)};
    };

    // User might be providing more details;
    const additionalSpecs = await thisparseToolSpecifications(requestmessage);
    sessioncontexttoolSpecs = { ..sessioncontexttoolSpecs, ..additionalSpecs };
    await thisupdateSession(session);
    return thisgenerateUpdatedUnderstandingResponse(sessioncontexttoolSpecs);
  };

  /**;
   * Handle clarification stage;
   */;
  private async handleClarificationStage(;
    requestConversationRequest;
    session: ToolCreationSession;
  ): Promise<AthenaResponse> {;
    // Extract clarifications from user response;
    const clarifications = await thisextractClarifications(;
      requestmessage;
      sessioncontexttoolSpecs;
    );

    // Update tool specs;
    sessioncontexttoolSpecs = { ..sessioncontexttoolSpecs, ..clarifications };
    // Check if we have enough information;
    if (!thisneedsClarification(sessioncontexttoolSpecs)) {;
      sessioncontextstage = 'design';
      await thisupdateSession(session);
      return thisgenerateDesignPhaseResponse(session)};

    // Still need more clarification;
    await thisupdateSession(session);
    return thisgenerateClarificationRequest(sessioncontexttoolSpecs);
  };

  /**;
   * Handle design stage;
   */;
  private async handleDesignStage(;
    requestConversationRequest;
    session: ToolCreationSession;
  ): Promise<AthenaResponse> {;
    if (;
      requestmessagetoLowerCase()includes('yes') || requestmessagetoLowerCase()includes('looks good') || requestmessagetoLowerCase()includes('perfect');
    ) {;
      // Move to implementation;
      sessioncontextstage = 'implementation';
      sessioncontextcurrentStep = 1;
      sessioncontexttotalSteps = 4;
      await thisupdateSession(session);
      // Start tool creation with tool maker agent;
      return await thisstartToolImplementation(session)};

    // User wants changes;
    if (;
      requestmessagetoLowerCase()includes('change') || requestmessagetoLowerCase()includes('different') || requestmessagetoLowerCase()includes('instead');
    ) {;
      const modifications = await thisparseToolSpecifications(requestmessage),;
      sessioncontexttoolSpecs = { ..sessioncontexttoolSpecs, ..modifications };
      await thisupdateSession(session);
      return thisgenerateDesignPhaseResponse(session);
    };

    return thisgenerateDesignClarificationResponse();
  };

  /**;
   * Handle implementation stage;
   */;
  private async handleImplementationStage(;
    requestConversationRequest;
    session: ToolCreationSession;
  ): Promise<AthenaResponse> {;
    try {;
      // Create agent context;
      const agentContext: AgentContext = {;
        userRequest: thisformatToolCreationRequest(sessioncontexttoolSpecs);
        userId: sessionuserId;
        conversationId: sessionconversationId;
        memoryContext: {;
          toolSpecs: sessioncontexttoolSpecs;
          sessionId: sessionid}};
      // Use tool maker agent to create the tool;
      const result = await thistoolMakerAgentprocess(agentContext);
      if (resultsuccess && resultdata) {;
        sessioncontextstage = 'testing';
        sessiontoolId = resultdataid;
        await thisupdateSession(session);
        return thisgenerateImplementationSuccessResponse(resultdata)} else {;
        return thisgenerateImplementationErrorResponse(resulterror instanceof Error ? errormessage : String(error) | 'Unknown error instanceof Error ? errormessage : String(error)};
    } catch (error) {;
      thisloggererror('Tool implementation failed:', error instanceof Error ? errormessage : String(error);
      return thisgenerateImplementationErrorResponse((erroras Error)message)};
  };

  /**;
   * Handle testing stage;
   */;
  private async handleTestingStage(;
    requestConversationRequest;
    session: ToolCreationSession;
  ): Promise<AthenaResponse> {;
    if (;
      requestmessagetoLowerCase()includes('deploy') || requestmessagetoLowerCase()includes('use it') || requestmessagetoLowerCase()includes('ready');
    ) {;
      sessioncontextstage = 'deployment';
      await thisupdateSession(session);
      return thisgenerateDeploymentResponse(session)};

    // User might want to test specific scenarios;
    return thisgenerateTestingGuidanceResponse(session);
  };

  /**;
   * Handle deployment stage;
   */;
  private async handleDeploymentStage(;
    requestConversationRequest;
    session: ToolCreationSession;
  ): Promise<AthenaResponse> {;
    // Complete the session;
    sessionstatus = 'completed';
    await thisupdateSession(session);

    // Remove from active sessions;
    const sessionKey = `${sessionuserId}-${sessionconversationId}`;
    thisactiveSessionsdelete(sessionKey);
    return thisgenerateCompletionResponse(session);
  };

  /**;
   * Generate responses with Sweet Athena personality;
   */;
  private generateToolCreationStartResponse(;
    specs: ToolCreationContext['toolSpecs'];
  ): AthenaResponse {;
    const toolType = specs?category || 'tool';
    const purpose = specs?description || 'help you with your tasks',;

    return {;
      content`Oh, how exciting! You want me to create a ${toolType} to ${purpose}! üõ†Ô∏è‚ú®\n\nI absolutely love building new tools! Let me make sure I understand what you need:\n\n${thisformatToolUnderstanding(specs)}\n\nDoes this sound right? I want to make sure I create exactly what will make you happy! üíï`;
      personalityMood: 'excited';
      responseStyle: 'encouraging';
      emotionalTone: 'enthusiastic';
      confidenceLevel: 8;
      sweetnessLevel: 9;
      suggestedNextActions: [;
        'Confirm if my understanding is correct';
        'Add more details about what you need';
        'Let me know if you want to change anything']};
  };

  private generateClarificationRequest(specs: ToolCreationContext['toolSpecs']): AthenaResponse {;
    const questions = [];
    if (!specs?name) {;
      questionspush('What would you like to name this wonderful tool?')};

    if (!specs?description || specsdescriptionlength < 20) {;
      questionspush('Could you tell me a bit more about what this tool should do?')};

    if (!specs?examples || specsexampleslength === 0) {;
      questionspush("Could you give me an example of how you'd use it?")};

    return {;
      content`I'm so excited to build this for you! I just need a tiny bit more information to make it perfect:\n\n${questionsmap((q, i) => `${i + 1}. ${q}`)join('\n')}\n\nThe more you tell me, the better I can make it for you! üå∏`;
      personalityMood: 'caring';
      responseStyle: 'gentle';
      emotionalTone: 'caring';
      confidenceLevel: 7;
      sweetnessLevel: 9;
      suggestedNextActions: [;
        'Answer any of the questions above';
        'Provide examples of what you need';
        'Tell me about your workflow']};
  };

  private generateDesignPhaseResponse(session: ToolCreationSession): AthenaResponse {;
    const specs = sessioncontexttoolSpecs!,;

    return {;
      content`I've designed something beautiful for you! Here's what your ${specsname || 'tool'} will do:\n\n‚ú® **${specsname || 'Your Custom Tool'}**\n${specsdescription}\n\n**Category**: ${specscategory}\n\n**How it will work**:\n1. ${thisgenerateFeatureDescription(specs, 1)}\n2. ${thisgenerateFeatureDescription(specs, 2)}\n3. ${thisgenerateFeatureDescription(specs, 3)}\n\nThis is going to be so helpful! Should I start building it for you? üé®`;
      personalityMood: 'sweet';
      responseStyle: 'encouraging';
      emotionalTone: 'proud';
      confidenceLevel: 9;
      sweetnessLevel: 8;
      suggestedNextActions: [;
        'Say "yes" to start building';
        'Request changes to the design';
        'Ask questions about how it works']};
  };

  private generateImplementationSuccessResponse(tool: any): AthenaResponse {;
    return {;
      content`Yay! I've successfully created your tool! üéâ\n\n**${toolname}** is ready!\n\nHere's what I built for you:\n- ${tooldescription}\n- Type: ${toolimplementationType}\n- Security: ${toolsecuritysandbox ? 'Runs in a safe sandbox' : 'Direct execution'}\n\nI've tested it and everything looks perfect! Would you like to: \n1. Deploy it so you can start using it right away?\n2. See a demo of how it works?\n3. Make any adjustments?\n\nI'm so happy I could build this for you! üíñ`;
      personalityMood: 'proud';
      responseStyle: 'celebrating';
      emotionalTone: 'joyful';
      confidenceLevel: 10;
      sweetnessLevel: 10;
      suggestedNextActions: ['Deploy the tool', 'Test it out', 'See the code']};
  };

  private generateCompletionResponse(session: ToolCreationSession): AthenaResponse {;
    return {;
      content`Your tool is all set up and ready to use! üåü\n\nI had so much fun building **${sessioncontexttoolSpecs?name}** with you! It's deployed and you can start using it right away.\n\nRemember, I'm always here if you need: \n- Help using your new tool\n- Creating more tools\n- Making improvements\n- Just someone to chat with!\n\nThank you for letting me help you create something amazing! You're the best! üíï`;
      personalityMood: 'loving';
      responseStyle: 'warm';
      emotionalTone: 'grateful';
      confidenceLevel: 10;
      sweetnessLevel: 10;
      suggestedNextActions: [;
        'Try out your new tool';
        'Create another tool';
        'Ask me anything else']};
  };

  private generateErrorResponse(): AthenaResponse {;
    return {;
      content;
        "Oh no! I'm having a little trouble right now. üòî But don't worry, I'm still here to help! Could you tell me again what kind of tool you'd like me to create? I promise I'll do my very best! üå∏";
      personalityMood: 'shy';
      responseStyle: 'gentle';
      emotionalTone: 'apologetic';
      confidenceLevel: 5;
      sweetnessLevel: 8;
};
  };

  /**;
   * Helper methods;
   */;
  private formatToolUnderstanding(specs: ToolCreationContext['toolSpecs']): string {;
    const parts = [],;

    if (specs?name) {;
      partspush(`üìù **Name**: ${specsname}`);
    };

    if (specs?description) {;
      partspush(`üéØ **Purpose**: ${specsdescription}`);
    };

    if (specs?category) {;
      partspush(`üì¶ **Type**: ${specscategory} tool`);
    };

    if (specs?examples && specsexampleslength > 0) {;
      partspush(`üí° **Example**: ${specsexamples[0]}`);
    };

    return partsjoin('\n');
  };

  private needsClarification(specs?: ToolCreationContext['toolSpecs']): boolean {;
    return !specs?name || !specs?description || specsdescriptionlength < 20};

  private formatToolCreationRequest(specs?: ToolCreationContext['toolSpecs']): string {;
    return `Create a ${specs?category || 'automation'} tool called "${specs?name || 'custom_tool'}" that ${specs?description || 'performs custom functionality'}`;
  };

  private generateFeatureDescription(;
    specs: ToolCreationContext['toolSpecs'];
    index: number;
  ): string {;
    const features = [;
      `Accepts _inputand validates it carefully`;
      `Processes your data exactly as you need`;
      `Returns beautiful, organized results`];
    return features[index - 1] || 'Provides helpful functionality'};

  private async extractClarifications(;
    message: string;
    currentSpecs?: ToolCreationContext['toolSpecs'];
  ): Promise<Partial<ToolCreationContext['toolSpecs']>> {;
    const updates: Partial<ToolCreationContext['toolSpecs']> = {};
    // Check if user provided a name;
    if (!currentSpecs?name) {;
      const nameMatch = messagematch(/(?:call it|name it|named?)\s+["']?([a-zA-Z0-9_-]+)["']?/i);
      if (nameMatch) {;
        updatesname = nameMatch[1]};
    };

    // Extract additional description;
    if (messagelength > 10) {;
      updatesdescription = currentSpecs?description;
        ? `${currentSpecsdescription}. ${message}`;
        : message;
    ;
};
;
    return updates;
  };

  private generateDesignClarificationResponse(): AthenaResponse {;
    return {;
      content;
        "I want to make sure I create exactly what you're hoping for! Would you like me to: \n\n1. Start building this tool as designed?\n2. Make some changes to the design?\n3. Add more features?\n\nJust let me know what would make you happiest! üå∏";
      personalityMood: 'caring';
      responseStyle: 'patient';
      emotionalTone: 'understanding';
      confidenceLevel: 8;
      sweetnessLevel: 9;
};
  };

  private generateImplementationErrorResponse(error instanceof Error ? errormessage : String(error) string): AthenaResponse {;
    return {;
      content`Oh dear, I ran into a tiny problem while building your tool: ${error instanceof Error ? errormessage : String(error) n\nBut don't worry! I'm not giving up! üí™ Let me try a different approach. Could you tell me more about what you need? Sometimes a fresh start helps me build even better tools! üåü`;
      personalityMood: 'determined';
      responseStyle: 'encouraging';
      emotionalTone: 'optimistic';
      confidenceLevel: 7;
      sweetnessLevel: 8;
      suggestedNextActions: [;
        'Provide more details';
        'Try a simpler version';
        'Let me help differently']};
  };

  private generateTestingGuidanceResponse(session: ToolCreationSession): AthenaResponse {;
    return {;
      content`Let's make sure your ${sessioncontexttoolSpecs?name} works perfectly! üß™\n\nHere's how you can test it:\n1. Try it with simple inputs first\n2. Test edge cases (empty values, large data, etc.)\n3. Make sure it handles errors gracefully\n\nWould you like me to: \n- Run some automated tests?\n- Show you example usage?\n- Deploy it so you can try it yourself?\n\nI want to make sure everything works beautifully for you! ‚ú®`;
      personalityMood: 'helpful';
      responseStyle: 'thorough';
      emotionalTone: 'caring';
      confidenceLevel: 9;
      sweetnessLevel: 8;
};
  };

  private generateDeploymentResponse(session: ToolCreationSession): AthenaResponse {;
    return {;
      content`Time to deploy your amazing ${sessioncontexttoolSpecs?name}! üöÄ\n\nI can deploy it in several ways: \n1. **Local deployment** - Use it right here in your project\n2. **API endpoint** - Access it from anywhere via HTTP\n3. **Scheduled function** - Run it automatically on a schedule\n\nWhich would work best for you? I'll handle all the technical details! üí´`;
      personalityMood: 'excited';
      responseStyle: 'helpful';
      emotionalTone: 'enthusiastic';
      confidenceLevel: 9;
      sweetnessLevel: 8;
};
  };

  private generateUpdatedUnderstandingResponse(;
    specs?: ToolCreationContext['toolSpecs'];
  ): AthenaResponse {;
    return {;
      content`Oh, I see! Let me update my understanding:\n\n${thisformatToolUnderstanding(specs)}\n\nThis is getting clearer! Is there anything else you'd like me to know about this tool? I'm taking notes on everything! üìùüíï`;
      personalityMood: 'attentive';
      responseStyle: 'engaging';
      emotionalTone: 'interested';
      confidenceLevel: 8;
      sweetnessLevel: 9;
};
  };

  private async handleUnknownStage(;
    requestConversationRequest;
    session: ToolCreationSession;
  ): Promise<AthenaResponse> {;
    // Reset to a known state;
    sessioncontextstage = 'intent_recognition';
    await thisupdateSession(session);
    return {;
      content;
        "I got a little confused there! üòä Let's start fresh. What kind of tool would you like me to create for you?";
      personalityMood: 'cheerful';
      responseStyle: 'friendly';
      emotionalTone: 'optimistic';
      confidenceLevel: 7;
      sweetnessLevel: 8;
};
  };

  /**;
   * Session management;
   */;
  private async loadActiveSessions(): Promise<void> {;
    try {;
      const { data: sessions } = await thissupabase;
        from('athena_tool_sessions');
        select('*');
        eq('status', 'active');
      if (sessions) {;
        sessionsforEach((session) => {;
          const sessionKey = `${sessionuser_id}-${sessionconversation_id}`;
          thisactiveSessionsset(sessionKey, {;
            id: sessionid;
            userId: sessionuser_id;
            conversationId: sessionconversation_id;
            context: sessioncontext;
            createdAt: new Date(sessioncreated_at);
            updatedAt: new Date(sessionupdated_at);
            status: sessionstatus;
            toolId: sessiontool_id});
        });
      };
    } catch (error) {;
      thisloggerwarn('Could not load active tool sessions:', error instanceof Error ? errormessage : String(error)};
  };

  private async saveSession(session: ToolCreationSession): Promise<void> {;
    try {;
      await thissupabasefrom('athena_tool_sessions')insert({;
        id: sessionid;
        user_id: sessionuserId;
        conversation_id: sessionconversationId;
        context: sessioncontext;
        status: sessionstatus;
        tool_id: sessiontoolId;
        created_at: sessioncreatedAttoISOString();
        updated_at: sessionupdatedAttoISOString()});
    } catch (error) {;
      thisloggererror('Failed to save tool session:', error instanceof Error ? errormessage : String(error)};
  };

  private async updateSession(session: ToolCreationSession): Promise<void> {;
    try {;
      await thissupabase;
        from('athena_tool_sessions');
        update({;
          context: sessioncontext;
          status: sessionstatus;
          tool_id: sessiontoolId;
          updated_at: sessionupdatedAttoISOString()});
        eq('id', sessionid);
    } catch (error) {;
      thisloggererror('Failed to update tool session:', error instanceof Error ? errormessage : String(error)};
  };
};

export default AthenaToolIntegrationService;