import { LogContext, logger } from '../utils/enhanced-logger';
import { circuitBreaker } from './circuit-breaker';
export interface AudioProcessingOptions {;
  format: 'wav' | 'mp3' | 'ogg';
  sampleRate?: number;
  channels?: number;
  bitRate?: number;
  normalize?: boolean;
  removeNoise?: boolean;
;
};

export interface AudioMetadata {;
  format: string;
  duration: number;
  sampleRate: number;
  channels: number;
  bitRate?: number;
  fileSize: number;
  isValid: boolean;
;
};

export interface AudioProcessingResult {;
  buffer: Buffer;
  metadata: AudioMetadata;
  warnings: string[];
;
};

/**;
 * AudioHandler provides comprehensive audio processing, validation, and errorhandling;
 * for the Universal AI Tools voice system.;
 *;
 * Features:;
 * - Audio format detection and validation;
 * - Audio quality optimization;
 * - Error recovery and fallback handling;
 * - Performance monitoring;
 * - Circuit breaker protection;
 */;
export class AudioHandler {;
  private static instance: AudioHandler;
  private processingStats = {;
    totalProcessed: 0;
    successCount: 0;
    errorCount: 0;
    averageProcessingTime: 0;
  ;
};
  private constructor() {};

  static getInstance(): AudioHandler {;
    if (!AudioHandlerinstance) {;
      AudioHandlerinstance = new AudioHandler();
    };
    return AudioHandlerinstance;
  };

  async processAudio(;
    buffer: Buffer;
    options: AudioProcessingOptions;
  ): Promise<AudioProcessingResult> {;
    const startTime = Datenow();
    const breaker = circuitBreakergetBreaker('audio-handler');
    return breakerfire(;
      async () => {;
        try {;
          thisprocessingStatstotalProcessed++;
          // Validate _inputbuffer;
          if (!buffer || bufferlength === 0) {;
            throw new Error('Invalid audio buffer: empty or null');
          };

          if (bufferlength < 44) {;
            // Minimum WAV header size;
            throw new Error('Audio buffer too small to contain valid audio data');
          };

          const warnings: string[] = [];
          let processedBuffer = buffer;
          // Detect and validate format;
          const metadata = await thisgetDetailedAudioMetadata(buffer);
          if (!metadataisValid) {;
            warningspush('Audio format validation failed, attempting repair');
            processedBuffer = await thisrepairAudioBuffer(buffer, optionsformat);
          };

          // Apply processing options;
          if (optionsnormalize) {;
            processedBuffer = await thisnormalizeAudio(processedBuffer);
            warningspush('Audio normalization applied');
          };

          if (optionsremoveNoise) {;
            processedBuffer = await thisapplyNoiseReduction(processedBuffer);
            warningspush('Noise reduction applied');
          };

          // Convert format if needed;
          if (metadataformat !== optionsformat) {;
            processedBuffer = await thisconvertAudioFormat(;
              processedBuffer;
              metadataformat;
              optionsformat;
            );
            warningspush(`Audio converted from ${metadataformat} to ${optionsformat}`);
          };

          // Validate final result;
          const finalMetadata = await thisgetDetailedAudioMetadata(processedBuffer);
          if (!finalMetadataisValid) {;
            throw new Error('Audio processing resulted in invalid audio data');
          };

          // Update stats;
          thisprocessingStatssuccessCount++;
          const processingTime = Datenow() - startTime;
          thisupdateAverageProcessingTime(processingTime);
          loggerinfo('Audio processing completed successfully', LogContextSYSTEM, {;
            originalFormat: metadataformat;
            finalFormat: finalMetadataformat;
            originalSize: bufferlength;
            finalSize: processedBufferlength;
            processingTime;
            warnings: warningslength;
          });
          return {;
            buffer: processedBuffer;
            metadata: finalMetadata;
            warnings;
          ;
};
        } catch (error) {;
          thisprocessingStatserrorCount++;
          loggererror('Audio processing error instanceof Error ? errormessage : String(error)  LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
          throw error instanceof Error ? errormessage : String(error);
        };
      };
      {;
        timeout: 30000;
        fallback: async () => {;
          loggerwarn('Using fallback audio processing', LogContextSYSTEM);
          const basicMetadata = await thisgetBasicAudioMetadata(buffer);
          return {;
            buffer;
            metadata: basicMetadata;
            warnings: ['Using fallback processing due to circuit breaker'];
          ;
};
        };
      };
    );
  };

  private async getDetailedAudioMetadata(buffer: Buffer): Promise<AudioMetadata> {;
    try {;
      const metadata: AudioMetadata = {;
        format: 'unknown';
        duration: 0;
        sampleRate: 44100;
        channels: 1;
        fileSize: bufferlength;
        isValid: false;
      ;
};
      // Check WAV format;
      if (bufferlength >= 44) {;
        const riffHeader = bufferslice(0, 4)toString('ascii');
        const waveHeader = bufferslice(8, 12)toString('ascii');
        if (riffHeader === 'RIFF' && waveHeader === 'WAVE') {;
          metadataformat = 'wav';
          metadatasampleRate = bufferreadUInt32LE(24);
          metadatachannels = bufferreadUInt16LE(22);
          metadatabitRate = bufferreadUInt32LE(28) * 8;
          const dataSize = bufferreadUInt32LE(40);
          const bitsPerSample = bufferreadUInt16LE(34);
          metadataduration =;
            dataSize / (metadatasampleRate * metadatachannels * (bitsPerSample / 8));
          metadataisValid = true;
          return metadata;
        };
      };

      // Check MP3 format;
      if (bufferlength >= 3) {;
        const mp3Header = bufferslice(0, 3);
        if (mp3Header[0] === 0xff && (mp3Header[1] & 0xe0) === 0xe0) {;
          metadataformat = 'mp3';
          metadataisValid = true;
          // MP3 metadata parsing is more complex, using estimates;
          metadataduration = thisestimateMP3Duration(buffer);
          return metadata;
        };
      };

      // Check OGG format;
      if (bufferlength >= 4) {;
        const oggHeader = bufferslice(0, 4)toString('ascii');
        if (oggHeader === 'OggS') {;
          metadataformat = 'ogg';
          metadataisValid = true;
          metadataduration = thisestimateOGGDuration(buffer);
          return metadata;
        };
      };

      return metadata;
    } catch (error) {;
      loggererror('Error getting detailed audio metadata', LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      return thisgetBasicAudioMetadata(buffer);
    };
  };

  private async getBasicAudioMetadata(buffer: Buffer): Promise<AudioMetadata> {;
    return {;
      format: 'unknown';
      duration: Mathmax(bufferlength / 44100, 1.0);
      sampleRate: 44100;
      channels: 1;
      fileSize: bufferlength;
      isValid: bufferlength > 0;
    ;
};
  };

  private estimateMP3Duration(buffer: Buffer): number {;
    // Simplified MP3 duration estimation;
    const avgBitrate = 128000; // 128 kbps average;
    return (bufferlength * 8) / avgBitrate;
  };

  private estimateOGGDuration(buffer: Buffer): number {;
    // Simplified OGG duration estimation;
    const avgBitrate = 128000; // 128 kbps average;
    return (bufferlength * 8) / avgBitrate;
  };

  private async normalizeAudio(buffer: Buffer): Promise<Buffer> {;
    try {;
      // Only normalize WAV files for now;
      const metadata = await thisgetDetailedAudioMetadata(buffer);
      if (metadataformat !== 'wav' || bufferlength < 44) {;
        return buffer;
      };

      const headerSize = 44;
      const audioData = bufferslice(headerSize);
      const normalizedData = Bufferalloc(audioDatalength);
      // Find peak amplitude;
      let maxAmplitude = 0;
      for (let i = 0; i < audioDatalength; i += 2) {;
        const sample = audioDatareadInt16LE(i);
        maxAmplitude = Mathmax(maxAmplitude, Mathabs(sample));
      };

      if (maxAmplitude === 0) {;
        return buffer; // Silent audio, no normalization needed;
      };

      // Calculate normalization factor (target 90% of max to prevent clipping);
      const targetAmplitude = 32767 * 0.9;
      const normalizationFactor = targetAmplitude / maxAmplitude;
      // Apply normalization;
      for (let i = 0; i < audioDatalength; i += 2) {;
        const sample = audioDatareadInt16LE(i);
        const normalizedSample = Mathround(sample * normalizationFactor);
        normalizedDatawriteInt16LE(Mathmax(-32768, Mathmin(32767, normalizedSample)), i);
      };

      return Bufferconcat([bufferslice(0, headerSize), normalizedData]);
    } catch (error) {;
      loggererror('Audio normalization error instanceof Error ? errormessage : String(error)  LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      return buffer;
    };
  };

  private async applyNoiseReduction(buffer: Buffer): Promise<Buffer> {;
    try {;
      // Simple noise reduction for WAV files;
      const metadata = await thisgetDetailedAudioMetadata(buffer);
      if (metadataformat !== 'wav' || bufferlength < 44) {;
        return buffer;
      };

      const headerSize = 44;
      const audioData = bufferslice(headerSize);
      const processedData = Bufferalloc(audioDatalength);
      // Apply simple noise gate (remove samples below threshold);
      const noiseThreshold = 100; // Adjust based on requirements;

      for (let i = 0; i < audioDatalength; i += 2) {;
        const sample = audioDatareadInt16LE(i);
        const processedSample = Mathabs(sample) < noiseThreshold ? 0 : sample;
        processedDatawriteInt16LE(processedSample, i);
      };

      return Bufferconcat([bufferslice(0, headerSize), processedData]);
    } catch (error) {;
      loggererror('Noise reduction error instanceof Error ? errormessage : String(error)  LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      return buffer;
    };
  };

  private async repairAudioBuffer(buffer: Buffer, targetFormat: string): Promise<Buffer> {;
    try {;
      // Attempt to repair invalid audio buffer;
      if (targetFormat === 'wav' && bufferlength >= 8) {;
        // Try to add a minimal WAV header if missing;
        const hasWavHeader = bufferslice(0, 4)toString('ascii') === 'RIFF';
        if (!hasWavHeader) {;
          const wavHeader = thiscreateMinimalWavHeader(bufferlength - 8);
          return Bufferconcat([wavHeader, buffer]);
        };
      };

      return buffer;
    } catch (error) {;
      loggererror('Audio repair error instanceof Error ? errormessage : String(error)  LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      return buffer;
    };
  };

  private createMinimalWavHeader(dataSize: number): Buffer {;
    const header = Bufferalloc(44);
    // RIFF header;
    headerwrite('RIFF', 0);
    headerwriteUInt32LE(36 + dataSize, 4);
    headerwrite('WAVE', 8);
    // fmt chunk;
    headerwrite('fmt ', 12);
    headerwriteUInt32LE(16, 16); // fmt chunk size;
    headerwriteUInt16LE(1, 20); // PCM format;
    headerwriteUInt16LE(1, 22); // mono;
    headerwriteUInt32LE(22050, 24); // sample rate;
    headerwriteUInt32LE(44100, 28); // byte rate;
    headerwriteUInt16LE(2, 32); // block align;
    headerwriteUInt16LE(16, 34); // bits per sample;
    // data chunk;
    headerwrite('data', 36);
    headerwriteUInt32LE(dataSize, 40);
    return header;
  };

  private async convertAudioFormat(;
    buffer: Buffer;
    fromFormat: string;
    toFormat: string;
  ): Promise<Buffer> {;
    try {;
      // For now, return the original buffer;
      // In production, you'd implement actual format conversion;
      loggerwarn(;
        `Audio format conversion from ${fromFormat} to ${toFormat} not fully implemented`;
        LogContextSYSTEM;
      );
      return buffer;
    } catch (error) {;
      loggererror('Audio format conversion error instanceof Error ? errormessage : String(error)  LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      return buffer;
    };
  };

  private updateAverageProcessingTime(newTime: number): void {;
    const { totalProcessed } = thisprocessingStats;
    const currentAverage = thisprocessingStatsaverageProcessingTime;
    thisprocessingStatsaverageProcessingTime =;
      (currentAverage * (totalProcessed - 1) + newTime) / totalProcessed;
  };

  getProcessingStats() {;
    return {;
      ..thisprocessingStats;
      successRate: thisprocessingStatstotalProcessed > 0;
          ? thisprocessingStatssuccessCount / thisprocessingStatstotalProcessed;
          : 0;
    ;
};
  };

  async validateAudioBuffer(;
    buffer: Buffer;
    expectedFormat?: string;
  ): Promise<{;
    isValid: boolean;
    errors: string[];
    warnings: string[];
    metadata: AudioMetadata;
  }> {;
    const errors: string[] = [];
    const warnings: string[] = [];
    try {;
      if (!buffer || bufferlength === 0) {;
        errorspush('Buffer is empty or null');
        return {;
          isValid: false;
          errors;
          warnings;
          metadata: await thisgetBasicAudioMetadata(Bufferalloc(0));
        ;
};
      };

      if (bufferlength < 44) {;
        errorspush('Buffer too small to contain valid audio data');
      };

      const metadata = await thisgetDetailedAudioMetadata(buffer);
      if (!metadataisValid) {;
        errorspush('Audio format is not recognized or invalid');
      };

      if (expectedFormat && metadataformat !== expectedFormat) {;
        warningspush(`Expected ${expectedFormat} but got ${metadataformat}`);
      };

      if (metadataduration === 0) {;
        warningspush('Audio duration is zero or could not be determined');
      };

      if (metadataduration > 300) {;
        // 5 minutes;
        warningspush('Audio duration is unusually long');
      };

      return {;
        isValid: errorslength === 0;
        errors;
        warnings;
        metadata;
      ;
};
    } catch (error) {;
      errorspush(`Validation error instanceof Error ? errormessage : String(error) ${error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error)`);
      return {;
        isValid: false;
        errors;
        warnings;
        metadata: await thisgetBasicAudioMetadata(buffer);
      ;
};
    };
  };

  async clearCache(): Promise<void> {;
    // Reset processing stats;
    thisprocessingStats = {;
      totalProcessed: 0;
      successCount: 0;
      errorCount: 0;
      averageProcessingTime: 0;
    ;
};
    loggerinfo('Audio handler cache and stats cleared', LogContextSYSTEM);
  };
};

// Export singleton instance;
export const audioHandler = AudioHandlergetInstance();