/**;
 * Database Performance Monitoring Service;
 *;
 * Comprehensive database monitoring for Universal AI Tools with:;
 * - Query performance tracking and analysis;
 * - Connection pool monitoring;
 * - Database resource utilization;
 * - Slow query detection and optimization;
 * - Transaction monitoring;
 * - Database health scoring;
 * - Automated performance tuning suggestions;
 * - Query _patternanalysis;
 */;

import { EventEmitter } from 'events';
import { performance } from 'perf_hooks';
import { telemetryService } from './telemetry-service';
import { LogContext, logger } from '../utils/enhanced-logger';
import type { SupabaseClient } from '@supabase/supabase-js';
import { createClient } from '@supabase/supabase-js';
export interface DatabasePerformanceConfig {;
  enabled: boolean;
  monitoringInterval: number; // ms;
  slowQueryThreshold: number; // ms;
  connectionPoolMonitoring: boolean;
  transactionMonitoring: boolean;
  // Thresholds;
  thresholds: {;
    queryTime: number; // ms;
    connectionCount: number;
    lockWaitTime: number; // ms;
    cacheHitRatio: number; // percentage;
    activeTransactions: number;
};
  // Performance scoring weights;
  scoring: {;
    queryPerformance: number;
    connectionHealth: number;
    resourceUtilization: number;
    concurrency: number;
};
  // Query _analysissettings;
  queryAnalysis: {;
    enableSlowQueryLog: boolean;
    sampleRate: number; // 0-1;
    maxQueriesTracked: number;
    enableQueryPlanAnalysis: boolean;
};
};

export interface QueryMetrics {;
  id: string;
  query: string;
  queryHash: string;
  executionTime: number;
  timestamp: Date;
  // Query details;
  table?: string;
  operation: 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'UPSERT' | 'RPC';
  rowsAffected?: number;
  // Performance metrics;
  planningTime?: number;
  executionPlan?: any;
  indexesUsed?: string[];
  cacheHit: boolean;
  // Context;
  traceId?: string;
  spanId?: string;
  userId?: string;
  sessionId?: string;
  // Resource usage;
  memoryUsed?: number;
  ioReads?: number;
  ioWrites?: number;
};

export interface ConnectionPoolMetrics {;
  timestamp: Date;
  activeConnections: number;
  idleConnections: number;
  totalConnections: number;
  maxConnections: number;
  connectionUtilization: number; // percentage;
  // Connection statistics;
  connectionsCreated: number;
  connectionsDestroyed: number;
  connectionErrors: number;
  averageConnectionTime: number;
  // Wait statistics;
  connectionWaitTime: number;
  queuedRequests: number;
};

export interface TransactionMetrics {;
  id: string;
  startTime: Date;
  endTime?: Date;
  duration?: number;
  status: 'active' | 'committed' | 'aborted' | 'timeout';
  // Transaction details;
  queries: QueryMetrics[];
  isolationLevel?: string;
  readOnly: boolean;
  // Lock information;
  locksHeld: number;
  locksWaited: number;
  lockWaitTime: number;
  // Context;
  traceId?: string;
  userId?: string;
};

export interface DatabaseHealth {;
  score: number; // 0-100;
  status: 'healthy' | 'degraded' | 'unhealthy';
  // Performance metrics;
  averageQueryTime: number;
  slowQueries: number;
  queryThroughput: number; // queries per second;
  // Connection health;
  connectionUtilization: number;
  connectionErrors: number;
  // Resource utilization;
  cpuUsage?: number;
  memoryUsage?: number;
  diskUsage?: number;
  cacheHitRatio: number;
  // Concurrency;
  activeTransactions: number;
  lockContention: number;
  // Issues and recommendations;
  issues: Array<{;
    severity: 'low' | 'medium' | 'high' | 'critical';
    type: string;
    description: string;
    recommendation: string}>;
};

export interface DatabaseReport {;
  timeRange: {;
    start: Date;
    end: Date;
};
  summary: {;
    totalQueries: number;
    averageQueryTime: number;
    slowQueries: number;
    errorRate: number;
    throughput: number;
};
  topSlowQueries: Array<{;
    queryHash: string;
    query: string;
    averageTime: number;
    count: number;
    totalTime: number}>;
  topTables: Array<{;
    table: string;
    queryCount: number;
    averageTime: number;
    totalTime: number}>;
  performance: {;
    queryTimePercentiles: {;
      p50: number;
      p95: number;
      p99: number;
};
    connectionMetrics: {;
      averageUtilization: number;
      peakConnections: number;
      connectionErrors: number;
};
    transactionMetrics: {;
      averageDuration: number;
      abortRate: number;
      lockContentions: number;
};
  };
  recommendations: string[];
;
};

export class DatabasePerformanceMonitor extends EventEmitter {;
  private config: DatabasePerformanceConfig;
  private supabase: SupabaseClient;
  private isStarted = false;
  private queryMetrics: QueryMetrics[] = [];
  private connectionMetrics: ConnectionPoolMetrics[] = [];
  private transactionMetrics: TransactionMetrics[] = [];
  private activeTransactions = new Map<string, TransactionMetrics>();
  private monitoringInterval?: NodeJSTimeout;
  private queryHashes = new Map<string, number>(); // Track query frequency;
  constructor(;
    supabaseUrl: string;
    supabaseKey: string;
    config: Partial<DatabasePerformanceConfig> = {;
};
  ) {;
    super();
    thissupabase = createClient(supabaseUrl, supabaseKey);
    thisconfig = {;
      enabled: true;
      monitoringInterval: 60000, // 1 minute;
      slowQueryThreshold: 1000, // 1 second;
      connectionPoolMonitoring: true;
      transactionMonitoring: true;

      thresholds: {;
        queryTime: 2000, // 2 seconds;
        connectionCount: 50, // 50 connections;
        lockWaitTime: 5000, // 5 seconds;
        cacheHitRatio: 80, // 80%;
        activeTransactions: 20, // 20 concurrent transactions};

      scoring: {;
        queryPerformance: 0.4;
        connectionHealth: 0.3;
        resourceUtilization: 0.2;
        concurrency: 0.1};

      queryAnalysis: {;
        enableSlowQueryLog: true;
        sampleRate: 0.1, // Sample 10% of queries;
        maxQueriesTracked: 10000;
        enableQueryPlanAnalysis: false, // Disabled by default due to overhead};

      ..config};
  };

  /**;
   * Start database performance monitoring;
   */;
  async start(): Promise<void> {;
    if (thisisStarted) {;
      loggerwarn('Database performance monitor already started', undefined, LogContextDATABASE);
      return};

    if (!thisconfigenabled) {;
      loggerinfo('Database performance monitoring disabled', undefined, LogContextDATABASE);
      return};

    try {;
      loggerinfo('Starting database performance monitor', undefined, {;
        context: LogContextDATABASE;
        config: thisconfig});
      // Setup query interception;
      thissetupQueryInterception();
      // Start periodic monitoring;
      thismonitoringInterval = setInterval(() => {;
        thiscollectMetrics()}, thisconfigmonitoringInterval);
      thisisStarted = true;
      thisemit('started', { config: thisconfig });
      loggerinfo(;
        'Database performance monitor started successfully';
        undefined;
        LogContextDATABASE;
      );
    } catch (error) {;
      loggererror('Failed to start database performance monitor', undefined, {;
        context: LogContextDATABASE;
        error});
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Stop database performance monitoring;
   */;
  async stop(): Promise<void> {;
    if (!thisisStarted) {;
      loggerwarn('Database performance monitor not started', undefined, LogContextDATABASE);
      return};

    try {;
      loggerinfo('Stopping database performance monitor', undefined, LogContextDATABASE);
      // Clear monitoring interval;
      if (thismonitoringInterval) {;
        clearInterval(thismonitoringInterval);
        thismonitoringInterval = undefined};

      thisisStarted = false;
      thisemit('stopped');
      loggerinfo(;
        'Database performance monitor stopped successfully';
        undefined;
        LogContextDATABASE;
      );
    } catch (error) {;
      loggererror('Error stopping database performance monitor', undefined, {;
        context: LogContextDATABASE;
        error});
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Track a database query;
   */;
  trackQuery(;
    query: string;
    executionTime: number;
    options: {;
      table?: string;
      operation?: QueryMetrics['operation'];
      rowsAffected?: number;
      traceId?: string;
      spanId?: string;
      userId?: string;
      sessionId?: string;
      error instanceof Error ? errormessage : String(error)  Error} = {};
  ): string {;
    // Sample queries based on configuration;
    if (Mathrandom() > thisconfigqueryAnalysissampleRate) {;
      return ''};

    const queryHash = thisgenerateQueryHash(query);
    const queryId = thisgenerateId();
    const queryMetric: QueryMetrics = {;
      id: queryId;
      query: thisnormalizeQuery(query);
      queryHash;
      executionTime;
      timestamp: new Date();
      table: optionstable;
      operation: optionsoperation || thisinferOperation(query);
      rowsAffected: optionsrowsAffected;
      cacheHit: false, // Would need to be determined by database;
      traceId: optionstraceId || telemetryServicegetCurrentTraceId();
      spanId: optionsspanId || telemetryServicegetCurrentSpanId();
      userId: optionsuserId;
      sessionId: optionssessionId;
};
    thisqueryMetricspush(queryMetric);
    // Track query frequency;
    thisqueryHashesset(queryHash, (thisqueryHashesget(queryHash) || 0) + 1);
    // Cleanup old metrics;
    if (thisqueryMetricslength > thisconfigqueryAnalysismaxQueriesTracked) {;
      thisqueryMetrics = thisqueryMetricsslice(-thisconfigqueryAnalysismaxQueriesTracked)};

    // Check for slow query;
    if (executionTime > thisconfigslowQueryThreshold) {;
      thishandleSlowQuery(queryMetric)};

    loggerdebug('Query tracked', undefined, {;
      context: LogContextDATABASE;
      query_id: queryId;
      query_hash: queryHash;
      execution_time: executionTime;
      operation: queryMetricoperation;
      table: queryMetrictable});
    thisemit('queryTracked', queryMetric);
    return queryId;
  };

  /**;
   * Start tracking a transaction;
   */;
  startTransaction(;
    options: {;
      traceId?: string;
      userId?: string;
      isolationLevel?: string;
      readOnly?: boolean} = {};
  ): string {;
    const transactionId = thisgenerateId(),;

    const transaction: TransactionMetrics = {;
      id: transactionId;
      startTime: new Date();
      status: 'active';
      queries: [];
      isolationLevel: optionsisolationLevel;
      readOnly: optionsreadOnly || false;
      locksHeld: 0;
      locksWaited: 0;
      lockWaitTime: 0;
      traceId: optionstraceId || telemetryServicegetCurrentTraceId();
      userId: optionsuserId;
};
    thisactiveTransactionsset(transactionId, transaction);
    loggerdebug('Transaction started', undefined, {;
      context: LogContextDATABASE;
      transaction_id: transactionId;
      trace_id: transactiontraceId;
      isolation_level: transactionisolationLevel});
    thisemit('transactionStarted', transaction);
    return transactionId;
  };

  /**;
   * End a transaction;
   */;
  endTransaction(;
    transactionId: string;
    status: 'committed' | 'aborted' | 'timeout';
    lockMetrics?: {;
      locksHeld: number;
      locksWaited: number;
      lockWaitTime: number;
};
  ): void {;
    const transaction = thisactiveTransactionsget(transactionId),;
    if (!transaction) {;
      loggerwarn('Transaction not found', undefined, {;
        context: LogContextDATABASE;
        transaction_id: transactionId});
      return;
    };

    transactionendTime = new Date();
    transactionduration = transactionendTimegetTime() - transactionstartTimegetTime();
    transactionstatus = status;
    if (lockMetrics) {;
      transactionlocksHeld = lockMetricslocksHeld;
      transactionlocksWaited = lockMetricslocksWaited;
      transactionlockWaitTime = lockMetricslockWaitTime};

    // Move to completed transactions;
    thisactiveTransactionsdelete(transactionId);
    thistransactionMetricspush(transaction);
    // Keep only recent transactions;
    if (thistransactionMetricslength > 1000) {;
      thistransactionMetrics = thistransactionMetricsslice(-1000)};

    loggerdebug('Transaction ended', undefined, {;
      context: LogContextDATABASE;
      transaction_id: transactionId;
      status;
      duration: transactionduration;
      queries: transactionquerieslength});
    thisemit('transactionEnded', transaction);
  };

  /**;
   * Associate query with transaction;
   */;
  addQueryToTransaction(transactionId: string, queryId: string): void {;
    const transaction = thisactiveTransactionsget(transactionId);
    const query = thisqueryMetricsfind((q) => qid === queryId);
    if (transaction && query) {;
      transactionqueriespush(query)};
  };

  /**;
   * Get current database health;
   */;
  async getDatabaseHealth(): Promise<DatabaseHealth> {;
    const recentQueries = thisgetRecentQueries(300000); // Last 5 minutes;
    const recentTransactions = thisgetRecentTransactions(300000);
    const recentConnections = thisgetRecentConnectionMetrics(300000);
    // Calculate query performance;
    const averageQueryTime =;
      recentQuerieslength > 0;
        ? recentQueriesreduce((sum, q) => sum + qexecutionTime, 0) / recentQuerieslength;
        : 0;
    const slowQueries = recentQueriesfilter(;
      (q) => qexecutionTime > thisconfigslowQueryThreshold;
    )length;
    const queryThroughput = recentQuerieslength / 5; // queries per minute;

    // Calculate connection health;
    const latestConnection = recentConnections[recentConnectionslength - 1];
    const connectionUtilization = latestConnection?connectionUtilization || 0;
    const connectionErrors = recentConnectionsreduce((sum, c) => sum + cconnectionErrors, 0);
    // Calculate resource utilization;
    const cacheHitRatio =;
      recentQuerieslength > 0;
        ? (recentQueriesfilter((q) => qcacheHit)length / recentQuerieslength) * 100;
        : 100;
    // Calculate concurrency metrics;
    const activeTransactions = thisactiveTransactionssize;
    const lockContention = recentTransactionsfilter((t) => tlockWaitTime > 0)length,;

    // Calculate overall health score;
    const score = thiscalculateHealthScore({;
      averageQueryTime;
      slowQueries;
      connectionUtilization;
      connectionErrors;
      cacheHitRatio;
      activeTransactions;
      lockContention});
    // Determine status;
    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
    if (score < 50) status = 'unhealthy';
    else if (score < 70) status = 'degraded';
    // Generate issues and recommendations;
    const issues = thisgenerateIssues({;
      averageQueryTime;
      slowQueries;
      connectionUtilization;
      connectionErrors;
      cacheHitRatio;
      activeTransactions;
      lockContention});
    return {;
      score;
      status;
      averageQueryTime;
      slowQueries;
      queryThroughput;
      connectionUtilization;
      connectionErrors;
      cacheHitRatio;
      activeTransactions;
      lockContention;
      issues};
  };

  /**;
   * Generate comprehensive database performance report;
   */;
  generateReport(durationMinutes = 60): DatabaseReport {;
    const endTime = new Date();
    const startTime = new Date(endTimegetTime() - durationMinutes * 60 * 1000);
    const queries = thisqueryMetricsfilter((q) => qtimestamp > startTime);
    const transactions = thistransactionMetricsfilter((t) => tstartTime > startTime);
    // Summary metrics;
    const totalQueries = querieslength;
    const averageQueryTime =;
      querieslength > 0;
        ? queriesreduce((sum, q) => sum + qexecutionTime, 0) / querieslength;
        : 0;
    const slowQueries = queriesfilter(;
      (q) => qexecutionTime > thisconfigslowQueryThreshold;
    )length;
    const errorRate = 0; // Would need errortracking in queries;
    const throughput = totalQueries / durationMinutes;
    // Top slow queries;
    const queryGroups = new Map<string, { queries: QueryMetrics[], totalTime: number }>();
    queriesforEach((q) => {;
      if (!queryGroupshas(qqueryHash)) {;
        queryGroupsset(qqueryHash, { queries: [], totalTime: 0 });
      };
      const group = queryGroupsget(qqueryHash)!;
      groupqueriespush(q);
      grouptotalTime += qexecutionTime;
    });
    const topSlowQueries = Arrayfrom(queryGroupsentries());
      map(([hash, group]) => ({;
        queryHash: hash;
        query: groupqueries[0]query;
        averageTime: grouptotalTime / groupquerieslength;
        count: groupquerieslength;
        totalTime: grouptotalTime}));
      sort((a, b) => baverageTime - aaverageTime);
      slice(0, 10);
    // Top tables by activity;
    const tableGroups = new Map<string, { count: number, totalTime: number }>();
    queriesforEach((q) => {;
      if (qtable) {;
        if (!tableGroupshas(qtable)) {;
          tableGroupsset(qtable, { count: 0, totalTime: 0 });
        };
        const group = tableGroupsget(qtable)!;
        groupcount++;
        grouptotalTime += qexecutionTime;
      };
    });
    const topTables = Arrayfrom(tableGroupsentries());
      map(([table, stats]) => ({;
        table;
        queryCount: statscount;
        averageTime: statstotalTime / statscount;
        totalTime: statstotalTime}));
      sort((a, b) => bqueryCount - aqueryCount);
      slice(0, 10);
    // Performance percentiles;
    const queryTimes = queriesmap((q) => qexecutionTime)sort((a, b) => a - b);
    const queryTimePercentiles = {;
      p50: thiscalculatePercentile(queryTimes, 50);
      p95: thiscalculatePercentile(queryTimes, 95);
      p99: thiscalculatePercentile(queryTimes, 99)};
    // Connection metrics;
    const recentConnections = thisgetRecentConnectionMetrics(durationMinutes * 60 * 1000);
    const connectionMetrics = {;
      averageUtilization:;
        recentConnectionslength > 0;
          ? recentConnectionsreduce((sum, c) => sum + cconnectionUtilization, 0) /;
            recentConnectionslength;
          : 0;
      peakConnections: recentConnectionslength > 0;
          ? Mathmax(..recentConnectionsmap((c) => cactiveConnections));
          : 0;
      connectionErrors: recentConnectionsreduce((sum, c) => sum + cconnectionErrors, 0)};
    // Transaction metrics;
    const completedTransactions = transactionsfilter((t) => tduration !== undefined);
    const transactionMetrics = {;
      averageDuration:;
        completedTransactionslength > 0;
          ? completedTransactionsreduce((sum, t) => sum + (tduration || 0), 0) /;
            completedTransactionslength;
          : 0;
      abortRate: transactionslength > 0;
          ? (transactionsfilter((t) => tstatus === 'aborted')length / transactionslength) * 100;
          : 0;
      lockContentions: transactionsfilter((t) => tlockWaitTime > 0)length};
    // Generate recommendations;
    const recommendations = thisgenerateRecommendations({;
      queries;
      transactions;
      connectionMetrics: recentConnections});
    return {;
      timeRange: { start: startTime, end: endTime };
      summary: {;
        totalQueries;
        averageQueryTime;
        slowQueries;
        errorRate;
        throughput};
      topSlowQueries;
      topTables;
      performance: {;
        queryTimePercentiles;
        connectionMetrics;
        transactionMetrics};
      recommendations};
  };

  // Private methods;

  private setupQueryInterception(): void {;
    // This is a simplified version. In practice, you'd need to hook into;
    // the Supabase client or use database-specific monitoring tools;
    loggerinfo('Query interception setup completed', undefined, LogContextDATABASE)};

  private async collectMetrics(): Promise<void> {;
    try {;
      // Collect connection pool metrics;
      if (thisconfigconnectionPoolMonitoring) {;
        const connectionMetrics = await thiscollectConnectionMetrics();
        thisconnectionMetricspush(connectionMetrics);
        // Keep only recent metrics;
        if (thisconnectionMetricslength > 1000) {;
          thisconnectionMetrics = thisconnectionMetricsslice(-1000)};
      };

      // Emit periodic metrics update;
      thisemit('metricsCollected', {;
        queries: thisqueryMetricslength;
        activeTransactions: thisactiveTransactionssize;
        connections: thisconnectionMetricslength});
    } catch (error) {;
      loggererror('Error collecting database metrics', undefined, {;
        context: LogContextDATABASE;
        error});
    };
  };

  private async collectConnectionMetrics(): Promise<ConnectionPoolMetrics> {;
    // This would typically query database system tables or connection pool stats;
    // For Supabase, this information might not be directly available;
;
    return {;
      timestamp: new Date();
      activeConnections: Mathfloor(Mathrandom() * 20) + 5, // Simulated;
      idleConnections: Mathfloor(Mathrandom() * 10) + 2;
      totalConnections: 30;
      maxConnections: 50;
      connectionUtilization: (25 / 50) * 100;
      connectionsCreated: 0;
      connectionsDestroyed: 0;
      connectionErrors: 0;
      averageConnectionTime: Mathrandom() * 100 + 50;
      connectionWaitTime: Mathrandom() * 10;
      queuedRequests: Mathfloor(Mathrandom() * 3);
};
  };

  private handleSlowQuery(query: QueryMetrics): void {;
    loggerwarn('Slow query detected', undefined, {;
      context: LogContextDATABASE;
      query_id: queryid;
      execution_time: queryexecutionTime;
      query_hash: queryqueryHash;
      table: querytable;
      operation: queryoperation});
    thisemit('slowQuery', query);
    // Check if this query _patternis frequently slow;
    const recentSimilarQueries = thisqueryMetricsfilter(;
      (q) => qqueryHash === queryqueryHash && qtimestamp > new Date(Datenow() - 3600000) // Last hour;
    );
    const slowCount = recentSimilarQueriesfilter(;
      (q) => qexecutionTime > thisconfigslowQueryThreshold;
    )length;
    const slowPercentage = (slowCount / recentSimilarQuerieslength) * 100;
    if (slowPercentage > 50 && recentSimilarQuerieslength > 5) {;
      thisemit('slowQueryPattern', {;
        queryHash: queryqueryHash;
        query: queryquery;
        slowPercentage;
        count: recentSimilarQuerieslength;
        averageTime:;
          recentSimilarQueriesreduce((sum, q) => sum + qexecutionTime, 0) /;
          recentSimilarQuerieslength});
    };
  };

  private calculateHealthScore(metrics: {;
    averageQueryTime: number;
    slowQueries: number;
    connectionUtilization: number;
    connectionErrors: number;
    cacheHitRatio: number;
    activeTransactions: number;
    lockContention: number}): number {;
    const { scoring, thresholds } = thisconfig;
    // Query performance score (0-100);
    const queryScore = Mathmax(0, 100 - (metricsaverageQueryTime / thresholdsqueryTime) * 100);
    // Connection health score (0-100);
    const connectionScore = Mathmax(;
      0;
      100 - (metricsconnectionUtilization / 100) * 100 - metricsconnectionErrors * 5;
    );
    // Resource utilization score (0-100);
    const resourceScore = metricscacheHitRatio;
    // Concurrency score (0-100);
    const concurrencyScore = Mathmax(;
      0;
      100 -;
        (metricsactiveTransactions / thresholdsactiveTransactions) * 50 -;
        metricslockContention * 10;
    );
    // Weighted total;
    const totalScore =;
      queryScore * scoringqueryPerformance +;
      connectionScore * scoringconnectionHealth +;
      resourceScore * scoringresourceUtilization +;
      concurrencyScore * scoringconcurrency;
    return Mathround(Mathmax(0, Mathmin(100, totalScore)));
  };

  private generateIssues(metrics: {;
    averageQueryTime: number;
    slowQueries: number;
    connectionUtilization: number;
    connectionErrors: number;
    cacheHitRatio: number;
    activeTransactions: number;
    lockContention: number}): DatabaseHealth['issues'] {;
    const issues: DatabaseHealth['issues'] = [],;

    // Query performance issues;
    if (metricsaverageQueryTime > thisconfigthresholdsqueryTime) {;
      issuespush({;
        severity: 'high';
        type: 'slow_queries';
        description: `Average query time (${metricsaverageQueryTimetoFixed(2)}ms) exceeds threshold`;
        recommendation: 'Review and optimize slow queries, consider adding indexes'});
    };

    if (metricsslowQueries > 10) {;
      issuespush({;
        severity: 'medium';
        type: 'query_count';
        description: `High number of slow queries detected: ${metricsslowQueries}`;
        recommendation: 'Analyze query patterns and optimize frequently used queries'});
    };

    // Connection issues;
    if (metricsconnectionUtilization > 80) {;
      issuespush({;
        severity: 'high';
        type: 'connection_pool';
        description: `Connection pool utilization is high: ${metricsconnectionUtilizationtoFixed(1)}%`;
        recommendation: 'Consider increasing connection pool size or optimizing connection usage'});
    };

    if (metricsconnectionErrors > 0) {;
      issuespush({;
        severity: 'critical';
        type: 'connectionerrors';
        description: `Database connection errors detected: ${metricsconnectionErrors}`;
        recommendation: 'Check database connectivity and configuration'});
    };

    // Cache performance;
    if (metricscacheHitRatio < thisconfigthresholdscacheHitRatio) {;
      issuespush({;
        severity: 'medium';
        type: 'cache_performance';
        description: `Cache hit ratio is low: ${metricscacheHitRatiotoFixed(1)}%`;
        recommendation: 'Optimize queries for better cache usage or increase cache size'});
    };

    // Concurrency issues;
    if (metricsactiveTransactions > thisconfigthresholdsactiveTransactions) {;
      issuespush({;
        severity: 'medium';
        type: 'high_concurrency';
        description: `High number of active transactions: ${metricsactiveTransactions}`;
        recommendation: 'Monitor for long-running transactions and optimize transaction scope'});
    };

    if (metricslockContention > 5) {;
      issuespush({;
        severity: 'high';
        type: 'lockcontention';
        description: `Lock contention detected in ${metricslockContention} transactions`;
        recommendation: 'Review transaction isolation levels and reduce transaction duration'});
    };

    return issues;
  };

  private generateRecommendations(data: {;
    queries: QueryMetrics[];
    transactions: TransactionMetrics[];
    connectionMetrics: ConnectionPoolMetrics[]}): string[] {;
    const recommendations: string[] = [];
    // Query optimization recommendations;
    const slowQueries = dataqueriesfilter(;
      (q) => qexecutionTime > thisconfigslowQueryThreshold;
    );
    if (slowQuerieslength > 0) {;
      recommendationspush(`Optimize ${slowQuerieslength} slow queries identified in the report`);
      // Check for missing indexes;
      const tablesWithSlowQueries = [..new Set(slowQueriesmap((q) => qtable)filter(Boolean))];
      if (tablesWithSlowQuerieslength > 0) {;
        recommendationspush(;
          `Consider adding indexes to tables: ${tablesWithSlowQueriesjoin(', ')}`;
        );
      };
    };

    // Connection pool recommendations;
    const avgConnectionUtil =;
      dataconnectionMetricslength > 0;
        ? dataconnectionMetricsreduce((sum, c) => sum + cconnectionUtilization, 0) /;
          dataconnectionMetricslength;
        : 0;
    if (avgConnectionUtil > 80) {;
      recommendationspush('Consider increasing database connection pool size');
      recommendationspush('Review application connection usage patterns');
};

    // Transaction recommendations;
    const longTransactions = datatransactionsfilter((t) => (tduration || 0) > 30000); // 30 seconds;
    if (longTransactionslength > 0) {;
      recommendationspush(;
        `Review ${longTransactionslength} long-running transactions for optimization`;
      );
    };

    // General performance recommendations;
    const queryCount = dataquerieslength;
    if (queryCount > 1000) {;
      recommendationspush('Consider implementing query result caching');
      recommendationspush('Review query patterns for potential batching opportunities')};

    return recommendations;
  };

  private getRecentQueries(durationMs: number): QueryMetrics[] {;
    const cutoffTime = new Date(Datenow() - durationMs);
    return thisqueryMetricsfilter((q) => qtimestamp > cutoffTime)};

  private getRecentTransactions(durationMs: number): TransactionMetrics[] {;
    const cutoffTime = new Date(Datenow() - durationMs);
    return thistransactionMetricsfilter((t) => tstartTime > cutoffTime)};

  private getRecentConnectionMetrics(durationMs: number): ConnectionPoolMetrics[] {;
    const cutoffTime = new Date(Datenow() - durationMs);
    return thisconnectionMetricsfilter((c) => ctimestamp > cutoffTime)};

  private calculatePercentile(values: number[], percentile: number): number {;
    if (valueslength === 0) return 0;
    const index = Mathceil((percentile / 100) * valueslength) - 1;
    return values[Mathmax(0, index)] || 0};

  private generateQueryHash(query: string): string {;
    // Simple hash based on normalized query structure;
    const normalized = thisnormalizeQuery(query);
    let hash = 0;
    for (let i = 0; i < normalizedlength; i++) {;
      const char = normalizedcharCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32-bit integer};
    return hashtoString(36);
  };

  private normalizeQuery(query: string): string {;
    // Normalize query by removing parameters and formatting;
    return query;
      replace(/\$\d+/g, '?') // Replace parameters;
      replace(/\s+/g, ' ') // Normalize whitespace;
      replace(/\d+/g, 'N') // Replace numbers;
      replace(/'[^']*'/g, "'X'") // Replace strings;
      trim();
      toLowerCase()};

  private inferOperation(query: string): QueryMetrics['operation'] {;
    const queryLower = querytoLowerCase()trim();
    if (queryLowerstartsWith('select')) return 'SELECT';
    if (queryLowerstartsWith('insert')) return 'INSERT';
    if (queryLowerstartsWith('update')) return 'UPDATE';
    if (queryLowerstartsWith('delete')) return 'DELETE';
    if (queryLowerincludes('upsert')) return 'UPSERT';
    if (queryLowerstartsWith('call') || queryLowerincludes('rpc')) return 'RPC';
    return 'SELECT'; // Default};

  private generateId(): string {;
    return (;
      Mathrandom()toString(36)substring(2, 15) + Mathrandom()toString(36)substring(2, 15);
    )};
};

// Create singleton instance;
let databasePerformanceMonitor: DatabasePerformanceMonitor | null = null;
export function getDatabasePerformanceMonitor(;
  supabaseUrl?: string;
  supabaseKey?: string;
  config?: Partial<DatabasePerformanceConfig>;
): DatabasePerformanceMonitor {;
  if (!databasePerformanceMonitor) {;
    if (!supabaseUrl || !supabaseKey) {;
      throw new Error('Supabase URL and key required to initialize database performance monitor')};
    databasePerformanceMonitor = new DatabasePerformanceMonitor(supabaseUrl, supabaseKey, config);
  };
  return databasePerformanceMonitor;
};

export default DatabasePerformanceMonitor;