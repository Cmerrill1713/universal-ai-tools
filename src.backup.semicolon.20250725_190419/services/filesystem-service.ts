import { promises as fs } from 'fs';
import path from 'path';
import { EventEmitter } from 'events';
import type { FSWatcher } from 'chokidar';
import { watch } from 'chokidar';
import crypto from 'crypto';
import type { SupabaseClient } from '@supabase/supabase-js';
import { LogContext, logger } from '../utils/enhanced-logger';
import { FileManagerAgent } from '../agents/personal/file_manager_agent';
import { z } from 'zod';
// Pydantic-style models using Zod;
const FileMetadataSchema = zobject({;
  path: zstring();
  name: zstring();
  size: znumber();
  type: zenum(['file', 'directory', 'symlink']);
  mimeType: zstring()optional();
  extension: zstring()optional();
  createdAt: zdate();
  modifiedAt: zdate();
  accessedAt: zdate();
  permissions: zobject({;
    readable: zboolean();
    writable: zboolean();
    executable: zboolean();
  });
  hash: zstring()optional();
  isHidden: zboolean();
});
const FileOperationSchema = zobject({;
  id: zstring();
  type: zenum(['read', 'write', 'delete', 'move', 'copy', 'mkdir', 'chmod']);
  sourcePath: zstring();
  targetPath: zstring()optional();
  contentzstring()optional();
  metadata: FileMetadataSchemaoptional();
  agentId: zstring();
  userId: zstring();
  status: zenum(['pending', 'in_progress', 'completed', 'failed']);
  error instanceof Error ? errormessage : String(error) zstring()optional();
  startedAt: zdate();
  completedAt: zdate()optional();
});
const DirectoryTreeSchema = zobject({;
  path: zstring();
  name: zstring();
  type: zliteral('directory');
  children: zarray(zlazy(() => FileTreeNodeSchema));
  expanded: zboolean()default(false);
});
const FileTreeNodeSchema = zunion([FileMetadataSchema, DirectoryTreeSchema]);
type FileMetadata = zinfer<typeof FileMetadataSchema>;
type FileOperation = zinfer<typeof FileOperationSchema>;
type DirectoryTree = zinfer<typeof DirectoryTreeSchema>;
type FileTreeNode = zinfer<typeof FileTreeNodeSchema>;
// a2a (Agent-to-Agent) Protocol;
interface A2AMessage {;
  from: string;
  to: string;
  type: 'request| 'response' | 'event';
  action: string;
  payload: any;
  correlationId: string;
  timestamp: Date;
;
};

interface A2AProtocol {;
  sendMessage(message: A2AMessage): Promise<void>;
  onMessage(handler: (message: A2AMessage) => Promise<void>): void;
  subscribe(agentId: string, eventType: string): void;
  unsubscribe(agentId: string, eventType: string): void;
;
};

export class FileSystemService extends EventEmitter implements A2AProtocol {;
  private supabase: SupabaseClient;
  private fileManagerAgent: FileManagerAgent;
  private watchers: Map<string, FSWatcher> = new Map();
  private operationQueue: FileOperation[] = [];
  private a2aHandlers: Map<string, (message: A2AMessage) => Promise<void>> = new Map();
  private a2aSubscriptions: Map<string, Set<string>> = new Map();
  private allowedPaths: string[] = [];
  private blockedPaths: string[] = [;
    '/etc';
    '/System';
    '/private';
    '/dev';
    '/proc';
    '/git';
    'node_modules';
  ];
  constructor(supabase: SupabaseClient, allowedPaths?: string[]) {;
    super();
    thissupabase = supabase;
    thisfileManagerAgent = new FileManagerAgent();
    // Set allowed paths (default to user's home directory and project directory);
    thisallowedPaths = allowedPaths || [processenvHOME || '~', processcwd()];
    loggerinfo('FileSystemService initialized', LogContextSYSTEM, {;
      allowedPaths: thisallowedPaths;
      blockedPaths: thisblockedPaths;
    });
  };

  // A2A Protocol Implementation;
  async sendMessage(message: A2AMessage): Promise<void> {;
    // Emit to local subscribers;
    const subscribers = thisa2aSubscriptionsget(messageaction) || new Set();
    for (const agentId of subscribers) {;
      const handler = thisa2aHandlersget(agentId);
      if (handler) {;
        await handler(message);
      };
    };

    // Log to Supabase for persistence and remote agents;
    await thissupabasefrom('a2a_messages')insert({;
      from_agent: messagefrom;
      to_agent: messageto;
      message_type: messagetype;
      action: messageaction;
      payload: messagepayload;
      correlation_id: messagecorrelationId;
      created_at: messagetimestamp;
    });
    // Emit for real-time subscribers;
    thisemit('a2a:message', message);
  };

  onMessage(handler: (message: A2AMessage) => Promise<void>): void {;
    const handlerId = cryptorandomUUID();
    thisa2aHandlersset(handlerId, handler);
  };

  subscribe(agentId: string, eventType: string): void {;
    if (!thisa2aSubscriptionshas(eventType)) {;
      thisa2aSubscriptionsset(eventType, new Set());
    };
    thisa2aSubscriptionsget(eventType)!add(agentId);
  };

  unsubscribe(agentId: string, eventType: string): void {;
    const subscribers = thisa2aSubscriptionsget(eventType);
    if (subscribers) {;
      subscribersdelete(agentId);
    };
  };

  // Path Security;
  private isPathAllowed(filePath: string): boolean {;
    const normalizedPath = pathresolve(filePath);
    // Check if path is in blocked list;
    for (const blocked of thisblockedPaths) {;
      if (normalizedPathstartsWith(blocked)) {;
        return false;
      };
    };

    // Check if path is within allowed paths;
    for (const allowed of thisallowedPaths) {;
      const resolvedAllowed = pathresolve(allowed);
      if (normalizedPathstartsWith(resolvedAllowed)) {;
        return true;
      };
    };

    return false;
  };

  private sanitizePath(filePath: string): string {;
    // Remove any directory traversal attempts;
    const sanitized = filePathreplace(/\.\./g, '')replace(/\/\//g, '/');
    return pathresolve(sanitized);
  };

  // File Operations;
  async readFile(filePath: string, options?: { encoding?: BufferEncoding }): Promise<string> {;
    const sanitizedPath = thissanitizePath(filePath);
    if (!thisisPathAllowed(sanitizedPath)) {;
      throw new Error(`Access denied: ${filePath}`);
    };

    const operation = await thistrackOperation({;
      type: 'read';
      sourcePath: sanitizedPath;
      agentId: 'filesystem-service';
      userId: 'system';
    });
    try {;
      const content await fsreadFile(sanitizedPath, options?encoding || 'utf-8');
      await thiscompleteOperation(operationid, { success: true });
      // Send a2a notification;
      await thissendMessage({;
        from: 'filesystem-service';
        to: 'all';
        type: 'event';
        action: 'file:read';
        payload: { path: sanitizedPath, size: content-length ;
};
        correlationId: operationid;
        timestamp: new Date();
      });
      return content;
    } catch (error) {;
      await thiscompleteOperation(operationid, {;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async writeFile(;
    filePath: string;
    contentstring;
    options?: { encoding?: BufferEncoding ;
};
  ): Promise<void> {;
    const sanitizedPath = thissanitizePath(filePath);
    if (!thisisPathAllowed(sanitizedPath)) {;
      throw new Error(`Access denied: ${filePath}`);
    };

    const operation = await thistrackOperation({;
      type: 'write';
      sourcePath: sanitizedPath;
      content;
      agentId: 'filesystem-service';
      userId: 'system';
    });
    try {;
      await fswriteFile(sanitizedPath, contentoptions?encoding || 'utf-8');
      await thiscompleteOperation(operationid, { success: true });
      // Send a2a notification;
      await thissendMessage({;
        from: 'filesystem-service';
        to: 'all';
        type: 'event';
        action: 'file:write';
        payload: { path: sanitizedPath, size: content-length ;
};
        correlationId: operationid;
        timestamp: new Date();
      });
    } catch (error) {;
      await thiscompleteOperation(operationid, {;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async deleteFile(filePath: string): Promise<void> {;
    const sanitizedPath = thissanitizePath(filePath);
    if (!thisisPathAllowed(sanitizedPath)) {;
      throw new Error(`Access denied: ${filePath}`);
    };

    const operation = await thistrackOperation({;
      type: 'delete';
      sourcePath: sanitizedPath;
      agentId: 'filesystem-service';
      userId: 'system';
    });
    try {;
      const stats = await fsstat(sanitizedPath);
      if (statsisDirectory()) {;
        await fsrmdir(sanitizedPath, { recursive: true });
      } else {;
        await fsunlink(sanitizedPath);
      };

      await thiscompleteOperation(operationid, { success: true });
      // Send a2a notification;
      await thissendMessage({;
        from: 'filesystem-service';
        to: 'all';
        type: 'event';
        action: 'file:delete';
        payload: { path: sanitizedPath, type: statsisDirectory() ? 'directory' : 'file' ;
};
        correlationId: operationid;
        timestamp: new Date();
      });
    } catch (error) {;
      await thiscompleteOperation(operationid, {;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async moveFile(sourcePath: string, targetPath: string): Promise<void> {;
    const sanitizedSource = thissanitizePath(sourcePath);
    const sanitizedTarget = thissanitizePath(targetPath);
    if (!thisisPathAllowed(sanitizedSource) || !thisisPathAllowed(sanitizedTarget)) {;
      throw new Error(`Access denied`);
    };

    const operation = await thistrackOperation({;
      type: 'move';
      sourcePath: sanitizedSource;
      targetPath: sanitizedTarget;
      agentId: 'filesystem-service';
      userId: 'system';
    });
    try {;
      await fsrename(sanitizedSource, sanitizedTarget);
      await thiscompleteOperation(operationid, { success: true });
      // Send a2a notification;
      await thissendMessage({;
        from: 'filesystem-service';
        to: 'all';
        type: 'event';
        action: 'file:move';
        payload: { from: sanitizedSource, to: sanitizedTarget ;
};
        correlationId: operationid;
        timestamp: new Date();
      });
    } catch (error) {;
      await thiscompleteOperation(operationid, {;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async copyFile(sourcePath: string, targetPath: string): Promise<void> {;
    const sanitizedSource = thissanitizePath(sourcePath);
    const sanitizedTarget = thissanitizePath(targetPath);
    if (!thisisPathAllowed(sanitizedSource) || !thisisPathAllowed(sanitizedTarget)) {;
      throw new Error(`Access denied`);
    };

    const operation = await thistrackOperation({;
      type: 'copy';
      sourcePath: sanitizedSource;
      targetPath: sanitizedTarget;
      agentId: 'filesystem-service';
      userId: 'system';
    });
    try {;
      await fscopyFile(sanitizedSource, sanitizedTarget);
      await thiscompleteOperation(operationid, { success: true });
      // Send a2a notification;
      await thissendMessage({;
        from: 'filesystem-service';
        to: 'all';
        type: 'event';
        action: 'file:copy';
        payload: { from: sanitizedSource, to: sanitizedTarget ;
};
        correlationId: operationid;
        timestamp: new Date();
      });
    } catch (error) {;
      await thiscompleteOperation(operationid, {;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async createDirectory(dirPath: string, options?: { recursive?: boolean }): Promise<void> {;
    const sanitizedPath = thissanitizePath(dirPath);
    if (!thisisPathAllowed(sanitizedPath)) {;
      throw new Error(`Access denied: ${dirPath}`);
    };

    const operation = await thistrackOperation({;
      type: 'mkdir';
      sourcePath: sanitizedPath;
      agentId: 'filesystem-service';
      userId: 'system';
    });
    try {;
      await fsmkdir(sanitizedPath, { recursive: options?recursive || false });
      await thiscompleteOperation(operationid, { success: true });
      // Send a2a notification;
      await thissendMessage({;
        from: 'filesystem-service';
        to: 'all';
        type: 'event';
        action: 'directory:create';
        payload: { path: sanitizedPath ;
};
        correlationId: operationid;
        timestamp: new Date();
      });
    } catch (error) {;
      await thiscompleteOperation(operationid, {;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async listDirectory(;
    dirPath: string;
    options?: {;
      recursive?: boolean;
      includeHidden?: boolean;
      maxDepth?: number;
    ;
};
  ): Promise<FileTreeNode[]> {;
    const sanitizedPath = thissanitizePath(dirPath);
    if (!thisisPathAllowed(sanitizedPath)) {;
      throw new Error(`Access denied: ${dirPath}`);
    };

    const entries = await fsreaddir(sanitizedPath, { withFileTypes: true });
    const result: FileTreeNode[] = [];
    for (const entry of entries) {;
      if (!options?includeHidden && entrynamestartsWith('.')) {;
        continue;
      };

      const fullPath = pathjoin(sanitizedPath, entryname);
      const stats = await fsstat(fullPath);
      if (entryisDirectory()) {;
        const node: DirectoryTree = {;
          path: fullPath;
          name: entryname;
          type: 'directory';
          children: [];
          expanded: false;
        ;
};
        if (options?recursive && (!optionsmaxDepth || optionsmaxDepth > 0)) {;
          nodechildren = await thislistDirectory(fullPath, {;
            ..options;
            maxDepth: optionsmaxDepth ? optionsmaxDepth - 1 : undefined;
          });
        };

        resultpush(node);
      } else {;
        const metadata = await thisgetFileMetadata(fullPath);
        resultpush(metadata);
      };
    };

    return result;
  };

  async getFileMetadata(filePath: string): Promise<FileMetadata> {;
    const sanitizedPath = thissanitizePath(filePath);
    if (!thisisPathAllowed(sanitizedPath)) {;
      throw new Error(`Access denied: ${filePath}`);
    };

    const stats = await fsstat(sanitizedPath);
    const name = pathbasename(sanitizedPath);
    const extension = pathextname(sanitizedPath)toLowerCase();
    const metadata: FileMetadata = {;
      path: sanitizedPath;
      name;
      size: statssize;
      type: statsisDirectory() ? 'directory' : statsisSymbolicLink() ? 'symlink' : 'file';
      extension: extension || undefined;
      createdAt: statsbirthtime;
      modifiedAt: statsmtime;
      accessedAt: statsatime;
      permissions: {;
        readable: !!(statsmode & 0o400);
        writable: !!(statsmode & 0o200);
        executable: !!(statsmode & 0o100);
      ;
};
      isHidden: namestartsWith('.');
    ;
};
    // Calculate hash for files;
    if (metadatatype === 'file' && statssize < 100 * 1024 * 1024) {;
      // Only hash files < 100MB;
      try {;
        const content await fsreadFile(sanitizedPath);
        metadatahash = cryptocreateHash('sha256')update(contentdigest('hex');
      } catch (error) {;
        loggerwarn('Failed to calculate file hash', LogContextSYSTEM, {;
          path: sanitizedPath;
          error;
        });
      };
    };
;
    return FileMetadataSchemaparse(metadata);
  };

  // File Watching;
  async watchPath(;
    watchPath: string;
    options?: {;
      recursive?: boolean;
      ignorePatterns?: string[];
    ;
};
  ): Promise<string> {;
    const sanitizedPath = thissanitizePath(watchPath);
    if (!thisisPathAllowed(sanitizedPath)) {;
      throw new Error(`Access denied: ${watchPath}`);
    };

    const watcherId = cryptorandomUUID();
    const watcher = watch(sanitizedPath, {;
      persistent: true;
      recursive: options?recursive;
      ignored: options?ignorePatterns;
      ignoreInitial: true;
      awaitWriteFinish: {;
        stabilityThreshold: 300;
        pollInterval: 100;
      ;
};
    });
    watcheron('add', (filePath) => thishandleFileEvent('add', filePath, watcherId));
    watcheron('change', (filePath) => thishandleFileEvent('change', filePath, watcherId));
    watcheron('unlink', (filePath) => thishandleFileEvent('unlink', filePath, watcherId));
    watcheron('addDir', (dirPath) => thishandleFileEvent('addDir', dirPath, watcherId));
    watcheron('unlinkDir', (dirPath) => thishandleFileEvent('unlinkDir', dirPath, watcherId));
    thiswatchersset(watcherId, watcher);
    loggerinfo('Started watching path', LogContextSYSTEM, {;
      watcherId;
      path: sanitizedPath;
      recursive: options?recursive;
    });
    return watcherId;
  };

  async unwatchPath(watcherId: string): Promise<void> {;
    const watcher = thiswatchersget(watcherId);
    if (watcher) {;
      await watcherclose();
      thiswatchersdelete(watcherId);
      loggerinfo('Stopped watching path', LogContextSYSTEM, { watcherId });
    };
  };

  private async handleFileEvent(event: string, filePath: string, watcherId: string): Promise<void> {;
    // Send a2a notification;
    await thissendMessage({;
      from: 'filesystem-service';
      to: 'all';
      type: 'event';
      action: `file:${event}`;
      payload: {;
        path: filePath;
        watcherId;
        event;
      ;
};
      correlationId: cryptorandomUUID();
      timestamp: new Date();
    });
    // Emit local event;
    thisemit('file:change', {;
      event;
      path: filePath;
      watcherId;
    });
  };

  // Operation Tracking;
  private async trackOperation(operation: Partial<FileOperation>): Promise<FileOperation> {;
    const op: FileOperation = {;
      id: cryptorandomUUID();
      status: 'pending';
      startedAt: new Date();
      ..operation;
    } as FileOperation;
    thisoperationQueuepush(op);
    // Store in Supabase;
    await thissupabasefrom('file_operations')insert({;
      id: opid;
      type: optype;
      source_path: opsourcePath;
      target_path: optargetPath;
      agent_id: opagentId;
      user_id: opuserId;
      status: opstatus;
      started_at: opstartedAt;
    });
    return op;
  };

  private async completeOperation(;
    operationId: string;
    result: { success: boolean, error instanceof Error ? errormessage : String(error) string ;
};
  ): Promise<void> {;
    const op = thisoperationQueuefind((o) => oid === operationId);
    if (!op) return;
    opstatus = resultsuccess ? 'completed' : 'failed';
    operror instanceof Error ? errormessage : String(error)  resulterror;
    opcompletedAt = new Date();
    // Update in Supabase;
    await thissupabase;
      from('file_operations');
      update({;
        status: opstatus;
        error instanceof Error ? errormessage : String(error) operror;
        completed_at: opcompletedAt;
      });
      eq('id', operationId);
    // Remove from queue;
    thisoperationQueue = thisoperationQueuefilter((o) => oid !== operationId);
  };

  // Integration with FileManagerAgent;
  async organizeFiles(dirPath: string, rules?: any): Promise<void> {;
    const sanitizedPath = thissanitizePath(dirPath);
    if (!thisisPathAllowed(sanitizedPath)) {;
      throw new Error(`Access denied: ${dirPath}`);
    };

    // Delegate to FileManagerAgent;
    await thisfileManagerAgentorganizeFiles({;
      directory: sanitizedPath;
      rules: rules || 'smart';
      preview: false;
    });
  };

  async findDuplicates(dirPath: string): Promise<any[]> {;
    const sanitizedPath = thissanitizePath(dirPath);
    if (!thisisPathAllowed(sanitizedPath)) {;
      throw new Error(`Access denied: ${dirPath}`);
    };

    // Delegate to FileManagerAgent;
    return thisfileManagerAgentfindDuplicates({;
      directory: sanitizedPath;
      includeSubdirs: true;
    });
  };

  async searchFiles(query: string, dirPath?: string): Promise<any[]> {;
    const searchPath = dirPath ? thissanitizePath(dirPath) : thisallowedPaths[0];
    if (!thisisPathAllowed(searchPath)) {;
      throw new Error(`Access denied: ${dirPath}`);
    };

    // Delegate to FileManagerAgent;
    return thisfileManagerAgentsmartSearch({;
      query;
      directory: searchPath;
      searchContent: true;
    });
  };

  // Cleanup;
  async shutdown(): Promise<void> {;
    // Close all file watchers;
    for (const [watcherId, watcher] of thiswatchers) {;
      await watcherclose();
    };
    thiswatchersclear();
    // Clear handlers;
    thisa2aHandlersclear();
    thisa2aSubscriptionsclear();
    loggerinfo('FileSystemService shut down', LogContextSYSTEM);
  };
};

// Factory function;
export function createFileSystemService(;
  supabase: SupabaseClient;
  options?: { allowedPaths?: string[] ;
};
): FileSystemService {;
  return new FileSystemService(supabase, options?allowedPaths);
};
