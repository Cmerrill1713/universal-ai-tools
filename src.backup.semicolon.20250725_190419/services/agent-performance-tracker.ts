import type { SupabaseClient } from '@supabase/supabase-js';
import { EventEmitter } from 'events';
import { z } from 'zod';
import { LogContext, logger } from '../utils/enhanced-logger';
// Performance Metric Schemas;
const PerformanceMetricSchema = zobject({;
  id: zstring()optional();
  agent_id: zstring();
  agent_name: zstring();
  agent_type: zstring();
  task_id: zstring()optional();
  task_name: zstring()optional();
  metric_type: zenum(['execution_time', 'resource_usage', 'success_rate', 'task_complexity']);
  value: znumber();
  unit: zstring()optional();
  timestamp: zdate()default(() => new Date());
  metadata: zrecord(zany())optional();
});
const AggregatedMetricsSchema = zobject({;
  agent_id: zstring();
  period: zenum(['minute', 'hour', 'day', 'week', 'month']);
  start_time: zdate();
  end_time: zdate();
  total_tasks: znumber();
  successful_tasks: znumber();
  failed_tasks: znumber();
  avg_execution_time: znumber();
  min_execution_time: znumber();
  max_execution_time: znumber();
  avg_cpu_usage: znumber()optional();
  avg_memory_usage: znumber()optional();
  complexity_handled: zrecord(znumber()), // complexity level -> count;
});
const ResourceUsageSchema = zobject({;
  cpu_percentage: znumber()min(0)max(100);
  memory_mb: znumber()min(0);
  network_kb: znumber()min(0)optional();
  disk_io_kb: znumber()min(0)optional();
});
export type PerformanceMetric = zinfer<typeof PerformanceMetricSchema>;
export type AggregatedMetrics = zinfer<typeof AggregatedMetricsSchema>;
export type ResourceUsage = zinfer<typeof ResourceUsageSchema>;
interface PerformanceTrackerConfig {;
  supabase: SupabaseClient;
  metricsRetentionDays?: number;
  aggregationIntervals?: ('minute' | 'hour' | 'day' | 'week' | 'month')[];
  realTimeUpdates?: boolean;
;
};

interface TaskExecution {;
  taskId: string;
  taskName: string;
  agentId: string;
  startTime: Date;
  endTime?: Date;
  success?: boolean;
  error instanceof Error ? errormessage : String(error)  string;
  complexity?: number;
  resourceUsage?: ResourceUsage;
;
};

export class AgentPerformanceTracker extends EventEmitter {;
  private supabase: SupabaseClient;
  private activeExecutions: Map<string, TaskExecution> = new Map();
  private metricsBuffer: PerformanceMetric[] = [];
  private bufferFlushInterval: NodeJSTimeout | null = null;
  private aggregationInterval: NodeJSTimeout | null = null;
  private config: Required<PerformanceTrackerConfig>;
  constructor(config: PerformanceTrackerConfig) {;
    super();
    thissupabase = configsupabase;
    thisconfig = {;
      supabase: configsupabase;
      metricsRetentionDays: configmetricsRetentionDays || 30;
      aggregationIntervals: configaggregationIntervals || ['hour', 'day', 'week'];
      realTimeUpdates: configrealTimeUpdates ?? true;
    ;
};
    thisinitializeBufferFlush();
    thisinitializeAggregation();
  };

  private initializeBufferFlush(): void {;
    // Flush metrics buffer every 5 seconds;
    thisbufferFlushInterval = setInterval(() => {;
      thisflushMetricsBuffer()catch((error instanceof Error ? errormessage : String(error)=> {;
        loggererror('Failed to flush metrics buffer', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error));
      });
    }, 5000);
  };

  private initializeAggregation(): void {;
    // Run aggregation every 5 minutes;
    thisaggregationInterval = setInterval(;
      () => {;
        thisrunAggregation()catch((error instanceof Error ? errormessage : String(error)=> {;
          loggererror('Failed to run aggregation', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error));
        });
      };
      5 * 60 * 1000;
    );
  };

  // Track the start of a task execution;
  async startTaskExecution(;
    agentId: string;
    agentName: string;
    agentType: string;
    taskId: string;
    taskName: string;
    complexity?: number;
  ): Promise<void> {;
    const execution: TaskExecution = {;
      taskId;
      taskName;
      agentId;
      startTime: new Date();
      complexity;
    ;
};
    thisactiveExecutionsset(`${agentId}-${taskId}`, execution);
    // Emit real-time event;
    if (thisconfigrealTimeUpdates) {;
      thisemit('taskStarted', {;
        agentId;
        agentName;
        taskId;
        taskName;
        startTime: executionstartTime;
      });
    };
  };

  // Track the end of a task execution;
  async endTaskExecution(;
    agentId: string;
    agentName: string;
    agentType: string;
    taskId: string;
    success: boolean;
    error instanceof Error ? errormessage : String(error)  string;
    resourceUsage?: ResourceUsage;
  ): Promise<void> {;
    const key = `${agentId}-${taskId}`;
    const execution = thisactiveExecutionsget(key);
    if (!execution) {;
      loggerwarn('No active execution found for task', LogContextPERFORMANCE, {;
        agentId;
        taskId;
      });
      return;
    };

    executionendTime = new Date();
    executionsuccess = success;
    executionerror instanceof Error ? errormessage : String(error)  error;
    executionresourceUsage = resourceUsage;
    const executionTime = executionendTimegetTime() - executionstartTimegetTime();
    // Record execution time metric;
    thisrecordMetric({;
      agent_id: agentId;
      agent_name: agentName;
      agent_type: agentType;
      task_id: taskId;
      task_name: executiontaskName;
      metric_type: 'execution_time';
      value: executionTime;
      unit: 'ms';
      metadata: {;
        success;
        error;
        complexity: executioncomplexity;
      ;
};
    });
    // Record resource usage metrics if available;
    if (resourceUsage) {;
      thisrecordMetric({;
        agent_id: agentId;
        agent_name: agentName;
        agent_type: agentType;
        task_id: taskId;
        task_name: executiontaskName;
        metric_type: 'resource_usage';
        value: resourceUsagecpu_percentage;
        unit: 'percentage';
        metadata: {;
          memory_mb: resourceUsagememory_mb;
          network_kb: resourceUsagenetwork_kb;
          disk_io_kb: resourceUsagedisk_io_kb;
        ;
};
      });
    };

    // Record task complexity if available;
    if (executioncomplexity !== undefined) {;
      thisrecordMetric({;
        agent_id: agentId;
        agent_name: agentName;
        agent_type: agentType;
        task_id: taskId;
        task_name: executiontaskName;
        metric_type: 'task_complexity';
        value: executioncomplexity;
        unit: 'level';
      });
    };

    thisactiveExecutionsdelete(key);
    // Emit real-time event;
    if (thisconfigrealTimeUpdates) {;
      thisemit('taskCompleted', {;
        agentId;
        agentName;
        taskId;
        taskName: executiontaskName;
        executionTime;
        success;
        error;
      });
    };
  };

  // Record a performance metric;
  private recordMetric(metric: PerformanceMetric): void {;
    const validated = PerformanceMetricSchemaparse(metric);
    thismetricsBufferpush(validated);
    // Emit real-time metric event;
    if (thisconfigrealTimeUpdates) {;
      thisemit('metricRecorded', validated);
    };
  };

  // Flush metrics buffer to database;
  private async flushMetricsBuffer(): Promise<void> {;
    if (thismetricsBufferlength === 0) return;
    const metricsToFlush = [..thismetricsBuffer];
    thismetricsBuffer = [];
    try {;
      const { error instanceof Error ? errormessage : String(error)  = await thissupabase;
        from('agent_performance_metrics');
        insert(metricsToFlush);
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      loggerdebug('Flushed performance metrics', LogContextPERFORMANCE, {;
        count: metricsToFlushlength;
      });
    } catch (error) {;
      loggererror('Failed to flush metrics to database', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error) );
      // Re-add metrics to buffer for retry;
      thismetricsBufferunshift(..metricsToFlush);
    ;
};
  };

  // Get agent performance summary;
  async getAgentPerformanceSummary(;
    agentId: string;
    startDate?: Date;
    endDate?: Date;
  ): Promise<{;
    successRate: number;
    avgExecutionTime: number;
    totalTasks: number;
    failedTasks: number;
    avgResourceUsage: ResourceUsage | null;
  }> {;
    const query = thissupabase;
      from('agent_performance_metrics');
      select('*');
      eq('agent_id', agentId);
    if (startDate) {;
      querygte('timestamp', startDatetoISOString());
    };
    if (endDate) {;
      querylte('timestamp', endDatetoISOString());
    };

    const { data: metrics, error instanceof Error ? errormessage : String(error)  = await query;
    if (error instanceof Error ? errormessage : String(error){;
      throw error instanceof Error ? errormessage : String(error);
    };

    if (!metrics || metricslength === 0) {;
      return {;
        successRate: 0;
        avgExecutionTime: 0;
        totalTasks: 0;
        failedTasks: 0;
        avgResourceUsage: null;
      ;
};
    };

    // Calculate summary statistics;
    const executionMetrics = metricsfilter((m) => mmetric_type === 'execution_time');
    const totalTasks = executionMetricslength;
    const successfulTasks = executionMetricsfilter((m) => mmetadata?success === true)length;
    const failedTasks = executionMetricsfilter((m) => mmetadata?success === false)length;
    const successRate = totalTasks > 0 ? (successfulTasks / totalTasks) * 100 : 0;
    const avgExecutionTime =;
      executionMetricsreduce((sum, m) => sum + mvalue, 0) / (executionMetricslength || 1);
    // Calculate average resource usage;
    const resourceMetrics = metricsfilter((m) => mmetric_type === 'resource_usage');
    let avgResourceUsage: ResourceUsage | null = null;
    if (resourceMetricslength > 0) {;
      const totalCpu = resourceMetricsreduce((sum, m) => sum + mvalue, 0);
      const totalMemory = resourceMetricsreduce((sum, m) => sum + (mmetadata?memory_mb || 0), 0);
      avgResourceUsage = {;
        cpu_percentage: totalCpu / resourceMetricslength;
        memory_mb: totalMemory / resourceMetricslength;
        network_kb: 0;
        disk_io_kb: 0;
      ;
};
    };

    return {;
      successRate;
      avgExecutionTime;
      totalTasks;
      failedTasks;
      avgResourceUsage;
    };
  };

  // Get performance trends;
  async getPerformanceTrends(;
    agentId: string;
    period: 'hour' | 'day' | 'week' | 'month';
    lookback = 7;
  ): Promise<AggregatedMetrics[]> {;
    const endDate = new Date();
    const startDate = new Date();
    switch (period) {;
      case 'hour':;
        startDatesetHours(startDategetHours() - lookback);
        break;
      case 'day':;
        startDatesetDate(startDategetDate() - lookback);
        break;
      case 'week':;
        startDatesetDate(startDategetDate() - lookback * 7);
        break;
      case 'month':;
        startDatesetMonth(startDategetMonth() - lookback);
        break;
    };

    const { data, error } = await thissupabase;
      from('agent_performance_aggregated');
      select('*');
      eq('agent_id', agentId);
      eq('period', period);
      gte('start_time', startDatetoISOString());
      lte('end_time', endDatetoISOString());
      order('start_time', { ascending: true });
    if (error instanceof Error ? errormessage : String(error){;
      throw error instanceof Error ? errormessage : String(error);
    };

    return data || [];
  };

  // Run aggregation for all periods;
  private async runAggregation(): Promise<void> {;
    for (const period of thisconfigaggregationIntervals) {;
      await thisaggregateMetrics(period);
    ;
};
  };

  // Aggregate metrics for a specific period;
  private async aggregateMetrics(;
    period: 'minute' | 'hour' | 'day' | 'week' | 'month';
  ): Promise<void> {;
    try {;
      const { error instanceof Error ? errormessage : String(error)  = await thissupabaserpc('aggregate_performance_metrics', {;
        p_period: period;
      });
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      loggerdebug('Completed metrics aggregation', LogContextPERFORMANCE, { period });
    } catch (error) {;
      loggererror('Failed to aggregate metrics', LogContextPERFORMANCE, { period, error instanceof Error ? errormessage : String(error) );
    ;
};
  };

  // Clean up old metrics;
  async cleanupOldMetrics(): Promise<void> {;
    const cutoffDate = new Date();
    cutoffDatesetDate(cutoffDategetDate() - thisconfigmetricsRetentionDays);
    try {;
      const { error instanceof Error ? errormessage : String(error)  = await thissupabase;
        from('agent_performance_metrics');
        delete();
        lt('timestamp', cutoffDatetoISOString());
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      loggerinfo('Cleaned up old performance metrics', LogContextPERFORMANCE, { cutoffDate });
    } catch (error) {;
      loggererror('Failed to cleanup old metrics', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error) );
    ;
};
  };

  // Get comparison between agents;
  async compareAgents(;
    agentIds: string[];
    startDate?: Date;
    endDate?: Date;
  ): Promise<;
    Map<;
      string;
      {;
        successRate: number;
        avgExecutionTime: number;
        totalTasks: number;
        reliability: number;
      ;
};
    >;
  > {;
    const comparisons = new Map();
    for (const agentId of agentIds) {;
      const summary = await thisgetAgentPerformanceSummary(agentId, startDate, endDate);
      // Calculate reliability score based on success rate and consistency;
      const reliability =;
        summarysuccessRate * 0.7 +;
        (summarytotalTasks > 0 ? Mathmin(summarytotalTasks / 100, 1) * 30 : 0);
      comparisonsset(agentId, {;
        successRate: summarysuccessRate;
        avgExecutionTime: summaryavgExecutionTime;
        totalTasks: summarytotalTasks;
        reliability;
      });
    };

    return comparisons;
  };

  // Cleanup;
  destroy(): void {;
    if (thisbufferFlushInterval) {;
      clearInterval(thisbufferFlushInterval);
    };
    if (thisaggregationInterval) {;
      clearInterval(thisaggregationInterval);
    };
    thisremoveAllListeners();
  };
};

// Export singleton instance creator;
export function createPerformanceTracker(;
  config: PerformanceTrackerConfig;
): AgentPerformanceTracker {;
  return new AgentPerformanceTracker(config);
};
