/**;
 * Human-in-the-Loop Feedback Service;
 *;
 * Collects and processes human feedback to improve DSPy and agent performance;
 */;

import { EventEmitter } from 'events';
import type { SupabaseClient } from '@supabase/supabase-js';
import { WebSocket, WebSocketServer } from 'ws';
import { logger } from '../utils/logger';
// Core feedback interfaces;
export interface UserFeedback {;
  feedbackId: string;
  requestId: string;
  feedbackType: 'rating' | 'correction' | 'preference' | 'label';
  rating?: number; // 1-5 stars;
  correctedResponse?: string;
  preferredResponse?: string;
  labels?: string[];
  comments?: string;
  timestamp: Date;
  userId?: string;
  sessionId?: string;
  metadata?: Record<string, any>};

export interface FeedbackRequest {;
  requestId: string;
  agentId: string;
  originalRequest: string;
  agentResponse: any;
  feedbackType: string[];
  priority: 'low' | 'medium' | 'high';
  timeout?: number; // ms to wait for feedback;
  callback?: (feedback: UserFeedback) => void;
};

export interface FeedbackAnalytics {;
  totalFeedback: number;
  averageRating: number;
  feedbackByType: Record<string, number>;
  improvementTrends: any[];
  commonIssues: string[];
  agentPerformance: Record<string, number>};

export interface DSPyTrainingData {;
  trainingId: string;
  examples: {;
    input: string;
    output: string;
    feedback: UserFeedback;
    quality_score: number}[];
  labels: string[];
  metadata: Record<string, any>;
  createdAt: Date;
;
};

/**;
 * Human Feedback Service for collecting and processing user feedback;
 */;
export class HumanFeedbackService extends EventEmitter {;
  private supabase: SupabaseClient;
  private wsServer?: WebSocketServer;
  private activeFeedbackRequests = new Map<string, FeedbackRequest>();
  private connectedClients = new Set<WebSocket>();
  private feedbackHistory: UserFeedback[] = [];
  private trainingDatasets: DSPyTrainingData[] = [];
  constructor(supabase: SupabaseClient) {;
    super();
    thissupabase = supabase;
    thissetupEventListeners()};

  /**;
   * Initialize the feedback service;
   */;
  async initialize(wsPort?: number): Promise<void> {;
    try {;
      loggerinfo('ü§ù Initializing Human Feedback Service...');
      // Setup database tables;
      await thissetupFeedbackTables();
      // Setup WebSocket server for real-time feedback;
      if (wsPort) {;
        await thissetupWebSocketServer(wsPort);
};

      // Load existing feedback for analytics;
      await thisloadFeedbackHistory();
      loggerinfo('‚úÖ Human Feedback Service ready');
    } catch (error) {;
      loggererror('‚ùå Failed to initialize Human Feedback Service:', error);
      throw error};
  };

  /**;
   * Request feedback from users;
   */;
  async requestFeedback(request: FeedbackRequest): Promise<string> {;
    const feedbackId = `feedback_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
    loggerinfo(`üìù Requesting feedback for ${requestagentId}`, {;
      feedbackId;
      requestId: requestrequestId;
      priority: requestpriority;
      types: requestfeedbackType});
    // Store the request;
    thisactiveFeedbackRequestsset(feedbackId, {;
      ..request;
      requestId: feedbackId});
    // Send to connected clients via WebSocket;
    thisbroadcastFeedbackRequest({;
      feedbackId;
      ..request});
    // Set timeout if specified;
    if (requesttimeout) {;
      setTimeout(() => {;
        if (thisactiveFeedbackRequestshas(feedbackId)) {;
          loggerwarn(`‚è∞ Feedback request ${feedbackId} timed out`);
          thisactiveFeedbackRequestsdelete(feedbackId);
        };
      }, requesttimeout);
    };

    return feedbackId;
  };

  /**;
   * Submit user feedback;
   */;
  async submitFeedback(feedback: Partial<UserFeedback>): Promise<UserFeedback> {;
    const completeFeedback: UserFeedback = {;
      feedbackId:;
        feedbackfeedbackId || `fb_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
      requestId: feedbackrequestId!;
      feedbackType: feedbackfeedbackType!;
      rating: feedbackrating;
      correctedResponse: feedbackcorrectedResponse;
      preferredResponse: feedbackpreferredResponse;
      labels: feedbacklabels || [];
      comments: feedbackcomments;
      timestamp: new Date();
      userId: feedbackuserId;
      sessionId: feedbacksessionId;
      metadata: feedbackmetadata || {}};
    loggerinfo(`üí¨ Received feedback: ${completeFeedbackfeedbackType}`, {;
      feedbackId: completeFeedbackfeedbackId;
      requestId: completeFeedbackrequestId;
      rating: completeFeedbackrating;
      hasCorrection: !!completeFeedbackcorrectedResponse});
    // Store in database;
    await thisstoreFeedback(completeFeedback);
    // Add to local history;
    thisfeedbackHistorypush(completeFeedback);
    // Process for DSPy training if applicable;
    await thisprocessFeedbackForTraining(completeFeedback);
    // Notify connected clients;
    thisbroadcastFeedbackUpdate(completeFeedback);
    // Handle callback if request exists;
    const request = thisactiveFeedbackRequestsget(completeFeedbackrequestId);
    if (request && requestcallback) {;
      requestcallback(completeFeedback);
      thisactiveFeedbackRequestsdelete(completeFeedbackrequestId)};

    // Emit event for other systems;
    thisemit('feedback_received', completeFeedback);
    return completeFeedback;
  };

  /**;
   * Get feedback analytics and insights;
   */;
  async getFeedbackAnalytics(;
    agentId?: string;
    timeRange?: { start: Date, end: Date ;
};
  ): Promise<FeedbackAnalytics> {;
    try {;
      let query = thissupabasefrom('user_feedback')select('*');
      if (agentId) {;
        // Join with feedbackrequests to filter by agent;
        query = queryeq('metadata->>agentId', agentId)};

      if (timeRange) {;
        query = query;
          gte('timestamp', timeRangestarttoISOString());
          lte('timestamp', timeRangeendtoISOString())};

      const { data, error } = await queryorder('timestamp', { ascending: false });
      if (error) throw error;
      const feedback = data || [];
      const totalFeedback = feedbacklength;
      // Calculate average rating;
      const ratingsData = feedbackfilter((f) => frating)map((f) => frating);
      const averageRating =;
        ratingsDatalength > 0 ? ratingsDatareduce((a, b) => a + b, 0) / ratingsDatalength : 0;
      // Group by feedback type;
      const feedbackByType: Record<string, number> = {};
      feedbackforEach((f) => {;
        feedbackByType[ffeedback_type] = (feedbackByType[ffeedback_type] || 0) + 1});
      // Calculate agent performance if not filtered by specific agent;
      const agentPerformance: Record<string, number> = {};
      if (!agentId) {;
        const agentFeedback = new Map<string, UserFeedback[]>();
        feedbackforEach((f) => {;
          const agent = fmetadata?agentId || 'unknown';
          if (!agentFeedbackhas(agent)) {;
            agentFeedbackset(agent, [])};
          agentFeedbackget(agent)!push(f);
        });
        // Calculate average rating per agent;
        for (const [agentId, feedbacks] of agentFeedback) {;
          const ratings = feedbacksfilter((f) => frating)map((f) => frating!);
          if (ratingslength > 0) {;
            performance[agentId] = ratingsreduce((a, b) => a + b, 0) / ratingslength};
        };
      };

      // Extract common issues from comments;
      const commonIssues = thisextractCommonIssues(feedback);
      // Calculate improvement trends (simplified);
      const improvementTrends = thiscalculateImprovementTrends(feedback);
      return {;
        totalFeedback;
        averageRating;
        feedbackByType;
        improvementTrends;
        commonIssues;
        agentPerformance};
    } catch (error) {;
      loggererror('Failed to get feedback analytics:', error);
      throw error};
  };

  /**;
   * Generate DSPy training dataset from collected feedback;
   */;
  async generateDSPyTrainingData(;
    criteria: {;
      minRating?: number;
      includeCorrections?: boolean;
      agentIds?: string[];
      maxExamples?: number} = {};
  ): Promise<DSPyTrainingData> {;
    const trainingId = `training_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
    loggerinfo('üß† Generating DSPy training dataset', {;
      trainingId;
      criteria});
    try {;
      let query = thissupabase;
        from('user_feedback');
        select('*, feedbackrequests(*)');
        order('timestamp', { ascending: false });
      // Apply filters;
      if (criteriaminRating) {;
        query = querygte('rating', criteriaminRating)};

      if (criteriamaxExamples) {;
        query = querylimit(criteriamaxExamples)};

      const { data, error } = await query;
      if (error) throw error;
      const feedbackData = data || [];
      const examples: any[] = [];
      const labels = new Set<string>();
      for (const feedback of feedbackData) {;
        // Skip if agent not in allowed list;
        if (criteriaagentIds && !criteriaagentIdsincludes(feedbackmetadata?agentId)) {;
          continue};

        // Create training example;
        const example = {;
          input: feedbackfeedbackrequests?originalrequest || '';
          output: criteriaincludeCorrections && feedbackcorrected_response;
              ? feedbackcorrected_response;
              : feedbackfeedbackrequests?agent_response || '';
          feedback;
          quality_score: thiscalculateQualityScore(feedback)};
        examplespush(example);
        // Collect labels;
        if (feedbacklabels) {;
          feedbacklabelsforEach((label: string) => labelsadd(label));
};
      };

      const trainingData: DSPyTrainingData = {;
        trainingId;
        examples;
        labels: Arrayfrom(labels);
        metadata: {;
          criteria;
          generatedAt: new Date()toISOString();
          totalExamples: exampleslength;
          averageQuality: examplesreduce((sum, ex) => sum + exquality_score, 0) / exampleslength};
        createdAt: new Date();
};
      // Store training dataset;
      await thisstoreTrainingDataset(trainingData);
      thistrainingDatasetspush(trainingData);
      loggerinfo('‚úÖ DSPy training dataset generated', {;
        trainingId;
        exampleCount: exampleslength;
        labelCount: labelssize});
      return trainingData;
    } catch (error) {;
      loggererror('Failed to generate DSPy training data:', error);
      throw error};
  };

  /**;
   * Export feedback data for external analysis;
   */;
  async exportFeedbackData(;
    format: 'json' | 'csv' | 'dspy';
    filters: {;
      agentIds?: string[];
      dateRange?: { start: Date, end: Date ;
};
      feedbackTypes?: string[];
      minRating?: number;
    } = {};
  ): Promise<any> {;
    try {;
      let query = thissupabasefrom('user_feedback')select('*, feedbackrequests(*)');
      // Apply filters;
      if (filtersdateRange) {;
        query = query;
          gte('timestamp', filtersdateRangestarttoISOString());
          lte('timestamp', filtersdateRangeendtoISOString())};

      if (filtersfeedbackTypes) {;
        query = queryin('feedback_type', filtersfeedbackTypes)};

      if (filtersminRating) {;
        query = querygte('rating', filtersminRating)};

      const { data, error } = await queryorder('timestamp', { ascending: false });
      if (error) throw error;
      const feedbackData = data || [];
      // Filter by agent IDs if specified;
      let filteredData = feedbackData;
      if (filtersagentIds) {;
        filteredData = feedbackDatafilter((f) => filtersagentIds!includes(fmetadata?agentId))};

      switch (format) {;
        case 'json':;
          return {;
            metadata: {;
              exportedAt: new Date()toISOString();
              totalRecords: filteredDatalength;
              filters};
            data: filteredData;
};
        case 'csv':;
          return thisformatAsCSV(filteredData);
        case 'dspy':;
          return thisformatForDSPy(filteredData);
        default:;
          throw new Error(`Unsupported export format: ${format}`);
      };
    } catch (error) {;
      loggererror('Failed to export feedback data:', error);
      throw error};
  };

  /**;
   * Setup WebSocket server for real-time feedback;
   */;
  private async setupWebSocketServer(port: number): Promise<void> {;
    thiswsServer = new WebSocketServer({ port });
    thiswsServeron('connection', (ws: WebSocket) => {;
      loggerinfo('üë• New feedback client connected');
      thisconnectedClientsadd(ws);
      wson('message', async (message: Buffer) => {;
        try {;
          const data = JSONparse(messagetoString());
          if (datatype === 'submit_feedback') {;
            await thissubmitFeedback(datafeedback)};
        } catch (error) {;
          loggererror('WebSocket message error instanceof Error ? errormessage : String(error)', error);
          wssend(;
            JSONstringify({;
              type: 'error';
              message: 'Invalid message format'});
          );
        };
      });
      wson('close', () => {;
        loggerinfo('üëã Feedback client disconnected');
        thisconnectedClientsdelete(ws)});
      // Send welcome message;
      wssend(;
        JSONstringify({;
          type: 'welcome';
          message: 'Connected to Human Feedback Service'});
      );
    });
    loggerinfo(`üåê Feedback WebSocket server listening on port ${port}`);
  };

  /**;
   * Broadcast feedback request to connected clients;
   */;
  private broadcastFeedbackRequest(request: any): void {;
    const message = JSONstringify({;
      type: 'feedbackrequest';
      data: request});
    thisconnectedClientsforEach((client) => {;
      if (clientreadyState === WebSocketOPEN) {;
        clientsend(message)};
    });
  };

  /**;
   * Broadcast feedback update to connected clients;
   */;
  private broadcastFeedbackUpdate(feedback: UserFeedback): void {;
    const message = JSONstringify({;
      type: 'feedback_update';
      data: feedback});
    thisconnectedClientsforEach((client) => {;
      if (clientreadyState === WebSocketOPEN) {;
        clientsend(message)};
    });
  };

  /**;
   * Setup database tables for feedback storage;
   */;
  private async setupFeedbackTables(): Promise<void> {;
    try {;
      // This would create the necessary tables;
      // For now, assume they exist or handle creation in migration files;
      loggerinfo('üìä Setting up feedback database tables')} catch (error) {;
      loggerwarn('Database setup failed:', error)};
  };

  /**;
   * Store feedback in database;
   */;
  private async storeFeedback(feedback: UserFeedback): Promise<void> {;
    try {;
      const { error } = await thissupabasefrom('user_feedback')insert({;
        feedback_id: feedbackfeedbackId;
        request_id: feedbackrequestId;
        feedback_type: feedbackfeedbackType;
        rating: feedbackrating;
        corrected_response: feedbackcorrectedResponse;
        preferred_response: feedbackpreferredResponse;
        labels: feedbacklabels;
        comments: feedbackcomments;
        timestamp: feedbacktimestamptoISOString();
        user_id: feedbackuserId;
        session_id: feedbacksessionId;
        metadata: feedbackmetadata});
      if (error) {;
        loggerwarn('Could not store feedback:', error)};
    } catch (error) {;
      loggerwarn('Feedback storage failed:', error)};
  };

  /**;
   * Process feedback for DSPy training;
   */;
  private async processFeedbackForTraining(feedback: UserFeedback): Promise<void> {;
    try {;
      // Only process high-quality feedback;
      if (feedbackrating && feedbackrating >= 4) {;
        // This would trigger DSPy retraining;
        thisemit('training_data_available', {;
          feedback;
          quality: 'high'});
      };

      // Process corrections for immediate learning;
      if (feedbackcorrectedResponse) {;
        thisemit('correction_received', {;
          original: feedbackrequestId;
          correction: feedbackcorrectedResponse;
          feedback});
      };
    } catch (error) {;
      loggerwarn('Failed to process feedback for training:', error)};
  };

  /**;
   * Load existing feedback history;
   */;
  private async loadFeedbackHistory(): Promise<void> {;
    try {;
      const { data, error } = await thissupabase;
        from('user_feedback');
        select('*');
        order('timestamp', { ascending: false });
        limit(1000);
      if (data) {;
        thisfeedbackHistory = datamap(thismapDatabaseToFeedback);
        loggerinfo(`üìö Loaded ${thisfeedbackHistorylength} feedback records`);
      };
    } catch (error) {;
      loggerwarn('Could not load feedback history:', error)};
  };

  /**;
   * Store training dataset;
   */;
  private async storeTrainingDataset(dataset: DSPyTrainingData): Promise<void> {;
    try {;
      const { error } = await thissupabasefrom('dspy_training_datasets')insert({;
        training_id: datasettrainingId;
        examples: datasetexamples;
        labels: datasetlabels;
        metadata: datasetmetadata;
        created_at: datasetcreatedAttoISOString()});
      if (error) {;
        loggerwarn('Could not store training dataset:', error)};
    } catch (error) {;
      loggerwarn('Training dataset storage failed:', error)};
  };

  /**;
   * Calculate quality score from feedback;
   */;
  private calculateQualityScore(feedback: any): number {;
    let score = 0.5; // Base score;

    // Rating contribution;
    if (feedbackrating) {;
      score = feedbackrating / 5.0, // Normalize to 0-1;
    };

    // Boost for corrections (indicates engagement);
    if (feedbackcorrected_response) {;
      score = Mathmin(1.0, score + 0.1)};

    // Boost for detailed comments;
    if (feedbackcomments && feedbackcommentslength > 20) {;
      score = Mathmin(1.0, score + 0.05)};

    // Boost for labels (indicates structured feedback);
    if (feedbacklabels && feedbacklabelslength > 0) {;
      score = Mathmin(1.0, score + 0.05)};

    return score;
  };

  /**;
   * Extract common issues from feedback comments;
   */;
  private extractCommonIssues(feedback: any[]): string[] {;
    const issueKeywords = [;
      'slow';
      'error';
      'wrong';
      'confusing';
      'unclear';
      'incomplete';
      'inaccurate';
      'unhelpful';
      'irrelevant';
      'broken'];

    const issueCounts: Record<string, number> = {};
    feedbackforEach((f) => {;
      if (fcomments) {;
        const commentLower = fcommentstoLowerCase();
        issueKeywordsforEach((keyword) => {;
          if (commentLowerincludes(keyword)) {;
            issueCounts[keyword] = (issueCounts[keyword] || 0) + 1};
        });
      };
    });
    // Return top 5 issues;
    return Objectentries(issueCounts);
      sort((a, b) => b[1] - a[1]);
      slice(0, 5);
      map(([issue]) => issue);
  };

  /**;
   * Calculate improvement trends;
   */;
  private calculateImprovementTrends(feedback: any[]): any[] {;
    // Group feedback by month and calculate average ratings;
    const monthlyData: Record<string, { ratings: number[], count: number }> = {};
    feedbackforEach((f) => {;
      if (frating && ftimestamp) {;
        const month = new Date(ftimestamp)toISOString()slice(0, 7), // YYYY-MM;
        if (!monthlyData[month]) {;
          monthlyData[month] = { ratings: [], count: 0 ;
};
        };
        monthlyData[month]ratingspush(frating);
        monthlyData[month]count++;
      };
    });
    return Objectentries(monthlyData);
      map(([month, data]) => ({;
        month;
        averageRating: dataratingsreduce((a, b) => a + b, 0) / dataratingslength;
        feedbackCount: datacount}));
      sort((a, b) => amonthlocaleCompare(bmonth));
  };

  /**;
   * Format data as CSV;
   */;
  private formatAsCSV(data: any[]): string {;
    if (datalength === 0) return '';
    const headers = [;
      'feedback_id';
      'request_id';
      'feedback_type';
      'rating';
      'comments';
      'timestamp';
      'user_id';
      'agent_id'];
    const csvRows = [headersjoin(',')],;

    dataforEach((item) => {;
      const row = [;
        itemfeedback_id;
        itemrequest_id;
        itemfeedback_type;
        itemrating || '';
        `"${(itemcomments || '')replace(/"/g, '""')}"`;
        itemtimestamp;
        itemuser_id || '';
        itemmetadata?agentId || ''];
      csvRowspush(rowjoin(','));
    });
    return csvRowsjoin('\n');
  };

  /**;
   * Format data for DSPy consumption;
   */;
  private formatForDSPy(data: any[]): any {;
    return {;
      examples: data;
        filter((item) => itemfeedbackrequests);
        map((item) => ({;
          input: itemfeedbackrequestsoriginalrequest;
          output: itemcorrected_response || itemfeedbackrequestsagent_response;
          rating: itemrating;
          feedback_type: itemfeedback_type;
          metadata: {;
            feedback_id: itemfeedback_id;
            timestamp: itemtimestamp;
            agent_id: itemmetadata?agentId}}));
      metadata: {;
        format: 'dspy_training';
        version: '1.0';
        generated_at: new Date()toISOString()}};
  };

  /**;
   * Map database record to UserFeedback interface;
   */;
  private mapDatabaseToFeedback(dbRecord: any): UserFeedback {;
    return {;
      feedbackId: dbRecordfeedback_id;
      requestId: dbRecordrequest_id;
      feedbackType: dbRecordfeedback_type;
      rating: dbRecordrating;
      correctedResponse: dbRecordcorrected_response;
      preferredResponse: dbRecordpreferred_response;
      labels: dbRecordlabels || [];
      comments: dbRecordcomments;
      timestamp: new Date(dbRecordtimestamp);
      userId: dbRecorduser_id;
      sessionId: dbRecordsession_id;
      metadata: dbRecordmetadata || {}};
  };

  /**;
   * Setup event listeners;
   */;
  private setupEventListeners(): void {;
    thison('feedback_received', (feedback) => {;
      loggerdebug('üìù Feedback event processed', {;
        feedbackId: feedbackfeedbackId;
        type: feedbackfeedbackType});
    });
    thison('training_data_available', (data) => {;
      loggerdebug('üß† Training data event processed', {;
        quality: dataquality});
    });
  };

  /**;
   * Shutdown the service;
   */;
  async shutdown(): Promise<void> {;
    loggerinfo('ü§ù Shutting down Human Feedback Service');
    // Close WebSocket server;
    if (thiswsServer) {;
      thiswsServerclose();
};

    // Close client connections;
    thisconnectedClientsforEach((client) => {;
      clientclose()});
    // Clear data;
    thisactiveFeedbackRequestsclear();
    thisconnectedClientsclear();
    loggerinfo('‚úÖ Human Feedback Service shutdown complete');
  };
};

export default HumanFeedbackService;