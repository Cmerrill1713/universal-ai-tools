/**;
 * Task-Aware Temperature Controller;
 * Dynamically adjusts temperature based on task type and performance metrics;
 */;

import { logger } from '../utils/logger';
import { SupabaseService } from './supabase_service';
interface TemperatureProfile {;
  taskType: string;
  minTemp: number;
  maxTemp: number;
  defaultTemp: number;
  description: string;
;
};

interface TemperatureAdjustment {;
  factor: string;
  adjustment: number;
  reason: string;
;
};

interface TaskMetrics {;
  taskType: string;
  successCount: number;
  failureCount: number;
  avgQualityScore: number;
  optimalTemp: number;
  lastUpdated: Date;
;
};

interface GenerationParams {;
  temperature: number;
  topP?: number;
  topK?: number;
  repetitionPenalty?: number;
  presencePenalty?: number;
  frequencyPenalty?: number;
;
};

export class TemperatureController {;
  private supabase: SupabaseService;
  // Task-specific temperature profiles;
  private temperatureProfiles: Map<string, TemperatureProfile> = new Map([;
    [;
      'creative_writing';
      {;
        taskType: 'creative_writing';
        minTemp: 0.7;
        maxTemp: 1.0;
        defaultTemp: 0.85;
        description: 'High creativity for storytelling and creative content;
      ;
};
    ];
    [;
      'code_generation';
      {;
        taskType: 'code_generation';
        minTemp: 0.0;
        maxTemp: 0.3;
        defaultTemp: 0.1;
        description: 'Low temperature for precise code generation';
      ;
};
    ];
    [;
      'factual_qa';
      {;
        taskType: 'factual_qa';
        minTemp: 0.0;
        maxTemp: 0.2;
        defaultTemp: 0.1;
        description: 'Very low temperature for accurate factual responses';
      ;
};
    ];
    [;
      'brainstorming';
      {;
        taskType: 'brainstorming';
        minTemp: 0.6;
        maxTemp: 0.9;
        defaultTemp: 0.75;
        description: 'High temperature for diverse idea generation';
      ;
};
    ];
    [;
      '_analysis;
      {;
        taskType: '_analysis;
        minTemp: 0.2;
        maxTemp: 0.4;
        defaultTemp: 0.3;
        description: 'Moderate temperature for balanced _analysis;
      ;
};
    ];
    [;
      'translation';
      {;
        taskType: 'translation';
        minTemp: 0.0;
        maxTemp: 0.2;
        defaultTemp: 0.1;
        description: 'Low temperature for accurate translations';
      ;
};
    ];
    [;
      'summarization';
      {;
        taskType: 'summarization';
        minTemp: 0.1;
        maxTemp: 0.3;
        defaultTemp: 0.2;
        description: 'Low-moderate temperature for concise summaries';
      ;
};
    ];
    [;
      'conversation';
      {;
        taskType: 'conversation';
        minTemp: 0.4;
        maxTemp: 0.7;
        defaultTemp: 0.55;
        description: 'Moderate temperature for natural conversation';
      ;
};
    ];
    [;
      'technical_documentation';
      {;
        taskType: 'technical_documentation';
        minTemp: 0.1;
        maxTemp: 0.3;
        defaultTemp: 0.2;
        description: 'Low temperature for precise technical writing';
      ;
};
    ];
    [;
      'general';
      {;
        taskType: 'general';
        minTemp: 0.3;
        maxTemp: 0.7;
        defaultTemp: 0.5;
        description: 'Balanced temperature for general tasks';
      ;
};
    ];
  ]);
  // Task performance metrics;
  private taskMetrics: Map<string, TaskMetrics> = new Map();
  // A/B testing configurations;
  private abTestConfigs = {;
    enabled: true;
    sampleRate: 0.1, // 10% of requests participate in A/B testing;
    variationRange: 0.1, // Test within ¬±0.1 of optimal temperature;
  };
  constructor() {;
    thissupabase = SupabaseServicegetInstance();
    thisloadTaskMetrics();
    loggerinfo('üå°Ô∏è Task-Aware Temperature Controller initialized');
  };

  /**;
   * Get optimal generation parameters for a task;
   */;
  public async getOptimalParams(;
    taskType: string;
    context?: {;
      complexity?: 'low' | 'medium' | 'high';
      userPreference?: number;
      previousAttempts?: number;
      qualityRequirement?: 'speed' | 'balanced' | 'quality';
    ;
};
  ): Promise<GenerationParams> {;
    // Get base temperature profile;
    const profile = thisgetTemperatureProfile(taskType);
    let temperature = profiledefaultTemp;
    // Apply adjustments based on context;
    const adjustments: TemperatureAdjustment[] = [];
    // Complexity adjustment;
    if (context?complexity) {;
      const complexityAdjustment = thisgetComplexityAdjustment(contextcomplexity, taskType);
      temperature += complexityAdjustmentadjustment;
      adjustmentspush(complexityAdjustment);
    };

    // User preference override;
    if (context?userPreference !== undefined) {;
      const userAdjustment = thisgetUserPreferenceAdjustment(contextuserPreference, profile);
      temperature = userAdjustmentadjustment;
      adjustmentspush({;
        factor: 'user_preference';
        adjustment: userAdjustmentadjustment - profiledefaultTemp;
        reason: 'User-specified temperature preference';
      });
    };

    // Previous attempts adjustment (increase temp for retries);
    if (context?previousAttempts && contextpreviousAttempts > 0) {;
      const retryAdjustment = thisgetRetryAdjustment(contextpreviousAttempts);
      temperature += retryAdjustmentadjustment;
      adjustmentspush(retryAdjustment);
    };

    // Quality vs speed trade-off;
    if (context?qualityRequirement) {;
      const qualityAdjustment = thisgetQualityAdjustment(contextqualityRequirement, taskType);
      temperature += qualityAdjustmentadjustment;
      adjustmentspush(qualityAdjustment);
    };

    // Apply learned optimizations;
    const learnedTemp = await thisgetLearnedTemperature(taskType);
    if (learnedTemp !== null) {;
      const diff = learnedTemp - temperature;
      if (Mathabs(diff) > 0.05) {;
        temperature = temperature + diff * 0.5; // Blend learned and calculated;
        adjustmentspush({;
          factor: 'learned_optimization';
          adjustment: diff * 0.5;
          reason: `Applied learned optimization from ${thistaskMetricsget(taskType)?successCount || 0} successful generations`;
        });
      };
    };

    // Ensure temperature is within bounds;
    temperature = Mathmax(profileminTemp, Mathmin(profilemaxTemp, temperature));
    // A/B testing variation;
    if (thisshouldRunABTest()) {;
      const variation = thisgetABTestVariation(temperature, profile);
      adjustmentspush({;
        factor: 'ab_testing';
        adjustment: variation - temperature;
        reason: 'A/B test variation for optimization';
      });
      temperature = variation;
    };

    // Calculate complementary parameters;
    const params = thiscalculateComplementaryParams(temperature, taskType);
    loggerinfo(;
      `üéØ Temperature optimized for ${taskType}: ${temperaturetoFixed(3)} ` +;
        `(${adjustmentslength} adjustments applied)`;
    );
    return params;
  };

  /**;
   * Get temperature profile for task type;
   */;
  private getTemperatureProfile(taskType: string): TemperatureProfile {;
    // Check for exact match;
    if (thistemperatureProfileshas(taskType)) {;
      return thistemperatureProfilesget(taskType)!;
    };

    // Check for partial match;
    const lowerTaskType = taskTypetoLowerCase();
    for (const [key, profile] of thistemperatureProfilesentries()) {;
      if (lowerTaskTypeincludes(key) || keyincludes(lowerTaskType)) {;
        return profile;
      };
    };

    // Default to general profile;
    return thistemperatureProfilesget('general')!;
  };

  /**;
   * Get complexity-based adjustment;
   */;
  private getComplexityAdjustment(;
    complexity: 'low' | 'medium' | 'high';
    taskType: string;
  ): TemperatureAdjustment {;
    const adjustments = {;
      low: -0.05;
      medium: 0;
      high: 0.05;
    };
    // Inverse for creative tasks (higher complexity needs more creativity);
    if (['creative_writing', 'brainstorming']includes(taskType)) {;
      adjustmentslow = 0.05;
      adjustmentshigh = -0.05;
    };
;
    return {;
      factor: 'complexity';
      adjustment: adjustments[complexity];
      reason: `${complexity} complexity adjustment`;
    };
  };

  /**;
   * Get user preference adjustment;
   */;
  private getUserPreferenceAdjustment(;
    userPreference: number;
    profile: TemperatureProfile;
  ): { adjustment: number } {;
    // Clamp to profile bounds;
    return {;
      adjustment: Mathmax(profileminTemp, Mathmin(profilemaxTemp, userPreference));
    };
  };

  /**;
   * Get retry adjustment (increase temperature for variety);
   */;
  private getRetryAdjustment(attempts: number): TemperatureAdjustment {;
    const adjustment = Mathmin(0.1, attempts * 0.02), // +0.02 per retry, max +0.1;
    return {;
      factor: 'retry';
      adjustment;
      reason: `Retry attempt #${attempts} - increasing variety`;
    };
  };

  /**;
   * Get quality vs speed adjustment;
   */;
  private getQualityAdjustment(;
    requirement: 'speed' | 'balanced' | 'quality';
    taskType: string;
  ): TemperatureAdjustment {;
    const adjustments = {;
      speed: -0.05, // Lower temp for faster, more deterministic output;
      balanced: 0;
      quality: 0.05, // Higher temp for more considered output;
    };
    // Inverse for factual tasks;
    if (['factual_qa', 'code_generation', 'translation']includes(taskType)) {;
      adjustmentsspeed = 0;
      adjustmentsquality = -0.05, // Lower temp for higher quality in factual tasks;
    };
;
    return {;
      factor: 'quality_requirement';
      adjustment: adjustments[requirement];
      reason: `Optimizing for ${requirement}`;
    };
  };

  /**;
   * Get learned temperature from historical performance;
   */;
  private async getLearnedTemperature(taskType: string): Promise<number | null> {;
    const metrics = thistaskMetricsget(taskType);
    if (!metrics || metricssuccessCount < 10) {;
      return null; // Not enough data;
    };

    return metricsoptimalTemp;
  };

  /**;
   * Calculate complementary parameters based on temperature;
   */;
  private calculateComplementaryParams(temperature: number, taskType: string): GenerationParams {;
    const params: GenerationParams = { temperature };
    // Top-p (nucleus sampling) - inverse relationship with temperature;
    paramstopP = 0.95 - temperature * 0.2; // Range: 0.75-0.95;
    // Top-k - task-specific;
    if (['code_generation', 'factual_qa']includes(taskType)) {;
      paramstopK = 10, // Very restrictive for factual tasks;
    } else if (['creative_writing', 'brainstorming']includes(taskType)) {;
      paramstopK = 50, // More options for creative tasks;
    } else {;
      paramstopK = 30; // Balanced;
    };

    // Repetition penalty - higher for creative tasks;
    if (['creative_writing', 'brainstorming']includes(taskType)) {;
      paramsrepetitionPenalty = 1.15;
    } else if (['code_generation']includes(taskType)) {;
      paramsrepetitionPenalty = 1.0, // No penalty for code (may need repetition);
    } else {;
      paramsrepetitionPenalty = 1.1;
    };

    // Presence and frequency penalties;
    if (temperature > 0.7) {;
      paramspresencePenalty = 0.1;
      paramsfrequencyPenalty = 0.1;
    };
;
    return params;
  };

  /**;
   * Should run A/B test for this request;
   */;
  private shouldRunABTest(): boolean {;
    return thisabTestConfigsenabled && Mathrandom() < thisabTestConfigssampleRate;
  };

  /**;
   * Get A/B test temperature variation;
   */;
  private getABTestVariation(baseTemp: number, profile: TemperatureProfile): number {;
    const variation = (Mathrandom() - 0.5) * 2 * thisabTestConfigsvariationRange;
    const testTemp = baseTemp + variation;
    // Keep within profile bounds;
    return Mathmax(profileminTemp, Mathmin(profilemaxTemp, testTemp));
  };

  /**;
   * Record generation result for learning;
   */;
  public async recordResult(;
    taskType: string;
    temperature: number;
    success: boolean;
    qualityScore?: number;
  ): Promise<void> {;
    const profileKey = thisgetTemperatureProfile(taskType)taskType;
    let metrics = thistaskMetricsget(profileKey);
    if (!metrics) {;
      metrics = {;
        taskType: profileKey;
        successCount: 0;
        failureCount: 0;
        avgQualityScore: 0.7;
        optimalTemp: thistemperatureProfilesget(profileKey)!defaultTemp;
        lastUpdated: new Date();
      ;
};
      thistaskMetricsset(profileKey, metrics);
    };

    // Update counts;
    if (success) {;
      metricssuccessCount++;
    } else {;
      metricsfailureCount++;
    };

    // Update quality score with exponential moving average;
    if (qualityScore !== undefined) {;
      const alpha = 0.1; // Learning rate;
      metricsavgQualityScore = alpha * qualityScore + (1 - alpha) * metricsavgQualityScore;
    };

    // Update optimal temperature using gradient descent;
    if (success && qualityScore !== undefined) {;
      const learningRate = 0.01;
      const gradient =;
        (qualityScore - metricsavgQualityScore) * (temperature - metricsoptimalTemp);
      metricsoptimalTemp += learningRate * gradient;
      // Keep within bounds;
      const profile = thistemperatureProfilesget(profileKey)!;
      metricsoptimalTemp = Mathmax(;
        profileminTemp;
        Mathmin(profilemaxTemp, metricsoptimalTemp);
      );
    };

    metricslastUpdated = new Date();
    // Persist metrics;
    await thissaveTaskMetrics();
  };

  /**;
   * Get temperature recommendations for all task types;
   */;
  public getRecommendations(): Array<{;
    taskType: string;
    description: string;
    recommended: number;
    range: { min: number, max: number ;
};
    learned?: number;
    performance?: {;
      successRate: number;
      avgQuality: number;
      totalGenerations: number;
    ;
};
  }> {;
    const recommendations = [];
    for (const [taskType, profile] of thistemperatureProfilesentries()) {;
      const metrics = thistaskMetricsget(taskType);
      const recommendation = {;
        taskType: profiletaskType;
        description: profiledescription;
        recommended: profiledefaultTemp;
        range: { min: profileminTemp, max: profilemaxTemp };
        learned: metrics?optimalTemp;
        performance: undefined as any;
      ;
};
      if (metrics) {;
        const total = metricssuccessCount + metricsfailureCount;
        if (total > 0) {;
          recommendationperformance = {;
            successRate: metricssuccessCount / total;
            avgQuality: metricsavgQualityScore;
            totalGenerations: total;
          ;
};
        };
      };

      recommendationspush(recommendation);
    };
;
    return recommendations;
  };

  /**;
   * Load task metrics from storage;
   */;
  private async loadTaskMetrics(): Promise<void> {;
    try {;
      const { data, error } = await thissupabaseclientfrom('temperature_metrics')select('*');
      if (error instanceof Error ? errormessage : String(error){;
        loggererror('Failed to load temperature metrics:', error instanceof Error ? errormessage : String(error);
        return;
      };

      if (data) {;
        dataforEach((record) => {;
          thistaskMetricsset(recordtask_type, {;
            taskType: recordtask_type;
            successCount: recordsuccess_count;
            failureCount: recordfailure_count;
            avgQualityScore: recordavg_quality_score;
            optimalTemp: recordoptimal_temp;
            lastUpdated: new Date(recordlast_updated);
          });
        });
      };
    } catch (error) {;
      loggererror('Error loading temperature metrics:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Save task metrics to storage;
   */;
  private async saveTaskMetrics(): Promise<void> {;
    try {;
      const records = Arrayfrom(thistaskMetricsentries())map(([_, metrics]) => ({;
        task_type: metricstaskType;
        success_count: metricssuccessCount;
        failure_count: metricsfailureCount;
        avg_quality_score: metricsavgQualityScore;
        optimal_temp: metricsoptimalTemp;
        last_updated: metricslastUpdatedtoISOString();
      }));
      const { error instanceof Error ? errormessage : String(error)  = await thissupabaseclient;
        from('temperature_metrics');
        upsert(records, { onConflict: 'task_type' });
      if (error instanceof Error ? errormessage : String(error){;
        loggererror('Failed to save temperature metrics:', error instanceof Error ? errormessage : String(error)  ;
};
    } catch (error) {;
      loggererror('Error saving temperature metrics:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Singleton instance;
   */;
  private static instance: TemperatureController;
  public static getInstance(): TemperatureController {;
    if (!TemperatureControllerinstance) {;
      TemperatureControllerinstance = new TemperatureController();
    };
    return TemperatureControllerinstance;
  };
};
