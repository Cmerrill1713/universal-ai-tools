/**;
 * Pydantic AI Service - Type-safe AI interactions with structured responses;
 * Provides validation, structured agent responses, and integration with DSPy;
 */;

import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import { LogContext, logger } from '../utils/enhanced-logger';
import {;
  type DSPyOrchestrationRequest;
  type DSPyOrchestrationResponse;
  getDSPyService;
} from './dspy-service';
import type { AgentContext, AgentResponse, BaseAgent } from '../agents/base_agent';
import {;
  ImportanceLevel;
  type MemoryModel;
  MemoryType;
  ModelUtils;
  type SearchOptions;
} from '../models/pydantic_models';
// ============================================;
// PYDANTIC AI MODELS;
// ============================================;

/**;
 * Structured AI Request with validation;
 */;
export const AIRequestSchema = zobject({;
  id: z;
    string();
    uuid();
    default(() => uuidv4());
  prompt: zstring()min(1)max(10000);
  context: z;
    object({;
      userId: zstring()optional();
      sessionId: zstring()optional();
      memoryEnabled: zboolean()default(true);
      temperature: znumber()min(0)max(2)default(0.7);
      maxTokens: znumber()min(1)max(4096)default(2048);
      model: zstring()optional();
      systemPrompt: zstring()optional();
      previousMessages: z;
        array(;
          zobject({;
            role: zenum(['user', 'assistant', 'system']);
            contentzstring();
          });
        );
        optional();
      metadata: zrecord(zany())optional();
    });
    default({});
  validation: z;
    object({;
      outputSchema: zany()optional(), // Zod schema for response validation;
      retryAttempts: znumber()min(0)max(3)default(1);
      strictMode: zboolean()default(false);
    });
    default({});
  orchestration: z;
    object({;
      mode: zenum(['simple', 'standard', 'cognitive', 'adaptive'])default('standard');
      preferredAgents: zarray(zstring())optional();
      excludeAgents: zarray(zstring())optional();
    });
    default({});
});
export type AIRequest = zinfer<typeof AIRequestSchema>;
/**;
 * Structured AI Response with validation;
 */;
export const AIResponseSchema = zobject({;
  id: zstring()uuid();
  requestId: zstring()uuid();
  success: zboolean();
  contentzstring();
  structuredData: zany()optional();
  reasoning: zstring();
  confidence: znumber()min(0)max(1);
  model: zstring();
  usage: z;
    object({;
      promptTokens: znumber();
      completionTokens: znumber();
      totalTokens: znumber();
    });
    optional();
  validation: zobject({;
    passed: zboolean();
    errors: zarray(zstring())optional();
    warnings: zarray(zstring())optional();
  });
  metadata: zobject({;
    latencyMs: znumber();
    agentsInvolved: zarray(zstring());
    memoryAccessed: zboolean();
    cacheHit: zboolean()default(false);
    timestamp: zdate();
  });
  nextActions: zarray(zstring())optional();
  relatedMemories: zarray(zany())optional();
});
export type AIResponse = zinfer<typeof AIResponseSchema>;
/**;
 * Agent-specific structured response schemas;
 */;
export const CognitiveAnalysisSchema = zobject({;
  _analysis zstring();
  keyInsights: zarray(zstring());
  recommendations: zarray(;
    zobject({;
      action: zstring();
      priority: zenum(['high', 'medium', 'low']);
      reasoning: zstring();
    });
  );
  entities: zarray(;
    zobject({;
      name: zstring();
      type: zstring();
      relevance: znumber();
    });
  );
  sentiment: zenum(['positive', 'negative', 'neutral', 'mixed']);
  confidence: znumber();
});
export const TaskPlanSchema = zobject({;
  objective: zstring();
  steps: zarray(;
    zobject({;
      id: znumber();
      description: zstring();
      agent: zstring();
      dependencies: zarray(znumber());
      estimatedDuration: znumber();
      resources: zarray(zstring());
    });
  );
  totalEstimatedTime: znumber();
  requiredAgents: zarray(zstring());
  risks: zarray(;
    zobject({;
      description: zstring();
      likelihood: zenum(['high', 'medium', 'low']);
      mitigation: zstring();
    });
  );
});
export const CodeGenerationSchema = zobject({;
  language: zstring();
  code: zstring();
  explanation: zstring();
  dependencies: zarray(zstring());
  testCases: z;
    array(;
      zobject({;
        name: zstring();
        inputzany();
        expectedOutput: zany();
      });
    );
    optional();
  complexity: z;
    object({;
      timeComplexity: zstring();
      spaceComplexity: zstring();
    });
    optional();
});
// ============================================;
// PYDANTIC AI SERVICE;
// ============================================;

export class PydanticAIService {;
  private dspyService = getDSPyService();
  private responseCache = new Map<string, AIResponse>();
  private validationCache = new Map<string, zZodSchema>();
  constructor() {;
    thissetupBuiltInSchemas();
  };

  /**;
   * Setup built-in validation schemas for common use cases;
   */;
  private setupBuiltInSchemas(): void {;
    thisvalidationCacheset('cognitive__analysis, CognitiveAnalysisSchema);
    thisvalidationCacheset('task_plan', TaskPlanSchema);
    thisvalidationCacheset('code_generation', CodeGenerationSchema);
  };

  /**;
   * Main AI requestmethod with type safety and validation;
   */;
  async requestrequest Partial<AIRequest>): Promise<AIResponse> {;
    const startTime = Datenow();
    try {;
      // Validate and parse request;
      const validatedRequest = AIRequestSchemaparse(request;

      // Check cache if enabled;
      const cacheKey = thisgenerateCacheKey(validatedRequest);
      if (thisresponseCachehas(cacheKey)) {;
        const cached = thisresponseCacheget(cacheKey)!;
        return {;
          ..cached;
          metadata: {;
            ..cachedmetadata;
            cacheHit: true;
            latencyMs: Datenow() - startTime;
          ;
};
        };
      };

      // Prepare DSPy orchestration request;
      const dspyRequest: DSPyOrchestrationRequest = {;
        requestId: validatedRequestid;
        userRequest: thisbuildPromptWithContext(validatedRequest);
        userId: validatedRequestcontextuserId || 'anonymous';
        orchestrationMode: validatedRequestorchestrationmode;
        context: {;
          ..validatedRequestcontext;
          validation: validatedRequestvalidation;
          preferredAgents: validatedRequestorchestrationpreferredAgents;
          excludeAgents: validatedRequestorchestrationexcludeAgents;
        ;
};
        timestamp: new Date();
      ;
};
      // Execute through DSPy orchestration;
      const dspyResponse = await thisdspyServiceorchestrate(dspyRequest);
      // Process and validate response;
      const aiResponse = await thisprocessResponse(validatedRequest, dspyResponse, startTime);
      // Cache successful responses;
      if (aiResponsesuccess && aiResponsevalidationpassed) {;
        thisresponseCacheset(cacheKey, aiResponse);
      };

      return aiResponse;
    } catch (error) {;
      loggererror('PydanticAI requestfailed:', LogContextSYSTEM, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      return thiscreateErrorResponse(requestid || uuidv4(), error instanceof Error ? errormessage : String(error) Datenow() - startTime);
    };
  };

  /**;
   * Request with custom output schema validation;
   */;
  async requestWithSchema<T>(;
    requestPartial<AIRequest>;
    outputSchema: zZodSchema<T>;
  ): Promise<AIResponse & { structuredData: T }> {;
    const enhancedRequest: Partial<AIRequest> = {;
      ..request;
      validation: {;
        ..requestvalidation;
        outputSchema;
      ;
};
    };
    const response = await thisrequestenhancedRequest);
    if (!responsesuccess || !responsestructuredData) {;
      throw new Error('Failed to get structured response');
    };

    return response as AIResponse & { structuredData: T };
  };

  /**;
   * Specialized cognitive _analysisrequest;
   */;
  async analyzeCognitive(;
    contentstring;
    context?: Partial<AIRequest['context']>;
  ): Promise<zinfer<typeof CognitiveAnalysisSchema>> {;
    const response = await thisrequestWithSchema(;
      {;
        prompt: `Perform a comprehensive cognitive _analysisof the following content${content,`;
        context: {;
          ..context;
          systemPrompt:;
            'You are a cognitive _analysisexpert. Provide detailed insights, entities, and recommendations.';
        };
        orchestration: {;
          mode: 'cognitive';
          preferredAgents: ['cognitive_analyzer', 'entity_extractor'];
        };
      };
      CognitiveAnalysisSchema;
    );
    return responsestructuredData;
  };

  /**;
   * Specialized task planning request;
   */;
  async planTask(;
    objective: string;
    constraints?: Record<string, unknown>;
  ): Promise<zinfer<typeof TaskPlanSchema>> {;
    const response = await thisrequestWithSchema(;
      {;
        prompt: `Create a detailed task plan for: ${objective}`;
        context: {;
          systemPrompt:;
            'You are a task planning expert. Break down objectives into actionable steps with clear dependencies.';
          metadata: { constraints ;
};
        };
        orchestration: {;
          mode: 'cognitive';
          preferredAgents: ['planner', 'resource_manager'];
        };
      };
      TaskPlanSchema;
    );
    return responsestructuredData;
  };

  /**;
   * Generate code with validation;
   */;
  async generateCode(;
    specification: string;
    language: string;
    options?: {;
      includeTests?: boolean;
      analyzeComplexity?: boolean;
    ;
};
  ): Promise<zinfer<typeof CodeGenerationSchema>> {;
    const response = await thisrequestWithSchema(;
      {;
        prompt: `Generate ${language} code for: ${specification}`;
        context: {;
          systemPrompt: `You are an expert ${language} developer. Generate clean, efficient, well-documented code.`;
          metadata: options;
        ;
};
        orchestration: {;
          mode: 'standard';
          preferredAgents: ['code_generator', 'code_reviewer'];
        };
      };
      CodeGenerationSchema;
    );
    return responsestructuredData;
  };

  /**;
   * Build prompt with context and system instructions;
   */;
  private buildPromptWithContext(requestAIRequest): string {;
    const parts: string[] = [];
    if (requestcontextsystemPrompt) {;
      partspush(`System: ${requestcontextsystemPrompt}`);
    };

    if (requestcontextpreviousMessages) {;
      requestcontextpreviousMessagesforEach((msg) => {;
        partspush(`${msgrole}: ${msgcontent);`;
      });
    };

    partspush(`User: ${requestprompt}`);
    return partsjoin('\n\n');
  };

  /**;
   * Process DSPy response into structured AI response;
   */;
  private async processResponse(;
    requestAIRequest;
    dspyResponse: DSPyOrchestrationResponse;
    startTime: number;
  ): Promise<AIResponse> {;
    const latencyMs = Datenow() - startTime;
    // Extract structured data if present;
    let structuredData: any = null;
    let validationResult = { passed: true, errors: [], warnings: [] };
    if (dspyResponsesuccess && dspyResponseresult) {;
      // Try to extract structured data;
      structuredData = thisextractStructuredData(dspyResponseresult);
      // Validate if schema provided;
      if (requestvalidationoutputSchema && structuredData) {;
        validationResult = thisvalidateStructuredData(;
          structuredData;
          requestvalidationoutputSchema;
        );
      };
    };

    // Build response;
    const response: AIResponse = {;
      id: uuidv4();
      requestId: requestid;
      success: dspyResponsesuccess && validationResultpassed;
      contentthisextractTextContent(dspyResponseresult);
      structuredData;
      reasoning: dspyResponsereasoning || '';
      confidence: dspyResponseconfidence || 0;
      model: 'dspy-orchestrated';
      usage: {;
        promptTokens: 0, // Would need token counting;
        completionTokens: 0;
        totalTokens: 0;
      ;
};
      validation: validationResult;
      metadata: {;
        latencyMs;
        agentsInvolved: dspyResponseparticipatingAgents || [];
        memoryAccessed: requestcontextmemoryEnabled;
        cacheHit: false;
        timestamp: new Date();
      ;
};
      nextActions: thisextractNextActions(dspyResponse);
      relatedMemories: [];
    ;
};
    // Store in memory if enabled;
    if (requestcontextmemoryEnabled) {;
      await thisstoreInteractionMemory(requestresponse);
    };

    return response;
  };

  /**;
   * Extract structured data from response;
   */;
  private extractStructuredData(result: any): any {;
    if (typeof result === 'object' && result !== null) {;
      // If result already has structured format;
      if (resultdata || resultstructuredData) {;
        return resultdata || resultstructuredData;
      };

      // Try to parse if it's a JSON string;
      if (typeof result === 'string') {;
        try {;
          return JSONparse(result);
        } catch {;
          // Not JSON, return null;
          return null;
        };
      };

      // Return the object itself if it looks structured;
      return result;
    };

    return null;
  };

  /**;
   * Extract text contentfrom response;
   */;
  private extractTextContent(result: any): string {;
    if (typeof result === 'string') {;
      return result;
    };

    if (result?content{;
      return String(resultcontent;
    };

    if (result?text) {;
      return String(resulttext);
    };

    if (result?message) {;
      return String(resultmessage);
    };

    return JSONstringify(result, null, 2);
  };

  /**;
   * Validate structured data against schema;
   */;
  private validateStructuredData(;
    data: any;
    schema: zZodSchema;
  ): { passed: boolean; errors: string[], warnings: string[] } {;
    try {;
      schemaparse(data);
      return { passed: true, errors: [], warnings: [] };
    } catch (error) {;
      if (error instanceof zZodError) {;
        return {;
          passed: false;
          errors: errorerrorsmap((e) => `${epathjoin('.')}: ${emessage}`);
          warnings: [];
        ;
};
      };
      return {;
        passed: false;
        errors: [`Validation failed: ${String(error instanceof Error ? errormessage : String(error)`];
        warnings: [];
      ;
};
    };
  };

  /**;
   * Extract next actions from response;
   */;
  private extractNextActions(response: DSPyOrchestrationResponse): string[] {;
    const actions: string[] = [];
    if (responseresult?nextActions) {;
      actionspush(..responseresultnextActions);
    };

    if (responseresult?recommendations) {;
      actionspush(..responseresultrecommendations);
    };

    return actions;
  };

  /**;
   * Store interaction in memory system;
   */;
  private async storeInteractionMemory(requestAIRequest, response: AIResponse): Promise<void> {;
    try {;
      const memory: Partial<MemoryModel> = {;
        content`Q: ${requestprompt}\nA: ${responsecontent,`;
        serviceId: 'pydantic-ai';
        memoryType: MemoryTypeUSER_INTERACTION;
        importanceScore: responseconfidence;
        keywords: ['ai-interaction', ..responsemetadataagentsInvolved];
        metadata: {;
          requestId: requestid;
          responseId: responseid;
          model: responsemodel;
          validation: responsevalidation;
          structuredData: responsestructuredData;
        ;
};
      };
      // Store through DSPy knowledge management;
      await thisdspyServicemanageKnowledge('store', { memory });
    } catch (error) {;
      loggerwarn('Failed to store interaction memory:', LogContextSYSTEM, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
    };
  };

  /**;
   * Generate cache key for request;
   */;
  private generateCacheKey(requestAIRequest): string {;
    const key = {;
      prompt: requestprompt;
      context: {;
        systemPrompt: requestcontextsystemPrompt;
        temperature: requestcontexttemperature;
        model: requestcontextmodel;
      };
      orchestration: requestorchestration;
    ;
};
    return JSONstringify(key);
  };

  /**;
   * Create errorresponse;
   */;
  private createErrorResponse(requestId: string, error instanceof Error ? errormessage : String(error) unknown, latencyMs: number): AIResponse {;
    return {;
      id: uuidv4();
      requestId;
      success: false;
      content`Request failed: ${error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error)`;
      reasoning: 'An erroroccurred during requestprocessing';
      confidence: 0;
      model: 'error instanceof Error ? errormessage : String(error);
      validation: {;
        passed: false;
        errors: [error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      ;
};
      metadata: {;
        latencyMs;
        agentsInvolved: [];
        memoryAccessed: false;
        cacheHit: false;
        timestamp: new Date();
      ;
};
    };
  };

  /**;
   * Clear response cache;
   */;
  clearCache(): void {;
    thisresponseCacheclear();
    loggerinfo('PydanticAI response cache cleared');
  ;
};

  /**;
   * Get service statistics;
   */;
  getStats(): {;
    cacheSize: number;
    registeredSchemas: string[];
  } {;
    return {;
      cacheSize: thisresponseCachesize;
      registeredSchemas: Arrayfrom(thisvalidationCachekeys());
    ;
};
  };

  /**;
   * Register custom validation schema;
   */;
  registerSchema(name: string, schema: zZodSchema): void {;
    thisvalidationCacheset(name, schema);
    loggerinfo(`Registered validation schema: ${name}`);
  };

  /**;
   * Create agent context from AI request;
   */;
  createAgentContext(requestAIRequest): AgentContext {;
    return {;
      requestId: requestid;
      userId: requestcontextuserId;
      sessionId: requestcontextsessionId;
      userRequest: requestprompt;
      previousContext: requestcontextmetadata;
      timestamp: new Date();
      memoryContext: {;
        enabled: requestcontextmemoryEnabled;
        temperature: requestcontexttemperature;
        model: requestcontextmodel;
      ;
};
      metadata: requestcontextmetadata;
    ;
};
  };

  /**;
   * Convert agent response to AI response;
   */;
  convertAgentResponse(agentResponse: AgentResponse, requestAIRequest): AIResponse {;
    return {;
      id: uuidv4();
      requestId: requestid;
      success: agentResponsesuccess;
      contentagentResponsedata ? String(agentResponsedata) : agentResponsemessage || '';
      structuredData: agentResponsedata;
      reasoning: agentResponsereasoning;
      confidence: agentResponseconfidence;
      model: agentResponseagentId;
      validation: {;
        passed: agentResponsesuccess;
        errors: agentResponseerror instanceof Error ? errormessage : String(error)  [agentResponseerror instanceof Error ? errormessage : String(error): undefined;
      ;
};
      metadata: {;
        latencyMs: agentResponselatencyMs;
        agentsInvolved: [agentResponseagentId];
        memoryAccessed: Boolean(agentResponsememoryUpdates);
        cacheHit: false;
        timestamp: new Date();
      ;
};
      nextActions: agentResponsenextActions;
    ;
};
  };
};

// ============================================;
// SINGLETON INSTANCE;
// ============================================;

let _pydanticAIService: PydanticAIService | null = null;
export function getPydanticAIService(): PydanticAIService {;
  if (!_pydanticAIService) {;
    _pydanticAIService = new PydanticAIService();
  };
  return _pydanticAIService;
};

// Export convenience methods;
export const pydanticAI = {;
  request(requestPartial<AIRequest>) => getPydanticAIService()requestrequest;
  requestWithSchema: <T>(requestPartial<AIRequest>, schema: zZodSchema<T>) =>;
    getPydanticAIService()requestWithSchema(requestschema);
  analyzeCognitive: (contentstring, context?: Partial<AIRequest['context']>) =>;
    getPydanticAIService()analyzeCognitive(contentcontext);
  planTask: (objective: string, constraints?: Record<string, unknown>) =>;
    getPydanticAIService()planTask(objective, constraints);
  generateCode: (spec: string, lang: string, options?: any) =>;
    getPydanticAIService()generateCode(spec, lang, options);
  registerSchema: (name: string, schema: zZodSchema) =>;
    getPydanticAIService()registerSchema(name, schema);
  clearCache: () => getPydanticAIService()clearCache();
  getStats: () => getPydanticAIService()getStats();
;
};