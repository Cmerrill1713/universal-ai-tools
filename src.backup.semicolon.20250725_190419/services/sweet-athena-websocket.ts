/**;
 * Sweet Athena WebSocket Service;
 *;
 * Real-time communication system for Sweet Athena avatar interactions;
 * Handles live personality changes, clothing updates, and avatar state synchronization;
 */;

import WebSocket from 'ws';
import { EventEmitter } from 'events';
import { logger } from '../utils/enhanced-logger';
import { SweetAthenaIntegrationService } from './sweet-athena-integration';
import { supabase } from './supabase_service';
import jwt from 'jsonwebtoken';
import type { PersonalityMode } from './sweet-athena-state-manager';
export interface WSMessage {;
  type: | 'ping';
    | 'pong';
    | 'auth';
    | 'personality_change';
    | 'clothing_update';
    | 'state_change';
    | 'voice_interaction';
    | 'avatar_response';
    | 'error;
    | 'success';
  id?: string;
  data?: any;
  timestamp?: string;
  userId?: string;
;
};

export interface AuthenticatedWebSocket extends WebSocket {;
  userId?: string;
  isAuthenticated?: boolean;
  lastPing?: number;
  sweetAthenaService?: SweetAthenaIntegrationService;
;
};

export interface SweetAthenaWSConfig {;
  port?: number;
  pingInterval?: number;
  maxConnections?: number;
  authTimeout?: number;
  messageRateLimit?: number;
;
};

export class SweetAthenaWebSocketService extends EventEmitter {;
  private wss: WebSocketServer | null = null;
  private clients: Map<string, AuthenticatedWebSocket> = new Map();
  private userConnections: Map<string, Set<AuthenticatedWebSocket>> = new Map();
  private config: Required<SweetAthenaWSConfig>;
  private pingInterval: NodeJSTimeout | null = null;
  private isRunning = false;
  // Rate limiting;
  private messageCounts: Map<string, { count: number, resetTime: number }> = new Map();
  constructor(config: SweetAthenaWSConfig = {}) {;
    super();
    thisconfig = {;
      port: configport || 8080;
      pingInterval: configpingInterval || 30000, // 30 seconds;
      maxConnections: configmaxConnections || 1000;
      authTimeout: configauthTimeout || 10000, // 10 seconds;
      messageRateLimit: configmessageRateLimit || 60, // messages per minute;
    };
  };

  /**;
   * Start the WebSocket server;
   */;
  async start(server?: any): Promise<void> {;
    try {;
      loggerinfo('Starting Sweet Athena WebSocket service...', undefined, {;
        port: thisconfigport;
        maxConnections: thisconfigmaxConnections;
      });
      // Create WebSocket server;
      thiswss = server;
        ? new WebSocketServer({ server, path: '/api/sweet-athena/ws' });
        : new WebSocketServer({ port: thisconfigport });
      // Setup connection handler;
      thiswsson('connection', thishandleConnectionbind(this));
      // Setup ping interval;
      thisstartPingInterval();
      thisisRunning = true;
      thisemit('started');
      loggerinfo('Sweet Athena WebSocket service started successfully');
    } catch (error) {;
      loggererror('Failed to start Sweet Athena WebSocket service:', undefined, error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Stop the WebSocket server;
   */;
  async stop(): Promise<void> {;
    try {;
      loggerinfo('Stopping Sweet Athena WebSocket service...');
      thisisRunning = false;
      // Stop ping interval;
      if (thispingInterval) {;
        clearInterval(thispingInterval);
        thispingInterval = null;
      };

      // Close all client connections;
      for (const [clientId, ws] of thisclients) {;
        thiscloseConnection(ws, 1001, 'Server shutting down');
      };

      // Close server;
      if (thiswss) {;
        await new Promise<void>((resolve) => {;
          thiswss!close(() => {;
            resolve();
          });
        });
        thiswss = null;
      };

      thisemit('stopped');
      loggerinfo('Sweet Athena WebSocket service stopped');
    } catch (error) {;
      loggererror('Error stopping Sweet Athena WebSocket service:', undefined, error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Handle new WebSocket connection;
   */;
  private async handleConnection(ws: AuthenticatedWebSocket, req: any): Promise<void> {;
    const clientId = thisgenerateClientId();
    const { remoteAddress } = reqsocket;
    loggerinfo('New WebSocket connection', undefined, { clientId, remoteAddress });
    // Check connection limit;
    if (thisclientssize >= thisconfigmaxConnections) {;
      thiscloseConnection(ws, 1013, 'Server at capacity');
      return;
    };

    // Setup client;
    wsuserId = undefined;
    wsisAuthenticated = false;
    wslastPing = Datenow();
    thisclientsset(clientId, ws);
    // Setup message handler;
    wson('message', (data) => thishandleMessage(ws, clientId, data));
    // Setup close handler;
    wson('close', (code, reason) => thishandleClose(ws, clientId, code, reason));
    // Setup errorhandler;
    wson('error instanceof Error ? errormessage : String(error)  (error instanceof Error ? errormessage : String(error)=> thishandleError(ws, clientId, error instanceof Error ? errormessage : String(error);
    // Setup authentication timeout;
    const authTimeout = setTimeout(() => {;
      if (!wsisAuthenticated) {;
        thiscloseConnection(ws, 1008, 'Authentication timeout');
      };
    }, thisconfigauthTimeout);
    // Clear timeout when authenticated;
    wson('authenticated', () => {;
      clearTimeout(authTimeout);
    });
    // Send welcome message;
    thissendMessage(ws, {;
      type: 'success';
      data: {;
        message: 'Connected to Sweet Athena WebSocket';
        clientId;
        authRequired: true;
        authTimeout: thisconfigauthTimeout;
      ;
};
    });
  };

  /**;
   * Handle incoming WebSocket message;
   */;
  private async handleMessage(;
    ws: AuthenticatedWebSocket;
    clientId: string;
    data: WebSocketRawData;
  ): Promise<void> {;
    try {;
      // Check rate limiting;
      if (!thischeckRateLimit(wsuserId || clientId)) {;
        thissendError(ws, 'Rate limit exceeded');
        return;
      };

      // Parse message;
      const message: WSMessage = JSONparse(datatoString());
      loggerdebug('WebSocket message received', undefined, {;
        clientId;
        userId: wsuserId;
        messageType: messagetype;
      });
      // Handle authentication first;
      if (!wsisAuthenticated && messagetype !== 'auth') {;
        thissendError(ws, 'Authentication required');
        return;
      };

      // Route message based on type;
      switch (messagetype) {;
        case 'auth':;
          await thishandleAuth(ws, clientId, message);
          break;
        case 'ping':;
          await thishandlePing(ws, message);
          break;
        case 'personality_change':;
          await thishandlePersonalityChange(ws, message);
          break;
        case 'clothing_update':;
          await thishandleClothingUpdate(ws, message);
          break;
        case 'state_change':;
          await thishandleStateChange(ws, message);
          break;
        case 'voice_interaction':;
          await thishandleVoiceInteraction(ws, message);
          break;
        default:;
          thissendError(ws, `Unknown message type: ${messagetype}`);
      };
    } catch (error) {;
      loggererror('Error handling WebSocket message:', undefined, { error instanceof Error ? errormessage : String(error) clientId });
      thissendError(ws, 'Invalid message format');
    };
  };

  /**;
   * Handle authentication;
   */;
  private async handleAuth(;
    ws: AuthenticatedWebSocket;
    clientId: string;
    message: WSMessage;
  ): Promise<void> {;
    try {;
      const { token } = messagedata || {};
      if (!token) {;
        thissendError(ws, 'Authentication token required');
        return;
      };

      // Verify JWT token;
      const decoded = jwtverify(token, processenvJWT_SECRET!) as any;
      const userId = decodedsub || decodeduser_id;
      if (!userId) {;
        thissendError(ws, 'Invalid token: missing user ID');
        return;
      };

      // Verify user exists in database;
      const { data: user, error instanceof Error ? errormessage : String(error)  = await supabase;
        from('users');
        select('id');
        eq('id', userId);
        single();
      if (error instanceof Error ? errormessage : String(error) | !user) {;
        thissendError(ws, 'Invalid user');
        return;
      };

      // Setup user connection;
      wsuserId = userId;
      wsisAuthenticated = true;
      // Initialize Sweet Athena service for user;
      try {;
        wssweetAthenaService = new SweetAthenaIntegrationService(supabase);
        await wssweetAthenaServiceinitialize(userId);
        // Setup service event handlers;
        thissetupServiceEventHandlers(ws);
      } catch (serviceError) {;
        loggererror('Failed to initialize Sweet Athena service:', undefined, serviceError);
        wssweetAthenaService = undefined;
      };

      // Track user connections;
      if (!thisuserConnectionshas(userId)) {;
        thisuserConnectionsset(userId, new Set());
      };
      thisuserConnectionsget(userId)!add(ws);
      wsemit('authenticated');
      // Send authentication success;
      thissendMessage(ws, {;
        type: 'success';
        data: {;
          message: 'Authentication successful';
          userId;
          sweetAthenaEnabled: !!wssweetAthenaService;
          currentState: wssweetAthenaService?getCurrentState();
        ;
};
      });
      loggerinfo('WebSocket client authenticated', undefined, { clientId, userId });
    } catch (error) {;
      loggererror('Authentication error instanceof Error ? errormessage : String(error) , undefined, error instanceof Error ? errormessage : String(error);
      thissendError(ws, 'Authentication failed');
    };
  };

  /**;
   * Setup Sweet Athena service event handlers;
   */;
  private setupServiceEventHandlers(ws: AuthenticatedWebSocket): void {;
    if (!wssweetAthenaService) return;
    wssweetAthenaServiceon('personalityChanged', (data) => {;
      thissendMessage(ws, {;
        type: 'personality_change';
        data: {;
          personality: datato;
          previousPersonality: datafrom;
          timestamp: new Date()toISOString();
        ;
};
      });
    });
    wssweetAthenaServiceon('clothingChanged', (data) => {;
      thissendMessage(ws, {;
        type: 'clothing_update';
        data: {;
          level: datato;
          previousLevel: datafrom;
          timestamp: new Date()toISOString();
        ;
};
      });
    });
    wssweetAthenaServiceon('avatarStateChanged', (state) => {;
      thissendMessage(ws, {;
        type: 'state_change';
        data: {;
          state;
          timestamp: new Date()toISOString();
        ;
};
      });
    });
    wssweetAthenaServiceon('avatarConnected', () => {;
      thissendMessage(ws, {;
        type: 'avatar_response';
        data: {;
          event: 'connected';
          message: 'Sweet Athena avatar connected';
          timestamp: new Date()toISOString();
        ;
};
      });
    });
    wssweetAthenaServiceon('avatarDisconnected', () => {;
      thissendMessage(ws, {;
        type: 'avatar_response';
        data: {;
          event: 'disconnected';
          message: 'Sweet Athena avatar disconnected';
          timestamp: new Date()toISOString();
        ;
};
      });
    });
  };

  /**;
   * Handle ping message;
   */;
  private async handlePing(ws: AuthenticatedWebSocket, message: WSMessage): Promise<void> {;
    wslastPing = Datenow();
    thissendMessage(ws, {;
      type: 'pong';
      id: messageid;
      data: { timestamp: new Date()toISOString() ;
};
    });
  };

  /**;
   * Handle personality change request;
   */;
  private async handlePersonalityChange(;
    ws: AuthenticatedWebSocket;
    message: WSMessage;
  ): Promise<void> {;
    try {;
      const { personality } = messagedata || {};
      if (;
        !personality || !['sweet', 'shy', 'confident', 'caring', 'playful']includes(personality);
      ) {;
        thissendError(ws, 'Invalid personality mode');
        return;
      };

      if (!wssweetAthenaService) {;
        thissendError(ws, 'Sweet Athena service not available');
        return;
      };

      await wssweetAthenaServicesetPersonality(personality as PersonalityMode);
      thissendMessage(ws, {;
        type: 'success';
        id: messageid;
        data: {;
          message: `Personality changed to ${personality}`;
          personality;
          timestamp: new Date()toISOString();
        ;
};
      });
      // Broadcast to other connections for this user;
      thisbroadcastToUser(;
        wsuserId!;
        {;
          type: 'personality_change';
          data: {;
            personality;
            source: 'websocket';
            timestamp: new Date()toISOString();
          ;
};
        };
        ws;
      );
    } catch (error) {;
      loggererror('Personality change error instanceof Error ? errormessage : String(error) , undefined, error instanceof Error ? errormessage : String(error);
      thissendError(ws, 'Failed to change personality', messageid);
    };
  };

  /**;
   * Handle clothing update request;
   */;
  private async handleClothingUpdate(;
    ws: AuthenticatedWebSocket;
    message: WSMessage;
  ): Promise<void> {;
    try {;
      const { level } = messagedata || {};
      if (!level || !['conservative', 'moderate', 'revealing', 'very_revealing']includes(level)) {;
        thissendError(ws, 'Invalid clothing level');
        return;
      };

      if (!wssweetAthenaService) {;
        thissendError(ws, 'Sweet Athena service not available');
        return;
      };

      await wssweetAthenaServicesetClothingLevel(level);
      thissendMessage(ws, {;
        type: 'success';
        id: messageid;
        data: {;
          message: `Clothing level changed to ${level}`;
          level;
          timestamp: new Date()toISOString();
        ;
};
      });
      // Broadcast to other connections for this user;
      thisbroadcastToUser(;
        wsuserId!;
        {;
          type: 'clothing_update';
          data: {;
            level;
            source: 'websocket';
            timestamp: new Date()toISOString();
          ;
};
        };
        ws;
      );
    } catch (error) {;
      loggererror('Clothing update error instanceof Error ? errormessage : String(error) , undefined, error instanceof Error ? errormessage : String(error);
      thissendError(ws, 'Failed to update clothing', messageid);
    };
  };

  /**;
   * Handle state change request;
   */;
  private async handleStateChange(ws: AuthenticatedWebSocket, message: WSMessage): Promise<void> {;
    try {;
      const { interaction, status } = messagedata || {};
      if (!wssweetAthenaService) {;
        thissendError(ws, 'Sweet Athena service not available');
        return;
      };

      // Update interaction mode;
      if (interaction?mode) {;
        await wssweetAthenaServicesetInteractionMode(interactionmode, interactioncontext || '');
      };

      // Update user engagement;
      if (interaction?userEngagement !== undefined) {;
        wssweetAthenaServiceupdateUserEngagement(interactionuserEngagement);
      };

      const currentState = wssweetAthenaServicegetCurrentState();
      thissendMessage(ws, {;
        type: 'success';
        id: messageid;
        data: {;
          message: 'State updated successfully';
          state: currentState;
          timestamp: new Date()toISOString();
        ;
};
      });
    } catch (error) {;
      loggererror('State change error instanceof Error ? errormessage : String(error) , undefined, error instanceof Error ? errormessage : String(error);
      thissendError(ws, 'Failed to update state', messageid);
    };
  };

  /**;
   * Handle voice interaction;
   */;
  private async handleVoiceInteraction(;
    ws: AuthenticatedWebSocket;
    message: WSMessage;
  ): Promise<void> {;
    try {;
      const { text, audioData, expectResponse } = messagedata || {};
      if (!text && !audioData) {;
        thissendError(ws, 'Text or audio data required for voice interaction');
        return;
      };

      if (!wssweetAthenaService) {;
        thissendError(ws, 'Sweet Athena service not available');
        return;
      };

      // For now, we'll handle text input;
      // Audio processing would require additional infrastructure;
      if (text) {;
        // This would integrate with the Sweet Athena voice system;
        const response = {;
          type: 'avatar_response';
          id: messageid;
          data: {;
            text;
            audioUrl: expectResponse ? `/api/sweet-athena/audio/response/${Datenow()}` : undefined;
            personality: wssweetAthenaServicegetCurrentState()personalitymode;
            timestamp: new Date()toISOString();
          ;
};
        };
        thissendMessage(ws, response);
      };
    } catch (error) {;
      loggererror('Voice interaction error instanceof Error ? errormessage : String(error) , undefined, error instanceof Error ? errormessage : String(error);
      thissendError(ws, 'Failed to process voice interaction', messageid);
    };
  };

  /**;
   * Handle connection close;
   */;
  private handleClose(;
    ws: AuthenticatedWebSocket;
    clientId: string;
    code: number;
    reason: Buffer;
  ): void {;
    loggerinfo('WebSocket connection closed', undefined, {;
      clientId;
      userId: wsuserId;
      code;
      reason: reasontoString();
    });
    thiscleanup(ws, clientId);
  };

  /**;
   * Handle connection error;
   */;
  private handleError(ws: AuthenticatedWebSocket, clientId: string, error instanceof Error ? errormessage : String(error) Error): void {;
    loggererror('WebSocket connection error instanceof Error ? errormessage : String(error) , undefined, { error instanceof Error ? errormessage : String(error)clientId, userId: wsuserId });
    thiscleanup(ws, clientId);
  };

  /**;
   * Cleanup connection resources;
   */;
  private cleanup(ws: AuthenticatedWebSocket, clientId: string): void {;
    // Remove from clients map;
    thisclientsdelete(clientId);
    // Remove from user connections;
    if (wsuserId && thisuserConnectionshas(wsuserId)) {;
      const userConnections = thisuserConnectionsget(wsuserId)!;
      userConnectionsdelete(ws);
      if (userConnectionssize === 0) {;
        thisuserConnectionsdelete(wsuserId);
      };
    };

    // Cleanup Sweet Athena service;
    if (wssweetAthenaService) {;
      wssweetAthenaServicedestroy();
    };
  };

  /**;
   * Send message to WebSocket;
   */;
  private sendMessage(ws: AuthenticatedWebSocket, message: WSMessage): void {;
    if (wsreadyState === WebSocketOPEN) {;
      messagetimestamp = messagetimestamp || new Date()toISOString();
      wssend(JSONstringify(message));
    ;
};
  };

  /**;
   * Send errormessage;
   */;
  private sendError(ws: AuthenticatedWebSocket, errorMessage: string, messageId?: string): void {;
    thissendMessage(ws, {;
      type: 'error instanceof Error ? errormessage : String(error);
      id: messageId;
      data: {;
        error instanceof Error ? errormessage : String(error) errorMessage;
        timestamp: new Date()toISOString();
      ;
};
    });
  };

  /**;
   * Broadcast message to all connections for a user;
   */;
  private broadcastToUser(;
    userId: string;
    message: WSMessage;
    excludeWs?: AuthenticatedWebSocket;
  ): void {;
    const userConnections = thisuserConnectionsget(userId);
    if (!userConnections) return;
    for (const ws of userConnections) {;
      if (ws !== excludeWs && wsreadyState === WebSocketOPEN) {;
        thissendMessage(ws, message);
      };
    };
  };

  /**;
   * Broadcast message to all authenticated connections;
   */;
  public broadcast(message: WSMessage): void {;
    for (const [clientId, ws] of thisclients) {;
      if (wsisAuthenticated && wsreadyState === WebSocketOPEN) {;
        thissendMessage(ws, message);
      };
    };
  };

  /**;
   * Close connection with code and reason;
   */;
  private closeConnection(ws: AuthenticatedWebSocket, code: number, reason: string): void {;
    if (wsreadyState === WebSocketOPEN || wsreadyState === WebSocketCONNECTING) {;
      wsclose(code, reason);
    };
  };

  /**;
   * Generate unique client ID;
   */;
  private generateClientId(): string {;
    return `client_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
  };

  /**;
   * Check rate limiting;
   */;
  private checkRateLimit(identifier: string): boolean {;
    const now = Datenow();
    const windowStart = now - 60000; // 1 minute window;

    const current = thismessageCountsget(identifier);
    if (!current || currentresetTime < windowStart) {;
      thismessageCountsset(identifier, { count: 1, resetTime: now });
      return true;
    };

    if (currentcount >= thisconfigmessageRateLimit) {;
      return false;
    };

    currentcount++;
    return true;
  };

  /**;
   * Start ping interval to keep connections alive;
   */;
  private startPingInterval(): void {;
    thispingInterval = setInterval(() => {;
      const now = Datenow();
      const staleThreshold = now - thisconfigpingInterval * 2;
      for (const [clientId, ws] of thisclients) {;
        if (wslastPing && wslastPing < staleThreshold) {;
          loggerwarn('Closing stale WebSocket connection', undefined, {;
            clientId;
            userId: wsuserId;
          });
          thiscloseConnection(ws, 1001, 'Connection stale');
        } else if (wsreadyState === WebSocketOPEN) {;
          thissendMessage(ws, { type: 'ping' });
        };
      };
    }, thisconfigpingInterval);
  };

  /**;
   * Get connection statistics;
   */;
  public getStats(): any {;
    return {;
      totalConnections: thisclientssize;
      authenticatedConnections: Arrayfrom(thisclientsvalues())filter((ws) => wsisAuthenticated);
        length;
      uniqueUsers: thisuserConnectionssize;
      isRunning: thisisRunning;
      uptime: thisisRunning ? Datenow() : 0;
    ;
};
  };
};

export default SweetAthenaWebSocketService;