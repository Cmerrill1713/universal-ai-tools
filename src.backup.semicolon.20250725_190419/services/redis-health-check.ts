/**;
 * Redis Health Check Service;
 * Provides comprehensive health monitoring for Redis infrastructure;
 */;

import { getRedisService } from './redis-service';
import { LogContext, logger } from '../utils/enhanced-logger';
import { performance } from 'perf_hooks';
export interface RedisHealthStatus {;
  status: 'healthy' | 'degraded' | 'unhealthy';
  connected: boolean;
  latency: number;
  memoryUsage: string;
  connectedClients: number;
  uptime: number;
  fallbackCacheActive: boolean;
  fallbackCacheStats?: {;
    size: number;
    itemCount: number;
  ;
};
  lastCheck: Date;
  details: {;
    connectionPool: {;
      size: number;
      active: boolean;
    ;
};
    readReplicas: {;
      count: number;
      healthy: number;
    ;
};
    clusterMode: boolean;
    errors: string[];
    warnings: string[];
  ;
};
};

export class RedisHealthCheckService {;
  private static instance: RedisHealthCheckService;
  private lastHealthCheck: RedisHealthStatus | null = null;
  private healthCheckInterval: NodeJSTimeout | null = null;
  private readonly checkIntervalMs = 30000; // 30 seconds;
  private constructor() {};

  static getInstance(): RedisHealthCheckService {;
    if (!RedisHealthCheckServiceinstance) {;
      RedisHealthCheckServiceinstance = new RedisHealthCheckService();
    };
    return RedisHealthCheckServiceinstance;
  };

  /**;
   * Start periodic health checks;
   */;
  startPeriodicHealthChecks(): void {;
    if (thishealthCheckInterval) {;
      return; // Already running;
    };

    // Perform initial health check;
    thisperformHealthCheck()catch((error instanceof Error ? errormessage : String(error)=> {;
      loggererror('Initial Redis health check failed', LogContextCACHE, { error instanceof Error ? errormessage : String(error));
    });
    // Set up periodic checks;
    thishealthCheckInterval = setInterval(() => {;
      thisperformHealthCheck()catch((error instanceof Error ? errormessage : String(error)=> {;
        loggererror('Periodic Redis health check failed', LogContextCACHE, { error instanceof Error ? errormessage : String(error));
      });
    }, thischeckIntervalMs);
    loggerinfo('Started Redis periodic health checks', LogContextCACHE, {;
      interval: thischeckIntervalMs;
    });
  };

  /**;
   * Stop periodic health checks;
   */;
  stopPeriodicHealthChecks(): void {;
    if (thishealthCheckInterval) {;
      clearInterval(thishealthCheckInterval);
      thishealthCheckInterval = null;
      loggerinfo('Stopped Redis periodic health checks', LogContextCACHE);
    };
  };

  /**;
   * Perform a comprehensive health check;
   */;
  async performHealthCheck(): Promise<RedisHealthStatus> {;
    const startTime = performancenow();
    const errors: string[] = [];
    const warnings: string[] = [];
    try {;
      const redisService = getRedisService();
      const basicHealth = await redisServicehealthCheck();
      const stats = await redisServicegetStats();
      const fallbackStats = redisServicegetFallbackCacheStats();
      // Determine overall status;
      let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
      if (!basicHealthhealthy) {;
        status = 'unhealthy';
        errorspush(basicHealtherror instanceof Error ? errormessage : String(error) | 'Redis connection failed');
      } else if (basicHealthlatency && basicHealthlatency > 100) {;
        status = 'degraded';
        warningspush(`High latency detected: ${basicHealthlatency}ms`);
      };

      // Check memory usage;
      if (statsmemoryUsage) {;
        const memoryValue = parseFloat(statsmemoryUsage);
        const memoryUnit = statsmemoryUsagereplace(/[0-9.]/g, '');
        if (memoryUnit === 'G' && memoryValue > 1.5) {;
          warningspush(`High memory usage: ${statsmemoryUsage}`);
          if (status === 'healthy') status = 'degraded';
        };
      };

      // Check fallback cache;
      const fallbackCacheActive = fallbackStatsitemCount > 0 && !statsconnected;
      if (fallbackCacheActive) {;
        warningspush('Fallback cache is active - Redis may be down');
        status = 'degraded';
      };

      const healthStatus: RedisHealthStatus = {;
        status;
        connected: statsconnected;
        latency: basicHealthlatency || -1;
        memoryUsage: statsmemoryUsage || 'unknown';
        connectedClients: statsconnectedClients || 0;
        uptime: statsuptime || 0;
        fallbackCacheActive;
        fallbackCacheStats: fallbackStats;
        lastCheck: new Date();
        details: {;
          connectionPool: {;
            size: parseInt(processenvREDIS_POOL_SIZE || '5', 10);
            active: statsconnected;
          ;
};
          readReplicas: {;
            count: 0, // Will be updated when read replicas are configured;
            healthy: 0;
          ;
};
          clusterMode: processenvREDIS_CLUSTER_MODE === 'true';
          errors;
          warnings;
        ;
};
      };
      // Cache the health status;
      thislastHealthCheck = healthStatus;
      // Log health status;
      const duration = performancenow() - startTime;
      loggerinfo('Redis health check completed', LogContextCACHE, {;
        status: healthStatusstatus;
        duration: `${durationtoFixed(2)}ms`;
        connected: healthStatusconnected;
        latency: healthStatuslatency;
      });
      return healthStatus;
    } catch (error) {;
      const errorMessage = error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      errorspush(errorMessage);
      const healthStatus: RedisHealthStatus = {;
        status: 'unhealthy';
        connected: false;
        latency: -1;
        memoryUsage: 'unknown';
        connectedClients: 0;
        uptime: 0;
        fallbackCacheActive: true;
        lastCheck: new Date();
        details: {;
          connectionPool: {;
            size: parseInt(processenvREDIS_POOL_SIZE || '5', 10);
            active: false;
          ;
};
          readReplicas: {;
            count: 0;
            healthy: 0;
          ;
};
          clusterMode: false;
          errors;
          warnings;
        ;
};
      };
      thislastHealthCheck = healthStatus;
      return healthStatus;
    };
  };

  /**;
   * Get the last health check result;
   */;
  getLastHealthCheck(): RedisHealthStatus | null {;
    return thislastHealthCheck;
  };

  /**;
   * Get health status summary for monitoring;
   */;
  getHealthSummary(): {;
    status: string;
    message: string;
    metrics: Record<string, unknown>;
  } {;
    const health = thislastHealthCheck;
    if (!health) {;
      return {;
        status: 'unknown';
        message: 'No health check performed yet';
        metrics: {;
};
      };
    };

    let message = 'Redis is operating normally';
    if (healthstatus === 'degraded') {;
      message = 'Redis is experiencing issues';
    } else if (healthstatus === 'unhealthy') {;
      message = 'Redis is unavailable';
    };

    return {;
      status: healthstatus;
      message;
      metrics: {;
        connected: healthconnected;
        latency_ms: healthlatency;
        memory_usage: healthmemoryUsage;
        connected_clients: healthconnectedClients;
        uptime_seconds: healthuptime;
        fallback_cache_active: healthfallbackCacheActive;
        fallback_cache_items: healthfallbackCacheStats?itemCount || 0;
        errors_count: healthdetailserrorslength;
        warnings_count: healthdetailswarningslength;
        last_check: healthlastChecktoISOString();
      ;
};
    };
  };

  /**;
   * Test Redis operations;
   */;
  async testRedisOperations(): Promise<{;
    passed: boolean;
    results: Array<{;
      operation: string;
      success: boolean;
      duration: number;
      error instanceof Error ? errormessage : String(error)  string;
    }>;
  }> {;
    const results: Array<{;
      operation: string;
      success: boolean;
      duration: number;
      error instanceof Error ? errormessage : String(error)  string;
    }> = [];
    const redisService = getRedisService();
    const testKey = `health:test:${Datenow()}`;
    const testValue = JSONstringify({;
      test: true;
      timestamp: new Date()toISOString();
    });
    // Test SET operation;
    const setStart = performancenow();
    try {;
      await redisServiceset(testKey, testValue, 60);
      resultspush({;
        operation: 'SET';
        success: true;
        duration: performancenow() - setStart;
      });
    } catch (error) {;
      resultspush({;
        operation: 'SET';
        success: false;
        duration: performancenow() - setStart;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
    };

    // Test GET operation;
    const getStart = performancenow();
    try {;
      const retrieved = await redisServiceget(testKey);
      const success = retrieved === testValue;
      resultspush({;
        operation: 'GET';
        success;
        duration: performancenow() - getStart;
        error instanceof Error ? errormessage : String(error) success ? undefined : 'Value mismatch';
      });
    } catch (error) {;
      resultspush({;
        operation: 'GET';
        success: false;
        duration: performancenow() - getStart;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
    };

    // Test EXISTS operation;
    const existsStart = performancenow();
    try {;
      const exists = await redisServiceexists(testKey);
      resultspush({;
        operation: 'EXISTS';
        success: exists === 1;
        duration: performancenow() - existsStart;
      });
    } catch (error) {;
      resultspush({;
        operation: 'EXISTS';
        success: false;
        duration: performancenow() - existsStart;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
    };

    // Test DEL operation;
    const delStart = performancenow();
    try {;
      await redisServicedel(testKey);
      resultspush({;
        operation: 'DEL';
        success: true;
        duration: performancenow() - delStart;
      });
    } catch (error) {;
      resultspush({;
        operation: 'DEL';
        success: false;
        duration: performancenow() - delStart;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
    };

    const passed = resultsevery((r) => rsuccess);
    loggerinfo('Redis operations test completed', LogContextCACHE, {;
      passed;
      totalOperations: resultslength;
      successfulOperations: resultsfilter((r) => rsuccess)length;
    });
    return { passed, results };
  };
};

// Export singleton instance;
export const redisHealthCheck = RedisHealthCheckServicegetInstance();