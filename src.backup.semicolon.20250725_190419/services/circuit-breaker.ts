import OpossumCircuitBreaker from 'opossum';
import { LogContext, logger } from '../utils/enhanced-logger';
import { EventEmitter } from 'events';
import type { AxiosRequestConfig } from 'axios';
import axios from 'axios';
interface CircuitBreakerOptions {;
  timeout: number;
  errorThresholdPercentage: number;
  resetTimeout: number;
  rollingCountTimeout: number;
  rollingCountBuckets: number;
  name: string;
  fallback?: (..args: any[]) => any;
;
};

interface CircuitBreakerMetrics {;
  name: string;
  state: string;
  requests: number;
  failures: number;
  successes: number;
  rejects: number;
  timeouts: number;
  fallbacks: number;
  latencyMean: number;
  latencyPercentiles: Record<string, number>;
};

export class CircuitBreakerService extends EventEmitter {;
  private breakers: Map<string, OpossumCircuitBreaker<any, any>> = new Map();
  private metrics: Map<string, CircuitBreakerMetrics> = new Map();
  constructor() {;
    super();
  };

  /**;
   * Create or get a circuit breaker for a specific service;
   */;
  getBreaker(;
    name: string;
    options?: Partial<CircuitBreakerOptions>;
  ): OpossumCircuitBreaker<any, any> {;
    if (thisbreakershas(name)) {;
      return thisbreakersget(name)!;
    };

    const defaultOptions = {;
      timeout: 10000, // 10 seconds;
      errorThresholdPercentage: 50, // Open circuit if 50% of requests fail;
      resetTimeout: 30000, // Try again after 30 seconds;
      rollingCountTimeout: 10000, // Count errors over 10 seconds;
      rollingCountBuckets: 10, // 10 buckets of 1 second each;
      name;
      ..options;
    };
    // Create the circuit breaker with a generic function;
    const breaker = new OpossumCircuitBreaker(async (fn: Function, ..args: any[]) => {;
      return await fn(..args);
    }, defaultOptions);
    // Set up event listeners;
    thissetupEventListeners(breaker, name);
    // Initialize metrics;
    thismetricsset(name, {;
      name;
      state: 'closed';
      requests: 0;
      failures: 0;
      successes: 0;
      rejects: 0;
      timeouts: 0;
      fallbacks: 0;
      latencyMean: 0;
      latencyPercentiles: {;
};
    });
    thisbreakersset(name, breaker);
    return breaker;
  };

  /**;
   * Set up event listeners for circuit breaker;
   */;
  private setupEventListeners(breaker: OpossumCircuitBreaker<any, any>, name: string): void {;
    breakeron('success', (result) => {;
      const metrics = thismetricsget(name)!;
      metricssuccesses++;
      metricsrequests++;
      loggerdebug(`Circuit breaker ${name}: Success`, LogContextSYSTEM);
    });
    breakeron('failure', (error) => {;
      const metrics = thismetricsget(name)!;
      metricsfailures++;
      metricsrequests++;
      loggerwarn(`Circuit breaker ${name}: Failure`, LogContextSYSTEM, { error instanceof Error ? errormessage : String(error) errormessage });
    });
    breakeron('timeout', () => {;
      const metrics = thismetricsget(name)!;
      metricstimeouts++;
      metricsrequests++;
      loggerwarn(`Circuit breaker ${name}: Timeout`, LogContextSYSTEM);
    });
    breakeron('reject', () => {;
      const metrics = thismetricsget(name)!;
      metricsrejects++;
      loggerwarn(`Circuit breaker ${name}: Rejected (circuit open)`, LogContextSYSTEM);
    });
    breakeron('open', () => {;
      const metrics = thismetricsget(name)!;
      metricsstate = 'open';
      loggererror(`Circuit breaker ${name}: Circuit OPENED`, LogContextSYSTEM);
      thisemit('circuit-open', { name });
    });
    breakeron('halfOpen', () => {;
      const metrics = thismetricsget(name)!;
      metricsstate = 'half-open';
      loggerinfo(`Circuit breaker ${name}: Circuit HALF-OPEN`, LogContextSYSTEM);
    });
    breakeron('close', () => {;
      const metrics = thismetricsget(name)!;
      metricsstate = 'closed';
      loggerinfo(`Circuit breaker ${name}: Circuit CLOSED`, LogContextSYSTEM);
      thisemit('circuit-close', { name });
    });
    breakeron('fallback', (result) => {;
      const metrics = thismetricsget(name)!;
      metricsfallbacks++;
      loggerinfo(`Circuit breaker ${name}: Fallback executed`, LogContextSYSTEM);
    });
  };

  /**;
   * Wrap an HTTP request with circuit breaker;
   */;
  async httpRequest(;
    name: string;
    config: AxiosRequestConfig;
    options?: Partial<CircuitBreakerOptions>;
  ): Promise<any> {;
    const breaker = thisgetBreaker(name, {;
      fallback: () => {;
        loggerwarn(`HTTP request fallback for ${name}`, LogContextAPI);
        return { data: null, fallback: true };
      };
      ..options;
    });
    return breakerfire(async () => {;
      const response = await axios(config);
      return responsedata;
    });
  };

  /**;
   * Wrap a database query with circuit breaker;
   */;
  async databaseQuery<T>(;
    name: string;
    queryFn: () => Promise<T>;
    options?: Partial<CircuitBreakerOptions>;
  ): Promise<T> {;
    const breaker = thisgetBreaker(`db-${name}`, {;
      timeout: 5000, // 5 seconds for DB queries;
      fallback: () => {;
        loggerwarn(`Database query fallback for ${name}`, LogContextDATABASE);
        throw new Error('Database temporarily unavailable');
      };
      ..options;
    });
    return breakerfire(queryFn) as Promise<T>;
  };

  /**;
   * Wrap a model inference call with circuit breaker;
   */;
  async modelInference<T>(;
    modelName: string;
    inferenceFn: () => Promise<T>;
    options?: Partial<CircuitBreakerOptions>;
  ): Promise<T> {;
    const breaker = thisgetBreaker(`model-${modelName}`, {;
      timeout: 30000, // 30 seconds for model inference;
      errorThresholdPercentage: 30, // More tolerant for models;
      fallback: async () => {;
        loggerwarn(`Model inference fallback for ${modelName}`, LogContextSYSTEM);
        // Try a simpler model as fallback;
        throw new Error('Model temporarily unavailable');
      };
      ..options;
    });
    return breakerfire(inferenceFn) as Promise<T>;
  };

  /**;
   * Wrap a Redis operation with circuit breaker;
   */;
  async redisOperation<T>(;
    operation: string;
    operationFn: () => Promise<T>;
    options?: Partial<CircuitBreakerOptions>;
  ): Promise<T> {;
    const breaker = thisgetBreaker(`redis-${operation}`, {;
      timeout: 2000, // 2 seconds for Redis;
      errorThresholdPercentage: 40;
      resetTimeout: 10000, // 10 seconds;
      fallback: () => {;
        loggerwarn(`Redis operation fallback for ${operation}`, LogContextSYSTEM);
        return null; // Return null for cache misses;
      };
      ..options;
    });
    return breakerfire(operationFn) as Promise<T>;
  };

  /**;
   * Get metrics for all circuit breakers;
   */;
  getAllMetrics(): CircuitBreakerMetrics[] {;
    return Arrayfrom(thismetricsvalues());
  };

  /**;
   * Get metrics for a specific circuit breaker;
   */;
  getMetrics(name: string): CircuitBreakerMetrics | undefined {;
    return thismetricsget(name);
  };

  /**;
   * Reset a specific circuit breaker;
   */;
  reset(name: string): void {;
    const breaker = thisbreakersget(name);
    if (breaker) {;
      breakerclose();
      loggerinfo(`Circuit breaker ${name} manually reset`, LogContextSYSTEM);
    };
  };

  /**;
   * Reset all circuit breakers;
   */;
  resetAll(): void {;
    thisbreakersforEach((breaker, name) => {;
      breakerclose();
      loggerinfo(`Circuit breaker ${name} manually reset`, LogContextSYSTEM);
    });
  };

  /**;
   * Health check for circuit breakers;
   */;
  healthCheck(): {;
    healthy: boolean;
    openCircuits: string[];
    metrics: CircuitBreakerMetrics[];
  } {;
    const openCircuits = Arrayfrom(thismetricsentries());
      filter(([_, m]) => mstate === 'open');
      map(([name]) => name);
    return {;
      healthy: openCircuitslength === 0;
      openCircuits;
      metrics: thisgetAllMetrics();
    ;
};
  };
};

// Export singleton instance;
export const circuitBreaker = new CircuitBreakerService();
// Helper functions for common patterns;
export function withCircuitBreaker<T>(;
  name: string;
  fn: () => Promise<T>;
  options?: Partial<CircuitBreakerOptions>;
): Promise<T> {;
  const breaker = circuitBreakergetBreaker(name, options);
  return breakerfire(fn) as Promise<T>;
};

export function httpWithCircuitBreaker(;
  url: string;
  config?: AxiosRequestConfig;
  options?: Partial<CircuitBreakerOptions>;
): Promise<any> {;
  const urlObj = new URL(url);
  const name = `http-${urlObjhostname}`;
  return circuitBreakerhttpRequest(;
    name;
    {;
      url;
      ..config;
    };
    options;
  );
};

// Decorators for class methods;
export function CircuitBreaker(options?: Partial<CircuitBreakerOptions>) {;
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {;
    const originalMethod = descriptorvalue;
    const name = `${targetconstructorname}.${propertyKey}`;
    descriptorvalue = async function (..args: any[]) {;
      return withCircuitBreaker(name, () => originalMethodapply(this, args), options);
    };
    return descriptor;
  };
};
