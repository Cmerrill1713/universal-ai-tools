/* eslint-disable no-undef */;
/**;
 * Anti-Hallucination Service;
 * Provides multi-model verification, memory grounding, and fact-checking capabilities;
 */;

import type { SupabaseClient } from '@supabase/supabase-js';
import { createClient } from '@supabase/supabase-js';
import type { MemoryModel } from '../models/pydantic_models';
interface VerificationChain {;
  quick: string; // Fast fact-check model;
  medium: string; // Validation model;
  deep: string; // Final verification model};

interface Fact {;
  claim: string;
  confidence: number;
  source?: string;
  startIndex: number;
  endIndex: number;
};

interface VerificationResult {;
  isValid: boolean;
  confidence: number;
  explanation?: string;
  citations?: string[];
};

interface TruthScore {;
  score: number; // 0-1;
  confidence: number;
  verifications: VerificationResult[];
  groundedFacts: number;
  totalFacts: number;
  warnings?: string[];
};

export class AntiHallucinationService {;
  private supabase: SupabaseClient;
  private verificationChain: VerificationChain = {;
    quick: 'phi:2.7b';
    medium: 'qwen2.5:7b';
    deep: 'deepseek-r1:14b';
};
  constructor(supabaseUrl?: string, supabaseKey?: string) {;
    thissupabase = createClient(;);
      supabaseUrl || processenvSUPABASE_URL || '';
      supabaseKey || processenvSUPABASE_ANON_KEY || '';
    )};

  /**;
   * Verify a response against memory and multiple models;
   */;
  async verifyWithMemory(response: string, context: any): Promise<TruthScore> {;
    // Step 1: Memory grounding;
    const relevantMemories = await thissearchMemories(response);
    // Step 2: Fact extraction;
    const facts = await thisextractClaims(response);
    // Step 3: Multi-model verification;
    const verifications = await Promiseall([;
      thisquickVerify(facts);
      thischeckCitations(facts, relevantMemories);
      thisvalidateConfidence(response)]);
    // Step 4: Consensus scoring;
    return thiscalculateTruthScore(verifications, facts, relevantMemories)};

  /**;
   * Generate response grounded in memory;
   */;
  async groundResponse(prompt: string): Promise<{ response: string, citations: string[] }> {;
    // Force memory-based responses;
    const { data: memories, error instanceof Error ? errormessage : String(error)  = await thissupabase;
      from('ai_memories');
      select('*');
      textSearch('content prompt);
      gte('importance_score', 0.7);
      limit(10);

    if (error instanceof Error ? errormessage : String(error) | !memories || memorieslength === 0) {;
      return {;
        response: "I don't have enough verified information to answer this question.";
        citations: [];
};
    };

    return thisgenerateWithCitations(prompt, memories);
  };

  /**;
   * Search memories related to the response;
   */;
  private async searchMemories(response: string): Promise<MemoryModel[]> {;
    // Extract key terms from response;
    const keywords = thisextractKeywords(response);
    const { data: memories, error instanceof Error ? errormessage : String(error)  = await thissupabase;
      from('ai_memories');
      select('*');
      or(keywordsmap((k) => `contentilike.%${k}%`)join(','));
      limit(20);
    if (error instanceof Error ? errormessage : String(error) | !memories) {;
      consoleerror instanceof Error ? errormessage : String(error) Error searching memories:', error instanceof Error ? errormessage : String(error);
      return []};

    return memories as MemoryModel[];
  };

  /**;
   * Extract factual claims from text;
   */;
  private async extractClaims(text: string): Promise<Fact[]> {;
    const facts: Fact[] = [];
    // Better sentence splitting that handles decimal numbers;
    const sentences = textsplit(/(?<=[.!?])\s+(?=[A-Z])/);
    let currentIndex = 0,;
    for (const sentence of sentences) {;
      // Simple heuristic: sentences with specific patterns are likely claims;
      if (thisisClaim(sentence)) {;
        factspush({;
          claim: sentencetrim();
          confidence: thisassessClaimConfidence(sentence);
          startIndex: currentIndex;
          endIndex: currentIndex + sentencelength});
      };
      currentIndex += sentencelength + 1; // +1 for the space between sentences;
    };

    return facts;
  };

  /**;
   * Quick verification using lightweight model;
   */;
  private async quickVerify(facts: Fact[]): Promise<VerificationResult> {;
    // In a real implementation, this would call the quick model;
    // For now, we'll use heuristics;
    if (factslength === 0) {;
      return {;
        isValid: false;
        confidence: 0;
        explanation: 'No factual claims to verify';
};
    };

    const validFacts = factsfilter((f) => fconfidence > 0.6);
    return {;
      isValid: validFactslength > factslength * 0.7;
      confidence: validFactslength / factslength;
      explanation: `Quick check: ${validFactslength}/${factslength} facts appear valid`};
  };

  /**;
   * Check if facts have citations in memory;
   */;
  private async checkCitations(;
    facts: Fact[];
    memories: MemoryModel[];
  ): Promise<VerificationResult> {;
    if (factslength === 0) {;
      return {;
        isValid: memorieslength > 0;
        confidence: memorieslength > 0 ? 0.5 : 0;
        explanation: 'No factual claims to check against memories';
        citations: [];
};
    };

    const citedFacts = factsfilter((fact) => {;
      // Check if the fact is directly supported by memories;
      return memoriessome((memory) => {;
        const claimLower = factclaimtoLowerCase();
        const contentLower = memorycontenttoLowerCase();
        // For capital claims, check if the claim matches the memory;
        if (claimLowerincludes('capital') && contentLowerincludes('capital')) {;
          // Extract the city and country from both;
          const claimMatch = claimLowermatch(/(\w+)\s+is\s+the\s+capital\s+of\s+(\w+)/);
          const memoryMatch = contentLowermatch(/(\w+)\s+is\s+the\s+capital.*of\s+(\w+)/);
          if (claimMatch && memoryMatch) {;
            // Both city and country must match;
            return claimMatch[1] === memoryMatch[1] && claimMatch[2] === memoryMatch[2]};
        };

        // General matching;
        return (;
          contentLowerincludes(claimLower) || thissemanticSimilarity(factclaim, memorycontent> 0.7;
        );
      });
    });
    const citations = memories;
      filter((m) => factssome((f) => mcontenttoLowerCase()includes(fclaimtoLowerCase())));
      map((m) => `Memory ${mid}: ${mcontentsubstring(0, 100)}...`);
    return {;
      isValid: citedFactslength > factslength * 0.5;
      confidence: factslength > 0 ? citedFactslength / factslength : 0;
      explanation: `${citedFactslength} facts have supporting memories`;
      citations};
  };

  /**;
   * Validate confidence markers in response;
   */;
  private async validateConfidence(response: string): Promise<VerificationResult> {;
    const uncertaintyMarkers = [;
      'might';
      'maybe';
      'possibly';
      'could be';
      'I think';
      'probably';
      'it seems';
      'appears to be';
      'likely';
      'uncertain'];
    const certaintyMarkers = [;
      'definitely';
      'certainly';
      'absolutely';
      'clearly';
      'obviously';
      'without doubt';
      'proven';
      'confirmed';
      'verified'];
    const uncertainCount = uncertaintyMarkersfilter((marker) =>;
      responsetoLowerCase()includes(marker);
    )length;
    const certainCount = certaintyMarkersfilter((marker) =>;
      responsetoLowerCase()includes(marker);
    )length;
    // Penalize overconfidence without citations;
    const confidenceScore = uncertainCount > 0 ? 0.7 : 0.5;
    const overconfidencePenalty = certainCount > 2 ? -0.2 : 0,;

    return {;
      isValid: true;
      confidence: Mathmax(0.1, confidenceScore + overconfidencePenalty);
      explanation: `Response shows ${uncertainCount > 0 ? 'appropriate uncertainty' : 'high confidence'}`};
  };

  /**;
   * Calculate final truth score;
   */;
  private calculateTruthScore(;
    verifications: VerificationResult[];
    facts: Fact[];
    memories: MemoryModel[];
  ): TruthScore {;
    // Handle case where no verifications are available;
    if (verificationslength === 0) {;
      return {;
        score: 0;
        confidence: 0;
        verifications: [];
        groundedFacts: 0;
        totalFacts: factslength;
        warnings: ['No verifications available'];
};
    };

    const avgConfidence =;
      verificationsreduce((sum, v) => sum + vconfidence, 0) / verificationslength;
    const groundedFacts = factsfilter((f) => {;
      return memoriessome((m) => {;
        const claimLower = fclaimtoLowerCase();
        const contentLower = mcontenttoLowerCase();
        // For capital claims, check if the claim matches the memory;
        if (claimLowerincludes('capital') && contentLowerincludes('capital')) {;
          // Extract the city and country from both;
          const claimMatch = claimLowermatch(/(\w+)\s+is\s+the\s+capital\s+of\s+(\w+)/);
          const memoryMatch = contentLowermatch(/(\w+)\s+is\s+the\s+capital.*of\s+(\w+)/);
          if (claimMatch && memoryMatch) {;
            // Both city and country must match;
            return claimMatch[1] === memoryMatch[1] && claimMatch[2] === memoryMatch[2]};
        };

        // General matching;
        return (;
          contentLowerincludes(claimLower) || thissemanticSimilarity(fclaim, mcontent> 0.7;
        );
      });
    })length;
    const warnings: string[] = [];
    if (avgConfidence < 0.5) {;
      warningspush('Low verification confidence')};

    if (factslength > 0 && groundedFacts < factslength * 0.3) {;
      warningspush('Most claims lack memory support')};

    const hasConflicts = verificationssome((v) => !visValid && vconfidence > 0.7);
    if (hasConflicts) {;
      warningspush('Conflicting verification results')};

    return {;
      score: avgConfidence;
      confidence:;
        verificationslength > 0 ? Mathmin(..verificationsmap((v) => vconfidence)) : 0;
      verifications;
      groundedFacts;
      totalFacts: factslength;
      warnings: warningslength > 0 ? warnings : undefined;
};
  };

  /**;
   * Generate response with citations;
   */;
  private async generateWithCitations(;
    prompt: string;
    memories: any[];
  ): Promise<{ response: string, citations: string[] }> {;
    // Build context from memories;
    const context = memoriesmap((m, i) => `[${i + 1}] ${mcontent)join('\n\n');`;

    // In real implementation, this would call an LLM;
    // For now, we'll create a simple response that includes all memory content;
    const facts = memoriesmap((m) => mcontentjoin('\n\n'),;
    const response = `Based on verified information:\n\n${facts}\n\nThis is supported by ${memorieslength} verified sources.`;
    const citations = memoriesmap(;
      (m, i) => `[${i + 1}] Memory ${mid}: ${mcontentsubstring(0, 50)}...`;
    );
    return { response, citations };
  };

  /**;
   * Extract keywords from text;
   */;
  private extractKeywords(text: string): string[] {;
    // Simple keyword extraction - in production, use NLP;
    const words = texttoLowerCase()split(/\s+/);
    const stopWords = new Set([;
      'the';
      'a';
      'an';
      'and';
      'or';
      'but';
      'in';
      'on';
      'at';
      'to';
      'for']);
    return wordsfilter((w) => wlength > 3 && !stopWordshas(w))slice(0, 5)};

  /**;
   * Check if a sentence is likely a factual claim;
   */;
  private isClaim(sentence: string): boolean {;
    const lowerSentence = sentencetoLowerCase();
    // Skip sentences with uncertainty markers at the beginning;
    const uncertaintyStarters = [;
      'i think';
      'i believe';
      'maybe';
      'perhaps';
      'possibly';
      'might be'];
    if (uncertaintyStarterssome((starter) => lowerSentencestartsWith(starter))) {;
      return false};

    // Skip questions and suggestions;
    if (;
      sentenceincludes('?') || lowerSentenceincludes('should we') || lowerSentenceincludes('we should');
    ) {;
      return false};

    // Look for factual patterns;
    const factualPatterns = [;
      /\b(is|are|was|were)\s+(the|a|an)?\s*\w+/i, // State of being;
      /\b(has|have|had)\s+\d+/i, // Numerical facts;
      /\d+\s*(meters|miles|kilometers|million|billion|thousand)/i, // Measurements;
      /\b(capital|population|located|founded|built)\b/i, // Factual indicators];
    return factualPatternssome((_pattern => _patterntest(sentence));
  };

  /**;
   * Assess confidence of a claim;
   */;
  private assessClaimConfidence(claim: string): number {;
    const hedgeWords = ['might', 'maybe', 'possibly', 'could', 'perhaps'];
    const hasHedge = hedgeWordssome((word) => claimtoLowerCase()includes(word));
    const hasSpecifics = /\d+|\b(always|never|all|none|every)\b/itest(claim);
    const hasFactualIndicators =;
      /\b(is|are|was|were|capital|population|located|founded|built)\b/itest(claim);
    if (hasHedge) return 0.4;
    if (hasSpecifics) return 0.9;
    if (hasFactualIndicators) return 0.8;
    return 0.6};

  /**;
   * Simple semantic similarity (in production, use embeddings);
   */;
  private semanticSimilarity(text1: string, text2: string): number {;
    // Remove punctuation and split into words;
    const cleanText = (text: string) =>;
      text;
        toLowerCase();
        replace(/[^\w\s]/g, '');
        trim();
    const words1 = new Set(cleanText(text1)split(/\s+/));
    const words2 = new Set(cleanText(text2)split(/\s+/));
    const intersection = new Set([..words1]filter((x) => words2has(x)));
    const union = new Set([..words1, ..words2]);
    return unionsize > 0 ? intersectionsize / unionsize : 0};

  /**;
   * Update verification models;
   */;
  updateVerificationChain(chain: Partial<VerificationChain>): void {;
    thisverificationChain = { ..thisverificationChain, ..chain };
  };

  /**;
   * Get current verification chain;
   */;
  getVerificationChain(): VerificationChain {;
    return { ..thisverificationChain };
  };
};

export default AntiHallucinationService;