/**;
 * Port Integration Service;
 *;
 * Integrates the SmartPortManager and PortHealthMonitor with the existing;
 * server infrastructure to provide comprehensive port management capabilities.;
 *;
 * Features:;
 * - Automatic port discovery and configuration;
 * - Real-time health monitoring integration;
 * - WebSocket support for live port status updates;
 * - Integration with existing Supabase configuration;
 * - Service startup coordination;
 */;

import type { PortConfiguration, ServiceConfig } from '../utils/smart-port-manager';
import { SmartPortManager } from '../utils/smart-port-manager';
import type { PortHealthMonitor } from './port-health-monitor';
import { MonitoringConfig, createPortHealthMonitor } from './port-health-monitor';
import { SupabaseService } from './supabase_service';
import { logger } from '../utils/logger';
import { WebSocket, WebSocketServer } from 'ws';
import type { Server } from 'http';
import { createServer } from 'http';
import { config } from '../config';
import { BATCH_SIZE_10, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500, MAX_ITEMS_100, PERCENT_10, PERCENT_100, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, TIME_10000MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_500MS, ZERO_POINT_EIGHT, ZERO_POINT_FIVE, ZERO_POINT_NINE } from "../utils/common-constants";
export interface PortIntegrationConfig {;
  enableAutoDiscovery: boolean;
  enableHealthMonitoring: boolean;
  enableWebSocketBroadcast: boolean;
  monitoringInterval: number;
  autoResolveConflicts: boolean;
  persistConfiguration: boolean;
  customServices?: ServiceConfig[];
;
};

export interface ServiceStartupResult {;
  service: string;
  port: number;
  status: 'success' | 'failed' | 'conflict_resolved';
  originalPort?: number;
  error instanceof Error ? errormessage : String(error)  string;
;
};

export interface PortSystemStatus {;
  smartPortManager: {;
    initialized: boolean;
    servicesConfigured: number;
    activeMonitoring: boolean;
  ;
};
  healthMonitor: {;
    initialized: boolean;
    monitoring: boolean;
    activeClients: number;
    healthScore: number;
  ;
};
  services: Array<{;
    name: string;
    port: number;
    status: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';
    lastChecked: Date;
  }>;
  webSocket: {;
    enabled: boolean;
    clients: number;
  ;
};
};

export class PortIntegrationService {;
  private portManager: SmartPortManager;
  private healthMonitor: PortHealthMonitor;
  private supabaseService: SupabaseService;
  private config: PortIntegrationConfig;
  private webSocketServer?: WebSocketServer;
  private httpServer?: Server;
  private isInitialized = false;
  private startupResults: ServiceStartupResult[] = [];
  constructor(customConfig: Partial<PortIntegrationConfig> = {}, customServices?: ServiceConfig[]) {;
    thisconfig = {;
      enableAutoDiscovery: true;
      enableHealthMonitoring: true;
      enableWebSocketBroadcast: true;
      monitoringInterval: 30000;
      autoResolveConflicts: true;
      persistConfiguration: true;
      ..customConfig;
    ;
};
    // Initialize port manager;
    thisportManager = new SmartPortManager(customServices);
    // Initialize Supabase service;
    thissupabaseService = SupabaseServicegetInstance();
    // Initialize health monitor;
    thishealthMonitor = createPortHealthMonitor(;);
      thisportManager;
      configdatabasesupabaseUrl;
      configdatabasesupabaseServiceKey || '';
      {;
        interval: thisconfigmonitoringInterval;
        enableWebSocket: thisconfigenableWebSocketBroadcast;
        persistMetrics: thisconfigpersistConfiguration;
        healthCheckTimeout: 5000;
        retryAttempts: 3;
        alertCooldown: 300000;
        maxHistoryAge: 30;
      ;
};
    );
    thissetupEventListeners();
  };

  /**;
   * Initialize the entire port management system;
   */;
  async initialize(): Promise<void> {;
    if (thisisInitialized) {;
      loggerwarn('Port integration service is already initialized');
      return;
    };

    try {;
      loggerinfo('üöÄ Initializing Port Integration Service...');
      // Step 1: Auto-discover existing services;
      if (thisconfigenableAutoDiscovery) {;
        await thisperformServiceDiscovery();
      ;
};

      // Step 2: Generate optimal port configuration;
      if (thisconfigautoResolveConflicts) {;
        await thisgenerateAndApplyOptimalConfiguration();
      ;
};

      // Step 3: Initialize health monitoring;
      if (thisconfigenableHealthMonitoring) {;
        await thishealthMonitorstartMonitoring();
        loggerinfo('‚úÖ Health monitoring started');
      ;
};

      // Step 4: Setup WebSocket server for real-time updates;
      if (thisconfigenableWebSocketBroadcast) {;
        await thissetupWebSocketServer();
        loggerinfo('‚úÖ WebSocket server initialized');
      ;
};

      // Step 5: Persist configuration if enabled;
      if (thisconfigpersistConfiguration) {;
        await thispersistCurrentConfiguration();
      ;
};

      thisisInitialized = true;
      loggerinfo('üéâ Port Integration Service initialized successfully');
      // Emit initialization complete event;
      thisportManageremit('integrationServiceInitialized', {;
        timestamp: new Date();
        config: thisconfig;
        servicesConfigured: thisstartupResultslength;
      });
    } catch (error) {;
      loggererror('Failed to initialize Port Integration Service:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Perform automatic service discovery;
   */;
  async performServiceDiscovery(): Promise<Map<string, any>> {;
    loggerinfo('üîç Performing service discovery...');
    try {;
      // Use a timeout wrapper to prevent hanging;
      const discoveryTimeout = 5000; // 5 seconds max for discovery;
      const discoveryPromise = thisportManagerdiscoverServices();
      const discoveredServices = await Promiserace([;
        discoveryPromise;
        new Promise<Map<string, any>>((_, reject) =>;
          setTimeout(() => reject(new Error('Service discovery timeout')), discoveryTimeout);
        );
      ])catch((error instanceof Error ? errormessage : String(error)=> {;
        loggerwarn('Service discovery timed out or failed, using empty map:', errormessage);
        return new Map();
      });
      loggerinfo(`Found ${discoveredServicessize} active services`);
      // Log discovered services;
      for (const [serviceName, status] of discoveredServices) {;
        loggerinfo(`  üì¶ ${serviceName}: port ${statusport} (${statushealthStatus})`);
        thisstartupResultspush({;
          service: serviceName;
          port: statusport;
          status: statushealthStatus === 'healthy' ? 'success' : 'failed';
        });
      };

      return discoveredServices;
    } catch (error) {;
      loggererror('Service discovery failed:', error instanceof Error ? errormessage : String(error);
      // Return empty map instead of throwing to prevent startup failure;
      return new Map();
    };
  };

  /**;
   * Generate and apply optimal port configuration;
   */;
  async generateAndApplyOptimalConfiguration(): Promise<PortConfiguration> {;
    loggerinfo('‚öôÔ∏è Generating optimal port configuration...');
    try {;
      const optimalConfig = await thisportManagergenerateOptimalPortConfig();
      // Log any port conflicts that were resolved;
      if (optimalConfigconflictslength > 0) {;
        loggerinfo('üîß Resolved port conflicts:');
        for (const conflict of optimalConfigconflicts) {;
          loggerinfo(`  üîÄ ${conflictservice}: ${conflictport} ‚Üí ${conflictresolvedTo}`);
          // Update startup results;
          const existingResult = thisstartupResultsfind((r) => rservice === conflictservice);
          if (existingResult) {;
            existingResultstatus = 'conflict_resolved';
            existingResultoriginalPort = conflictport;
            existingResultport = conflictresolvedTo;
          } else {;
            thisstartupResultspush({;
              service: conflictservice;
              port: conflictresolvedTo;
              originalPort: conflictport;
              status: 'conflict_resolved';
            });
          };
        };
      };

      await thisportManagersavePortConfiguration(optimalConfig);
      loggerinfo('‚úÖ Optimal port configuration applied and saved');
      return optimalConfig;
    } catch (error) {;
      loggererror('Failed to generate optimal configuration:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Setup WebSocket server for real-time port status updates;
   */;
  async setupWebSocketServer(): Promise<void> {;
    if (!thishttpServer) {;
      // Create a minimal HTTP server for WebSocket upgrade;
      thishttpServer = createServer();
    ;
};

    thiswebSocketServer = new WebSocketServer({;
      server: thishttpServer;
      path: '/ws/port-status';
    });
    thiswebSocketServeron('connection', (ws: WebSocket) => {;
      loggerinfo('WebSocket client connected to port status updates');
      // Subscribe client to health updates;
      thishealthMonitorsubscribeToHealthUpdates(ws);
      // Send initial port system status;
      thissendPortSystemStatus(ws);
      wson('message', (message) => {;
        try {;
          const data = JSONparse(messagetoString());
          thishandleWebSocketMessage(ws, data);
        } catch (error) {;
          loggererror('Invalid WebSocket message:', error instanceof Error ? errormessage : String(error);
          wssend(JSONstringify({ error instanceof Error ? errormessage : String(error) 'Invalid message format' }));
        };
      });
      wson('close', () => {;
        loggerinfo('WebSocket client disconnected from port status updates');
      });
    });
    loggerinfo('WebSocket server setup complete for port status updates');
  };

  /**;
   * Handle incoming WebSocket messages;
   */;
  private handleWebSocketMessage(ws: WebSocket, data: any): void {;
    switch (datatype) {;
      case 'get_port_status':;
        thissendPortSystemStatus(ws);
        break;
      case 'request_health_check':;
        thistriggerHealthCheck(dataservice);
        break;
      case 'resolve_port_conflict':;
        thisresolveSpecificPortConflict(dataservice, datarequestedPort);
        break;
      default:;
        wssend(JSONstringify({ error instanceof Error ? errormessage : String(error) 'Unknown message type' }));
    };
  };

  /**;
   * Send current port system status to WebSocket client;
   */;
  private sendPortSystemStatus(ws: WebSocket): void {;
    const status = thisgetPortSystemStatus();
    wssend(;
      JSONstringify({;
        type: 'port_system_status';
        timestamp: new Date()toISOString();
        status;
      });
    );
  };

  /**;
   * Get comprehensive port system status;
   */;
  getPortSystemStatus(): PortSystemStatus {;
    const overallHealth = thishealthMonitorgetOverallHealth();
    const monitoringStats = thishealthMonitorgetMonitoringStats();
    return {;
      smartPortManager: {;
        initialized: thisisInitialized;
        servicesConfigured: thisstartupResultslength;
        activeMonitoring: monitoringStatsisMonitoring;
      ;
};
      healthMonitor: {;
        initialized: true;
        monitoring: monitoringStatsisMonitoring;
        activeClients: monitoringStatswebSocketClients;
        healthScore: overallHealthscore;
      ;
};
      services: thisstartupResultsmap((result) => ({;
        name: resultservice;
        port: resultport;
        status:;
          resultstatus === 'success';
            ? 'healthy';
            : resultstatus === 'conflict_resolved';
              ? 'healthy';
              : 'unhealthy';
        lastChecked: new Date();
      }));
      webSocket: {;
        enabled: thisconfigenableWebSocketBroadcast;
        clients: monitoringStatswebSocketClients;
      ;
};
    };
  };

  /**;
   * Get startup results for analysis;
   */;
  getStartupResults(): ServiceStartupResult[] {;
    return [..thisstartupResults];
  };

  /**;
   * Trigger manual health check for a specific service;
   */;
  async triggerHealthCheck(serviceName?: string): Promise<void> {;
    const HEALTH_CHECK_TIMEOUT = 10000; // 10 seconds timeout;

    try {;
      if (serviceName) {;
        const metric = await Promiserace([;
          thishealthMonitormonitorServiceHealth(serviceName);
          new Promise((_, reject) =>;
            setTimeout(() => reject(new Error('Health check timeout')), HEALTH_CHECK_TIMEOUT);
          );
        ]);
        loggerinfo(`Health check for ${serviceName}: ${metricstatus}`);
      } else {;
        // Trigger health checks for all known services with timeout;
        const servicesPromise = thisportManagerdiscoverServices();
        const services = await Promiserace([;
          servicesPromise;
          new Promise<Map<string, any>>((_, reject) =>;
            setTimeout(TIME_500MS0);
          );
        ])catch(() => new Map());
        // Limit concurrent health checks and add timeout;
        const MAX_CONCURRENT_CHECKS = 5;
        const servicesToCheck = Arrayfrom(serviceskeys());
        const results = [];
        for (let i = 0; i < servicesToChecklength; i += MAX_CONCURRENT_CHECKS) {;
          const batch = servicesToCheckslice(i, i + MAX_CONCURRENT_CHECKS);
          const batchResults = await PromiseallSettled(;
            batchmap((service) =>;
              Promiserace([;
                thishealthMonitormonitorServiceHealth(service);
                new Promise((_, reject) =>;
                  setTimeout(;
                    () => reject(new Error(`Health check timeout for ${service}`));
                    HEALTH_CHECK_TIMEOUT;
                  );
                );
              ]);
            );
          );
          resultspush(..batchResults);
        };

        const successful = resultsfilter((r) => rstatus === 'fulfilled')length;
        loggerinfo(;
          `Full health check completed: ${successful}/${resultslength} services checked successfully`;
        );
      };
    } catch (error) {;
      loggererror('Health check failed:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Resolve a specific port conflict;
   */;
  async resolveSpecificPortConflict(service: string, requestedPort: number): Promise<number> {;
    const RESOLVE_TIMEOUT = 5000; // 5 seconds timeout;

    try {;
      const resolvedPort = await Promiserace([;
        thisportManagerresolvePortConflict(service, requestedPort);
        new Promise<number>((_, reject) =>;
          setTimeout(() => reject(new Error('Port conflict resolution timeout')), RESOLVE_TIMEOUT);
        );
      ]);
      // Update startup results;
      const existingResult = thisstartupResultsfind((r) => rservice === service);
      if (existingResult) {;
        existingResultoriginalPort = existingResultport;
        existingResultport = resolvedPort;
        existingResultstatus = 'conflict_resolved';
      };

      loggerinfo(`Port conflict resolved for ${service}: ${requestedPort} ‚Üí ${resolvedPort}`);
      return resolvedPort;
    } catch (error) {;
      loggererror`Failed to resolve port conflict for ${service}:`, error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Persist current configuration to Supabase;
   */;
  async persistCurrentConfiguration(): Promise<void> {;
    const PERSIST_TIMEOUT = 10000; // 10 seconds timeout;

    try {;
      const configPromise = thisportManagerloadPortConfiguration();
      const config = await Promiserace([;
        configPromise;
        new Promise<PortConfiguration | null>((_, reject) =>;
          setTimeout(() => reject(new Error('Configuration load timeout')), PERSIST_TIMEOUT);
        );
      ]);
      if (config) {;
        await Promiserace([;
          thissupabaseServiceinsert('port_configurations', {;
            configuration: config;
            startup_results: thisstartupResults;
            system_status: thisgetPortSystemStatus();
            created_at: new Date()toISOString();
          });
          new Promise((_, reject) =>;
            setTimeout(() => reject(new Error('Database persist timeout')), PERSIST_TIMEOUT);
          );
        ]);
        loggerinfo('Port configuration persisted to database');
      };
    } catch (error) {;
      loggererror('Failed to persist configuration:', error instanceof Error ? errormessage : String(error) // Don't throw - this is a non-critical operation;
    ;
};
  };

  /**;
   * Setup event listeners for port manager and health monitor events;
   */;
  private setupEventListeners(): void {;
    // Port Manager Events;
    thisportManageron('portConflictResolved', (event) => {;
      loggerinfo(`Port conflict resolved: ${eventservice} ${eventoriginal} ‚Üí ${eventresolved}`);
      thisbroadcastToWebSocketClients({;
        type: 'port_conflict_resolved';
        timestamp: new Date()toISOString();
        event;
      });
    });
    thisportManageron('portStatusChanged', (event) => {;
      loggerinfo(;
        `Port status changed: ${eventservice} port ${eventport} ${eventpreviousStatus} ‚Üí ${eventnewStatus}`;
      );
      thisbroadcastToWebSocketClients({;
        type: 'port_status_changed';
        timestamp: new Date()toISOString();
        event;
      });
    });
    // Health Monitor Events;
    thishealthMonitoron('alertCreated', (alert) => {;
      loggerwarn(`Health alert: ${alerttype} - ${alertmessage}`);
      thisbroadcastToWebSocketClients({;
        type: 'health_alert';
        timestamp: new Date()toISOString();
        alert;
      });
    });
    thishealthMonitoron('healthCheckCompleted', (event) => {;
      thisbroadcastToWebSocketClients({;
        type: 'health_check_completed';
        timestamp: new Date()toISOString();
        results: eventresults;
      });
    });
  };

  /**;
   * Broadcast message to all connected WebSocket clients;
   */;
  private broadcastToWebSocketClients(message: any): void {;
    if (thiswebSocketServer) {;
      thiswebSocketServerclientsforEach((client) => {;
        if (clientreadyState === WebSocketOPEN) {;
          try {;
            clientsend(JSONstringify(message));
          } catch (error) {;
            loggererror('Failed to broadcast WebSocket message:', error instanceof Error ? errormessage : String(error)  ;
};
        };
      });
    };
  };

  /**;
   * Gracefully shutdown the port integration service;
   */;
  async shutdown(): Promise<void> {;
    loggerinfo('Shutting down Port Integration Service...');
    try {;
      // Stop health monitoring;
      if (thishealthMonitor) {;
        await thishealthMonitorstopMonitoring();
      ;
};

      // Stop port monitoring;
      if (thisportManager) {;
        thisportManagerstopMonitoring();
      };

      // Close WebSocket server;
      if (thiswebSocketServer) {;
        thiswebSocketServerclose();
      };

      // Close HTTP server;
      if (thishttpServer) {;
        thishttpServerclose();
      };

      thisisInitialized = false;
      loggerinfo('‚úÖ Port Integration Service shutdown complete');
    } catch (error) {;
      loggererror('Error during Port Integration Service shutdown:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Generate comprehensive port management report;
   */;
  async generatePortManagementReport(): Promise<unknown> {;
    const healthReport = await thishealthMonitorgenerateHealthReport();
    const systemStatus = thisgetPortSystemStatus();
    const startupResults = thisgetStartupResults();
    return {;
      timestamp: new Date()toISOString();
      systemStatus;
      healthReport;
      startupResults;
      configuration: thisconfig;
      summary: {;
        totalServices: startupResultslength;
        successfulStartups: startupResultsfilter((r) => rstatus === 'success')length;
        conflictsResolved: startupResultsfilter((r) => rstatus === 'conflict_resolved')length;
        failures: startupResultsfilter((r) => rstatus === 'failed')length;
        overallHealthScore: healthReporthealthScore;
        monitoringActive: systemStatushealthMonitormonitoring;
      ;
};
    };
  };
};

// Export singleton instance for application use;
export const portIntegrationService = new PortIntegrationService();
// Export utility functions for easy integration;
export async function initializePortSystem(;
  customConfig?: Partial<PortIntegrationConfig>;
): Promise<PortIntegrationService> {;
  const service = new PortIntegrationService(customConfig);
  await serviceinitialize();
  return service;
};

export async function getPortSystemStatus(): Promise<PortSystemStatus> {;
  return portIntegrationServicegetPortSystemStatus();
};

export async function generatePortReport(): Promise<unknown> {;
  return portIntegrationServicegeneratePortManagementReport();
};
