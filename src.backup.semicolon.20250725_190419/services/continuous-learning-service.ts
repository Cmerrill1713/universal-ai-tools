/**;
 * Continuous Learning Service;
 * Main orchestrator for the knowledge update and learning system;
 */;

import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
import { supabase } from './supabase_service';
import { KnowledgeScraperService } from './knowledge-scraper-service';
import { KnowledgeValidationService } from './knowledge-validation-service';
import type { KnowledgeFeedbackService } from './knowledge-feedback-service';
import { createKnowledgeFeedbackService } from './knowledge-feedback-service';
import type { KnowledgeUpdateAutomationService } from './knowledge-update-automation';
import { createKnowledgeUpdateAutomation } from './knowledge-update-automation';
import { DSPyKnowledgeManager } from '../core/knowledge/dspy-knowledge-manager';
import { RerankingPipeline } from './reranking-pipeline';
import * as cron from 'node-cron';
interface ServiceHealth {;
  service: string;
  status: 'healthy' | 'degraded' | 'unhealthy';
  lastCheck: Date;
  issues: string[];
  metrics: Record<string, unknown>;
};

interface LearningCycle {;
  cycleId: string;
  startTime: Date;
  endTime?: Date;
  phase: 'collection' | 'validation' | 'integration' | 'optimization' | 'complete';
  itemsProcessed: number;
  itemsValidated: number;
  itemsIntegrated: number;
  insights: string[];
  errors: string[];
;
};

export class ContinuousLearningService extends EventEmitter {;
  private scraperService: KnowledgeScraperService;
  private validationService: KnowledgeValidationService;
  private feedbackService: KnowledgeFeedbackService;
  private updateAutomation: KnowledgeUpdateAutomationService;
  private knowledgeManager: DSPyKnowledgeManager;
  private rerankingPipeline: RerankingPipeline;
  private scheduledJobs: Map<string, cronScheduledTask> = new Map();
  private currentCycle: LearningCycle | null = null;
  private serviceHealth: Map<string, ServiceHealth> = new Map();
  private isRunning = false;
  constructor() {;
    super();
    // Initialize all services;
    thisknowledgeManager = new DSPyKnowledgeManager();
    thisscraperService = new KnowledgeScraperService();
    thisvalidationService = new KnowledgeValidationService();
    thisrerankingPipeline = new RerankingPipeline(supabase, logger);
    thisfeedbackService = createKnowledgeFeedbackService(supabase, logger);
    thisupdateAutomation = createKnowledgeUpdateAutomation(;);
      thisscraperService;
      thisvalidationService;
      thisfeedbackService;
      thisknowledgeManager;
    );
    thissetupEventHandlers();
  };

  /**;
   * Start the continuous learning system;
   */;
  async start(): Promise<void> {;
    if (thisisRunning) {;
      loggerwarn('Continuous learning service is already running');
      return;
    };

    try {;
      loggerinfo('Starting continuous learning service...');
      // Initialize all sub-services;
      await thisinitializeServices();
      // Schedule learning cycles;
      thisscheduleLearningCycles();
      // Schedule health checks;
      thisscheduleHealthChecks();
      // Schedule optimization runs;
      thisscheduleOptimization();
      thisisRunning = true;
      thisemit('service_started');
      loggerinfo('Continuous learning service started successfully');
      // Run initial learning cycle;
      await thisrunLearningCycle();
    } catch (error) {;
      loggererror('Failed to start continuous learning service:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Stop the continuous learning system;
   */;
  async stop(): Promise<void> {;
    if (!thisisRunning) {;
      loggerwarn('Continuous learning service is not running');
      return;
    };

    try {;
      loggerinfo('Stopping continuous learning service...');
      // Stop all scheduled jobs;
      for (const [name, job] of thisscheduledJobs) {;
        jobstop();
        loggerinfo(`Stopped scheduled job: ${name}`);
      };
      thisscheduledJobsclear();
      // Shutdown all sub-services;
      await thisshutdownServices();
      thisisRunning = false;
      thisemit('service_stopped');
      loggerinfo('Continuous learning service stopped successfully');
    } catch (error) {;
      loggererror('Error stopping continuous learning service:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Run a complete learning cycle;
   */;
  async runLearningCycle(): Promise<void> {;
    const cycleId = `cycle-${Datenow()}`;
    thiscurrentCycle = {;
      cycleId;
      startTime: new Date();
      phase: 'collection';
      itemsProcessed: 0;
      itemsValidated: 0;
      itemsIntegrated: 0;
      insights: [];
      errors: [];
    ;
};
    try {;
      loggerinfo(`Starting learning cycle: ${cycleId}`);
      thisemit('cycle_started', thiscurrentCycle);
      // Phase 1: Collection;
      await thisrunCollectionPhase();
      // Phase 2: Validation;
      await thisrunValidationPhase();
      // Phase 3: Integration;
      await thisrunIntegrationPhase();
      // Phase 4: Optimization;
      await thisrunOptimizationPhase();
      // Complete cycle;
      thiscurrentCyclephase = 'complete';
      thiscurrentCycleendTime = new Date();
      // Store cycle results;
      await thisstoreCycleResults();
      loggerinfo(`Completed learning cycle: ${cycleId}`);
      thisemit('cycle_completed', thiscurrentCycle);
    } catch (error) {;
      loggererror`Error in learning cycle ${cycleId}:`, error instanceof Error ? errormessage : String(error) if (thiscurrentCycle) {;
        thiscurrentCycleerrorspush(String(error instanceof Error ? errormessage : String(error);
        thiscurrentCyclephase = 'complete';
        thiscurrentCycleendTime = new Date();
      ;
};

      thisemit('cycleerror instanceof Error ? errormessage : String(error)  { cycle: thiscurrentCycle, error instanceof Error ? errormessage : String(error));
    } finally {;
      thiscurrentCycle = null;
    };
  };

  /**;
   * Phase 1: Collection - Gather new knowledge;
   */;
  private async runCollectionPhase(): Promise<void> {;
    if (!thiscurrentCycle) return;
    loggerinfo('Running collection phase...');
    thiscurrentCyclephase = 'collection';
    try {;
      // Check for scheduled updates;
      const updateStatus = await thisupdateAutomationgetStatistics();
      // Process update queue;
      if (updateStatusqueuedJobs > 0) {;
        loggerinfo(`Processing ${updateStatusqueuedJobs} queued update jobs`);
        // The automation service handles this automatically;
      };

      // Collect from high-priority sources;
      const sourcesToScrape = await thisidentifySourcesForCollection();
      for (const source of sourcesToScrape) {;
        try {;
          const items = await thisscraperServicescrapeSource(source);
          thiscurrentCycleitemsProcessed += itemslength;
          loggerinfo(`Collected ${itemslength} items from ${sourcename}`);
        } catch (error) {;
          loggererror`Failed to collect from ${sourcename}:`, error instanceof Error ? errormessage : String(error);
          thiscurrentCycleerrorspush(`Collection failed for ${sourcename}: ${error instanceof Error ? errormessage : String(error)),`;
        };
      };

      thiscurrentCycleinsightspush(;
        `Collected ${thiscurrentCycleitemsProcessed} new knowledge items`;
      );
    } catch (error) {;
      loggererror('Error in collection phase:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Phase 2: Validation - Validate collected knowledge;
   */;
  private async runValidationPhase(): Promise<void> {;
    if (!thiscurrentCycle) return;
    loggerinfo('Running validation phase...');
    thiscurrentCyclephase = 'validation';
    try {;
      // Get unvalidated knowledge;
      const { data: unvalidated } = await supabase;
        from('scraped_knowledge');
        select('*');
        eq('validation_status', 'pending');
        limit(100);
      if (!unvalidated || unvalidatedlength === 0) {;
        loggerinfo('No items pending validation');
        return;
      };

      loggerinfo(`Validating ${unvalidatedlength} knowledge items`);
      for (const item of unvalidated) {;
        try {;
          // Find source configuration;
          const source = await thisgetSourceConfig(itemsource_id);
          if (!source) continue;
          // Validate;
          await thisvalidationServicevalidateScrapedKnowledge(;
            itemid;
            itemcontent;
            source;
            itemmetadata;
          );
          thiscurrentCycleitemsValidated++;
        } catch (error) {;
          loggererror`Validation failed for item ${itemid}:`, error instanceof Error ? errormessage : String(error);
          thiscurrentCycleerrorspush(`Validation failed: ${error instanceof Error ? errormessage : String(error));`;
        };
      };

      thiscurrentCycleinsightspush(;
        `Validated ${thiscurrentCycleitemsValidated} knowledge items`;
      );
    } catch (error) {;
      loggererror('Error in validation phase:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Phase 3: Integration - Integrate validated knowledge;
   */;
  private async runIntegrationPhase(): Promise<void> {;
    if (!thiscurrentCycle) return;
    loggerinfo('Running integration phase...');
    thiscurrentCyclephase = 'integration';
    try {;
      // Get validated knowledge ready for integration;
      const { data: validated } = await supabase;
        from('scraped_knowledge');
        select('*');
        eq('validation_status', 'validated');
        eq('processed', false);
        limit(50);
      if (!validated || validatedlength === 0) {;
        loggerinfo('No validated items to integrate');
        return;
      };

      loggerinfo(`Integrating ${validatedlength} validated items`);
      for (const item of validated) {;
        try {;
          // Store in knowledge manager;
          const knowledgeId = await thisknowledgeManagerstoreKnowledge({;
            type: 'solution';
            title: itemtitle;
            description: `Integrated from ${itemsource_id}`;
            contentitemcontent;
            tags: itemcategories;
            confidence: itemquality_score;
            metadata: {;
              ..itemmetadata;
              sourceUrl: itemurl;
              integratedAt: new Date()toISOString();
            ;
};
          });
          // Mark as processed;
          await supabasefrom('scraped_knowledge')update({ processed: true })eq('id', itemid);
          // Track integration;
          await thisfeedbackServicetrackUsage({;
            knowledgeId;
            knowledgeType: 'solution';
            agentId: 'continuous-learning';
            actionType: 'used';
            context: { phase: 'integration', sourceId: itemsource_id ;
};
            performanceScore: itemquality_score;
          });
          thiscurrentCycleitemsIntegrated++;
        } catch (error) {;
          loggererror`Integration failed for item ${itemid}:`, error instanceof Error ? errormessage : String(error);
          thiscurrentCycleerrorspush(`Integration failed: ${error instanceof Error ? errormessage : String(error));`;
        };
      };

      // Update relationships based on integration patterns;
      await thisupdateKnowledgeRelationships();
      thiscurrentCycleinsightspush(;
        `Integrated ${thiscurrentCycleitemsIntegrated} knowledge items into the system`;
      );
    } catch (error) {;
      loggererror('Error in integration phase:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Phase 4: Optimization - Optimize knowledge and search;
   */;
  private async runOptimizationPhase(): Promise<void> {;
    if (!thiscurrentCycle) return;
    loggerinfo('Running optimization phase...');
    thiscurrentCyclephase = 'optimization';
    try {;
      // Get performance insights;
      const insights = thisfeedbackServicegetInsights();
      const patterns = thisfeedbackServicegetPatterns();
      // Optimize search configuration;
      const searchPerf = await thisrerankingPipelineanalyzePerformance();
      if (searchPerfrecommendationslength > 0) {;
        loggerinfo('Applying search optimization recommendations');
        // Apply recommendations would be done here;

        thiscurrentCycleinsightspush(;
          `Applied ${searchPerfrecommendationslength} search optimizations`;
        );
      };

      // Optimize knowledge modules if using DSPy;
      loggerinfo('Running knowledge optimization');
      const optimizationResult = await thisknowledgeManageroptimizeKnowledgeModules();
      if (optimizationResultsuccess) {;
        thiscurrentCycleinsightspush('Successfully optimized knowledge modules with MIPROv2');
      };

      // Process learning insights;
      for (const insight of insightsslice(0, 5)) {;
        thiscurrentCycleinsightspush(;
          `${insighttype}: ${insighttitle} (${insightrecommendationsjoin(', ')})`;
        );
      };

      // Clean up old data;
      await thisperformMaintenance();
    } catch (error) {;
      loggererror('Error in optimization phase:', error instanceof Error ? errormessage : String(error);
      // Non-critical, don't throw;
      thiscurrentCycleerrorspush(`Optimization error instanceof Error ? errormessage : String(error) ${error instanceof Error ? errormessage : String(error));`;
    };
  };

  /**;
   * Setup event handlers for sub-services;
   */;
  private setupEventHandlers(): void {;
    // Feedback service events;
    thisfeedbackServiceon('insight_generated', (insight) => {;
      loggerinfo('New insight generated:', insighttitle);
      thisemit('insight_generated', insight);
    });
    thisfeedbackServiceon('critical_failure', async (failure) => {;
      loggererror('Critical knowledge failure detected:', failure);
      // Create high-priority alert;
      await thiscreateAlert(;
        'critical_failure';
        'critical';
        'Critical Knowledge Failure';
        `Knowledge item ${failureknowledgeId} has failed ${failurefailureCount} times`;
        [failure];
      );
    });
    // Update automation events;
    thisupdateAutomationon('job_completed', (job) => {;
      loggerinfo(`Update job completed: ${jobid}`);
      thisemit('update_completed', job);
    });
    thisupdateAutomationon('job_failed', async (job) => {;
      loggererror`Update job failed: ${jobid}`);
      await thiscreateAlert(;
        'update_failure';
        'high';
        'Knowledge Update Failed';
        `Update job ${jobid} failed after ${jobattempts} attempts`;
        [job];
      );
    });
    // Knowledge manager events;
    thisknowledgeManageron('knowledge_stored', (data) => {;
      thisemit('knowledge_added', data);
    });
    thisknowledgeManageron('modules_optimized', (result) => {;
      loggerinfo('Knowledge modules optimized:', result);
      thisemit('optimization_completed', result);
    });
  };

  /**;
   * Initialize all sub-services;
   */;
  private async initializeServices(): Promise<void> {;
    await Promiseall([;
      thisscraperServiceinitialize();
      // Other services initialize automatically;
    ]);
    // Set initial health status;
    thisupdateServiceHealth('scraper', 'healthy', {});
    thisupdateServiceHealth('validation', 'healthy', {});
    thisupdateServiceHealth('feedback', 'healthy', {});
    thisupdateServiceHealth('automation', 'healthy', {});
    thisupdateServiceHealth('knowledge', 'healthy', {});
  };

  /**;
   * Shutdown all sub-services;
   */;
  private async shutdownServices(): Promise<void> {;
    await Promiseall([;
      thisscraperServiceshutdown();
      thisfeedbackServiceshutdown();
      thisupdateAutomationshutdown();
      thisknowledgeManagershutdown();
    ]);
  ;
};

  /**;
   * Schedule learning cycles;
   */;
  private scheduleLearningCycles(): void {;
    // Main learning cycle - every 6 hours;
    const mainCycle = cronschedule('0 */6 * * *', () => {;
      thisrunLearningCycle()catch((error instanceof Error ? errormessage : String(error)=> {;
        loggererror('Scheduled learning cycle failed:', error instanceof Error ? errormessage : String(error);
      });
    });
    thisscheduledJobsset('main_cycle', mainCycle);
    mainCyclestart();
    // Quick validation cycle - every hour;
    const validationCycle = cronschedule('30 * * * *', async () => {;
      if (thiscurrentCycle) return; // Don't run if main cycle is active;

      try {;
        await thisrunValidationPhase();
      } catch (error) {;
        loggererror('Scheduled validation failed:', error instanceof Error ? errormessage : String(error)  ;
};
    });
    thisscheduledJobsset('validation_cycle', validationCycle);
    validationCyclestart();
  };

  /**;
   * Schedule health checks;
   */;
  private scheduleHealthChecks(): void {;
    const healthCheck = cronschedule('*/15 * * * *', () => {;
      thischeckSystemHealth()catch((error instanceof Error ? errormessage : String(error)=> {;
        loggererror('Health check failed:', error instanceof Error ? errormessage : String(error);
      });
    });
    thisscheduledJobsset('health_check', healthCheck);
    healthCheckstart();
  };

  /**;
   * Schedule optimization runs;
   */;
  private scheduleOptimization(): void {;
    // Daily optimization;
    const optimization = cronschedule('0 4 * * *', async () => {;
      if (thiscurrentCycle) return;
      try {;
        await thisrunOptimizationPhase();
      } catch (error) {;
        loggererror('Scheduled optimization failed:', error instanceof Error ? errormessage : String(error)  ;
};
    });
    thisscheduledJobsset('optimization', optimization);
    optimizationstart();
  };

  /**;
   * Check system health;
   */;
  private async checkSystemHealth(): Promise<void> {;
    try {;
      // Check scraper health;
      const scraperStats = await thisgetScraperHealth();
      thisupdateServiceHealth('scraper', scraperStatsstatus, scraperStats);
      // Check validation health;
      const validationStats = await thisgetValidationHealth();
      thisupdateServiceHealth('validation', validationStatsstatus, validationStats);
      // Check feedback health;
      const feedbackStats = await thisgetFeedbackHealth();
      thisupdateServiceHealth('feedback', feedbackStatsstatus, feedbackStats);
      // Check automation health;
      const automationStats = await thisupdateAutomationgetStatistics();
      const automationStatus =;
        automationStatsrecentFailures > automationStatsrecentCompletions * 0.5;
          ? 'unhealthy';
          : automationStatsactiveJobs > 10;
            ? 'degraded';
            : 'healthy';
      thisupdateServiceHealth('automation', automationStatus, automationStats);
      // Check knowledge manager health;
      const knowledgeStats = await thisknowledgeManagergetMetrics();
      const knowledgeStatus = knowledgeStatstotal_items === 0 ? 'unhealthy' : 'healthy';
      thisupdateServiceHealth('knowledge', knowledgeStatus, knowledgeStats);
      // Check overall health;
      const overallHealth = thiscalculateOverallHealth();
      if (overallHealthstatus !== 'healthy') {;
        await thiscreateAlert(;
          'system_health';
          overallHealthstatus === 'unhealthy' ? 'critical' : 'medium';
          'System Health Degraded';
          `${overallHealthunhealthyServiceslength} services are experiencing issues`;
          overallHealthissues;
        );
      };
    } catch (error) {;
      loggererror('Error checking system health:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  // Helper methods;

  private async identifySourcesForCollection(): Promise<any[]> {;
    const { KNOWLEDGE_SOURCES } = await import('../config/knowledge-sources');
    // Filter enabled sources with high priority;
    return KNOWLEDGE_SOURCESfilter((s) => senabled && spriority === 'high')slice(0, 3); // Limit to prevent overload;
  };

  private async getSourceConfig(sourceId: string): Promise<unknown> {;
    const { KNOWLEDGE_SOURCES } = await import('../config/knowledge-sources');
    return KNOWLEDGE_SOURCESfind((s) => sid === sourceId);
  };

  private async updateKnowledgeRelationships(): Promise<void> {;
    // This would analyze integration patterns and update relationships;
    loggerinfo('Updating knowledge relationships based on integration patterns');
  ;
};

  private async performMaintenance(): Promise<void> {;
    loggerinfo('Performing system maintenance');
    // Clean old analytics data (older than 30 days);
    const thirtyDaysAgo = new Date(Datenow() - 30 * 24 * 60 * 60 * 1000);
    await supabase;
      from('knowledge_usage_analytics');
      delete();
      lt('created_at', thirtyDaysAgotoISOString());
    // Archive old alerts;
    await supabase;
      from('knowledge_monitoring_alerts');
      update({ status: 'archived' });
      eq('status', 'resolved');
      lt('resolved_at', thirtyDaysAgotoISOString());
  };

  private async storeCycleResults(): Promise<void> {;
    if (!thiscurrentCycle) return;
    await supabasefrom('learning_cycles')insert({;
      cycle_id: thiscurrentCyclecycleId;
      start_time: thiscurrentCyclestartTime;
      end_time: thiscurrentCycleendTime;
      items_processed: thiscurrentCycleitemsProcessed;
      items_validated: thiscurrentCycleitemsValidated;
      items_integrated: thiscurrentCycleitemsIntegrated;
      insights: thiscurrentCycleinsights;
      errors: thiscurrentCycleerrors;
      metadata: {;
        duration: thiscurrentCycleendTime;
          ? thiscurrentCycleendTimegetTime() - thiscurrentCyclestartTimegetTime();
          : 0;
      ;
};
    });
  };

  private updateServiceHealth(;
    service: string;
    status: 'healthy' | 'degraded' | 'unhealthy';
    metrics: Record<string, unknown>;
  ): void {;
    const issues: string[] = [];
    if (status === 'unhealthy') {;
      issuespush(`${service} service is unhealthy`);
    } else if (status === 'degraded') {;
      issuespush(`${service} service is degraded`);
    };

    thisserviceHealthset(service, {;
      service;
      status;
      lastCheck: new Date();
      issues;
      metrics;
    });
  };

  private async getScraperHealth(): Promise<unknown> {;
    // Check last scrape times;
    const { data: recentScrapes } = await supabase;
      from('scraped_knowledge');
      select('source_id, scraped_at');
      gte('scraped_at', new Date(Datenow() - 24 * 60 * 60 * 1000)toISOString());
      limit(100);
    const status = recentScrapes && recentScrapeslength > 0 ? 'healthy' : 'unhealthy';
    return {;
      status;
      recentScrapeCount: recentScrapes?length || 0;
      lastScrapeTime: recentScrapes?.[0]?scraped_at;
    ;
};
  };

  private async getValidationHealth(): Promise<unknown> {;
    const { data: pendingValidations } = await supabase;
      from('scraped_knowledge');
      select('id', { count: 'exact' });
      eq('validation_status', 'pending');
    const backlog = pendingValidations?length || 0;
if (    const status = backlog > 100) { return 'degraded'} else if (backlog > 500) { return 'unhealthy'} else { return 'healthy'};

    return {;
      status;
      validationBacklog: backlog;
    ;
};
  };

  private async getFeedbackHealth(): Promise<unknown> {;
    const patterns = thisfeedbackServicegetPatterns();
    const insights = thisfeedbackServicegetInsights();
    const status = patternssize > 0 ? 'healthy' : 'degraded';
    return {;
      status;
      activePatterns: patternssize;
      recentInsights: insightslength;
    ;
};
  };

  private calculateOverallHealth(): {;
    status: 'healthy' | 'degraded' | 'unhealthy';
    unhealthyServices: string[];
    issues: any[];
  } {;
    const unhealthyServices: string[] = [];
    const issues: any[] = [];
    for (const [service, health] of thisserviceHealth) {;
      if (healthstatus === 'unhealthy') {;
        unhealthyServicespush(service);
        issuespush({ ..health, service });
      };
    };

    const status =;
      unhealthyServiceslength === 0;
        ? 'healthy';
        : unhealthyServiceslength <= 2;
          ? 'degraded';
          : 'unhealthy';
    return { status, unhealthyServices, issues };
  };

  private async createAlert(;
    alertType: string;
    severity: string;
    title: string;
    description: string;
    affectedItems: any[];
  ): Promise<void> {;
    await supabasefrom('knowledge_monitoring_alerts')insert({;
      alert_type: alertType;
      severity;
      title;
      description;
      affected_items: affectedItems;
    });
    thisemit('alert_created', { alertType, severity, title });
  };

  /**;
   * Get service status;
   */;
  getStatus(): {;
    isRunning: boolean;
    currentCycle: LearningCycle | null;
    serviceHealth: ServiceHealth[];
    scheduledJobs: string[];
  } {;
    return {;
      isRunning: thisisRunning;
      currentCycle: thiscurrentCycle;
      serviceHealth: Arrayfrom(thisserviceHealthvalues());
      scheduledJobs: Arrayfrom(thisscheduledJobskeys());
    ;
};
  };

  /**;
   * Trigger manual learning cycle;
   */;
  async triggerManualCycle(): Promise<void> {;
    if (thiscurrentCycle) {;
      throw new Error('A learning cycle is already in progress');
    };

    await thisrunLearningCycle();
  };

  /**;
   * Get learning history;
   */;
  async getLearningHistory(limit = 10): Promise<any[]> {;
    const { data } = await supabase;
      from('learning_cycles');
      select('*');
      order('start_time', { ascending: false });
      limit(limit);
    return data || [];
  };
};

// Export singleton instance;
export const continuousLearningService = new ContinuousLearningService();