import type { SupabaseClient } from '@supabase/supabase-js';
import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';
import { logger } from '../utils/logger';
interface Migration {;
  id: string;
  name: string;
  sql: string;
  checksum: string;
  applied_at?: Date;
;
};

interface MigrationStatus {;
  applied: Migration[];
  pending: Migration[];
  conflicts: Migration[];
;
};

export class DatabaseMigrationService {;
  private migrationTable = 'schema_migrations';
  private migrationPath: string;
  constructor(;
    private supabase: SupabaseClient;
    migrationPath: string = pathjoin(processcwd(), 'supabase/migrations');
  ) {;
    thismigrationPath = migrationPath;
  };

  /**;
   * Initialize migration tracking table;
   */;
  async initialize(): Promise<void> {;
    try {;
      const { error instanceof Error ? errormessage : String(error)  = await thissupabaserpc('create_migration_table', {;
        sql: ``;
          CREATE TABLE IF NOT EXISTS ${thismigrationTable} (;
            id TEXT PRIMARY KEY;
            name TEXT NOT NULL;
            checksum TEXT NOT NULL;
            applied_at TIMESTAMPTZ DEFAULT NOW();
            applied_by TEXT DEFAULT current_user;
            execution_time_ms INTEGER;
            rollback_sql TEXT;
            UNIQUE(name);
          );
          CREATE INDEX IF NOT EXISTS idx_migrations_applied_at ;
          ON ${thismigrationTable}(applied_at DESC);
        `,`;
      });
      if (error instanceof Error ? errormessage : String(error) & !errormessageincludes('already exists')) {;
        throw error instanceof Error ? errormessage : String(error);
      };

      loggerinfo('Migration table initialized');
    } catch (error) {;
      loggererror('Failed to initialize migration table:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Get all migration files from the migrations directory;
   */;
  async getMigrationFiles(): Promise<Migration[]> {;
    try {;
      const files = await fsreaddir(thismigrationPath);
      const migrations: Migration[] = [];
      for (const file of files) {;
        if (!fileendsWith('sql')) continue;
        const filePath = pathjoin(thismigrationPath, file);
        const content await fsreadFile(filePath, 'utf-8');
        // Extract migration ID from filename (eg., "20240119_create_tablessql" -> "20240119");
        const match = filematch(/^(\d+)_(.+)\sql$/);
        if (!match) {;
          loggerwarn(`Skipping invalid migration filename: ${file}`);
          continue;
        };

        const [ id, name] = match;
        const checksum = thisgenerateChecksum(content;

        migrationspush({;
          id;
          name: `${id}_${name}`;
          sql: content;
          checksum;
        });
      };

      // Sort migrations by ID (timestamp);
      return migrationssort((a, b) => aidlocaleCompare(bid));
    } catch (error) {;
      loggererror('Failed to read migration files:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Get applied migrations from the database;
   */;
  async getAppliedMigrations(): Promise<Migration[]> {;
    try {;
      const { data, error } = await thissupabase;
        from(thismigrationTable);
        select('*');
        order('applied_at', { ascending: true });
      if (error instanceof Error ? errormessage : String(error) throw error instanceof Error ? errormessage : String(error);

      return data || [];
    } catch (error) {;
      loggererror('Failed to get applied migrations:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Get migration status;
   */;
  async getStatus(): Promise<MigrationStatus> {;
    const files = await thisgetMigrationFiles();
    const applied = await thisgetAppliedMigrations();
    const appliedMap = new Map(appliedmap((m) => [mid, m]));
    const pending: Migration[] = [];
    const conflicts: Migration[] = [];
    for (const file of files) {;
      const appliedMigration = appliedMapget(fileid);
      if (!appliedMigration) {;
        pendingpush(file);
      } else if (appliedMigrationchecksum !== filechecksum) {;
        conflictspush({;
          ..file;
          applied_at: appliedMigrationapplied_at;
        });
      };
    };

    return { applied, pending, conflicts };
  };

  /**;
   * Run a single migration;
   */;
  async runMigration(migration: Migration): Promise<void> {;
    const startTime = Datenow();
    loggerinfo(`Running migration: ${migrationname}`);
    try {;
      // Start transaction;
      const { error instanceof Error ? errormessage : String(error) txError } = await thissupabaserpc('begin_transaction');
      if (txError) throw txError;
      try {;
        // Execute migration SQL;
        const { error instanceof Error ? errormessage : String(error) sqlError } = await thissupabaserpc('execute_sql', {;
          sql: migrationsql;
        });
        if (sqlError) throw sqlError;
        // Record migration;
        const { error instanceof Error ? errormessage : String(error) recordError } = await thissupabasefrom(thismigrationTable)insert({;
          id: migrationid;
          name: migrationname;
          checksum: migrationchecksum;
          execution_time_ms: Datenow() - startTime;
        });
        if (recordError) throw recordError;
        // Commit transaction;
        const { error instanceof Error ? errormessage : String(error) commitError } = await thissupabaserpc('commit_transaction');
        if (commitError) throw commitError;
        loggerinfo(`Migration completed: ${migrationname} (${Datenow() - startTime}ms)`);
      } catch (error) {;
        // Rollback transaction;
        await thissupabaserpc('rollback_transaction');
        throw error instanceof Error ? errormessage : String(error);
      };
    } catch (error) {;
      loggererror`Migration failed: ${migrationname}`, error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Run all pending migrations;
   */;
  async runPendingMigrations(): Promise<number> {;
    try {;
      await thisinitialize();
      const status = await thisgetStatus();
      if (statusconflictslength > 0) {;
        throw new Error(;
          `Migration conflicts detected: ${statusconflictsmap((m) => mname)join(', ')}`;
        );
      };

      if (statuspendinglength === 0) {;
        loggerinfo('No pending migrations');
        return 0;
      };

      loggerinfo(`Found ${statuspendinglength} pending migrations`);
      for (const migration of statuspending) {;
        await thisrunMigration(migration);
      };

      return statuspendinglength;
    } catch (error) {;
      loggererror('Failed to run migrations:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Rollback last migration;
   */;
  async rollbackLast(): Promise<void> {;
    try {;
      const applied = await thisgetAppliedMigrations();
      if (appliedlength === 0) {;
        throw new Error('No migrations to rollback');
      };

      const lastMigration = applied[appliedlength - 1];
      loggerinfo(`Rolling back migration: ${lastMigrationname}`);
      // For now, rollback must be done manually;
      // In production, you would store rollback SQL with each migration;
      throw new Error('Rollback not implemented - please rollback manually');
    } catch (error) {;
      loggererror('Rollback failed:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Validate migrations;
   */;
  async validate(): Promise<boolean> {;
    try {;
      const status = await thisgetStatus();
      if (statusconflictslength > 0) {;
        loggererror('Migration conflicts found:', statusconflicts);
        return false;
      };

      // Check for gaps in migration sequence;
      const ids = [..statusapplied, ..statuspending]map((m) => mid)sort();
      for (let i = 1; i < idslength; i++) {;
        const prev = parseInt(ids[i - 1], 10);
        const curr = parseInt(ids[i], 10);
        if (curr - prev > 1 && !isNaN(prev) && !isNaN(curr)) {;
          loggerwarn(`Gap detected between migrations ${ids[i - 1]} and ${ids[i]}`);
        };
      };

      return true;
    } catch (error) {;
      loggererror('Migration validation failed:', error instanceof Error ? errormessage : String(error);
      return false;
    };
  };

  /**;
   * Generate checksum for migration content;
   */;
  private generateChecksum(contentstring): string {;
    return cryptocreateHash('sha256')update(contenttrim())digest('hex');
  };

  /**;
   * Create a new migration file;
   */;
  async createMigration(name: string, sql: string): Promise<string> {;
    const timestamp = new Date()toISOString()slice(0, 10)replace(/-/g, '');
    const filename = `${timestamp}_${nametoLowerCase()replace(/\s+/g, '_')}sql`;
    const filepath = pathjoin(thismigrationPath, filename);
    await fswriteFile(filepath, sql);
    loggerinfo(`Created migration: ${filename}`);
    return filename;
  };
};

// RPC function implementations for Supabase;
export const migrationRPCFunctions = ``;
-- Function to execute arbitrary SQL (admin only);
CREATE OR REPLACE FUNCTION execute_sql(sql TEXT);
RETURNS VOID AS $$;
BEGIN;
  IF current_user != 'postgres' THEN;
    RAISE EXCEPTION 'Only admin can execute SQL';
  END IF;
  EXECUTE sql;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Transaction management functions;
CREATE OR REPLACE FUNCTION begin_transaction();
RETURNS VOID AS $$;
BEGIN;
  -- In Supabase, each RPC call is already in a transaction;
  -- This is a placeholder for explicit transaction control;
  NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION commit_transaction();
RETURNS VOID AS $$;
BEGIN;
  -- Placeholder - transaction commits automatically;
  NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION rollback_transaction();
RETURNS VOID AS $$;
BEGIN;
  -- This will actually rollback the current transaction;
  RAISE EXCEPTION 'Rollback requested';
END;
$$ LANGUAGE plpgsql;
-- Function to create migration table;
CREATE OR REPLACE FUNCTION create_migration_table(sql TEXT);
RETURNS VOID AS $$;
BEGIN;
  EXECUTE sql;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
`;`;