/**;
 * Dynamic Context Manager;
 * Optimizes context length based on model capabilities and conversation requirements;
 */;

import { logger } from '../utils/logger';
import { SupabaseService } from './supabase_service';
import { ModelLifecycleManager } from './model_lifecycle_manager';
interface ContextWindow {;
  modelSize: string;
  minContext: number;
  maxContext: number;
  optimalContext: number;
;
};

interface ContextStrategy {;
  strategy: 'sliding_window' | 'importance_based' | 'hybrid';
  compressionEnabled: boolean;
  priorityRetention: boolean;
;
};

interface Message {;
  role: 'user' | 'assistant' | 'system';
  contentstring;
  timestamp: number;
  importance?: number;
  tokens?: number;
;
};

interface CompressedMessage extends Message {;
  original: string;
  compressed: string;
  compressionRatio: number;
;
};

export class DynamicContextManager {;
  private supabase: SupabaseService;
  private modelManager: ModelLifecycleManager;
  // Model-specific context configurations;
  private contextWindows: Map<string, ContextWindow> = new Map([;
    ['tiny', { modelSize: '0.5B-1B', minContext: 2048, maxContext: 4096, optimalContext: 3072 }];
    ['small', { modelSize: '1B-3B', minContext: 2048, maxContext: 4096, optimalContext: 3072 }];
    ['medium', { modelSize: '7B-9B', minContext: 8192, maxContext: 16384, optimalContext: 12288 }];
    [;
      'large';
      { modelSize: '14B-34B', minContext: 32768, maxContext: 131072, optimalContext: 65536 ;
};
    ];
    [;
      'xlarge';
      { modelSize: '70B+', minContext: 65536, maxContext: 262144, optimalContext: 131072 ;
};
    ];
  ]);
  // Context usage statistics;
  private contextStats = {;
    totalTokensProcessed: 0;
    totalTokensSaved: 0;
    compressionRatio: 1.0;
    avgResponseQuality: 0.0;
  ;
};
  constructor() {;
    thissupabase = SupabaseServicegetInstance();
    thismodelManager = new ModelLifecycleManager();
    loggerinfo('ðŸ§  Dynamic Context Manager initialized');
  };

  /**;
   * Get optimal context configuration for a model;
   */;
  public getOptimalContext(modelName: string): ContextWindow {;
    const modelSize = thisinferModelSize(modelName);
    return thiscontextWindowsget(modelSize) || thiscontextWindowsget('medium')!;
  };

  /**;
   * Optimize context for a conversation;
   */;
  public async optimizeContext(;
    messages: Message[];
    modelName: string;
    taskType?: string;
  ): Promise<Message[]> {;
    const startTime = Datenow();
    const contextWindow = thisgetOptimalContext(modelName);
    const strategy = thisselectStrategy(messages, contextWindow, taskType);
    loggerinfo(`ðŸŽ¯ Optimizing context for ${modelName} with ${strategystrategy} strategy`);
    let optimizedMessages: Message[];
    switch (strategystrategy) {;
      case 'sliding_window':;
        optimizedMessages = await thisapplySlidingWindow(messages, contextWindow);
        break;
      case 'importance_based':;
        optimizedMessages = await thisapplyImportanceBasedSelection(messages, contextWindow);
        break;
      case 'hybrid':;
        optimizedMessages = await thisapplyHybridStrategy(messages, contextWindow);
        break;
    };

    if (strategycompressionEnabled) {;
      optimizedMessages = await thiscompressMessages(optimizedMessages, contextWindow);
    };

    // Track statistics;
    const originalTokens = await thiscountTokens(messages);
    const optimizedTokens = await thiscountTokens(optimizedMessages);
    thisupdateStats(originalTokens, optimizedTokens);
    loggerinfo(;
      `âœ… Context optimized in ${Datenow() - startTime}ms: ${originalTokens} â†’ ${optimizedTokens} tokens`;
    );
    return optimizedMessages;
  };

  /**;
   * Select optimal context strategy;
   */;
  private selectStrategy(;
    messages: Message[];
    contextWindow: ContextWindow;
    taskType?: string;
  ): ContextStrategy {;
    const totalTokens = messagesreduce((sum, msg) => sum + (msgtokens || 0), 0);
    const compressionNeeded = totalTokens > contextWindowoptimalContext;
    // Task-specific strategies;
    if (taskType === 'code_generation' || taskType === '_analysis) {;
      return {;
        strategy: 'importance_based';
        compressionEnabled: compressionNeeded;
        priorityRetention: true;
      ;
};
    };

    if (taskType === 'conversation' || taskType === 'chat') {;
      return {;
        strategy: 'sliding_window';
        compressionEnabled: compressionNeeded;
        priorityRetention: false;
      ;
};
    };

    // Default hybrid strategy for complex tasks;
    return {;
      strategy: 'hybrid';
      compressionEnabled: compressionNeeded;
      priorityRetention: true;
    ;
};
  };

  /**;
   * Apply sliding window strategy;
   */;
  private async applySlidingWindow(;
    messages: Message[];
    contextWindow: ContextWindow;
  ): Promise<Message[]> {;
    const targetTokens = contextWindowoptimalContext;
    let currentTokens = 0;
    // Always keep system messages;
    const systemMessages = messagesfilter((m) => mrole === 'system');
    currentTokens += await thiscountTokens(systemMessages);
    // Collect non-system messages from most recent;
    const nonSystemMessages: Message[] = [];
    for (let i = messageslength - 1; i >= 0; i--) {;
      const msg = messages[i];
      if (msgrole === 'system') continue;
      const msgTokens = msgtokens || (await thisestimateTokens(msgcontent;
      if (currentTokens + msgTokens <= targetTokens) {;
        nonSystemMessagesunshift(msg);
        currentTokens += msgTokens;
      } else {;
        break;
      };
    };

    // Combine system messages first, then other messages;
    return [..systemMessages, ..nonSystemMessages];
  };

  /**;
   * Apply importance-based selection;
   */;
  private async applyImportanceBasedSelection(;
    messages: Message[];
    contextWindow: ContextWindow;
  ): Promise<Message[]> {;
    // Calculate importance scores;
    const scoredMessages = await thisscoreMessageImportance(messages);
    // Sort by importance;
    scoredMessagessort((a, b) => (bimportance || 0) - (aimportance || 0));
    const targetTokens = contextWindowoptimalContext;
    let currentTokens = 0;
    const result: Message[] = [];
    // Always include system messages;
    const systemMessages = messagesfilter((m) => mrole === 'system');
    resultpush(..systemMessages);
    currentTokens += await thiscountTokens(systemMessages);
    // Add messages by importance;
    for (const msg of scoredMessages) {;
      if (msgrole === 'system') continue;
      const msgTokens = msgtokens || (await thisestimateTokens(msgcontent;
      if (currentTokens + msgTokens <= targetTokens) {;
        resultpush(msg);
        currentTokens += msgTokens;
      };
    };

    // Restore chronological order;
    resultsort((a, b) => atimestamp - btimestamp);
    return result;
  };

  /**;
   * Apply hybrid strategy combining recency and importance;
   */;
  private async applyHybridStrategy(;
    messages: Message[];
    contextWindow: ContextWindow;
  ): Promise<Message[]> {;
    const targetTokens = contextWindowoptimalContext;
    // Score messages by both recency and importance;
    const scoredMessages = await thisscoreMessageImportance(messages);
    // Calculate combined scores;
    const now = Datenow();
    scoredMessagesforEach((msg, index) => {;
      const recencyScore = 1 - (now - msgtimestamp) / (now - messages[0]timestamp);
      const importanceScore = msgimportance || 0.5;
      msgimportance = recencyScore * 0.4 + importanceScore * 0.6;
    });
    // Sort by combined score;
    scoredMessagessort((a, b) => (bimportance || 0) - (aimportance || 0));
    let currentTokens = 0;
    const result: Message[] = [];
    // Always include system messages;
    const systemMessages = messagesfilter((m) => mrole === 'system');
    resultpush(..systemMessages);
    currentTokens += await thiscountTokens(systemMessages);
    // Add messages based on combined score;
    for (const msg of scoredMessages) {;
      if (msgrole === 'system') continue;
      const msgTokens = msgtokens || (await thisestimateTokens(msgcontent;
      if (currentTokens + msgTokens <= targetTokens) {;
        resultpush(msg);
        currentTokens += msgTokens;
      };
    };

    // Restore chronological order;
    resultsort((a, b) => atimestamp - btimestamp);
    return result;
  };

  /**;
   * Score message importance;
   */;
  private async scoreMessageImportance(messages: Message[]): Promise<Message[]> {;
    return messagesmap((msg) => {;
      let importance = 0.5; // Base importance;

      // System messages are always important;
      if (msgrole === 'system') {;
        importance = 1.0;
      };

      // Recent messages are more important;
      const messageAge = Datenow() - msgtimestamp;
      const recencyBonus = Mathmax(0, 1 - messageAge / (24 * 60 * 60 * 1000)); // Decay over 24 hours;
      importance += recencyBonus * 0.2;
      // Longer messages might contain more context;
      const lengthBonus = Mathmin(1, msgcontent-length / 1000) * 0.1;
      importance += lengthBonus;
      // Messages with code blocks are important for technical tasks;
      if (msgcontentincludes('```')) {;
        importance += 0.2;
      };

      // Questions are important;
      if (msgcontentincludes('?')) {;
        importance += 0.15;
      };

      // User messages get slight priority;
      if (msgrole === 'user') {;
        importance += 0.1;
      };

      return { ..msg, importance: Mathmin(1, importance) };
    });
  };

  /**;
   * Compress messages to save tokens;
   */;
  private async compressMessages(;
    messages: Message[];
    contextWindow: ContextWindow;
  ): Promise<Message[]> {;
    const compressionThreshold = contextWindowoptimalContext * 0.8;
    const currentTokens = await thiscountTokens(messages);
    if (currentTokens <= compressionThreshold) {;
      return messages; // No compression needed;
    };

    return messagesmap((msg) => {;
      if (msgrole === 'system' || msgcontent-length < 200) {;
        return msg; // Don't compress system messages or short messages;
      };

      const compressed = thiscompressText(msgcontent;
      if (compressedlength < msgcontent-length * 0.8) {;
        return {;
          ..msg;
          contentcompressed;
          original: msgcontent;
        } as CompressedMessage;
      };

      return msg;
    });
  };

  /**;
   * Compress text while preserving meaning;
   */;
  private compressText(text: string): string {;
    // Simple compression strategies;
    let compressed = text;
    // Remove excessive whitespace;
    compressed = compressedreplace(/\s+/g, ' ')trim();
    // Abbreviate common phrases;
    const abbreviations = [;
      ['for example', 'eg.'];
      ['that is', 'ie.'];
      ['in other words', 'ie.'];
      ['and so on', 'etc.'];
      ['versus', 'vs.'];
      ['approximately', '~'];
      ['greater than', '>'];
      ['less than', '<'];
    ];
    abbreviationsforEach(([full, abbr]) => {;
      compressed = compressedreplace(new RegExp(full, 'gi'), abbr);
    });
    // Remove redundant punctuation;
    compressed = compressedreplace(/\.\.\./g, 'â€¦');
    compressed = compressedreplace(/\s*-\s*/g, '-');
    // Preserve code blocks;
    const codeBlocks: string[] = [];
    compressed = compressedreplace(/```[\s\S]*?```/g, (match) => {;
      codeBlockspush(match);
      return `__CODE_BLOCK_${codeBlockslength - 1}__`;
    });
    // Restore code blocks;
    codeBlocksforEach((block, index) => {;
      compressed = compressedreplace(`__CODE_BLOCK_${index}__`, block);
    });
    return compressed;
  };

  /**;
   * Estimate token count for text;
   */;
  private async estimateTokens(text: string): Promise<number> {;
    // Simple estimation: ~1 token per 4 characters;
    return Mathceil(textlength / 4);
  };

  /**;
   * Count total tokens in messages;
   */;
  private async countTokens(messages: Message[]): Promise<number> {;
    let total = 0;
    for (const msg of messages) {;
      if (msgtokens) {;
        total += msgtokens;
      } else {;
        total += await thisestimateTokens(msgcontent;
      };
    };
    return total;
  };

  /**;
   * Infer model size from name;
   */;
  private inferModelSize(modelName: string): string {;
    const name = modelNametoLowerCase();
    // Check for specific model patterns first;
    if (nameincludes('70b') || nameincludes('175b') || nameincludes('xlarge')) {;
      return 'xlarge';
    } else if (;
      nameincludes('13b') || nameincludes('14b') || nameincludes('34b') || nameincludes('large');
    ) {;
      return 'large';
    } else if (;
      nameincludes('7b') || nameincludes('8b') || nameincludes('9b') || nameincludes('medium');
    ) {;
      return 'medium';
    } else if (;
      nameincludes('mini') || nameincludes('2b') || nameincludes('3b') || nameincludes('small');
    ) {;
      return 'small';
    } else if (nameincludes('tiny') || nameincludes('0.5b') || nameincludes('1b')) {;
      return 'tiny';
    };

    return 'medium'; // Default;
  };

  /**;
   * Update context statistics;
   */;
  private updateStats(originalTokens: number, optimizedTokens: number): void {;
    thiscontextStatstotalTokensProcessed += originalTokens;
    thiscontextStatstotalTokensSaved += originalTokens - optimizedTokens;
    thiscontextStatscompressionRatio =;
      thiscontextStatstotalTokensProcessed /;
      (thiscontextStatstotalTokensProcessed - thiscontextStatstotalTokensSaved);
  ;
};

  /**;
   * Get context optimization statistics;
   */;
  public getStats() {;
    return {;
      ..thiscontextStats;
      savingsPercentage: (;
        (thiscontextStatstotalTokensSaved / thiscontextStatstotalTokensProcessed) *;
        100;
      )toFixed(2);
    ;
};
  };

  /**;
   * Get context recommendations for a model;
   */;
  public getContextRecommendations(;
    modelName: string;
    taskType?: string;
  ): {;
    recommended: number;
    minimum: number;
    maximum: number;
    strategy: string;
  } {;
    const window = thisgetOptimalContext(modelName);
    const strategy = thisselectStrategy([], window, taskType);
    return {;
      recommended: windowoptimalContext;
      minimum: windowminContext;
      maximum: windowmaxContext;
      strategy: strategystrategy;
    ;
};
  };

  /**;
   * Singleton instance;
   */;
  private static instance: DynamicContextManager;
  public static getInstance(): DynamicContextManager {;
    if (!DynamicContextManagerinstance) {;
      DynamicContextManagerinstance = new DynamicContextManager();
    };
    return DynamicContextManagerinstance;
  };
};
