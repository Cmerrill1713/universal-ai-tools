import type { SupabaseClient } from '@supabase/supabase-js';
import type { RedisClientType } from 'redis';
import os from 'os';
import { logger } from '../utils/logger';
import { circuitBreaker } from './circuit-breaker';
// Conditionally import kokoro-tts-service to handle missing dependencies;
let kokoroTTS: any;
try {;
  const kokoroModule = require('./kokoro-tts-service');
  kokoroTTS = kokoroModulekokoroTTS} catch (error) {;
  // Kokoro TTS not available;
};

// Conditionally import ollama-assistant to handle missing dependencies;
let getOllamaAssistant: any;
try {;
  const ollamaModule = require('./ollama-assistant');
  getOllamaAssistant = ollamaModulegetOllamaAssistant} catch (error) {;
  // Ollama assistant not available;
};
import axios from 'axios';
import type { DatabaseMigrationService } from './database-migration';
import { redisHealthCheck } from './redis-health-check';
export interface HealthStatus {;
  healthy: boolean;
  status: 'healthy' | 'degraded' | 'unhealthy';
  message?: string;
  details?: any;
  lastCheck?: Date;
};

export interface ServiceHealth {;
  database: HealthStatus;
  redis: HealthStatus;
  ollama: HealthStatus;
  kokoro: HealthStatus;
  storage: HealthStatus;
  memory: HealthStatus;
  cpu: HealthStatus;
  disk: HealthStatus;
  migrations: HealthStatus;
  circuitBreakers: HealthStatus;
};

export interface HealthCheckResult {;
  status: 'healthy' | 'degraded' | 'unhealthy';
  version: string;
  uptime: number;
  timestamp: string;
  services: ServiceHealth;
  metrics: {;
    cpu: {;
      usage: number;
      loadAverage: number[];
};
    memory: {;
      used: number;
      total: number;
      percentage: number;
};
    disk: {;
      used: number;
      total: number;
      percentage: number;
};
    requestsPerMinute?: number;
    averageResponseTime?: number;
  ;
};
  dependencies: {;
    name: string;
    version: string;
    healthy: boolean}[];
  // Enhanced monitoring features;
  healthScore: number; // 0-100;
  trends: {;
    status: 'improving' | 'stable' | 'degrading';
    score: number; // Change in health score over time};
  alerts: Array<{;
    level: 'info' | 'warning' | 'error instanceof Error ? errormessage : String(error) | 'critical';
    message: string;
    service?: string;
    timestamp: string}>;
  suggestions: string[];
  telemetry?: {;
    traceId?: string;
    spanId?: string;
    activeSpans: number;
    tracingEnabled: boolean;
};
};

export interface HealthHistory {;
  timestamp: Date;
  status: 'healthy' | 'degraded' | 'unhealthy';
  score: number;
  responseTime: number;
  services: Record<string, 'healthy' | 'degraded' | 'unhealthy'>};

export class HealthCheckService {;
  private startTime: Date;
  private healthChecks: Map<string, () => Promise<HealthStatus>> = new Map();
  private healthHistory: HealthHistory[] = [];
  private lastHealthScore = 100;
  private requestMetrics: {;
    totalRequests: number;
    requestsInLastMinute: number[];
    responseTimes: number[];
    lastMinuteStart: number} = {;
    totalRequests: 0;
    requestsInLastMinute: [];
    responseTimes: [];
    lastMinuteStart: Datenow();
};
  constructor(;
    private supabase: SupabaseClient;
    private redis?: RedisClientType;
    private migrationService?: DatabaseMigrationService;
  ) {;
    thisstartTime = new Date();
    thisregisterHealthChecks();
    thisstartMetricsCleanup();
};

  private registerHealthChecks() {;
    // Database health check;
    thishealthChecksset('database', async () => {;
      try {;
        // First try a simple query that should always work;
        const { data, error } = await thissupabaserpc('health_check_db', {});
        if (error instanceof Error ? errormessage : String(error){;
          // Fallback to a simple table query if the RPC doesn't exist;
          const { data: fallbackData, error instanceof Error ? errormessage : String(error) fallbackError } = await thissupabase;
            from('ai_memories');
            select('id');
            limit(1);
          if (fallbackError) {;
            throw fallbackError};
        };

        return {;
          healthy: true;
          status: 'healthy';
          message: 'Database connection successful';
};
      } catch (error instanceof Error ? errormessage : String(error) any) {;
        // Try one more simple query;
        try {;
          await thissupabaseauthgetSession();
          return {;
            healthy: true;
            status: 'healthy';
            message: 'Database connection via auth successful';
};
        } catch (authError: any) {;
          return {;
            healthy: false;
            status: 'unhealthy';
            message: 'Database connection failed';
            details: `${errormessage} (Auth fallback also failed: ${authErrormessage})`};
        };
      };
    });
    // Redis health check;
    thishealthChecksset('redis', async () => {;
      try {;
        // Use the comprehensive Redis health check service;
        const redisHealth = await redisHealthCheckperformHealthCheck();
        return {;
          healthy: redisHealthstatus !== 'unhealthy';
          status: redisHealthstatus;
          message: redisHealthstatus === 'healthy';
              ? 'Redis is operating normally';
              : redisHealthstatus === 'degraded';
                ? 'Redis is experiencing issues';
                : 'Redis is unavailable';
          details: {;
            connected: redisHealthconnected;
            latency: redisHealthlatency;
            memoryUsage: redisHealthmemoryUsage;
            connectedClients: redisHealthconnectedClients;
            uptime: redisHealthuptime;
            fallbackCacheActive: redisHealthfallbackCacheActive;
            errors: redisHealthdetailserrors;
            warnings: redisHealthdetailswarnings}};
      } catch (error instanceof Error ? errormessage : String(error) any) {;
        return {;
          healthy: false;
          status: 'unhealthy';
          message: 'Redis health check failed';
          details: errormessage;
};
      };
    });
    // Ollama health check;
    thishealthChecksset('ollama', async () => {;
      if (!getOllamaAssistant) {;
        return {;
          healthy: false;
          status: 'degraded';
          message: 'Ollama assistant not available';
          details: 'Module not loaded';
};
      };

      try {;
        const ollamaAssistant = getOllamaAssistant(thissupabase),;

        if (!ollamaAssistant || typeof ollamaAssistantcheckAvailability !== 'function') {;
          return {;
            healthy: false;
            status: 'degraded';
            message: 'Ollama assistant invalid';
            details: 'Assistant instance or method not available';
};
        };

        const isAvailable = await ollamaAssistantcheckAvailability();
        return {;
          healthy: isAvailable;
          status: isAvailable ? 'healthy' : 'degraded';
          message: isAvailable ? 'Ollama service available' : 'Ollama service unavailable';
};
      } catch (error instanceof Error ? errormessage : String(error) any) {;
        return {;
          healthy: false;
          status: 'degraded';
          message: 'Ollama check failed';
          details: errormessage;
};
      };
    });
    // Kokoro TTS health check;
    thishealthChecksset('kokoro', async () => {;
      if (!kokoroTTS) {;
        return {;
          healthy: false;
          status: 'degraded';
          message: 'Kokoro TTS not available';
          details: 'Module not loaded';
};
      };

      try {;
        if (typeof kokoroTTSinitialize === 'function') {;
          await kokoroTTSinitialize();
          return {;
            healthy: true;
            status: 'healthy';
            message: 'Kokoro TTS initialized';
};
        } else {;
          return {;
            healthy: false;
            status: 'degraded';
            message: 'Kokoro TTS initialization method not available';
};
        };
      } catch (error instanceof Error ? errormessage : String(error) any) {;
        return {;
          healthy: false;
          status: 'degraded';
          message: 'Kokoro TTS unavailable';
          details: errormessage;
};
      };
    });
    // Storage health check;
    thishealthChecksset('storage', async () => {;
      try {;
        const { data, error } = await thissupabasestorage;
          from('voice-outputs');
          list('', { limit: 1 });
        if (error instanceof Error ? errormessage : String(error) throw error instanceof Error ? errormessage : String(error);

        return {;
          healthy: true;
          status: 'healthy';
          message: 'Storage buckets accessible';
};
      } catch (error instanceof Error ? errormessage : String(error) any) {;
        return {;
          healthy: false;
          status: 'degraded';
          message: 'Storage access failed';
          details: errormessage;
};
      };
    });
    // Memory health check;
    thishealthChecksset('memory', () => {;
      const memUsage = processmemoryUsage();
      const totalMem = ostotalmem();
      const percentUsed = (memUsageheapUsed / totalMem) * 100,;

      return Promiseresolve({;
        healthy: percentUsed < 80;
        status: percentUsed < 80 ? 'healthy' : percentUsed < 90 ? 'degraded' : 'unhealthy';
        message: `Memory usage: ${percentUsedtoFixed(1)}%`;
        details: {;
          heapUsed: memUsageheapUsed;
          heapTotal: memUsageheapTotal;
          external: memUsageexternal;
          rss: memUsagerss}});
    });
    // CPU health check;
    thishealthChecksset('cpu', () => {;
      const loadAvg = osloadavg();
      const cpuCount = oscpus()length;
      const normalizedLoad = loadAvg[0] / cpuCount,;

      return Promiseresolve({;
        healthy: normalizedLoad < 0.8;
        status: normalizedLoad < 0.8 ? 'healthy' : normalizedLoad < 0.9 ? 'degraded' : 'unhealthy';
        message: `CPU load: ${(normalizedLoad * 100)toFixed(1)}%`;
        details: {;
          loadAverage: loadAvg;
          cpuCount}});
    });
    // Disk health check;
    thishealthChecksset('disk', async () => {;
      try {;
        const { exec } = await import('child_process');
        const { promisify } = await import('util');
        const execAsync = promisify(exec);
        // Use different commands based on platform;
        const isWindows = processplatform === 'win32';
        const command = isWindows ? 'wmic logicaldisk get size,freespace,caption' : 'df -k /';
        const { stdout } = await execAsync(command);
        if (isWindows) {;
          // Parse Windows WMIC output;
          const lines = stdout;
            trim();
            split('\n');
            filter((line) => linetrim());
          if (lineslength < 2) {;
            throw new Error('No disk information available')};

          // Parse the first data line (usually C: drive);
          const dataLine = lines[1]trim()split(/\s+/);
          const freeSpace = parseInt(dataLine[1], 10) || 0;
          const totalSpace = parseInt(dataLine[2], 10) || 1;
          const usedSpace = totalSpace - freeSpace;
          const percentUsed = Mathround((usedSpace / totalSpace) * 100);
          return {;
            healthy: percentUsed < 80;
            status: percentUsed < 80 ? 'healthy' : percentUsed < 90 ? 'degraded' : 'unhealthy';
            message: `Disk usage: ${percentUsed}%`;
            details: {;
              used: usedSpace;
              available: freeSpace;
              total: totalSpace;
              percentUsed}};
        } else {;
          // Parse Unix/Linux df output;
          const lines = stdouttrim()split('\n');
          if (lineslength < 2) {;
            throw new Error('No disk information available')};

          const stats = lines[1]split(/\s+/);
          const percentUsed = parseInt(stats[4]?replace('%', '', 10)) || 0;
          return {;
            healthy: percentUsed < 80;
            status: percentUsed < 80 ? 'healthy' : percentUsed < 90 ? 'degraded' : 'unhealthy';
            message: `Disk usage: ${percentUsed}%`;
            details: {;
              used: parseInt(stats[2], 10) * 1024;
              available: parseInt(stats[3], 10) * 1024;
              total: (parseInt(stats[1], 10) || 0) * 1024;
              percentUsed}};
        };
      } catch (error instanceof Error ? errormessage : String(error) any) {;
        return {;
          healthy: true;
          status: 'healthy';
          message: 'Disk check not available on this platform';
          details: { error instanceof Error ? errormessage : String(error) errormessage: platform: processplatform }};
      };
    });
    // Migrations health check;
    thishealthChecksset('migrations', async () => {;
      if (!thismigrationService) {;
        return {;
          healthy: true;
          status: 'healthy';
          message: 'Migrations not configured';
};
      };

      try {;
        const status = await thismigrationServicegetStatus();
        const hasPending = statuspendinglength > 0;
        const hasConflicts = statusconflictslength > 0;
        return {;
          healthy: !hasConflicts;
          status: hasConflicts ? 'unhealthy' : hasPending ? 'degraded' : 'healthy';
          message: hasConflicts;
            ? `Migration conflicts: ${statusconflictslength}`;
            : hasPending;
              ? `Pending migrations: ${statuspendinglength}`;
              : 'All migrations applied';
          details: {;
            applied: statusappliedlength;
            pending: statuspendinglength;
            conflicts: statusconflictslength}};
      } catch (error instanceof Error ? errormessage : String(error) any) {;
        return {;
          healthy: false;
          status: 'unhealthy';
          message: 'Migration check failed';
          details: errormessage;
};
      };
    });
    // Circuit breakers health check;
    thishealthChecksset('circuitBreakers', () => {;
      const cbHealth = circuitBreakerhealthCheck();
      return Promiseresolve({;
        healthy: cbHealthhealthy;
        status: cbHealthhealthy ? 'healthy' : 'degraded';
        message: cbHealthopenCircuitslength > 0;
            ? `Open circuits: ${cbHealthopenCircuitsjoin(', ')}`;
            : 'All circuits closed';
        details: {;
          metrics: cbHealthmetrics;
          openCircuits: cbHealthopenCircuits}});
    });
  };

  async checkHealth(): Promise<HealthCheckResult> {;
    const startTime = Datenow(),;
    const services: Partial<ServiceHealth> = {};
    // Run all health checks in parallel;
    const checkPromises = Arrayfrom(thishealthChecksentries())map(async ([name, check]) => {;
      try {;
        services[name as keyof ServiceHealth] = await check()} catch (error) {;
        services[name as keyof ServiceHealth] = {;
          healthy: false;
          status: 'unhealthy';
          message: `Health check failed: ${error instanceof Error ? errormessage : String(error),`};
      };
    });
    await Promiseall(checkPromises);
    // Calculate overall status;
    const statuses = Objectvalues(services)map((s) => s?status || 'unhealthy');
    const overallStatus = statusesincludes('unhealthy');
      ? 'unhealthy';
      : statusesincludes('degraded');
        ? 'degraded';
        : 'healthy';
    // Calculate health score;
    const healthScore = thiscalculateHealthScore(services as ServiceHealth);
    // Calculate trends;
    const trends = thiscalculateTrends(healthScore);
    // Generate alerts and suggestions;
    const alerts = thisgenerateAlerts(services as ServiceHealth);
    const suggestions = thisgenerateSuggestions(services as ServiceHealth, healthScore);
    // Get system metrics;
    const memUsage = processmemoryUsage();
    const totalMem = ostotalmem();
    const freeMem = osfreemem();
    const loadAvg = osloadavg();
    // Get telemetry information;
    const telemetry = thisgetTelemetryInfo();
    // Record health history;
    const responseTime = Datenow() - startTime;
    thisrecordHealthHistory(overallStatus, healthScore, responseTime, services as ServiceHealth);
    const result: HealthCheckResult = {;
      status: overallStatus;
      version: processenvnpm_package_version || '1.0.0';
      uptime: Datenow() - thisstartTimegetTime();
      timestamp: new Date()toISOString();
      services: services as ServiceHealth;
      metrics: {;
        cpu: {;
          usage: (loadAvg[0] / oscpus()length) * 100;
          loadAverage: loadAvg};
        memory: {;
          used: totalMem - freeMem;
          total: totalMem;
          percentage: ((totalMem - freeMem) / totalMem) * 100};
        disk: {;
          used: 0, // Populated by disk health check;
          total: 0;
          percentage: 0};
        requestsPerMinute: thiscalculateRequestsPerMinute();
        averageResponseTime: thiscalculateAverageResponseTime()};
      dependencies: thischeckDependencies();
      healthScore;
      trends;
      alerts;
      suggestions;
      telemetry};
    return result;
  };

  private calculateHealthScore(services: ServiceHealth): number {;
    const weights = {;
      database: 30, // Critical;
      redis: 10, // Important but not critical;
      ollama: 20, // AI services are important;
      kokoro: 10, // Voice features;
      storage: 15, // File storage;
      memory: 5, // System resources;
      cpu: 5, // System resources;
      disk: 3, // System resources;
      migrations: 2, // Less critical for runtime;
      circuitBreakers: 0, // Already factored into other services};
    let totalScore = 0;
    let totalWeight = 0;
    for (const [serviceName, serviceHealth] of Objectentries(services)) {;
      const weight = weights[serviceName as keyof typeof weights] || 1;
      totalWeight += weight;
      let serviceScore = 0;
      switch (serviceHealthstatus) {;
        case 'healthy':;
          serviceScore = 100;
          break;
        case 'degraded':;
          serviceScore = 60;
          break;
        case 'unhealthy':;
          serviceScore = 0;
          break;
        default:;
          serviceScore = 0};

      totalScore += serviceScore * weight;
    };

    return totalWeight > 0 ? Mathround(totalScore / totalWeight) : 0;
  };

  private calculateTrends(currentScore: number): {;
    status: 'improving' | 'stable' | 'degrading';
    score: number} {;
    const scoreDifference = currentScore - thislastHealthScore;
    thislastHealthScore = currentScore;
    let status: 'improving' | 'stable' | 'degrading' = 'stable';
    if (scoreDifference > 5) status = 'improving';
    else if (scoreDifference < -5) status = 'degrading';

    return { status, score: scoreDifference };
  };

  private generateAlerts(services: ServiceHealth): Array<{;
    level: 'info' | 'warning' | 'error instanceof Error ? errormessage : String(error) | 'critical';
    message: string;
    service?: string;
    timestamp: string}> {;
    const alerts: Array<{;
      level: 'info' | 'warning' | 'error instanceof Error ? errormessage : String(error) | 'critical';
      message: string;
      service?: string;
      timestamp: string}> = [];
    const timestamp = new Date()toISOString();
    for (const [serviceName, serviceHealth] of Objectentries(services)) {;
      if (serviceHealthstatus === 'unhealthy') {;
        alertspush({;
          level: serviceName === 'database' ? 'critical' : 'error instanceof Error ? errormessage : String(error);
          message: serviceHealthmessage || `Service ${serviceName} is unhealthy`;
          service: serviceName;
          timestamp});
      } else if (serviceHealthstatus === 'degraded') {;
        alertspush({;
          level: 'warning';
          message: serviceHealthmessage || `Service ${serviceName} is degraded`;
          service: serviceName;
          timestamp});
      };
    };

    // Check system resource alerts;
    const memUsage = processmemoryUsage();
    const memPercentage = (memUsageheapUsed / memUsageheapTotal) * 100;
    if (memPercentage > 90) {;
      alertspush({;
        level: 'critical';
        message: `Memory usage critically high: ${memPercentagetoFixed(1)}%`;
        service: 'memory';
        timestamp});
    } else if (memPercentage > 80) {;
      alertspush({;
        level: 'warning';
        message: `Memory usage high: ${memPercentagetoFixed(1)}%`;
        service: 'memory';
        timestamp});
    };

    return alerts;
  };

  private generateSuggestions(services: ServiceHealth, healthScore: number): string[] {;
    const suggestions: string[] = [];
    // Service-specific suggestions;
    for (const [serviceName, serviceHealth] of Objectentries(services)) {;
      if (serviceHealthstatus === 'unhealthy') {;
        switch (serviceName) {;
          case 'database':;
            suggestionspush('Check database connection and credentials');
            suggestionspush('Verify database server is running');
            break;
          case 'redis':;
            suggestionspush('Check Redis server status');
            suggestionspush('Verify Redis connection configuration');
            break;
          case 'ollama':;
            suggestionspush('Start Ollama service');
            suggestionspush('Check Ollama configuration and model availability');
            break;
          case 'memory':;
            suggestionspush('Consider increasing memory allocation');
            suggestionspush('Check for memory leaks');
            suggestionspush('Enable garbage collection optimization');
            break;
          case 'cpu':;
            suggestionspush('Reduce CPU load by scaling services');
            suggestionspush('Check for infinite loops or CPU-intensive operations');
            break};
      };
    };

    // Overall health suggestions;
    if (healthScore < 50) {;
      suggestionspush('System health is critically low - immediate attention required');
      suggestionspush('Consider scaling up resources or restarting services')} else if (healthScore < 70) {;
      suggestionspush('System health is degraded - investigate failing services');
      suggestionspush('Monitor resource usage and optimize as needed')};

    // Remove duplicates;
    return [..new Set(suggestions)];
  };

  private getTelemetryInfo(): {;
    traceId?: string;
    spanId?: string;
    activeSpans: number;
    tracingEnabled: boolean} {;
    try {;
      // Try to get telemetry service information;
      const { telemetryService } = require('./telemetry-service');
      if (telemetryService) {;
        const currentTrace = telemetryServicegetCurrentTraceContext();
        const metrics = telemetryServicegetServiceMetrics(),;

        return {;
          traceId: currentTrace?traceId;
          spanId: currentTrace?spanId;
          activeSpans: metrics?activeSpans || 0;
          tracingEnabled: true;
};
      };
    } catch (error) {;
      // Telemetry service not available or not initialized;
    };

    return {;
      activeSpans: 0;
      tracingEnabled: false;
};
  };

  private recordHealthHistory(;
    status: 'healthy' | 'degraded' | 'unhealthy';
    score: number;
    responseTime: number;
    services: ServiceHealth;
  ): void {;
    const serviceStatuses: Record<string, 'healthy' | 'degraded' | 'unhealthy'> = {};
    for (const [name, service] of Objectentries(services)) {;
      serviceStatuses[name] = servicestatus};

    thishealthHistorypush({;
      timestamp: new Date();
      status;
      score;
      responseTime;
      services: serviceStatuses});
    // Keep only last 1000 entries;
    if (thishealthHistorylength > 1000) {;
      thishealthHistory = thishealthHistoryslice(-1000)};
  };

  /**;
   * Get health history for analysis;
   */;
  getHealthHistory(limit = 100): HealthHistory[] {;
    return thishealthHistoryslice(-limit)};

  /**;
   * Get health trends over time;
   */;
  getHealthTrends(durationMinutes = 60): {;
    averageScore: number;
    trend: 'improving' | 'stable' | 'degrading';
    uptimePercentage: number;
    incidents: number} {;
    const cutoffTime = new Date(Datenow() - durationMinutes * 60 * 1000);
    const recentHistory = thishealthHistoryfilter((h) => htimestamp > cutoffTime),;

    if (recentHistorylength === 0) {;
      return {;
        averageScore: thislastHealthScore;
        trend: 'stable';
        uptimePercentage: 100;
        incidents: 0;
};
    };

    const averageScore = recentHistoryreduce((sum, h) => sum + hscore, 0) / recentHistorylength;
    const healthyCount = recentHistoryfilter((h) => hstatus === 'healthy')length;
    const uptimePercentage = (healthyCount / recentHistorylength) * 100;
    const incidents = recentHistoryfilter((h) => hstatus === 'unhealthy')length;
    // Simple trend calculation;
    const firstHalf = recentHistoryslice(0, Mathfloor(recentHistorylength / 2));
    const secondHalf = recentHistoryslice(Mathfloor(recentHistorylength / 2));
    const firstHalfAvg = firstHalfreduce((sum, h) => sum + hscore, 0) / firstHalflength;
    const secondHalfAvg = secondHalfreduce((sum, h) => sum + hscore, 0) / secondHalflength;
    let trend: 'improving' | 'stable' | 'degrading' = 'stable';
    const difference = secondHalfAvg - firstHalfAvg;
    if (difference > 5) trend = 'improving';
    else if (difference < -5) trend = 'degrading';
    return {;
      averageScore: Mathround(averageScore);
      trend;
      uptimePercentage: Mathround(uptimePercentage * 100) / 100;
      incidents};
  };

  private checkDependencies(): { name: string; version: string, healthy: boolean }[] {;
    const deps = [];
    // Check critical dependencies;
    try {;
      const packageJson = require('../../packagejson');
      const criticalDeps = ['@supabase/supabase-js', 'express', 'zod', 'winston'];
      for (const dep of criticalDeps) {;
        let healthy = true;
        let version = packageJsondependencies[dep] || 'unknown';
        // Try to require the dependency to check if it's actually available;
        try {;
          require(dep)} catch (requireError) {;
          healthy = false;
          version = 'missing'};

        depspush({;
          name: dep;
          version;
          healthy});
      };
    } catch (error) {;
      loggererror('Failed to check dependencies:', error instanceof Error ? errormessage : String(error);
      // Add fallback dependency info if packagejson can't be read;
      const fallbackDeps = ['@supabase/supabase-js', 'express', 'zod', 'winston'],;
      for (const dep of fallbackDeps) {;
        depspush({;
          name: dep;
          version: 'unknown';
          healthy: false});
      };
    };

    return deps;
  };

  async runReadinessCheck(): Promise<boolean> {;
    // Readiness check - is the service ready to accept traffic?;
    const criticalServices = ['database'];
    for (const service of criticalServices) {;
      const check = thishealthChecksget(service);
      if (check) {;
        const result = await check();
        if (!resulthealthy) {;
          return false};
      };
    };

    return true;
  };

  async runLivenessCheck(): Promise<boolean> {;
    // Liveness check - is the service alive and not deadlocked?;
    try {;
      // Simple check that we can allocate memory and respond;
      const testData = Bufferalloc(1024);
      return testDatalength === 1024} catch {;
      return false};
  };

  getUptime(): number {;
    return Datenow() - thisstartTimegetTime()};

  async getDetailedReport(): Promise<string> {;
    const health = await thischeckHealth();
    let report = ``;
Universal AI Tools Health Report;
================================;
Status: ${healthstatustoUpperCase();
};
Version: ${healthversion;
};
Uptime: ${Mathfloor(healthuptime / 1000)}s;
Timestamp: ${healthtimestamp;
};

Services:;
`;`;
    for (const [name, status] of Objectentries(healthservices)) {;
      report += `  ${name}: ${statusstatus} - ${statusmessage}\n`;
      if (statusdetails) {;
        report += `    Details: ${JSONstringify(statusdetails)}\n`;
      };
    };

    report += `;
System Metrics:;
  CPU: ${healthmetricscpuusagetoFixed(1)}% (Load: ${healthmetricscpuloadAveragejoin(', ')});
  Memory: ${healthmetricsmemorypercentagetoFixed(1)}% (${(healthmetricsmemoryused / 1024 / 1024 / 1024)toFixed(2)}GB / ${(healthmetricsmemorytotal / 1024 / 1024 / 1024)toFixed(2)}GB);
Dependencies:;
`;`;
    for (const dep of healthdependencies) {;
      report += `  ${depname}@${depversion}: ${dephealthy ? 'OK' : 'FAILED'}\n`;
    };

    return report;
  };

  /**;
   * Track a requestand its response time;
   */;
  trackRequest(responseTimeMs: number): void {;
    const now = Datenow();
    // Clean up old data if needed;
    thiscleanupOldMetrics(now);
    // Track total requests;
    thisrequestMetricstotalRequests++;
    // Track requests in current minute;
    thisrequestMetricsrequestsInLastMinutepush(now);
    // Track response times (keep last 1000);
    thisrequestMetricsresponseTimespush(responseTimeMs);
    if (thisrequestMetricsresponseTimeslength > 1000) {;
      thisrequestMetricsresponseTimesshift()};
  };

  /**;
   * Calculate requests per minute;
   */;
  private calculateRequestsPerMinute(): number {;
    const now = Datenow();
    thiscleanupOldMetrics(now);
    return thisrequestMetricsrequestsInLastMinutelength};

  /**;
   * Calculate average response time from recent requests;
   */;
  private calculateAverageResponseTime(): number {;
    if (thisrequestMetricsresponseTimeslength === 0) {;
      return 0};

    const sum = thisrequestMetricsresponseTimesreduce((a, b) => a + b, 0);
    return Mathround(sum / thisrequestMetricsresponseTimeslength);
  };

  /**;
   * Clean up metrics older than 1 minute;
   */;
  private cleanupOldMetrics(now: number): void {;
    const oneMinuteAgo = now - 60000; // 60 seconds;

    // Remove requests older than 1 minute;
    thisrequestMetricsrequestsInLastMinute = thisrequestMetricsrequestsInLastMinutefilter(;
      (timestamp) => timestamp > oneMinuteAgo;
    )};

  /**;
   * Start periodic cleanup of old metrics;
   */;
  private startMetricsCleanup(): void {;
    // Clean up every 30 seconds;
    setInterval(() => {;
      thiscleanupOldMetrics(Datenow())}, 30000);
  };

  /**;
   * Get current requestmetrics;
   */;
  getRequestMetrics(): {;
    totalRequests: number;
    requestsPerMinute: number;
    averageResponseTime: number} {;
    return {;
      totalRequests: thisrequestMetricstotalRequests;
      requestsPerMinute: thiscalculateRequestsPerMinute();
      averageResponseTime: thiscalculateAverageResponseTime();
};
  };

  /**;
   * Reset requestmetrics;
   */;
  resetMetrics(): void {;
    thisrequestMetrics = {;
      totalRequests: 0;
      requestsInLastMinute: [];
      responseTimes: [];
      lastMinuteStart: Datenow();
};
  };
};

// Export a factory function to create the health check service;
export function createHealthCheckService(;
  supabase: SupabaseClient;
  redis?: RedisClientType;
  migrationService?: DatabaseMigrationService;
): HealthCheckService {;
  return new HealthCheckService(supabase, redis, migrationService)};

/**;
 * Middleware to track requestmetrics;
 */;
export function createRequestTrackingMiddleware(healthService: HealthCheckService) {;
  return (req: any, res: any, next: any) => {;
    const startTime = Datenow();
    // Track when response finishes;
    reson('finish', () => {;
      const responseTime = Datenow() - startTime;
      healthServicetrackRequest(responseTime)});
    next();
  };
};
