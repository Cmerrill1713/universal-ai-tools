/**;
 * Adaptive Autofix Service - Learns and improves between fixes using feedback loops;
 */;

import fs from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import type { SupabaseClient } from '@supabase/supabase-js';
import { type AutofixMemory, AutofixMemoryService } from './autofix-memory-service';
import { logger } from '../utils/logger';
const execAsync = promisify(exec);
export interface FixValidation {;
  fix_id: string;
  validation_type: 'lint' | 'type_check' | 'build' | 'runtime';
  success: boolean;
  error_count_before: number;
  error_count_after: number;
  improvement_score: number;
  newerrors_introduced: string[];
  validation_time_ms: number;
;
};

export interface LearningInsight {;
  _pattern string;
  success_rate: number;
  confidence_trend: number;
  usage_frequency: number;
  recommended_adjustments: string[];
  file_type_effectiveness: Record<string, number>;
};

export class AdaptiveAutofixService {;
  private supabase: SupabaseClient;
  private memoryService: AutofixMemoryService;
  private sessionId: string;
  private fixHistory: AutofixMemory[] = [];
  private learningInsights: LearningInsight[] = [];
  constructor(supabase: SupabaseClient) {;
    thissupabase = supabase;
    thismemoryService = new AutofixMemoryService(supabase);
    thissessionId = `adaptive_${Datenow()}`;
  };

  /**;
   * Apply a fix with immediate validation and learning;
   */;
  async applyFixWithFeedback(;
    filePath: string;
    fixType: string;
    originalCode: string;
    fixedCode: string;
    reasoning: string;
    lineNumbers?: number[];
  ): Promise<{;
    success: boolean;
    validation: FixValidation;
    learningAdjustments: string[];
  }> {;
    const fixId = `fix_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
    loggerinfo(`üîß Applying fix: ${fixType} in ${pathbasename(filePath)}`);
    // 1. Get baseline errors before fix;
    const beforeValidation = await thisvalidateFile(filePath);
    // 2. Apply the fix;
    let content fsreadFileSync(filePath, 'utf8');
    content contentreplace(originalCode, fixedCode);
    fswriteFileSync(filePath, content;
    // 3. Validate after fix;
    const afterValidation = await thisvalidateFile(filePath);
    // 4. Calculate improvement;
    const improvement = beforeValidationerrorCount - afterValidationerrorCount;
    const improvementScore = improvement / Mathmax(beforeValidationerrorCount, 1);
    // 5. Check for new errors introduced;
    const newErrors = afterValidationerrorsfilter(;
      (error instanceof Error ? errormessage : String(error)=>;
        !beforeValidationerrorssome(;
          (oldError) => oldErrorline === errorline && oldErrormessage === errormessage;
        );
    );
    const validation: FixValidation = {;
      fix_id: fixId;
      validation_type: 'lint';
      success: improvement >= 0 && newErrorslength === 0;
      error_count_before: beforeValidationerrorCount;
      error_count_after: afterValidationerrorCount;
      improvement_score: improvementScore;
      newerrors_introduced: newErrorsmap((e) => emessage);
      validation_time_ms: Datenow() - parseInt(fixIdsplit('_', 10)[1]);
    };
    // 6. Store fix with validation results;
    const fix: AutofixMemory = {;
      id: fixId;
      file_path: filePath;
      fix_type: fixType;
      original_code: originalCode;
      fixed_code: fixedCode;
      reasoning;
      confidence: validationsuccess ? Mathmin(0.9, 0.5 + improvementScore) : 0.2;
      success: validationsuccess;
      session_id: thissessionId;
      metadata: {;
        line_numbers: lineNumbers;
        imports_changed: false;
        types_improved: validationsuccess;
        magic_numbers_extracted: false;
        unused_vars_fixed: false;
      ;
};
    };
    await thismemoryServicestoreFix(fix);
    thisfixHistorypush(fix);
    // 7. Learn from this fix;
    const learningAdjustments = await thislearnFromFix(fix, validation);
    // 8. Update fix patterns (placeholder for future implementation);
    // await thisupdateFixPatterns(fixType, validationsuccess, improvementScore);
    loggerinfo(;
      `üìä Fix ${validationsuccess ? 'succeeded' : 'failed'}: ${improvement} errors fixed, ${newErrorslength} new errors`;
    );
    return {;
      success: validationsuccess;
      validation;
      learningAdjustments;
    ;
};
  };

  /**;
   * Learn from fix outcome and adjust future strategies;
   */;
  private async learnFromFix(fix: AutofixMemory, validation: FixValidation): Promise<string[]> {;
    const adjustments: string[] = [];
    // Learn from success patterns;
    if (validationsuccess && validationimprovement_score > 0.5) {;
      adjustmentspush(;
        `‚úÖ ${fixfix_type} is highly effective for ${pathextname(fixfile_path)} files`;
      );
      // Store successful pattern;
      await thisstoreSuccessPattern(fix);
    };

    // Learn from failures;
    if (!validationsuccess) {;
      adjustmentspush(;
        `‚ùå ${fixfix_type} may need refinement - introduced ${validationnewerrors_introducedlength} new errors`;
      );
      // Analyze what went wrong;
      const failureAnalysis = await thisanalyzeFailure(fix, validation);
      adjustmentspush(..failureAnalysis);
    };

    // Learn from partial success;
    if (validationsuccess && validationimprovement_score < 0.3) {;
      adjustmentspush(`‚ö†Ô∏è ${fixfix_type} has low impact - consider combining with other fixes`);
    };

    // Update learning insights;
    await thisupdateLearningInsights(fix, validation);
    return adjustments;
  };

  /**;
   * Get adaptive recommendations for next fixes;
   */;
  async getAdaptiveRecommendations(;
    filePath: string;
    currentErrors: string[];
  ): Promise<{;
    prioritizedFixes: string[];
    confidenceAdjustments: Record<string, number>;
    avoidPatterns: string[];
    recommendations: string[];
  }> {;
    const fileExtension = pathextname(filePath)slice(1);
    // Get similar fixes from memory;
    const similarFixes = await thismemoryServicegetSimilarFixes(;
      currentErrorsjoin(' ');
      filePath;
      10;
    );
    // Analyze success patterns;
    const successPatterns = similarFixes;
      filter((fix) => fixsuccess && fixconfidence > 0.7);
      map((fix) => fixfix_type);
    const failurePatterns = similarFixesfilter((fix) => !fixsuccess)map((fix) => fixfix_type);
    // Get file-type specific insights;
    const fileTypeInsights = thislearningInsightsfilter(;
      (insight) => insightfile_type_effectiveness[fileExtension] > 0.6;
    );
    // Prioritize fixes based on learning;
    const prioritizedFixes = thisprioritizeFixTypes(successPatterns, fileTypeInsights);
    // Adjust confidence based on past performance;
    const confidenceAdjustments = thiscalculateConfidenceAdjustments(similarFixes);
    return {;
      prioritizedFixes;
      confidenceAdjustments;
      avoidPatterns: [..new Set(failurePatterns)];
      recommendations: [;
        `Focus on ${prioritizedFixesslice(0, 3)join(', ')} - highest success rate`;
        `Avoid ${failurePatternsslice(0, 2)join(', ')} - recent failures in similar files`;
        `Consider batch fixes for ${fileExtension} files - ${fileTypeInsightslength} effective patterns found`;
      ];
    };
  };

  /**;
   * Run continuous learning loop;
   */;
  async runAdaptiveLearningLoop(): Promise<void> {;
    loggerinfo('üß† Starting adaptive learning loop...');
    // 1. Analyze recent fix patterns;
    const recentFixes = thisfixHistoryslice(-20);
    const patterns = thisextractPatterns(recentFixes);
    // 2. Identify declining patterns;
    const decliningPatterns = patternsfilter((p) => psuccess_rate < 0.5);
    // 3. Identify improving patterns;
    const improvingPatterns = patternsfilter((p) => psuccess_rate > 0.8);
    // 4. Update fix strategies;
    for (const _patternof decliningPatterns) {;
      await thisadjustFixStrategy(_pattern_pattern 'reduce_confidence');
    };

    for (const _patternof improvingPatterns) {;
      await thisadjustFixStrategy(_pattern_pattern 'increase_priority');
    };

    // 5. Generate new fix variations;
    const newVariations = await thisgenerateFixVariations(improvingPatterns);
    // 6. Store learning updates;
    await thisstoreLearningUpdate({;
      session_id: thissessionId;
      declining_patterns: decliningPatternsmap((p) => p._pattern;
      improving_patterns: improvingPatternsmap((p) => p._pattern;
      new_variations: newVariations;
      timestamp: new Date()toISOString();
    });
    loggerinfo(;
      `üìà Learning loop complete: ${improvingPatternslength} improving, ${decliningPatternslength} declining patterns`;
    );
  };

  /**;
   * Validate file and get errordetails;
   */;
  private async validateFile(filePath: string): Promise<{;
    errorCount: number;
    errors: Array<{ line: number; message: string, severity: string }>;
  }> {;
    try {;
      const { stdout, stderr } = await execAsync(`npx eslint "${filePath}" --format json`, {;
        cwd: processcwd();
      });
      const results = JSONparse(stdout || '[]');
      const fileResult = results[0];
      if (!fileResult) {;
        return { errorCount: 0, errors: [] };
      };

      return {;
        errorCount: fileResulterrorCount + fileResultwarningCount;
        errors: fileResultmessagesmap((msg: any) => ({;
          line: msgline;
          message: msgmessage;
          severity: msgseverity === 2 ? 'error instanceof Error ? errormessage : String(error): 'warning';
        }));
      };
    } catch (error) {;
      // Fallback to basic errorcount;
      return { errorCount: 0, errors: [] };
    };
  };

  private async storeSuccessPattern(fix: AutofixMemory): Promise<void> {;
    // Store in memory as a successful pattern;
    const content `Successful fix _pattern ${fixfix_type} in ${fixfile_path}`;
    try {;
      await thissupabasefrom('memories')insert({;
        content;
        metadata: {;
          memory_type: 'success__pattern;
          fix_type: fixfix_type;
          file_extension: pathextname(fixfile_path)slice(1);
          confidence: fixconfidence;
          reasoning: fixreasoning;
          tags: ['autofix', 'success__pattern, fixfix_type];
        };
        user_id: 'claude-autofix';
      });
    } catch (error) {;
      loggerwarn('Failed to store success _pattern', error instanceof Error ? errormessage : String(error)  ;
};
  };

  private async analyzeFailure(fix: AutofixMemory, validation: FixValidation): Promise<string[]> {;
    const _analysis string[] = [];
    if (validationnewerrors_introducedlength > 0) {;
      _analysispush(`Fix introduced ${validationnewerrors_introducedlength} new errors`);
      // Common failure patterns;
      const newErrors = validationnewerrors_introducedjoin(' ');
      if (newErrorsincludes('is not defined')) {;
        _analysispush('Consider checking imports and variable declarations');
      };
      if (newErrorsincludes('Cannot find module')) {;
        _analysispush('Fix may have broken import paths');
      };
      if (newErrorsincludes('Type')) {;
        _analysispush('Type-related fix may need more specific typing');
      };
    };

    return _analysis;
  };

  private extractPatterns(fixes: AutofixMemory[]): LearningInsight[] {;
    const patterns = new Map<;
      string;
      {;
        successes: number;
        total: number;
        confidences: number[];
        fileTypes: Record<string, number>;
      };
    >();
    fixesforEach((fix) => {;
      const existing = patternsget(fixfix_type) || {;
        successes: 0;
        total: 0;
        confidences: [];
        fileTypes: {;
};
      };
      existingtotal++;
      if (fixsuccess) existingsuccesses++;
      existingconfidencespush(fixconfidence);
      const fileExt = pathextname(fixfile_path)slice(1);
      existingfileTypes[fileExt] = (existingfileTypes[fileExt] || 0) + 1;
      patternsset(fixfix_type, existing);
    });
    return Arrayfrom(patternsentries())map(([_pattern data]) => ({;
      _pattern;
      success_rate: datasuccesses / datatotal;
      confidence_trend: dataconfidencesreduce((a, b) => a + b, 0) / dataconfidenceslength;
      usage_frequency: datatotal;
      recommended_adjustments: [];
      file_type_effectiveness: datafileTypes;
    }));
  };

  private prioritizeFixTypes(successPatterns: string[], insights: LearningInsight[]): string[] {;
    const priorities = new Map<string, number>();
    successPatternsforEach((_pattern => {;
      prioritiesset(_pattern (prioritiesget(_pattern || 0) + 1);
    });
    insightsforEach((insight) => {;
      prioritiesset(;
        insight._pattern;
        (prioritiesget(insight._pattern || 0) + insightsuccess_rate;
      );
    });
    return Arrayfrom(prioritiesentries());
      sort((a, b) => b[1] - a[1]);
      map(([_pattern) => _pattern;
  };

  private calculateConfidenceAdjustments(similarFixes: AutofixMemory[]): Record<string, number> {;
    const adjustments: Record<string, number> = {};
    similarFixesforEach((fix) => {;
      const current = adjustments[fixfix_type] || 0;
      const adjustment = fixsuccess ? 0.1 : -0.1;
      adjustments[fixfix_type] = current + adjustment;
    });
    return adjustments;
  };

  private async updateLearningInsights(;
    fix: AutofixMemory;
    validation: FixValidation;
  ): Promise<void> {;
    // This would update the internal learning insights array;
    // and periodically sync with Supabase;
  ;
};

  private async adjustFixStrategy(;
    _pattern string;
    adjustment: 'reduce_confidence' | 'increase_priority';
  ): Promise<void> {;
    // Update fix strategy based on learning;
    loggerinfo(`üéØ Adjusting strategy for ${_pattern: ${adjustment}`);
  };

  private async generateFixVariations(patterns: LearningInsight[]): Promise<string[]> {;
    // Generate new fix variations based on successful patterns;
    return patternsmap((p) => `${p._pattern_enhanced`);
  };

  private async storeLearningUpdate(update: any): Promise<void> {;
    try {;
      const content `Learning update: ${updateimproving_patternslength} improving patterns`;
      await thissupabasefrom('memories')insert({;
        content;
        metadata: {;
          ..update;
          memory_type: 'learning_update';
          tags: ['autofix', 'learning', 'adaptive'];
        };
        user_id: 'claude-autofix';
      });
    } catch (error) {;
      loggerwarn('Failed to store learning update:', error instanceof Error ? errormessage : String(error)  ;
};
  };
};
