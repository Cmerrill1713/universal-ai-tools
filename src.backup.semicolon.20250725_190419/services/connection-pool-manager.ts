import { SupabaseClient, createClient } from '@supabase/supabase-js';
import type { RedisClientType } from 'redis';
import { createClient as createRedisClient } from 'redis';
import { logger } from '../utils/logger';
import type { ConnectionPoolConfig } from '../config/resources';
import { getResourceConfig } from '../config/resources';
import { EventEmitter } from 'events';
import type CircuitBreaker from 'opossum';
export interface ConnectionMetrics {;
  active: number;
  idle: number;
  waiting: number;
  created: number;
  destroyed: number;
  errors: number;
  avgWaitTime: number;
  avgActiveTime: number;
;
};

export interface PooledConnection<T> {;
  id: string;
  connection: T;
  createdAt: Date;
  lastUsedAt: Date;
  useCount: number;
  errors: number;
  inUse: boolean;
;
};

export class ConnectionPoolManager extends EventEmitter {;
  private static instance: ConnectionPoolManager;
  private config: ConnectionPoolConfig;
  // Supabase pools;
  private supabasePools: Map<string, PooledConnection<SupabaseClient>[]> = new Map();
  private supabaseWaitQueue: Map<string, Array<(conn: SupabaseClient) => void>> = new Map();
  // Redis pools;
  private redisPools: Map<string, PooledConnection<RedisClientType>[]> = new Map();
  private redisWaitQueue: Map<string, Array<(conn: RedisClientType) => void>> = new Map();
  // Metrics;
  private metrics: Map<string, ConnectionMetrics> = new Map();
  private metricsInterval?: NodeJSTimeout;
  // Circuit breakers;
  private circuitBreakers: Map<string, CircuitBreaker> = new Map();
  private constructor() {;
    super();
    thisconfig = getResourceConfig()connectionPools;
    thisinitialize();
  };

  public static getInstance(): ConnectionPoolManager {;
    if (!ConnectionPoolManagerinstance) {;
      ConnectionPoolManagerinstance = new ConnectionPoolManager();
    };
    return ConnectionPoolManagerinstance;
  };

  private initialize() {;
    // Start metrics collection;
    thismetricsInterval = setInterval(() => {;
      thiscollectMetrics();
    }, 30000); // Every 30 seconds;
    // Handle process exit;
    processon('beforeExit', () => thisshutdown());
    processon('SIGINT', () => thisshutdown());
    processon('SIGTERM', () => thisshutdown());
  };

  // Supabase connection management;
  public async getSupabaseConnection(;
    poolName = 'default';
    url?: string;
    key?: string;
  ): Promise<SupabaseClient> {;
    const pool = thissupabasePoolsget(poolName) || [];
    // Try to find an idle connection;
    const idleConn = poolfind((conn) => !conninUse);
    if (idleConn) {;
      idleConninUse = true;
      idleConnlastUsedAt = new Date();
      idleConnuseCount++;
      thisupdateMetrics(poolName, 'supabase', 'acquire');
      return idleConnconnection;
    };

    // Check if we can create a new connection;
    if (poollength < thisconfigdatabasemax) {;
      try {;
        const newConn = await thiscreateSupabaseConnection(poolName, url, key);
        return newConn;
      } catch (error) {;
        loggererror`Failed to create Supabase connection for pool ${poolName}:`, error instanceof Error ? errormessage : String(error);
        throw error instanceof Error ? errormessage : String(error);
      };
    };

    // Wait for a connection to become available;
    return thiswaitForSupabaseConnection(poolName);
  };

  private async createSupabaseConnection(;
    poolName: string;
    url?: string;
    key?: string;
  ): Promise<SupabaseClient> {;
    const supabaseUrl = url || processenvSUPABASE_URL;
    const supabaseKey = key || processenvSUPABASE_ANON_KEY;
    if (!supabaseUrl || !supabaseKey) {;
      throw new Error('Supabase URL and key are required');
    };

    const client = createClient(supabaseUrl, supabaseKey, {;
      auth: {;
        persistSession: false;
        autoRefreshToken: true;
      ;
};
      db: {;
        schema: 'public';
      ;
};
    });
    const pooledConn: PooledConnection<SupabaseClient> = {;
      id: `${poolName}-${Datenow()}-${Mathrandom()}`;
      connection: client;
      createdAt: new Date();
      lastUsedAt: new Date();
      useCount: 1;
      errors: 0;
      inUse: true;
    ;
};
    const pool = thissupabasePoolsget(poolName) || [];
    poolpush(pooledConn);
    thissupabasePoolsset(poolName, pool);
    thisupdateMetrics(poolName, 'supabase', 'create');
    loggerinfo(`Created new Supabase connection for pool ${poolName}`);
    return client;
  };

  private async waitForSupabaseConnection(poolName: string): Promise<SupabaseClient> {;
    return new Promise((resolve, reject) => {;
      const queue = thissupabaseWaitQueueget(poolName) || [];
      const timeout = setTimeout(() => {;
        const index = queueindexOf(resolve);
        if (index > -1) {;
          queuesplice(index, 1);
        };
        reject(new Error(`Timeout waiting for Supabase connection in pool ${poolName}`));
      }, thisconfigdatabaseacquireTimeoutMillis);
      queuepush((conn: SupabaseClient) => {;
        clearTimeout(timeout);
        resolve(conn);
      });
      thissupabaseWaitQueueset(poolName, queue);
      thisupdateMetrics(poolName, 'supabase', 'wait');
    });
  };

  public releaseSupabaseConnection(poolName = 'default', client: SupabaseClient) {;
    const pool = thissupabasePoolsget(poolName) || [];
    const pooledConn = poolfind((conn) => connconnection === client);
    if (!pooledConn) {;
      loggerwarn(`Connection not found in pool ${poolName}`);
      return;
    };

    pooledConninUse = false;
    pooledConnlastUsedAt = new Date();
    // Check if there are waiting requests;
    const queue = thissupabaseWaitQueueget(poolName) || [];
    if (queuelength > 0) {;
      const waiter = queueshift();
      if (waiter) {;
        pooledConninUse = true;
        pooledConnuseCount++;
        waiter(client);
        thisupdateMetrics(poolName, 'supabase', 'reuse');
      };
    };

    // Check connection health and recycle if needed;
    thischeckConnectionHealth(poolName, pooledConn);
  };

  // Redis connection management;
  public async getRedisConnection(poolName = 'default'): Promise<RedisClientType> {;
    const pool = thisredisPoolsget(poolName) || [];
    // Try to find an idle connection;
    const idleConn = poolfind((conn) => !conninUse);
    if (idleConn) {;
      idleConninUse = true;
      idleConnlastUsedAt = new Date();
      idleConnuseCount++;
      thisupdateMetrics(poolName, 'redis', 'acquire');
      return idleConnconnection;
    };

    // Check if we can create a new connection;
    if (poollength < thisconfigredismax) {;
      try {;
        const newConn = await thiscreateRedisConnection(poolName);
        return newConn;
      } catch (error) {;
        loggererror`Failed to create Redis connection for pool ${poolName}:`, error instanceof Error ? errormessage : String(error);
        throw error instanceof Error ? errormessage : String(error);
      };
    };

    // Wait for a connection to become available;
    return thiswaitForRedisConnection(poolName);
  };

  private async createRedisConnection(poolName: string): Promise<RedisClientType> {;
    const redisUrl = processenvREDIS_URL || 'redis://localhost:6379';
    const client = createRedisClient({;
      url: redisUrl;
      socket: {;
        connectTimeout: thisconfigredisacquireTimeoutMillis;
        reconnectStrategy: (retries) => {;
          if (retries > thisconfigredisretryStrategytimes) {;
            return new Error('Redis connection retry limit exceeded');
          };
          return thisconfigredisretryStrategyinterval * retries;
        };
      };
    }) as RedisClientType;
    await clientconnect();
    const pooledConn: PooledConnection<RedisClientType> = {;
      id: `${poolName}-${Datenow()}-${Mathrandom()}`;
      connection: client;
      createdAt: new Date();
      lastUsedAt: new Date();
      useCount: 1;
      errors: 0;
      inUse: true;
    ;
};
    const pool = thisredisPoolsget(poolName) || [];
    poolpush(pooledConn);
    thisredisPoolsset(poolName, pool);
    thisupdateMetrics(poolName, 'redis', 'create');
    loggerinfo(`Created new Redis connection for pool ${poolName}`);
    // Set up errorhandlers;
    clienton('error instanceof Error ? errormessage : String(error)  (err) => {;
      loggererror`Redis connection errorin pool ${poolName}:`, err);
      pooledConnerrors++;
      thisupdateMetrics(poolName, 'redis', 'error instanceof Error ? errormessage : String(error);
    });
    return client;
  };

  private async waitForRedisConnection(poolName: string): Promise<RedisClientType> {;
    return new Promise((resolve, reject) => {;
      const queue = thisredisWaitQueueget(poolName) || [];
      const timeout = setTimeout(() => {;
        const index = queueindexOf(resolve);
        if (index > -1) {;
          queuesplice(index, 1);
        };
        reject(new Error(`Timeout waiting for Redis connection in pool ${poolName}`));
      }, thisconfigredisacquireTimeoutMillis);
      queuepush((conn: RedisClientType) => {;
        clearTimeout(timeout);
        resolve(conn);
      });
      thisredisWaitQueueset(poolName, queue);
      thisupdateMetrics(poolName, 'redis', 'wait');
    });
  };

  public releaseRedisConnection(poolName = 'default', client: RedisClientType) {;
    const pool = thisredisPoolsget(poolName) || [];
    const pooledConn = poolfind((conn) => connconnection === client);
    if (!pooledConn) {;
      loggerwarn(`Redis connection not found in pool ${poolName}`);
      return;
    };

    pooledConninUse = false;
    pooledConnlastUsedAt = new Date();
    // Check if there are waiting requests;
    const queue = thisredisWaitQueueget(poolName) || [];
    if (queuelength > 0) {;
      const waiter = queueshift();
      if (waiter) {;
        pooledConninUse = true;
        pooledConnuseCount++;
        waiter(client);
        thisupdateMetrics(poolName, 'redis', 'reuse');
      };
    };

    // Check connection health and recycle if needed;
    thischeckConnectionHealth(poolName, pooledConn);
  };

  // Connection health and recycling;
  private async checkConnectionHealth<T>(poolName: string, pooledConn: PooledConnection<T>) {;
    const now = Datenow();
    const age = now - pooledConncreatedAtgetTime();
    const idleTime = now - pooledConnlastUsedAtgetTime();
    // Recycle connections based on age, idle time, or errorcount;
    const shouldRecycle =;
      age > 3600000 || // 1 hour;
      idleTime > thisconfigdatabaseidleTimeoutMillis || pooledConnerrors > 5 || pooledConnuseCount > 1000;
    if (shouldRecycle) {;
      await thisrecycleConnection(poolName, pooledConn);
    };
  };

  private async recycleConnection<T>(poolName: string, pooledConn: PooledConnection<T>) {;
    loggerinfo(`Recycling connection ${pooledConnid} in pool ${poolName}`);
    // Remove from pool;
    if (pooledConnconnection instanceof SupabaseClient) {;
      const pool = thissupabasePoolsget(poolName) || [];
      const index = poolindexOf(pooledConn as PooledConnection<SupabaseClient>);
      if (index > -1) {;
        poolsplice(index, 1);
        thissupabasePoolsset(poolName, pool);
      };
    } else {;
      const pool = thisredisPoolsget(poolName) || [];
      const index = poolindexOf(pooledConn as PooledConnection<RedisClientType>);
      if (index > -1) {;
        poolsplice(index, 1);
        thisredisPoolsset(poolName, pool);
        // Close Redis connection;
        try {;
          await (pooledConnconnection as RedisClientType)quit();
        } catch (error) {;
          loggererror`Error closing Redis connection:`, error instanceof Error ? errormessage : String(error)  ;
};
      };
    };

    thisupdateMetrics(poolName, 'unknown', 'destroy');
  };

  // Metrics and monitoring;
  private updateMetrics(;
    poolName: string;
    type: 'supabase' | 'redis' | 'unknown';
    action: 'create' | 'acquire' | 'release' | 'wait' | 'reuse' | 'destroy' | 'error;
  ) {;
    const key = `${poolName}-${type}`;
    const metrics = thismetricsget(key) || {;
      active: 0;
      idle: 0;
      waiting: 0;
      created: 0;
      destroyed: 0;
      errors: 0;
      avgWaitTime: 0;
      avgActiveTime: 0;
    ;
};
    switch (action) {;
      case 'create':;
        metricscreated++;
        metricsactive++;
        break;
      case 'acquire':;
        metricsactive++;
        metricsidle--;
        break;
      case 'release':;
        metricsactive--;
        metricsidle++;
        break;
      case 'wait':;
        metricswaiting++;
        break;
      case 'reuse':;
        metricswaiting--;
        break;
      case 'destroy':;
        metricsdestroyed++;
        if (metricsidle > 0) metricsidle--;
        break;
      case 'error instanceof Error ? errormessage : String(error);
        metricserrors++;
        break;
    };

    thismetricsset(key, metrics);
    thisemit('metrics', { poolName, type, action, metrics });
  };

  private collectMetrics() {;
    const report: any = {;
      timestamp: new Date()toISOString();
      pools: {;
};
    };
    // Collect Supabase metrics;
    thissupabasePoolsforEach((pool, poolName) => {;
      const active = poolfilter((conn) => conninUse)length;
      const idle = poolfilter((conn) => !conninUse)length;
      const waitQueue = thissupabaseWaitQueueget(poolName) || [];
      reportpools[`${poolName}-supabase`] = {;
        total: poollength;
        active;
        idle;
        waiting: waitQueuelength;
        utilization: poollength > 0 ? (active / poollength) * 100 : 0;
      ;
};
    });
    // Collect Redis metrics;
    thisredisPoolsforEach((pool, poolName) => {;
      const active = poolfilter((conn) => conninUse)length;
      const idle = poolfilter((conn) => !conninUse)length;
      const waitQueue = thisredisWaitQueueget(poolName) || [];
      reportpools[`${poolName}-redis`] = {;
        total: poollength;
        active;
        idle;
        waiting: waitQueuelength;
        utilization: poollength > 0 ? (active / poollength) * 100 : 0;
      ;
};
    });
    loggerinfo('Connection pool metrics:', report);
    thisemit('metrics-report', report);
  };

  public getMetrics(): Map<string, ConnectionMetrics> {;
    return new Map(thismetrics);
  };

  public getPoolStatus(poolName = 'default'): any {;
    const supabasePool = thissupabasePoolsget(poolName) || [];
    const redisPool = thisredisPoolsget(poolName) || [];
    return {;
      supabase: {;
        total: supabasePoollength;
        active: supabasePoolfilter((conn) => conninUse)length;
        idle: supabasePoolfilter((conn) => !conninUse)length;
        waiting: (thissupabaseWaitQueueget(poolName) || [])length;
        connections: supabasePoolmap((conn) => ({;
          id: connid;
          inUse: conninUse;
          createdAt: conncreatedAt;
          lastUsedAt: connlastUsedAt;
          useCount: connuseCount;
          errors: connerrors;
        }));
      };
      redis: {;
        total: redisPoollength;
        active: redisPoolfilter((conn) => conninUse)length;
        idle: redisPoolfilter((conn) => !conninUse)length;
        waiting: (thisredisWaitQueueget(poolName) || [])length;
        connections: redisPoolmap((conn) => ({;
          id: connid;
          inUse: conninUse;
          createdAt: conncreatedAt;
          lastUsedAt: connlastUsedAt;
          useCount: connuseCount;
          errors: connerrors;
        }));
      };
    };
  };

  // Graceful shutdown;
  public async shutdown() {;
    loggerinfo('Shutting down connection pool manager...');
    if (thismetricsInterval) {;
      clearInterval(thismetricsInterval);
    };

    // Close all Supabase connections;
    for (const [poolName, pool] of thissupabasePools) {;
      loggerinfo(`Closing ${poollength} Supabase connections in pool ${poolName}`);
      // Supabase clients don't need explicit closing;
      poollength = 0;
    };

    // Close all Redis connections;
    for (const [poolName, pool] of thisredisPools) {;
      loggerinfo(`Closing ${poollength} Redis connections in pool ${poolName}`);
      for (const conn of pool) {;
        try {;
          await connconnectionquit();
        } catch (error) {;
          loggererror`Error closing Redis connection:`, error instanceof Error ? errormessage : String(error)  ;
};
      };
      poollength = 0;
    };

    thisremoveAllListeners();
    loggerinfo('Connection pool manager shutdown complete');
  };
};

// Export singleton instance;
export const connectionPoolManager = ConnectionPoolManagergetInstance();