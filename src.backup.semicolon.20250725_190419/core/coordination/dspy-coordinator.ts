import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
import { dspyService } from '../../services/dspy-service';
import type { BrowserAgentPool } from './agent-pool';
import { v4 as uuidv4 } from 'uuid';
// Re-export interfaces for compatibility;
export interface CoordinationPlan {;
  id: string;
  problem: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  assignedAgents: string[];
  status: 'planning' | 'executing' | 'completed' | 'failed';
  startTime: number;
  endTime?: number;
  results: any[];
  dspyResponse?: any;
;
};

export interface ProblemAnalysis {;
  problemType: string;
  technology: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  affectedComponents: string[];
  potentialCauses: string[];
  recommendedStrategies: string[];
;
};

/**;
 * Lightweight DSPy-based Agent Coordinator;
 * Replaces the 1,200+ line agent-coordinatorts with DSPy's intelligent coordination;
 */;
export class DSPyCoordinator extends EventEmitter {;
  private agentPool: BrowserAgentPool;
  private activePlans: Map<string, CoordinationPlan> = new Map();
  constructor(agentPool: BrowserAgentPool) {;
    super();
    thisagentPool = agentPool;
  };

  /**;
   * Coordinate a group fix using DSPy's intelligent agent selection and coordination;
   */;
  async coordinateGroupFix(problem: string, context: any): Promise<CoordinationPlan> {;
    loggerinfo(`üéØ Starting DSPy-coordinated group fix for: ${problem}`);
    const planId = `plan-${Datenow()}`;
    const plan: CoordinationPlan = {;
      id: planId;
      problem;
      severity: thisanalyzeSeverity(problem);
      assignedAgents: [];
      status: 'planning';
      startTime: Datenow();
      results: [];
    ;
};
    thisactivePlansset(planId, plan);
    try {;
      // Get available agents;
      const agentMap = await thisagentPoolgetAvailableAgents();
      const availableAgents = Arrayfrom(agentMapkeys())map(String);
      // Use DSPy to coordinate agents;
      const coordinationResult = await dspyServicecoordinateAgents(problem, availableAgents, {;
        context;
        severity: planseverity;
        planId;
      });
      planassignedAgents = coordinationResultselectedAgents || [];
      plandspyResponse = coordinationResult;
      planstatus = 'executing';
      loggerinfo(`üìã DSPy coordination plan created with ${planassignedAgentslength} agents`);
      // Execute the coordination plan;
      await thisexecuteDSPyPlan(plan, coordinationResult);
      planstatus = 'completed';
      planendTime = Datenow();
      loggerinfo(`‚úÖ DSPy-coordinated fix completed in ${planendTime - planstartTime}ms`);
    } catch (error) {;
      planstatus = 'failed';
      planendTime = Datenow();
      loggererror(‚ùå DSPy coordination failed:`, error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };

    return plan;
  };

  /**;
   * Execute the plan generated by DSPy;
   */;
  private async executeDSPyPlan(plan: CoordinationPlan, coordinationResult: any): Promise<void> {;
    const assignments = coordinationResultassignments || [];
    // Execute each assignment;
    for (const assignment of assignments) {;
      try {;
        const result = await thisexecuteAgentAssignment(assignmentagentId, assignmenttask, plan);
        planresultspush(result);
      } catch (error) {;
        loggererror(Failed to execute assignment for agent ${assignmentagentId}:`, error instanceof Error ? errormessage : String(error);
        planresultspush({;
          agentId: assignmentagentId;
          success: false;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
        });
      };
    };
  };

  /**;
   * Execute a single agent assignment;
   */;
  private async executeAgentAssignment(;
    agentId: string;
    task: string;
    plan: CoordinationPlan;
  ): Promise<unknown> {;
    const agent = thisagentPoolgetAgent(agentId);
    if (!agent) {;
      throw new Error(`Agent ${agentId} not found`);
    };

    loggerinfo(`ü§ñ Agent ${agentId} executing: ${task}`);
    // Simple execution - can be extended based on task type;
    return {;
      agentId;
      task;
      success: true;
      timestamp: Datenow();
    ;
};
  };

  /**;
   * Analyze problem severity;
   */;
  private analyzeSeverity(problem: string): 'low' | 'medium' | 'high' | 'critical' {;
    const problemLower = problemtoLowerCase();
    if (;
      problemLowerincludes('critical') ||;
      problemLowerincludes('crash') ||;
      problemLowerincludes('connection refused');
    ) {;
      return 'critical';
    } else if (problemLowerincludes('error instanceof Error ? errormessage : String(error)  || problemLowerincludes('failed')) {;
      return 'high';
    } else if (problemLowerincludes('warning')) {;
      return 'low';
    };

    return 'medium';
  };

  /**;
   * Get active plans;
   */;
  async getActivePlans(): Promise<CoordinationPlan[]> {;
    return Arrayfrom(thisactivePlansvalues());
  };

  /**;
   * Get plan status;
   */;
  async getPlanStatus(planId: string): Promise<CoordinationPlan | null> {;
    return thisactivePlansget(planId) || null;
  };

  /**;
   * Cancel a plan;
   */;
  async cancelPlan(planId: string): Promise<boolean> {;
    const plan = thisactivePlansget(planId);
    if (!plan) return false;
    planstatus = 'failed';
    planendTime = Datenow();
    thisactivePlansdelete(planId);
    loggerinfo(`üö´ Plan cancelled: ${planId}`);
    return true;
  };

  /**;
   * Clean up old plans;
   */;
  async cleanup(): Promise<void> {;
    const cutoff = Datenow() - 3600000; // 1 hour;

    for (const [planId, plan] of thisactivePlansentries()) {;
      if (;
        (planstatus === 'completed' || planstatus === 'failed') &&;
        planendTime &&;
        planendTime < cutoff;
      ) {;
        thisactivePlansdelete(planId);
        loggerinfo(`üßπ Cleaned up old plan: ${planId}`);
      };
    };
  };
};

// Alias for compatibility - existing code can use AgentCoordinator;
export { DSPyCoordinator as AgentCoordinator };