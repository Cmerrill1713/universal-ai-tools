import { fetchWithTimeout } from '../utils/fetch-with-timeout';
import chokidar from 'chokidar';
import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
import { BrowserAgentPool } from './agent-pool';
import { UIValidator } from '../browser/ui-validator';
import { PerformanceMonitor } from './performance-monitor';
import { BATCH_SIZE_10, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500, MAX_ITEMS_100, PERCENT_10, PERCENT_100, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, TIME_10000MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_500MS, ZERO_POINT_EIGHT, ZERO_POINT_FIVE, ZERO_POINT_NINE } from "../utils/common-constants";
interface HotReloadConfig {;
  watchPaths: string[];
  ignorePatterns: string[];
  debounceMs: number;
  maxConcurrentTests: number;
  testTimeout: number;
;
};

export class HotReloadMonitor extends EventEmitter {;
  private watcher: any | null = null;
  private agentPool: BrowserAgentPool;
  private uiValidator: UIValidator;
  private performanceMonitor: PerformanceMonitor;
  private config: HotReloadConfig;
  private reloadInProgress = false;
  private debounceTimer: NodeJSTimeout | null = null;
  private testResults: Map<string, any> = new Map();
  constructor(config: Partial<HotReloadConfig> = {}) {;
    super();
    thisconfig = {;
      watchPaths: ['src/**/*', 'ui/src/**/*'];
      ignorePatterns: [;
        '**/node_modules/**';
        '**/dist/**';
        '**/build/**';
        '**/*log';
        '**/*tmp';
        '**/git/**';
      ];
      debounceMs: 1000;
      maxConcurrentTests: 14;
      testTimeout: 30000;
      ..config;
    ;
};
    thisagentPool = new BrowserAgentPool({;
      maxConcurrentAgents: thisconfigmaxConcurrentTests;
    });
    thisuiValidator = new UIValidator();
    thisperformanceMonitor = new PerformanceMonitor();
  };

  async start(): Promise<void> {;
    loggerinfo('Starting Hot Reload Monitor...');
    // Initialize agent pool;
    await thisagentPoolinitialize();
    // Start file watching;
    thiswatcher = chokidarwatch(thisconfigwatchPaths, {;
      ignored: thisconfigignorePatterns;
      persistent: true;
      ignoreInitial: true;
      awaitWriteFinish: {;
        stabilityThreshold: 100;
        pollInterval: 50;
      ;
};
    });
    // Set up event listeners;
    thiswatcher;
      on('change', (path: string) => thishandleFileChange(path, 'change'));
      on('add', (path: string) => thishandleFileChange(path, 'add'));
      on('unlink', (path: string) => thishandleFileChange(path, 'unlink'));
      on('error instanceof Error ? errormessage : String(error)  (error instanceof Error ? errormessage : String(error)any) => loggererror('File watcher error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error) // Start performance monitoring;
    thisperformanceMonitorstart();
    loggerinfo('Hot Reload Monitor started successfully');
    thisemit('started');
  ;
};

  async stop(): Promise<void> {;
    loggerinfo('Stopping Hot Reload Monitor...');
    if (thisdebounceTimer) {;
      clearTimeout(thisdebounceTimer);
    };

    if (thiswatcher) {;
      await thiswatcherclose();
    };

    await thisagentPoolshutdown();
    await thisperformanceMonitorstop();
    loggerinfo('Hot Reload Monitor stopped');
    thisemit('stopped');
  };

  private handleFileChange(filePath: string, eventType: string): void {;
    if (thisreloadInProgress) {;
      loggerdebug(`Ignoring file change (${eventType}): ${filePath} - reload in progress`);
      return;
    };

    loggerinfo(`File ${eventType}: ${filePath}`);
    // Clear existing debounce timer;
    if (thisdebounceTimer) {;
      clearTimeout(thisdebounceTimer);
    };

    // Set new debounce timer;
    thisdebounceTimer = setTimeout(() => {;
      thistriggerHotReload(filePath, eventType);
    }, thisconfigdebounceMs);
  };

  private async triggerHotReload(filePath: string, eventType: string): Promise<void> {;
    if (thisreloadInProgress) {;
      return;
    };

    thisreloadInProgress = true;
    const startTime = Datenow();
    try {;
      loggerinfo(`Triggering hot reload for ${filePath} (${eventType})`);
      thisemit('reload-start', { filePath, eventType });
      // Step 1: Notify all agents about the reload;
      await thisagentPoolbroadcastReload();
      // Step 2: Wait for UI to reload (Vite HMR);
      await thiswaitForUIReload();
      // Step 3: Validate UI functionality across all browsers;
      const validationResults = await thisvalidateAllBrowsers();
      // Step 4: Run performance checks;
      const performanceResults = await thisperformanceMonitorrunChecks();
      // Step 5: Compile results;
      const reloadResults = {;
        filePath;
        eventType;
        startTime;
        duration: Datenow() - startTime;
        validationResults;
        performanceResults;
        success: validationResultsevery((r) => rsuccess);
      };
      thistestResultsset(`${Datenow()}-${filePath}`, reloadResults);
      // Step 6: Emit results;
      thisemit('reload-complete', reloadResults);
      if (reloadResultssuccess) {;
        loggerinfo(`Hot reload successful for ${filePath} (${reloadResultsduration}ms)`);
      } else {;
        loggererror(Hot reload failed for ${filePath}`, reloadResults);
        thisemit('reload-failed', reloadResults);
      };
    } catch (error) {;
      loggererror('Hot reload error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error);
      thisemit('reload-error instanceof Error ? errormessage : String(error)  { filePath, eventType, error instanceof Error ? errormessage : String(error));
    } finally {;
      thisreloadInProgress = false;
    };
  };

  private async waitForUIReload(): Promise<void> {;
    // Wait for Vite HMR to complete;
    await new Promise((resolve) => setTimeout(TIME_500MS));
    // Check if UI is responding;
    const maxRetries = 10;
    for (let i = 0; i < maxRetries; i++) {;
      try {;
        const response = await fetchWithTimeout('http://localhost:5173/', { timeout: 30000 });
        if (responseok) {;
          return;
        };
      } catch (error) {;
        // UI not ready yet;
      };
      await new Promise((resolve) => setTimeout(resolve, 100));
    };

    throw new Error('UI did not respond after reload');
  };

  private async validateAllBrowsers(): Promise<any[]> {;
    const agents = await thisagentPoolgetAllAgents();
    const validationPromises = agentsmap((agent) => thisuiValidatorvalidateAgent(agent));
    return Promiseall(validationPromises);
  };

  public getTestResults(): Map<string, any> {;
    return thistestResults;
  };

  public getLatestResults(): any | null {;
    const keys = Arrayfrom(thistestResultskeys())sort();
    const latestKey = keys[keyslength - 1];
    return latestKey ? thistestResultsget(latestKey) : null;
  };

  public clearResults(): void {;
    thistestResultsclear();
  ;
};
};

// Export singleton instance;
export const hotReloadMonitor = new HotReloadMonitor();