import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
import { DSPyTaskExecutor } from './dspy-task-executor';
export interface Task {;
  id: string;
  planId: string;
  type: 'research' | 'test' | 'execute' | 'monitor' | 'coordinate';
  description: string;
  assignedAgent: string;
  dependencies: string[];
  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
  priority: 'low' | 'medium' | 'high' | 'critical';
  input any;
  output?: any;
  startTime?: number;
  endTime?: number;
  error instanceof Error ? errormessage : String(error)  string;
  metadata: Record<string, unknown>;
  retryCount: number;
  maxRetries: number;
  timeout: number;
  estimatedDuration?: number;
;
};

export interface TaskCreateRequest {;
  planId: string;
  type: Task['type'];
  description: string;
  assignedAgent: string;
  dependencies?: string[];
  priority?: Task['priority'];
  input any;
  timeout?: number;
  maxRetries?: number;
  metadata?: Record<string, unknown>;
};

export interface TaskUpdateRequest {;
  status?: Task['status'];
  output?: any;
  error instanceof Error ? errormessage : String(error)  string;
  metadata?: Record<string, unknown>;
};

export interface TaskExecutionResult {;
  taskId: string;
  success: boolean;
  output?: any;
  error instanceof Error ? errormessage : String(error)  string;
  duration: number;
  metadata?: Record<string, unknown>;
};

export interface TaskDependencyGraph {;
  tasks: Map<string, Task>;
  dependencies: Map<string, string[]>; // taskId -> dependent task IDs;
  dependents: Map<string, string[]>; // taskId -> tasks that depend on this;
};

export class TaskManager extends EventEmitter {;
  private tasks: Map<string, Task> = new Map();
  private taskQueue: Task[] = [];
  private runningTasks: Map<string, Task> = new Map();
  private completedTasks: Map<string, Task> = new Map();
  private failedTasks: Map<string, Task> = new Map();
  private dependencyGraph: TaskDependencyGraph = {;
    tasks: new Map();
    dependencies: new Map();
    dependents: new Map();
  ;
};
  private maxConcurrentTasks = 10;
  private taskTimeouts: Map<string, NodeJSTimeout> = new Map();
  private taskExecutor: DSPyTaskExecutor;
  constructor(maxConcurrentTasks = 10) {;
    super();
    thismaxConcurrentTasks = maxConcurrentTasks;
    thistaskExecutor = new DSPyTaskExecutor(this);
    thisstartTaskProcessor();
  };

  async createTask(requestTaskCreateRequest): Promise<Task> {;
    const task: Task = {;
      id: `task-${Datenow()}-${Mathrandom()toString(36)substr(2, 9)}`;
      planId: requestplanId;
      type: requesttype;
      description: requestdescription;
      assignedAgent: requestassignedAgent;
      dependencies: requestdependencies || [];
      status: 'pending';
      priority: requestpriority || 'medium';
      inputrequestinput;
      metadata: requestmetadata || {;
};
      retryCount: 0;
      maxRetries: requestmaxRetries || 3;
      timeout: requesttimeout || 60000, // 1 minute default;
      estimatedDuration: thisestimateTaskDuration(requesttype);
    ;
};
    thistasksset(taskid, task);
    thisdependencyGraphtasksset(taskid, task);
    // Build dependency graph;
    thisbuildDependencyGraph(task);
    // Add to queue if dependencies are satisfied;
    if (thisareDependenciesSatisfied(task)) {;
      thisaddToQueue(task);
    };

    loggerinfo(`üìã Task created: ${taskid} (${tasktype}) assigned to ${taskassignedAgent}`);
    thisemit('task_created', task);
    return task;
  };

  private buildDependencyGraph(task: Task): void {;
    // Set up dependencies;
    if (taskdependencieslength > 0) {;
      thisdependencyGraphdependenciesset(taskid, taskdependencies);
      // Add this task as a dependent of its dependencies;
      taskdependenciesforEach((depId) => {;
        if (!thisdependencyGraphdependentshas(depId)) {;
          thisdependencyGraphdependentsset(depId, []);
        };
        thisdependencyGraphdependentsget(depId)!push(taskid);
      });
    };
  };

  private areDependenciesSatisfied(task: Task): boolean {;
    return taskdependenciesevery((depId) => {;
      const depTask = thistasksget(depId);
      return depTask && depTaskstatus === 'completed';
    });
  };

  private addToQueue(task: Task): void {;
    // Insert task in priority order;
    const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
    const taskPriority = priorityOrder[taskpriority];
    let insertIndex = thistaskQueuelength;
    for (let i = 0; i < thistaskQueuelength; i++) {;
      const queuedTaskPriority = priorityOrder[thistaskQueue[i]priority];
      if (taskPriority > queuedTaskPriority) {;
        insertIndex = i;
        break;
      };
    };

    thistaskQueuesplice(insertIndex, 0, task);
    loggerinfo(`üì• Task queued: ${taskid} (position ${insertIndex + 1})`);
  };

  private startTaskProcessor(): void {;
    setInterval(() => {;
      thisprocessTaskQueue();
    }, 1000); // Process every second;
  };

  private async processTaskQueue(): Promise<void> {;
    if (thisrunningTaskssize >= thismaxConcurrentTasks) {;
      return; // At capacity;
    };

    const readyTasks = thistaskQueuefilter(;
      (task) => thisareDependenciesSatisfied(task) && taskstatus === 'pending';
    );
    const tasksToStart = readyTasksslice(0, thismaxConcurrentTasks - thisrunningTaskssize);
    for (const task of tasksToStart) {;
      await thisstartTask(task);
    };
  };

  private async startTask(task: Task): Promise<void> {;
    // Remove from queue;
    const queueIndex = thistaskQueueindexOf(task);
    if (queueIndex !== -1) {;
      thistaskQueuesplice(queueIndex, 1);
    };

    // Mark as running;
    taskstatus = 'running';
    taskstartTime = Datenow();
    thisrunningTasksset(taskid, task);
    // Set up timeout;
    const timeoutId = setTimeout(() => {;
      thishandleTaskTimeout(taskid);
    }, tasktimeout);
    thistaskTimeoutsset(taskid, timeoutId);
    loggerinfo(`üöÄ Task started: ${taskid} (${tasktype})`);
    thisemit('task_started', task);
    try {;
      // Execute task (this would be handled by the agent);
      await thisexecuteTask(task);
    } catch (error) {;
      await thishandleTaskError(taskid, error instanceof Error ? errormessage : String(error)  ;
};
  };

  private async executeTask(task: Task): Promise<void> {;
    // This is a placeholder - actual execution would be handled by the assigned agent;
    // The agent would call updateTask with the result;
    loggerinfo(`‚ö° Executing task: ${taskid}`);
    // Simulate task execution by emitting an event;
    thisemit('task_executionrequested', {;
      task;
      agentId: taskassignedAgent;
    });
  };

  async updateTask(taskId: string, update: TaskUpdateRequest): Promise<void> {;
    const task = thistasksget(taskId);
    if (!task) {;
      throw new Error(`Task not found: ${taskId}`);
    };

    const oldStatus = taskstatus;
    // Update task properties;
    if (updatestatus) taskstatus = updatestatus;
    if (updateoutput !== undefined) taskoutput = updateoutput;
    if (updateerror instanceof Error ? errormessage : String(error) taskerror instanceof Error ? errormessage : String(error) updateerror;
    if (updatemetadata) Objectassign(taskmetadata, updatemetadata);
    // Handle status changes;
    if (updatestatus && updatestatus !== oldStatus) {;
      await thishandleStatusChange(task, oldStatus, updatestatus);
    };

    loggerinfo(`üìù Task updated: ${taskId} (${oldStatus} ‚Üí ${taskstatus})`);
    thisemit('task_updated', { task, oldStatus, newStatus: taskstatus });
  };

  private async handleStatusChange(;
    task: Task;
    oldStatus: Task['status'];
    newStatus: Task['status'];
  ): Promise<void> {;
    // Clean up timeout;
    const timeoutId = thistaskTimeoutsget(taskid);
    if (timeoutId) {;
      clearTimeout(timeoutId);
      thistaskTimeoutsdelete(taskid);
    };

    // Handle completion;
    if (newStatus === 'completed') {;
      taskendTime = Datenow();
      thisrunningTasksdelete(taskid);
      thiscompletedTasksset(taskid, task);
      loggerinfo(`‚úÖ Task completed: ${taskid} (${taskendTime - taskstartTime!}ms)`);
      thisemit('task_completed', task);
      // Check if dependent tasks can now be queued;
      await thischeckDependentTasks(taskid);
    };

    // Handle failure;
    if (newStatus === 'failed') {;
      taskendTime = Datenow();
      thisrunningTasksdelete(taskid);
      // Try to retry if retries are available;
      if (taskretryCount < taskmaxRetries) {;
        await thisretryTask(task);
      } else {;
        thisfailedTasksset(taskid, task);
        loggererror(‚ùå Task failed permanently: ${taskid}`);
        thisemit('task_failed', task);
        // Handle dependent tasks;
        await thishandleDependentTaskFailure(taskid);
      };
    };

    // Handle cancellation;
    if (newStatus === 'cancelled') {;
      taskendTime = Datenow();
      thisrunningTasksdelete(taskid);
      loggerwarn(`üö´ Task cancelled: ${taskid}`);
      thisemit('task_cancelled', task);
      // Handle dependent tasks;
      await thishandleDependentTaskFailure(taskid);
    };
  };

  private async retryTask(task: Task): Promise<void> {;
    taskretryCount++;
    taskstatus = 'pending';
    taskerror instanceof Error ? errormessage : String(error)  undefined;
    taskstartTime = undefined;
    taskendTime = undefined;
    loggerinfo(`üîÑ Retrying task: ${taskid} (attempt ${taskretryCount}/${taskmaxRetries})`);
    thisemit('task_retry', task);
    // Add back to queue;
    thisaddToQueue(task);
  };

  private async handleTaskTimeout(taskId: string): Promise<void> {;
    const task = thistasksget(taskId);
    if (!task || taskstatus !== 'running') return;
    loggerwarn(`‚è±Ô∏è Task timeout: ${taskId}`);
    await thisupdateTask(taskId, {;
      status: 'failed';
      error instanceof Error ? errormessage : String(error) 'Task timeout';
    });
  };

  private async handleTaskError(taskId: string, error instanceof Error ? errormessage : String(error) any): Promise<void> {;
    loggererror(‚ùå Task error instanceof Error ? errormessage : String(error) ${taskId}`, error instanceof Error ? errormessage : String(error);
    await thisupdateTask(taskId, {;
      status: 'failed';
      error instanceof Error ? errormessage : String(error) errormessage || 'Unknown error instanceof Error ? errormessage : String(error);
    });
  };

  private async checkDependentTasks(completedTaskId: string): Promise<void> {;
    const dependents = thisdependencyGraphdependentsget(completedTaskId) || [];
    for (const dependentId of dependents) {;
      const dependentTask = thistasksget(dependentId);
      if (dependentTask && dependentTaskstatus === 'pending') {;
        if (thisareDependenciesSatisfied(dependentTask)) {;
          thisaddToQueue(dependentTask);
        };
      };
    };
  };

  private async handleDependentTaskFailure(failedTaskId: string): Promise<void> {;
    const dependents = thisdependencyGraphdependentsget(failedTaskId) || [];
    for (const dependentId of dependents) {;
      const dependentTask = thistasksget(dependentId);
      if (dependentTask && dependentTaskstatus === 'pending') {;
        loggerwarn(`üö´ Cancelling dependent task: ${dependentId}`);
        await thisupdateTask(dependentId, {;
          status: 'cancelled';
          error instanceof Error ? errormessage : String(error) `Dependency failed: ${failedTaskId}`;
        });
      };
    };
  };

  async getTask(taskId: string): Promise<Task | null> {;
    return thistasksget(taskId) || null;
  };

  async getTasksByPlan(planId: string): Promise<Task[]> {;
    return Arrayfrom(thistasksvalues())filter((task) => taskplanId === planId);
  };

  async getTasksByAgent(agentId: string): Promise<Task[]> {;
    return Arrayfrom(thistasksvalues())filter((task) => taskassignedAgent === agentId);
  };

  async getTasksByStatus(status: Task['status']): Promise<Task[]> {;
    return Arrayfrom(thistasksvalues())filter((task) => taskstatus === status);
  };

  async getTaskStats(): Promise<{;
    total: number;
    byStatus: Record<Task['status'], number>;
    byType: Record<Task['type'], number>;
    byPriority: Record<Task['priority'], number>;
    averageDuration: number;
    successRate: number;
  }> {;
    const tasks = Arrayfrom(thistasksvalues());
    const total = taskslength;
    const byStatus: Record<Task['status'], number> = {;
      pending: 0;
      running: 0;
      completed: 0;
      failed: 0;
      cancelled: 0;
    ;
};
    const byType: Record<Task['type'], number> = {;
      research: 0;
      test: 0;
      execute: 0;
      monitor: 0;
      coordinate: 0;
    ;
};
    const byPriority: Record<Task['priority'], number> = {;
      low: 0;
      medium: 0;
      high: 0;
      critical: 0;
    ;
};
    let totalDuration = 0;
    let completedCount = 0;
    tasksforEach((task) => {;
      byStatus[taskstatus]++;
      byType[tasktype]++;
      byPriority[taskpriority]++;
      if (taskstatus === 'completed' && taskstartTime && taskendTime) {;
        totalDuration += taskendTime - taskstartTime;
        completedCount++;
      };
    });
    const averageDuration = completedCount > 0 ? totalDuration / completedCount : 0;
    const successRate = total > 0 ? (byStatuscompleted / total) * 100 : 0;
    return {;
      total;
      byStatus;
      byType;
      byPriority;
      averageDuration;
      successRate;
    };
  };

  async cancelTask(taskId: string): Promise<void> {;
    const task = thistasksget(taskId);
    if (!task) {;
      throw new Error(`Task not found: ${taskId}`);
    };

    if (taskstatus === 'completed' || taskstatus === 'failed' || taskstatus === 'cancelled') {;
      throw new Error(`Cannot cancel task in status: ${taskstatus}`);
    };

    await thisupdateTask(taskId, { status: 'cancelled' });
  };

  async getPendingTasks(): Promise<Task[]> {;
    return thistaskQueuefilter((task) => taskstatus === 'pending');
  };

  async getRunningTasks(): Promise<Task[]> {;
    return Arrayfrom(thisrunningTasksvalues());
  };

  private estimateTaskDuration(type: Task['type']): number {;
    // Estimate based on task type (in milliseconds);
    const estimates = {;
      research: 30000, // 30 seconds;
      test: 15000, // 15 seconds;
      execute: 10000, // 10 seconds;
      monitor: 5000, // 5 seconds;
      coordinate: 2000, // 2 seconds;
    };
    return estimates[type] || 10000;
  };

  async cleanup(): Promise<void> {;
    // Clean up old completed and failed tasks (older than 1 hour);
    const cutoff = Datenow() - 3600000; // 1 hour;
    const tasksToClean = Arrayfrom(thistasksvalues())filter(;
      (task) =>;
        (taskstatus === 'completed' || taskstatus === 'failed' || taskstatus === 'cancelled') &&;
        taskendTime &&;
        taskendTime < cutoff;
    );
    tasksToCleanforEach((task) => {;
      thistasksdelete(taskid);
      thiscompletedTasksdelete(taskid);
      thisfailedTasksdelete(taskid);
      thisdependencyGraphtasksdelete(taskid);
      thisdependencyGraphdependenciesdelete(taskid);
      thisdependencyGraphdependentsdelete(taskid);
    });
    if (tasksToCleanlength > 0) {;
      loggerinfo(`üßπ Cleaned up ${tasksToCleanlength} old tasks`);
    };
  };

  async shutdown(): Promise<void> {;
    // Cancel all running tasks;
    const runningTasks = Arrayfrom(thisrunningTasksvalues());
    for (const task of runningTasks) {;
      await thiscancelTask(taskid);
    };

    // Clear all timeouts;
    thistaskTimeoutsforEach((timeout) => clearTimeout(timeout));
    thistaskTimeoutsclear();
    // Shutdown the task executor;
    await thistaskExecutorshutdown();
    loggerinfo('üî• Task manager shut down');
  };
};
