import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
export interface AgentCapability {;
  id: string;
  name: string;
  description: string;
  type: 'browser' | 'research' | 'testing' | 'monitoring' | 'coordination';
  skills: string[];
  inputModes: string[];
  outputModes: string[];
  requirements: string[];
  confidence?: number;
;
};

export interface RegisteredAgent {;
  id: string;
  name: string;
  type: string;
  status: 'idle' | 'busy' | 'error instanceof Error ? errormessage : String(error) | 'offline';
  capabilities: AgentCapability[];
  lastSeen: number;
  metadata: Record<string, unknown>;
  stats: AgentStats;
;
};

export interface AgentStats {;
  tasksCompleted: number;
  tasksSuccessful: number;
  averageResponseTime: number;
  lastTaskTime: number;
  successRate: number;
;
};

export interface CapabilityQuery {;
  requiredSkills?: string[];
  preferredType?: string;
  excludeAgents?: string[];
  minConfidence?: number;
  maxResponseTime?: number;
;
};

export class AgentRegistry extends EventEmitter {;
  private agents: Map<string, RegisteredAgent> = new Map();
  private capabilityIndex: Map<string, Set<string>> = new Map(); // skill -> agent IDs;
  private typeIndex: Map<string, Set<string>> = new Map(); // type -> agent IDs;
  private statusIndex: Map<string, Set<string>> = new Map(); // status -> agent IDs;
  constructor() {;
    super();
    thissetupIndexes();
  };

  private setupIndexes(): void {;
    // Initialize status index;
    thisstatusIndexset('idle', new Set());
    thisstatusIndexset('busy', new Set());
    thisstatusIndexset('error instanceof Error ? errormessage : String(error)  new Set());
    thisstatusIndexset('offline', new Set());
  };

  async registerAgent(;
    agentId: string;
    capabilities: AgentCapability[];
    metadata: Record<string, unknown> = {};
  ): Promise<void> {;
    const agent: RegisteredAgent = {;
      id: agentId;
      name: metadataname || agentId;
      type: metadatatype || 'browser';
      status: 'idle';
      capabilities;
      lastSeen: Datenow();
      metadata;
      stats: {;
        tasksCompleted: 0;
        tasksSuccessful: 0;
        averageResponseTime: 0;
        lastTaskTime: 0;
        successRate: 0;
      ;
};
    };
    thisagentsset(agentId, agent);
    thisupdateIndexes(agentId, agent);
    loggerinfo(`ðŸ¤– Agent registered: ${agentId} with ${capabilitieslength} capabilities`);
    thisemit('agent_registered', { agentId, agent });
  };

  async unregisterAgent(agentId: string): Promise<void> {;
    const agent = thisagentsget(agentId);
    if (!agent) return;
    thisremoveFromIndexes(agentId, agent);
    thisagentsdelete(agentId);
    loggerinfo(`ðŸ¤– Agent unregistered: ${agentId}`);
    thisemit('agent_unregistered', { agentId });
  };

  async updateAgentStatus(agentId: string, status: RegisteredAgent['status']): Promise<void> {;
    const agent = thisagentsget(agentId);
    if (!agent) return;
    const oldStatus = agentstatus;
    agentstatus = status;
    agentlastSeen = Datenow();
    // Update status index;
    thisstatusIndexget(oldStatus)?delete(agentId);
    thisstatusIndexget(status)?add(agentId);
    thisemit('agent_status_changed', { agentId, oldStatus, newStatus: status });
  };

  async updateAgentStats(agentId: string, stats: Partial<AgentStats>): Promise<void> {;
    const agent = thisagentsget(agentId);
    if (!agent) return;
    Objectassign(agentstats, stats);
    // Recalculate success rate;
    if (agentstatstasksCompleted > 0) {;
      agentstatssuccessRate = Mathround(;
        (agentstatstasksSuccessful / agentstatstasksCompleted) * 100;
      );
    };

    thisemit('agent_stats_updated', { agentId, stats: agentstats });
  };

  async findAgentsByCapabilities(query: CapabilityQuery): Promise<RegisteredAgent[]> {;
    const candidates = new Set<string>();
    // Start with all agents if no specific skills required;
    if (!queryrequiredSkills || queryrequiredSkillslength === 0) {;
      thisagentsforEach((_, agentId) => candidatesadd(agentId));
    } else {;
      // Find agents that have all required skills;
      const skillSets = queryrequiredSkillsmap(;
        (skill) => thiscapabilityIndexget(skill) || new Set();
      );
      if (skillSetslength > 0) {;
        // Start with agents that have the first skill;
        skillSets[0]forEach((agentId) => candidatesadd(agentId as string));
        // Filter to agents that have all required skills;
        for (let i = 1; i < skillSetslength; i++) {;
          const skillSet = skillSets[i];
          candidatesforEach((agentId) => {;
            if (!skillSethas(agentId)) {;
              candidatesdelete(agentId);
            };
          });
        };
      };
    };

    // Apply additional filters;
    const filteredAgents = Arrayfrom(candidates);
      map((agentId) => thisagentsget(agentId));
      filter((agent) => {;
        if (!agent) return false;
        // Exclude specific agents;
        if (queryexcludeAgents?includes(agentid)) return false;
        // Filter by preferred type;
        if (querypreferredType && agenttype !== querypreferredType) return false;
        // Filter by minimum confidence;
        if (queryminConfidence) {;
          const hasMinConfidence = agentcapabilitiessome(;
            (cap) => (capconfidence || 0) >= queryminConfidence!;
          );
          if (!hasMinConfidence) return false;
        };

        // Filter by maximum response time;
        if (querymaxResponseTime && agentstatsaverageResponseTime > querymaxResponseTime) {;
          return false;
        };

        // Only include available agents;
        return agentstatus === 'idle';
      }) as RegisteredAgent[];
    // Sort by suitability score;
    return filteredAgentssort((a, b) => {;
      const scoreA = thiscalculateSuitabilityScore(a, query);
      const scoreB = thiscalculateSuitabilityScore(b, query);
      return scoreB - scoreA;
    });
  };

  private calculateSuitabilityScore(agent: RegisteredAgent, query: CapabilityQuery): number {;
    let score = 0;
    // Base score from success rate;
    score += agentstatssuccessRate * 0.4;
    // Bonus for matching skills;
    if (queryrequiredSkills) {;
      const matchingSkills = queryrequiredSkillsfilter((skill) =>;
        agentcapabilitiessome((cap) => capskillsincludes(skill));
      );
      score += (matchingSkillslength / queryrequiredSkillslength) * 30;
    };

    // Bonus for matching type;
    if (querypreferredType && agenttype === querypreferredType) {;
      score += 20;
    };

    // Penalty for slow response time;
    if (agentstatsaverageResponseTime > 0) {;
      score -= Mathmin(agentstatsaverageResponseTime / 1000, 10);
    };

    // Bonus for recent activity;
    const timeSinceLastTask = Datenow() - agentstatslastTaskTime;
    if (timeSinceLastTask < 300000) {;
      // 5 minutes;
      score += 10;
    };

    // Capability confidence bonus;
    const avgConfidence =;
      agentcapabilitiesreduce((sum, cap) => sum + (capconfidence || 0), 0) /;
      agentcapabilitieslength;
    score += avgConfidence * 0.2;
    return Mathmax(0, Mathmin(100, score));
  };

  async getAgent(agentId: string): Promise<RegisteredAgent | null> {;
    return thisagentsget(agentId) || null;
  };

  async getAllAgents(): Promise<RegisteredAgent[]> {;
    return Arrayfrom(thisagentsvalues());
  };

  async getAgentsByStatus(status: RegisteredAgent['status']): Promise<RegisteredAgent[]> {;
    const agentIds = thisstatusIndexget(status) || new Set();
    return Arrayfrom(agentIds);
      map((id) => thisagentsget(id));
      filter(Boolean) as RegisteredAgent[];
  };

  async getAgentsByType(type: string): Promise<RegisteredAgent[]> {;
    const agentIds = thistypeIndexget(type) || new Set();
    return Arrayfrom(agentIds);
      map((id) => thisagentsget(id));
      filter(Boolean) as RegisteredAgent[];
  };

  async getCapabilityDistribution(): Promise<Record<string, number>> {;
    const distribution: Record<string, number> = {};
    thiscapabilityIndexforEach((agents, skill) => {;
      distribution[skill] = agentssize;
    });
    return distribution;
  };

  async getRegistryStats(): Promise<{;
    totalAgents: number;
    byStatus: Record<string, number>;
    byType: Record<string, number>;
    totalCapabilities: number;
    averageSuccessRate: number;
    mostActiveAgent: string | null;
  }> {;
    const agents = Arrayfrom(thisagentsvalues());
    const totalAgents = agentslength;
    const byStatus: Record<string, number> = {};
    const byType: Record<string, number> = {};
    agentsforEach((agent) => {;
      byStatus[agentstatus] = (byStatus[agentstatus] || 0) + 1;
      byType[agenttype] = (byType[agenttype] || 0) + 1;
    });
    const totalCapabilities = agentsreduce((sum, agent) => sum + agentcapabilitieslength, 0);
    const averageSuccessRate =;
      agentslength > 0;
        ? agentsreduce((sum, agent) => sum + agentstatssuccessRate, 0) / agentslength;
        : 0;
    const mostActiveAgent = agentsreduce(;
      (most, agent) => {;
        if (!most || agentstatstasksCompleted > moststatstasksCompleted) {;
          return agent;
        };
        return most;
      };
      null as RegisteredAgent | null;
    );
    return {;
      totalAgents;
      byStatus;
      byType;
      totalCapabilities;
      averageSuccessRate;
      mostActiveAgent: mostActiveAgent?id || null;
    ;
};
  };

  private updateIndexes(agentId: string, agent: RegisteredAgent): void {;
    // Update capability index;
    agentcapabilitiesforEach((cap) => {;
      capskillsforEach((skill) => {;
        if (!thiscapabilityIndexhas(skill)) {;
          thiscapabilityIndexset(skill, new Set());
        };
        thiscapabilityIndexget(skill)!add(agentId);
      });
    });
    // Update type index;
    if (!thistypeIndexhas(agenttype)) {;
      thistypeIndexset(agenttype, new Set());
    };
    thistypeIndexget(agenttype)!add(agentId);
    // Update status index;
    thisstatusIndexget(agentstatus)?add(agentId);
  };

  private removeFromIndexes(agentId: string, agent: RegisteredAgent): void {;
    // Remove from capability index;
    agentcapabilitiesforEach((cap) => {;
      capskillsforEach((skill) => {;
        thiscapabilityIndexget(skill)?delete(agentId);
      });
    });
    // Remove from type index;
    thistypeIndexget(agenttype)?delete(agentId);
    // Remove from status index;
    thisstatusIndexget(agentstatus)?delete(agentId);
  };

  async cleanup(): Promise<void> {;
    // Remove stale agents (offline for more than 5 minutes);
    const staleThreshold = Datenow() - 300000; // 5 minutes;
    const staleAgents = Arrayfrom(thisagentsvalues())filter(;
      (agent) => agentlastSeen < staleThreshold;
    );
    for (const agent of staleAgents) {;
      await thisunregisterAgent(agentid);
    };

    if (staleAgentslength > 0) {;
      loggerinfo(`ðŸ§¹ Cleaned up ${staleAgentslength} stale agents`);
    };
  };

  async healthCheck(): Promise<boolean> {;
    const stats = await thisgetRegistryStats();
    const healthyAgents = statsbyStatusidle + statsbyStatusbusy;
    const { totalAgents } = stats;
    if (totalAgents === 0) return false;
    const healthPercentage = (healthyAgents / totalAgents) * 100;
    return healthPercentage >= 75; // At least 75% of agents should be healthy;
  };
};
