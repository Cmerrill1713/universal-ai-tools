import { SamplingDecision } from '@opentelemetry/api';
export interface TelemetryConfig {;
  serviceName: string;
  serviceVersion: string;
  environment: string;
  enableConsoleExporter: boolean;
  enableJaeger: boolean;
  enableZipkin: boolean;
  enableOTLP: boolean;
  samplingRate: number;
  debug: boolean;
  exporters: {;
    jaeger: {;
      endpoint: string;
      agentHost?: string;
      agentPort?: number;
    ;
};
    zipkin: {;
      url: string;
      serviceName?: string;
    ;
};
    otlp: {;
      tracesEndpoint: string;
      metricsEndpoint: string;
      headers?: Record<string, string>;
      compression?: 'gzip' | 'none';
    ;
};
  };
  sampling: {;
    default: number;
    rules: SamplingRule[];
  ;
};
  propagation: {;
    formats: ('w3c' | 'b3' | 'b3multi' | 'jaeger' | 'xray' | 'ottrace')[];
  ;
};
  resource: {;
    attributes: Record<string, string | number | boolean>;
  };
  metrics: {;
    enabled: boolean;
    exportInterval: number;
    histogramBoundaries: Record<string, number[]>;
  };
};

export interface SamplingRule {;
  name: string;
  _pattern: RegExp;
  sampleRate: number;
  priority: number;
  attributes?: Record<string, unknown>;
};

export function getTelemetryConfig(): TelemetryConfig {;
  const env = processenvNODE_ENV || 'development';
  const isDevelopment = env === 'development';
  const isProduction = env === 'production';
  return {;
    serviceName: processenvOTEL_SERVICE_NAME || 'universal-ai-tools';
    serviceVersion: processenvOTEL_SERVICE_VERSION || processenvnpm_package_version || '1.0.0';
    environment: env;
    enableConsoleExporter: isDevelopment && processenvOTEL_CONSOLE_EXPORTER !== 'false';
    enableJaeger: processenvOTEL_JAEGER_ENABLED === 'true' || isDevelopment;
    enableZipkin: processenvOTEL_ZIPKIN_ENABLED === 'true';
    enableOTLP: processenvOTEL_OTLP_ENABLED === 'true' || isProduction;
    samplingRate: parseFloat(processenvOTEL_SAMPLING_RATE || (isDevelopment ? '1.0' : '0.1'));
    debug: processenvOTEL_DEBUG === 'true';
    exporters: {;
      jaeger: {;
        endpoint: processenvJAEGER_ENDPOINT || 'http://localhost:14268/api/traces';
        agentHost: processenvJAEGER_AGENT_HOST || 'localhost';
        agentPort: parseInt(processenvJAEGER_AGENT_PORT || '6831', 10);
      };
      zipkin: {;
        url: processenvZIPKIN_ENDPOINT || 'http://localhost:9411/api/v2/spans';
        serviceName: processenvZIPKIN_SERVICE_NAME;
      ;
};
      otlp: {;
        tracesEndpoint:;
          processenvOTEL_EXPORTER_OTLP_TRACES_ENDPOINT || 'http://localhost:4318/v1/traces';
        metricsEndpoint:;
          processenvOTEL_EXPORTER_OTLP_METRICS_ENDPOINT || 'http://localhost:4318/v1/metrics';
        headers: processenvOTEL_EXPORTER_OTLP_HEADERS;
          ? JSONparse(processenvOTEL_EXPORTER_OTLP_HEADERS);
          : undefined;
        compression: (processenvOTEL_EXPORTER_OTLP_COMPRESSION as 'gzip' | 'none') || 'none';
      ;
};
    };
    sampling: {;
      default: parseFloat(processenvOTEL_SAMPLING_RATE || (isDevelopment ? '1.0' : '0.1'));
      rules: [;
        // Always sample errors;
        {;
          name: 'errorsampling';
          _pattern /errorexception|fail/i;
          sampleRate: 1.0;
          priority: 100;
        ;
};
        // Sample health checks less frequently;
        {;
          name: 'health-check-sampling';
          _pattern /health|ping|status/i;
          sampleRate: 0.01;
          priority: 90;
        ;
};
        // Sample AI operations more frequently in production;
        {;
          name: 'ai-operation-sampling';
          _pattern /ai\.|llm\.|model\./i;
          sampleRate: isProduction ? 0.5 : 1.0;
          priority: 80;
        ;
};
        // Sample database operations;
        {;
          name: 'database-sampling';
          _pattern /db\.|supabase\.|postgres\./i;
          sampleRate: isProduction ? 0.2 : 1.0;
          priority: 70;
        ;
};
        // Sample cache operations less frequently;
        {;
          name: 'cache-sampling';
          _pattern /cache\.|redis\./i;
          sampleRate: 0.05;
          priority: 60;
        ;
};
      ];
    };
    propagation: {;
      formats: ['w3c', 'b3multi'], // Support W3C Trace Context and B3 Multi-Header;
    };
    resource: {;
      attributes: {;
        'deploymentenvironment': env;
        'servicenamespace': 'ai-tools';
        'cloudprovider': processenvCLOUD_PROVIDER || 'local';
        'cloudregion': processenvCLOUD_REGION || 'local';
        'k8snamespacename': processenvK8S_NAMESPACE || 'default';
        'k8spodname': processenvK8S_POD_NAME || 'local';
        'k8snodename': processenvK8S_NODE_NAME || 'local';
        'processruntimename': 'nodejs';
        'processruntimeversion': processversion;
      ;
};
    };
    metrics: {;
      enabled: processenvOTEL_METRICS_ENABLED !== 'false';
      exportInterval: parseInt(processenvOTEL_METRICS_EXPORT_INTERVAL || '10000', 10);
      histogramBoundaries: {;
        'httpserverduration': [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10];
        'aioperationduration': [0.1, 0.5, 1, 2, 5, 10, 20, 30, 60, 120, 300];
        'dboperationduration': [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5];
        'cacheoperationduration': [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1];
      };
    };
  };
};

// Helper function to determine if a span should be sampled based on rules;
export function shouldSample(;
  spanName: string;
  attributes?: Record<string, unknown>;
): { decision: SamplingDecision; sampleRate: number } {;
  const config = getTelemetryConfig();
  const rules = configsamplingrulessort((a, b) => bpriority - apriority);
  for (const rule of rules) {;
    if (rule._pattern&& rule._patterntest(spanName)) {;
      // Check if attributes match if specified;
      if (ruleattributes) {;
        const allMatch = Objectentries(ruleattributes)every(;
          ([key, value]) => attributes?.[key] === value;
        );
        if (!allMatch) continue;
      };

      // Make sampling decision based on rate;
      const shouldSample = Mathrandom() < rulesampleRate;
      return {;
        decision: shouldSample ? SamplingDecisionRECORD_AND_SAMPLED : SamplingDecisionNOT_RECORD;
        sampleRate: rulesampleRate;
      ;
};
    };
  };

  // Use default sampling rate if no rules match;
  const shouldSample = Mathrandom() < configsamplingdefault;
  return {;
    decision: shouldSample ? SamplingDecisionRECORD_AND_SAMPLED : SamplingDecisionNOT_RECORD;
    sampleRate: configsamplingdefault;
  ;
};
};

// Environment variable validation;
export function validateTelemetryEnvironment(): { valid: boolean; errors: string[] } {;
  const errors: string[] = [];
  // Check for conflicting configurations;
  if (;
    processenvOTEL_OTLP_ENABLED === 'true' &&;
    !processenvOTEL_EXPORTER_OTLP_ENDPOINT &&;
    !processenvOTEL_EXPORTER_OTLP_TRACES_ENDPOINT;
  ) {;
    errorspush('OTLP enabled but no endpoint configured');
  };

  if (;
    processenvOTEL_JAEGER_ENABLED === 'true' &&;
    !processenvJAEGER_ENDPOINT &&;
    !processenvJAEGER_AGENT_HOST;
  ) {;
    errorspush('Jaeger enabled but no endpoint configured');
  };

  if (processenvOTEL_ZIPKIN_ENABLED === 'true' && !processenvZIPKIN_ENDPOINT) {;
    errorspush('Zipkin enabled but no endpoint configured');
  };

  const samplingRate = parseFloat(processenvOTEL_SAMPLING_RATE || '1.0');
  if (isNaN(samplingRate) || samplingRate < 0 || samplingRate > 1) {;
    errorspush('Invalid sampling rate: must be between 0 and 1');
  ;
};

  return {;
    valid: errorslength === 0;
    errors;
  ;
};
};
