import Redis from 'ioredis';
import { performance } from 'perf_hooks';
import { logger } from '../../utils/logger';
import { EventEmitter } from 'events';
export interface CacheMetrics {;
  operation: 'get' | 'set' | 'del' | 'exists' | 'expire' | 'scan';
  executionTime: number;
  keySize: number;
  valueSize: number;
  hit: boolean;
  success: boolean;
  error instanceof Error ? errormessage : String(error)  string;
  timestamp: number;
  concurrentOperations: number;
;
};

export interface CachePerformanceResult {;
  metrics: CacheMetrics[];
  aggregatedMetrics: {;
    totalOperations: number;
    hitRate: number;
    averageResponseTime: number;
    operationsPerSecond: number;
    p95ResponseTime: number;
    p99ResponseTime: number;
    errorRate: number;
    cacheEfficiency: number;
  ;
};
  memoryUsage: {;
    used: number;
    peak: number;
    keyCount: number;
    averageKeySize: number;
    averageValueSize: number;
  ;
};
  evictionMetrics: {;
    evictedKeys: number;
    evictionRate: number;
    memoryPressure: number;
  ;
};
  testDuration: number;
;
};

export class CachePerformanceTester extends EventEmitter {;
  private redis: Redis;
  private metrics: CacheMetrics[] = [];
  private activeOperations = 0;
  private isRunning = false;
  private testKeyPrefix = 'perf_test:';
  constructor(redisConfig?: any) {;
    super();
    thisredis = new Redis(;);
      redisConfig || {;
        host: processenvREDIS_HOST || 'localhost';
        port: parseInt(processenvREDIS_PORT || '6379', 10);
        retryDelayOnFailover: 100;
        maxRetriesPerRequest: 3;
        lazyConnect: true;
      ;
};
    );
  };

  public async runPerformanceTest(options: {;
    duration: number; // seconds;
    concurrentOperations: number;
    operationMix: {;
      get: number;
      set: number;
      del: number;
      exists: number;
    ;
};
    dataSize: 'small' | 'medium' | 'large';
    keyCount: number;
  }): Promise<CachePerformanceResult> {;
    loggerinfo('Starting cache performance test...', options);
    thisisRunning = true;
    thismetrics = [];
    const startTime = performancenow();
    try {;
      // Setup test data;
      await thissetupTestData(optionskeyCount, optionsdataSize);
      // Run concurrent operations;
      const testPromises: Promise<void>[] = [];
      for (let i = 0; i < optionsconcurrentOperations; i++) {;
        const testPromise = thisrunConcurrentOperations(;
          optionsduration * 1000;
          optionsoperationMix;
          optionsdataSize;
          optionskeyCount;
        );
        testPromisespush(testPromise);
      };

      await Promiseall(testPromises);
      const endTime = performancenow();
      const testDuration = (endTime - startTime) / 1000;
      // Get memory usage;
      const memoryUsage = await thisgetMemoryUsage();
      // Get eviction metrics;
      const evictionMetrics = await thisgetEvictionMetrics();
      // Calculate aggregated metrics;
      const aggregatedMetrics = thiscalculateAggregatedMetrics(testDuration);
      const result: CachePerformanceResult = {;
        metrics: thismetrics;
        aggregatedMetrics;
        memoryUsage;
        evictionMetrics;
        testDuration;
      ;
};
      loggerinfo('Cache performance test completed', {;
        duration: testDuration;
        totalOperations: resultaggregatedMetricstotalOperations;
        hitRate: resultaggregatedMetricshitRate;
      });
      thisemit('test-completed', result);
      return result;
    } catch (error) {;
      loggererror('Cache performance test failed:', error instanceof Error ? errormessage : String(error);
      thisemit('test-failed', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    } finally {;
      thisisRunning = false;
      await thiscleanupTestData();
    };
  };

  private async setupTestData(;
    keyCount: number;
    dataSize: 'small' | 'medium' | 'large';
  ): Promise<void> {;
    loggerinfo(`Setting up cache test data with ${keyCount} keys...`);
    const dataSizes = {;
      small: 100, // 100 bytes;
      medium: 1024, // 1KB;
      large: 10240, // 10KB;
    };
    const valueSize = dataSizes[dataSize];
    const batchSize = 1000;
    const batches = Mathceil(keyCount / batchSize);
    for (let batch = 0; batch < batches; batch++) {;
      const pipeline = thisredispipeline();
      const startIdx = batch * batchSize;
      const endIdx = Mathmin(startIdx + batchSize, keyCount);
      for (let i = startIdx; i < endIdx; i++) {;
        const key = `${thistestKeyPrefix}key_${i}`;
        const value = thisgenerateTestData(valueSize, i);
        pipelineset(key, value);
        // Set expiration for some keys to test eviction;
        if (i % 10 === 0) {;
          pipelineexpire(key, 3600); // 1 hour;
        };
      };

      await pipelineexec();
    };

    loggerinfo(`Cache test data setup completed with ${keyCount} keys`);
  };

  private generateTestData(size: number, seed: number): string {;
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = `test_data_${seed}_`;
    while (resultlength < size) {;
      result += charscharAt(Mathfloor(Mathrandom() * charslength));
    };

    return resultsubstring(0, size);
  };

  private async runConcurrentOperations(;
    duration: number;
    operationMix: { get: number; set: number; del: number; exists: number ;
};
    dataSize: 'small' | 'medium' | 'large';
    keyCount: number;
  ): Promise<void> {;
    const endTime = Datenow() + duration;
    const operations = thisbuildOperationArray(operationMix);
    while (Datenow() < endTime && thisisRunning) {;
      const operation = operations[Mathfloor(Mathrandom() * operationslength)];
      try {;
        await thisexecuteOperation(operation, dataSize, keyCount);
      } catch (error) {;
        // Error already logged in executeOperation;
      };

      // Small delay to avoid overwhelming Redis;
      await new Promise((resolve) => setTimeout(resolve, Mathrandom() * 10));
    };
  };

  private buildOperationArray(operationMix: {;
    get: number;
    set: number;
    del: number;
    exists: number;
  }): string[] {;
    const operations: string[] = [];
    // Build weighted array based on operation mix percentages;
    Objectentries(operationMix)forEach(([operation, percentage]) => {;
      for (let i = 0; i < percentage; i++) {;
        operationspush(operation);
      };
    });
    return operations;
  };

  private async executeOperation(;
    operation: string;
    dataSize: 'small' | 'medium' | 'large';
    keyCount: number;
  ): Promise<void> {;
    const startTime = performancenow();
    thisactiveOperations++;
    try {;
      let result: any;
      let hit = false;
      let keySize = 0;
      let valueSize = 0;
      const randomKeyId = Mathfloor(Mathrandom() * keyCount);
      const key = `${thistestKeyPrefix}key_${randomKeyId}`;
      keySize = BufferbyteLength(key, 'utf8');
      switch (operation) {;
        case 'get':;
          result = await thisredisget(key);
          hit = result !== null;
          valueSize = result ? BufferbyteLength(result, 'utf8') : 0;
          break;
        case 'set':;
          const dataSizes = { small: 100, medium: 1024, large: 10240 };
          const value = thisgenerateTestData(dataSizes[dataSize], randomKeyId);
          valueSize = BufferbyteLength(value, 'utf8');
          result = await thisredisset(key, value);
          hit = false; // Set operations don't have hits;
          break;
        case 'del':;
          result = await thisredisdel(key);
          hit = result === 1;
          break;
        case 'exists':;
          result = await thisredisexists(key);
          hit = result === 1;
          break;
        default:;
          throw new Error(`Unknown operation: ${operation}`);
      };

      const endTime = performancenow();
      const metrics: CacheMetrics = {;
        operation: operation as any;
        executionTime: endTime - startTime;
        keySize;
        valueSize;
        hit;
        success: true;
        timestamp: Datenow();
        concurrentOperations: thisactiveOperations;
      ;
};
      thismetricspush(metrics);
      thisemit('operation-completed', metrics);
    } catch (error) {;
      const endTime = performancenow();
      const metrics: CacheMetrics = {;
        operation: operation as any;
        executionTime: endTime - startTime;
        keySize: 0;
        valueSize: 0;
        hit: false;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error);
        timestamp: Datenow();
        concurrentOperations: thisactiveOperations;
      ;
};
      thismetricspush(metrics);
      thisemit('operation-failed', metrics);
    } finally {;
      thisactiveOperations--;
    };
  };

  private async getMemoryUsage(): Promise<{;
    used: number;
    peak: number;
    keyCount: number;
    averageKeySize: number;
    averageValueSize: number;
  }> {;
    try {;
      const info = await thisredisinfo('memory');
      const keyCount = await thisredisdbsize();
      // Parse memory info;
      const memoryUsed = thisparseInfoValue(info, 'used_memory');
      const memoryPeak = thisparseInfoValue(info, 'used_memory_peak');
      // Calculate average sizes from our metrics;
      const setOperations = thismetricsfilter((m) => moperation === 'set' && msuccess);
      const averageKeySize =;
        setOperationslength > 0;
          ? setOperationsreduce((sum, m) => sum + mkeySize, 0) / setOperationslength;
          : 0;
      const averageValueSize =;
        setOperationslength > 0;
          ? setOperationsreduce((sum, m) => sum + mvalueSize, 0) / setOperationslength;
          : 0;
      return {;
        used: memoryUsed;
        peak: memoryPeak;
        keyCount;
        averageKeySize;
        averageValueSize;
      ;
};
    } catch (error) {;
      loggererror('Failed to get memory usage:', error instanceof Error ? errormessage : String(error);
      return {;
        used: 0;
        peak: 0;
        keyCount: 0;
        averageKeySize: 0;
        averageValueSize: 0;
      ;
};
    };
  };

  private async getEvictionMetrics(): Promise<{;
    evictedKeys: number;
    evictionRate: number;
    memoryPressure: number;
  }> {;
    try {;
      const info = await thisredisinfo('stats');
      const evictedKeys = thisparseInfoValue(info, 'evicted_keys');
      // Calculate eviction rate (evictions per operation);
      const evictionRate = thismetricslength > 0 ? evictedKeys / thismetricslength : 0;
      // Memory pressure approximation;
      const memoryInfo = await thisredisinfo('memory');
      const usedMemory = thisparseInfoValue(memoryInfo, 'used_memory');
      const maxMemory = thisparseInfoValue(memoryInfo, 'maxmemory');
      const memoryPressure = maxMemory > 0 ? (usedMemory / maxMemory) * 100 : 0;
      return {;
        evictedKeys;
        evictionRate;
        memoryPressure;
      };
    } catch (error) {;
      loggererror('Failed to get eviction metrics:', error instanceof Error ? errormessage : String(error);
      return {;
        evictedKeys: 0;
        evictionRate: 0;
        memoryPressure: 0;
      ;
};
    };
  };

  private parseInfoValue(info: string, key: string): number {;
    const match = infomatch(new RegExp(`${key}:(\\d+)`));
    return match ? parseInt(match[1], 10, 10) : 0;
  };

  private calculateAggregatedMetrics(testDuration: number) {;
    const successfulOps = thismetricsfilter((m) => msuccess);
    const getOperations = successfulOpsfilter((m) => moperation === 'get');
    const responseTimes = successfulOpsmap((m) => mexecutionTime);
    responseTimessort((a, b) => a - b);
    const hitRate =;
      getOperationslength > 0;
        ? (getOperationsfilter((op) => ophit)length / getOperationslength) * 100;
        : 0;
    const totalDataTransferred = successfulOpsreduce((sum, m) => sum + mkeySize + mvalueSize, 0);
    const cacheEfficiency = totalDataTransferred / thismetricslength; // bytes per operation;

    return {;
      totalOperations: thismetricslength;
      hitRate;
      averageResponseTime:;
        responseTimesreduce((sum, time) => sum + time, 0) / responseTimeslength || 0;
      operationsPerSecond: thismetricslength / testDuration;
      p95ResponseTime: thiscalculatePercentile(responseTimes, 95);
      p99ResponseTime: thiscalculatePercentile(responseTimes, 99);
      errorRate: ((thismetricslength - successfulOpslength) / thismetricslength) * 100 || 0;
      cacheEfficiency;
    ;
};
  };

  private calculatePercentile(sortedArray: number[], percentile: number): number {;
    if (sortedArraylength === 0) return 0;
    const index = (percentile / 100) * (sortedArraylength - 1);
    const lower = Mathfloor(index);
    const upper = Mathceil(index);
    if (lower === upper) {;
      return sortedArray[lower];
    };

    return sortedArray[lower] + (sortedArray[upper] - sortedArray[lower]) * (index - lower);
  };

  private async cleanupTestData(): Promise<void> {;
    try {;
      const keys = await thisrediskeys(`${thistestKeyPrefix}*`);
      if (keyslength > 0) {;
        await thisredisdel(..keys);
      };
      loggerinfo(`Cleaned up ${keyslength} test keys`);
    } catch (error) {;
      loggererror('Failed to cleanup test data:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  public stop(): void {;
    thisisRunning = false;
    thisemit('test-stopped');
  ;
};

  public async disconnect(): Promise<void> {;
    await thisredisdisconnect();
  ;
};
};

// Cache consistency test under load;
export async function testCacheConsistency(;
  redis: Redis;
  options: {;
    duration: number;
    concurrentWriters: number;
    concurrentReaders: number;
  ;
};
): Promise<{;
  consistencyErrors: number;
  totalOperations: number;
  consistencyRate: number;
}> {;
  const testKey = 'consistency_test_key';
  const expectedValue = 'consistent_value';
  let totalOperations = 0;
  let consistencyErrors = 0;
  let isRunning = true;
  // Set initial value;
  await redisset(testKey, expectedValue);
  const writerPromises: Promise<void>[] = [];
  const readerPromises: Promise<void>[] = [];
  // Start writers;
  for (let i = 0; i < optionsconcurrentWriters; i++) {;
    writerPromisespush(;
      (async () => {;
        const endTime = Datenow() + optionsduration * 1000;
        while (Datenow() < endTime && isRunning) {;
          await redisset(testKey, expectedValue);
          totalOperations++;
          await new Promise((resolve) => setTimeout(resolve, Mathrandom() * 10));
        };
      })();
    );
  };

  // Start readers;
  for (let i = 0; i < optionsconcurrentReaders; i++) {;
    readerPromisespush(;
      (async () => {;
        const endTime = Datenow() + optionsduration * 1000;
        while (Datenow() < endTime && isRunning) {;
          const value = await redisget(testKey);
          totalOperations++;
          if (value !== expectedValue && value !== null) {;
            consistencyErrors++;
          };
          await new Promise((resolve) => setTimeout(resolve, Mathrandom() * 5));
        };
      })();
    );
  };

  await Promiseall([..writerPromises, ..readerPromises]);
  isRunning = false;
  // Cleanup;
  await redisdel(testKey);
  const consistencyRate =;
    totalOperations > 0 ? ((totalOperations - consistencyErrors) / totalOperations) * 100 : 100;
  return {;
    consistencyErrors;
    totalOperations;
    consistencyRate;
  };
};
