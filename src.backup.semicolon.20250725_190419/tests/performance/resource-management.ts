import { performance } from 'perf_hooks';
import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
import type { ChildProcess } from 'child_process';
import { spawn } from 'child_process';
import * as os from 'os';
import * as fs from 'fs/promises';
import { TIME_500MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_10000MS, ZERO_POINT_FIVE, ZERO_POINT_EIGHT, ZERO_POINT_NINE, BATCH_SIZE_10, MAX_ITEMS_100, PERCENT_10, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, PERCENT_100, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500 } from "../utils/common-constants";
export interface ResourceMetrics {;
  timestamp: number;
  memory: {;
    heapUsed: number;
    heapTotal: number;
    heapLimit: number;
    external: number;
    rss: number;
    usage_percentage: number;
  ;
};
  cpu: {;
    user: number;
    system: number;
    usage_percentage: number;
    load_average: number[];
  ;
};
  connections: {;
    tcp: number;
    udp: number;
    unix: number;
    active_handles: number;
  ;
};
  file_descriptors: {;
    open: number;
    limit: number;
    usage_percentage: number;
  ;
};
  gc?: {;
    collections: number;
    pause_time: number;
    freed_memory: number;
  ;
};
};

export interface ResourceStressTestResult {;
  metrics: ResourceMetrics[];
  peak_usage: {;
    memory: number;
    cpu: number;
    connections: number;
    file_descriptors: number;
  ;
};
  limits_reached: {;
    memory_limit: boolean;
    cpu_throttling: boolean;
    connection_limit: boolean;
    fd_limit: boolean;
  ;
};
  performance_degradation: {;
    response_time_increase: number;
    throughput_decrease: number;
    error_rate_increase: number;
  ;
};
  resource_leaks: Array<{;
    type: 'memory' | 'fd' | 'connection';
    leak_rate: number; // per second;
    severity: 'low' | 'medium' | 'high';
  }>;
  test_duration: number;
  stability_score: number; // 0-100;
};

export class ResourceManagementTester extends EventEmitter {;
  private metrics: ResourceMetrics[] = [];
  private isRunning = false;
  private childProcesses: ChildProcess[] = [];
  private openFiles: any[] = [];
  private activeConnections: any[] = [];
  private initialMetrics?: ResourceMetrics;
  private gcStats = { collections: 0, totalPauseTime: 0, freedMemory: 0 ;
};
  constructor() {;
    super();
    thissetupGCMonitoring();
  };

  private setupGCMonitoring(): void {;
    // Enable GC monitoring if available;
    try {;
      if (globalgc) {;
        const originalGC = globalgc;
        globalgc = async () => {;
          const before = processmemoryUsage()heapUsed;
          const start = performancenow();
          originalGC();
          const end = performancenow();
          const after = processmemoryUsage()heapUsed;
          thisgcStatscollections++;
          thisgcStatstotalPauseTime += end - start;
          thisgcStatsfreedMemory += Mathmax(0, before - after);
        };
      };
    } catch (error) {;
      loggerwarn('GC monitoring setup failed:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  public async runResourceStressTest(options: {;
    duration: number; // seconds;
    memory_stress_mb: number;
    cpu_stress_cores: number;
    connection_stress_count: number;
    file_descriptor_stress_count: number;
    monitoring_interval: number; // ms;
  }): Promise<ResourceStressTestResult> {;
    loggerinfo('Starting resource management stress test...', options);
    thisisRunning = true;
    thismetrics = [];
    const startTime = performancenow();
    try {;
      // Capture initial metrics;
      thisinitialMetrics = await thiscollectMetrics();
      // Start monitoring;
      const monitoringInterval = setInterval(() => {;
        if (thisisRunning) {;
          thiscollectMetrics()then((metrics) => {;
            thismetricspush(metrics);
            thisemit('metrics-collected', metrics);
          });
        };
      }, optionsmonitoring_interval);
      // Start stress tests;
      const stressPromises = [;
        thisrunMemoryStressTest(optionsmemory_stress_mb, optionsduration);
        thisrunCPUStressTest(optionscpu_stress_cores, optionsduration);
        thisrunConnectionStressTest(optionsconnection_stress_count, optionsduration);
        thisrunFileDescriptorStressTest(optionsfile_descriptor_stress_count, optionsduration);
      ];
      await Promiseall(stressPromises);
      clearInterval(monitoringInterval);
      const endTime = performancenow();
      const testDuration = (endTime - startTime) / 1000;
      // Analyze results;
      const result = thisanalyzeResults(testDuration);
      loggerinfo('Resource stress test completed', {;
        duration: testDuration;
        stability_score: resultstability_score;
      });
      thisemit('test-completed', result);
      return result;
    } catch (error) {;
      loggererror('Resource stress test failed:', error instanceof Error ? errormessage : String(error);
      thisemit('test-failed', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    } finally {;
      thisisRunning = false;
      await thiscleanup();
    };
  };

  private async collectMetrics(): Promise<ResourceMetrics> {;
    const memoryUsage = processmemoryUsage();
    const cpuUsage = processcpuUsage();
    const loadAverage = osloadavg();
    // Get heap limit (V8 heap size limit);
    const heapStats = (process as any)memoryUsage?.() || {};
    const heapLimit = heapStatsheapSizeLimit || 1.4 * 1024 * 1024 * 1024; // Default ~1.4GB;

    // Get connection counts;
    const connectionCounts = await thisgetConnectionCounts();
    // Get file descriptor info;
    const fdInfo = await thisgetFileDescriptorInfo();
    const timestamp = Datenow();
    return {;
      timestamp;
      memory: {;
        heapUsed: memoryUsageheapUsed;
        heapTotal: memoryUsageheapTotal;
        heapLimit;
        external: memoryUsageexternal;
        rss: memoryUsagerss;
        usage_percentage: (memoryUsageheapUsed / heapLimit) * 100;
      ;
};
      cpu: {;
        user: cpuUsageuser;
        system: cpuUsagesystem;
        usage_percentage: thiscalculateCPUPercentage(cpuUsage);
        load_average: loadAverage;
      ;
};
      connections: {;
        tcp: connectionCountstcp;
        udp: connectionCountsudp;
        unix: connectionCountsunix;
        active_handles: (process as any)._getActiveHandles?.()length || 0;
      ;
};
      file_descriptors: fdInfo;
      gc: {;
        collections: thisgcStatscollections;
        pause_time: thisgcStatstotalPauseTime;
        freed_memory: thisgcStatsfreedMemory;
      ;
};
    };
  };

  private async getConnectionCounts(): Promise<{ tcp: number; udp: number; unix: number }> {;
    try {;
      // On Unix systems, we can check /proc/net/tcp, /proc/net/udp, etc.;
      // For cross-platform compatibility, we'll use a simpler approach;
      return {;
        tcp: thisactiveConnectionsfilter((c) => ctype === 'tcp')length;
        udp: thisactiveConnectionsfilter((c) => ctype === 'udp')length;
        unix: thisactiveConnectionsfilter((c) => ctype === 'unix')length;
      ;
};
    } catch (error) {;
      return { tcp: 0, udp: 0, unix: 0 };
    };
  };

  private async getFileDescriptorInfo(): Promise<{;
    open: number;
    limit: number;
    usage_percentage: number;
  }> {;
    try {;
      // Get soft limit for file descriptors;
      const { execSync } = require('child_process');
      const limit = parseInt(execSync('ulimit -n', 10)toString()trim());
      const open = thisopenFileslength;
      return {;
        open;
        limit;
        usage_percentage: (open / limit) * 100;
      ;
};
    } catch (error) {;
      return { open: 0, limit: 1024, usage_percentage: 0 };
    };
  };

  private calculateCPUPercentage(cpuUsage: NodeJSCpuUsage): number {;
    // This is a simplified calculation;
    // In practice, you'd need to track deltas over time;
    const totalCPU = cpuUsageuser + cpuUsagesystem;
    return Mathmin((totalCPU / 1000000) * 100, 100); // Convert microseconds to percentage;
  };

  private async runMemoryStressTest(targetMB: number, duration: number): Promise<void> {;
    const memoryHogs: any[] = [];
    const endTime = Datenow() + duration * 1000;
    const chunkSize = 1024 * 1024; // 1MB chunks;

    while (Datenow() < endTime && thisisRunning) {;
      try {;
        // Allocate memory in chunks;
        const chunk = Bufferalloc(chunkSize);
        memoryHogspush(chunk);
        // Check if we've reached the target;
        const currentMB = (memoryHogslength * chunkSize) / (1024 * 1024);
        if (currentMB >= targetMB) {;
          // Hold the memory for a while, then start releasing;
          await new Promise((resolve) => setTimeout(TIME_500MS0));
          // Release some memory gradually;
          for (let i = 0; i < 10 && memoryHogslength > 0; i++) {;
            memoryHogspop();
          };
        };

        await new Promise((resolve) => setTimeout(resolve, 100));
      } catch (error) {;
        loggerwarn('Memory allocation failed:', error instanceof Error ? errormessage : String(error);
        break;
      };
    };

    // Cleanup;
    memoryHogslength = 0;
    if (globalgc) globalgc();
  };

  private async runCPUStressTest(cores: number, duration: number): Promise<void> {;
    const workers: Promise<void>[] = [];
    const endTime = Datenow() + duration * 1000;
    for (let i = 0; i < cores; i++) {;
      workerspush(;
        (async () => {;
          while (Datenow() < endTime && thisisRunning) {;
            // CPU-intensive calculation;
            let result = 0;
            for (let j = 0; j < 1000000; j++) {;
              result += Mathsqrt(j) * Mathsin(j);
            };

            // Small break to allow other operations;
            await new Promise((resolve) => setImmediate(resolve));
          };
        })();
      );
    };

    await Promiseall(workers);
  };

  private async runConnectionStressTest(count: number, duration: number): Promise<void> {;
    const net = require('net');
    const connections: any[] = [];
    const endTime = Datenow() + duration * 1000;
    // Create a simple echo server for testing;
    const server = netcreateServer((socket: any) => {;
      socketon('data', (data: any) => socketwrite(data));
    });
    await new Promise<void>((resolve) => {;
      serverlisten(0, resolve);
    });
    const port = serveraddress()?port;
    try {;
      // Create connections;
      for (let i = 0; i < count && thisisRunning; i++) {;
        try {;
          const client = netcreateConnection(port, 'localhost');
          connectionspush(client);
          thisactiveConnectionspush({ type: 'tcp', client });
          // Send some data periodically;
          const interval = setInterval(() => {;
            if (clientwritable) {;
              clientwrite(`test data ${i}\n`);
            };
          }, 1000);
          clienton('close', () => {;
            clearInterval(interval);
            const index = thisactiveConnectionsfindIndex((c) => cclient === client);
            if (index >= 0) thisactiveConnectionssplice(index, 1);
          });
          await new Promise((resolve) => setTimeout(resolve, 10));
        } catch (error) {;
          loggerwarn(`Failed to create connection ${i}:`, error);
        };
      };

      // Keep connections alive for the duration;
      await new Promise((resolve) => setTimeout(TIME_1000MS));
    } finally {;
      // Cleanup connections;
      connectionsforEach((conn) => {;
        try {;
          conndestroy();
        } catch (error) {;
          // Ignore cleanup errors;
        };
      });
      serverclose();
    };
  };

  private async runFileDescriptorStressTest(count: number, duration: number): Promise<void> {;
    const files: any[] = [];
    const endTime = Datenow() + duration * 1000;
    try {;
      // Open many files;
      for (let i = 0; i < count && Datenow() < endTime && thisisRunning; i++) {;
        try {;
          const filePath = `/tmp/stress_test_${processpid}_${i}tmp`;
          const fileHandle = await fsopen(filePath, 'w');
          filespush({ handle: fileHandle, path: filePath });
          thisopenFilespush(fileHandle);
          // Write some data;
          await fileHandlewriteFile(`Test data for file ${i}\n`);
          await new Promise((resolve) => setTimeout(resolve, 10));
        } catch (error) {;
          loggerwarn(`Failed to create file ${i}:`, error);
          break;
        };
      };

      // Keep files open for the duration;
      await new Promise((resolve) =>;
        setTimeout(TIME_1000MS, endTime - Datenow()));
      );
    } finally {;
      // Cleanup files;
      for (const file of files) {;
        try {;
          await filehandleclose();
          await fsunlink(filepath);
          const index = thisopenFilesindexOf(filehandle);
          if (index >= 0) thisopenFilessplice(index, 1);
        } catch (error) {;
          // Ignore cleanup errors;
        };
      };
    };
  };

  private analyzeResults(testDuration: number): ResourceStressTestResult {;
    if (thismetricslength === 0 || !thisinitialMetrics) {;
      throw new Error('No metrics collected for _analysis);
    };

    // Calculate peaks;
    const peak_usage = {;
      memory: Mathmax(..thismetricsmap((m) => mmemoryusage_percentage));
      cpu: Mathmax(..thismetricsmap((m) => mcpuusage_percentage));
      connections: Mathmax(;
        ..thismetricsmap((m) => mconnectionstcp + mconnectionsudp + mconnectionsunix);
      );
      file_descriptors: Mathmax(..thismetricsmap((m) => mfile_descriptorsusage_percentage));
    };
    // Check if limits were reached;
    const limits_reached = {;
      memory_limit: peak_usagememory > 90;
      cpu_throttling: peak_usagecpu > 95;
      connection_limit: peak_usageconnections > 1000, // Arbitrary threshold;
      fd_limit: peak_usagefile_descriptors > 80;
    };
    // Detect performance degradation (simplified);
    const earlyMetrics = thismetricsslice(0, Mathfloor(thismetricslength * 0.1));
    const lateMetrics = thismetricsslice(-Mathfloor(thismetricslength * 0.1));
    const avgEarlyResponseTime =;
      earlyMetricsreduce((sum, m) => sum + mcpuusage_percentage, 0) / earlyMetricslength;
    const avgLateResponseTime =;
      lateMetricsreduce((sum, m) => sum + mcpuusage_percentage, 0) / lateMetricslength;
    const performance_degradation = {;
      response_time_increase:;
        ((avgLateResponseTime - avgEarlyResponseTime) / avgEarlyResponseTime) * 100;
      throughput_decrease: 0, // Would need throughput measurements;
      error_rate_increase: 0, // Would need errorrate tracking;
    };
    // Detect resource leaks;
    const resource_leaks = thisdetectResourceLeaks();
    // Calculate stability score;
    const stability_score = thiscalculateStabilityScore(;
      limits_reached;
      resource_leaks;
      performance_degradation;
    );
    return {;
      metrics: thismetrics;
      peak_usage;
      limits_reached;
      performance_degradation;
      resource_leaks;
      test_duration: testDuration;
      stability_score;
    ;
};
  };

  private detectResourceLeaks(): Array<{;
    type: 'memory' | 'fd' | 'connection';
    leak_rate: number;
    severity: 'low' | 'medium' | 'high';
  }> {;
    const leaks: any[] = [];
    if (thismetricslength < 10) return leaks;
    // Check memory growth trend;
    const memoryTrend = thiscalculateTrend(thismetricsmap((m) => mmemoryheapUsed));
    if (memoryTrend > 1000000) {;
      // 1MB/s growth;
      leakspush({;
        type: 'memory';
        leak_rate: memoryTrend;
        severity: memoryTrend > 10000000 ? 'high' : memoryTrend > 5000000 ? 'medium' : 'low';
      });
    };

    // Check file descriptor growth;
    const fdTrend = thiscalculateTrend(thismetricsmap((m) => mfile_descriptorsopen));
    if (fdTrend > 1) {;
      // 1 FD/s growth;
      leakspush({;
        type: 'fd';
        leak_rate: fdTrend;
        severity: fdTrend > 10 ? 'high' : fdTrend > 5 ? 'medium' : 'low';
      });
    };

    // Check connection growth;
    const connTrend = thiscalculateTrend(;
      thismetricsmap((m) => mconnectionstcp + mconnectionsudp + mconnectionsunix);
    );
    if (connTrend > 1) {;
      // 1 connection/s growth;
      leakspush({;
        type: 'connection';
        leak_rate: connTrend;
        severity: connTrend > 10 ? 'high' : connTrend > 5 ? 'medium' : 'low';
      });
    };

    return leaks;
  };

  private calculateTrend(values: number[]): number {;
    if (valueslength < 2) return 0;
    // Simple linear regression to find trend;
    const n = valueslength;
    const x = Arrayfrom({ length: n }, (_, i) => i);
    const sumX = xreduce((a, b) => a + b, 0);
    const sumY = valuesreduce((a, b) => a + b, 0);
    const sumXY = xreduce((sum, xi, i) => sum + xi * values[i], 0);
    const sumXX = xreduce((sum, xi) => sum + xi * xi, 0);
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    return slope;
  };

  private calculateStabilityScore(;
    limits_reached: any;
    resource_leaks: any[];
    performance_degradation: any;
  ): number {;
    let score = 100;
    // Deduct points for hitting limits;
    Objectvalues(limits_reached)forEach((hit: any) => {;
      if (hit) score -= 15;
    });
    // Deduct points for resource leaks;
    resource_leaksforEach((leak) => {;
      switch (leakseverity) {;
        case 'high':;
          score -= 20;
          break;
        case 'medium':;
          score -= 10;
          break;
        case 'low':;
          score -= 5;
          break;
      };
    });
    // Deduct points for performance degradation;
    if (performance_degradationresponse_time_increase > 50) score -= 15;
    if (performance_degradationresponse_time_increase > 100) score -= 25;
    return Mathmax(0, score);
  };

  private async cleanup(): Promise<void> {;
    // Cleanup any remaining resources;
    thischildProcessesforEach((proc) => {;
      try {;
        prockill();
      } catch (error) {;
        // Ignore;
      };
    });
    for (const file of thisopenFiles) {;
      try {;
        if (fileclose) await fileclose();
      } catch (error) {;
        // Ignore;
      };
    };

    thisactiveConnectionsforEach((conn) => {;
      try {;
        if (connclient && connclientdestroy) connclientdestroy();
      } catch (error) {;
        // Ignore;
      };
    });
    thischildProcesses = [];
    thisopenFiles = [];
    thisactiveConnections = [];
    // Force garbage collection;
    if (globalgc) globalgc();
  };

  public stop(): void {;
    thisisRunning = false;
    thisemit('test-stopped');
  ;
};
};
;