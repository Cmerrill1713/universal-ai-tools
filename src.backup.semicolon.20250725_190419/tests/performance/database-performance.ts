import { PerformanceObserver, performance } from 'perf_hooks';
import { createClient } from '@supabase/supabase-js';
import { BATCH_SIZE_10, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500, MAX_ITEMS_100, PERCENT_10, PERCENT_100, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, TIME_10000MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_500MS, ZERO_POINT_EIGHT, ZERO_POINT_FIVE, ZERO_POINT_NINE } from "../utils/common-constants";
const supabase = createClient(;);
  processenvSUPABASE_URL || 'http://localhost:54321';
  processenvSUPABASE_ANON_KEY || '';
);
import { logger } from '../../utils/logger';
import { EventEmitter } from 'events';
import { BATCH_SIZE_10, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500, MAX_ITEMS_100, PERCENT_10, PERCENT_100, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, TIME_10000MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_500MS, ZERO_POINT_EIGHT, ZERO_POINT_FIVE, ZERO_POINT_NINE } from "../utils/common-constants";
export interface DatabaseMetrics {;
  connectionTime: number;
  queryExecutionTime: number;
  resultSetSize: number;
  memoryUsage: number;
  concurrent_connections: number;
  query_type: 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE';
  success: boolean;
  error instanceof Error ? errormessage : String(error)  string;
  timestamp: number;
;
};

export interface ConnectionPoolMetrics {;
  total_connections: number;
  active_connections: number;
  idle_connections: number;
  waiting_connections: number;
  connectionerrors: number;
  average_wait_time: number;
  max_wait_time: number;
  pool_exhausted_count: number;
;
};

export interface DatabasePerformanceResult {;
  queryMetrics: DatabaseMetrics[];
  connectionPoolMetrics: ConnectionPoolMetrics;
  aggregatedMetrics: {;
    averageQueryTime: number;
    maxQueryTime: number;
    minQueryTime: number;
    successRate: number;
    queriesPerSecond: number;
    p95ResponseTime: number;
    p99ResponseTime: number;
  ;
};
  testDuration: number;
  totalQueries: number;
;
};

export class DatabasePerformanceTester extends EventEmitter {;
  private metrics: DatabaseMetrics[] = [];
  private connectionPool: any[] = [];
  private activeConnections = 0;
  private maxConnections = 20;
  private isRunning = false;
  constructor() {;
    super();
  };

  public async runPerformanceTest(options: {;
    duration: number; // seconds;
    concurrentConnections: number;
    queryTypes: Array<'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE'>;
    dataSize: 'small' | 'medium' | 'large';
  }): Promise<DatabasePerformanceResult> {;
    loggerinfo('Starting database performance test...', options);
    thisisRunning = true;
    thismetrics = [];
    const startTime = performancenow();
    try {;
      // Initialize test data;
      await thissetupTestData(optionsdataSize);
      // Run concurrent query tests;
      const testPromises: Promise<void>[] = [];
      for (let i = 0; i < optionsconcurrentConnections; i++) {;
        const testPromise = thisrunConcurrentQueries(optionsduration * 1000, optionsqueryTypes);
        testPromisespush(testPromise);
      };

      await Promiseall(testPromises);
      const endTime = performancenow();
      const testDuration = (endTime - startTime) / 1000;
      // Get connection pool metrics;
      const poolMetrics = await thisgetConnectionPoolMetrics();
      // Calculate aggregated metrics;
      const aggregatedMetrics = thiscalculateAggregatedMetrics();
      const result: DatabasePerformanceResult = {;
        queryMetrics: thismetrics;
        connectionPoolMetrics: poolMetrics;
        aggregatedMetrics;
        testDuration;
        totalQueries: thismetricslength;
      ;
};
      loggerinfo('Database performance test completed', {;
        duration: testDuration;
        totalQueries: resulttotalQueries;
        successRate: resultaggregatedMetricssuccessRate;
      });
      thisemit('test-completed', result);
      return result;
    } catch (error) {;
      loggererror('Database performance test failed:', error instanceof Error ? errormessage : String(error);
      thisemit('test-failed', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    } finally {;
      thisisRunning = false;
      await thiscleanupTestData();
    };
  };

  private async setupTestData(size: 'small' | 'medium' | 'large'): Promise<void> {;
    const recordCounts = {;
      small: 1000;
      medium: 10000;
      large: 100000;
    };
    const recordCount = recordCounts[size];
    loggerinfo(`Setting up test data with ${recordCount} records...`);
    // Create test table if it doesn't exist;
    try {;
      await supabaserpc('create_performance_test_table');
    } catch (error) {;
      // Table might already exist;
    };

    // Insert test data in batches;
    const batchSize = 1000;
    const batches = Mathceil(recordCount / batchSize);
    for (let i = 0; i < batches; i++) {;
      const batchData = [];
      const startIdx = i * batchSize;
      const endIdx = Mathmin(startIdx + batchSize, recordCount);
      for (let j = startIdx; j < endIdx; j++) {;
        batchDatapush({;
          test_id: `test_${j}`;
          test_data: `Performance test data for record ${j}`;
          test_number: j;
          test_timestamp: new Date()toISOString();
          test_json: {;
            id: j;
            data: `Test data ${j}`;
            nested: {;
              value: j * 2;
              text: `Nested value ${j}`;
            };
          };
        });
      };

      await supabasefrom('performance_test_data')insert(batchData);
    };

    loggerinfo(`Test data setup completed with ${recordCount} records`);
  };

  private async runConcurrentQueries(;
    duration: number;
    queryTypes: Array<'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE'>;
  ): Promise<void> {;
    const endTime = Datenow() + duration;
    while (Datenow() < endTime && thisisRunning) {;
      const queryType = queryTypes[Mathfloor(Mathrandom() * queryTypeslength)];
      try {;
        await thisexecuteQuery(queryType);
      } catch (error) {;
        // Error already logged in executeQuery;
      };

      // Small delay to avoid overwhelming the database;
      await new Promise((resolve) => setTimeout(resolve, Mathrandom() * 100));
    };
  };

  private async executeQuery(queryType: 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE'): Promise<void> {;
    const startTime = performancenow();
    const memoryBefore = processmemoryUsage();
    thisactiveConnections++;
    try {;
      let result: any;
      switch (queryType) {;
        case 'SELECT':;
          result = await thisexecuteSelectQuery();
          break;
        case 'INSERT':;
          result = await thisexecuteInsertQuery();
          break;
        case 'UPDATE':;
          result = await thisexecuteUpdateQuery();
          break;
        case 'DELETE':;
          result = await thisexecuteDeleteQuery();
          break;
      };

      const endTime = performancenow();
      const memoryAfter = processmemoryUsage();
      const metrics: DatabaseMetrics = {;
        connectionTime: 0, // Supabase handles connection pooling;
        queryExecutionTime: endTime - startTime;
        resultSetSize: result?data?length || 0;
        memoryUsage: memoryAfterheapUsed - memoryBeforeheapUsed;
        concurrent_connections: thisactiveConnections;
        query_type: queryType;
        success: !resulterror;
        error instanceof Error ? errormessage : String(error) resulterror instanceof Error ? errormessage : String(error)message;
        timestamp: Datenow();
      ;
};
      thismetricspush(metrics);
      thisemit('query-completed', metrics);
    } catch (error) {;
      const endTime = performancenow();
      const memoryAfter = processmemoryUsage();
      const metrics: DatabaseMetrics = {;
        connectionTime: 0;
        queryExecutionTime: endTime - startTime;
        resultSetSize: 0;
        memoryUsage: memoryAfterheapUsed - memoryBeforeheapUsed;
        concurrent_connections: thisactiveConnections;
        query_type: queryType;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error);
        timestamp: Datenow();
      ;
};
      thismetricspush(metrics);
      thisemit('query-failed', metrics);
    } finally {;
      thisactiveConnections--;
    };
  };

  private async executeSelectQuery(): Promise<unknown> {;
    const randomOffset = Mathfloor(Mathrandom() * 1000);
    const queries = [;
      // Simple select;
      () =>;
        supabase;
          from('performance_test_data');
          select('*');
          range(randomOffset, randomOffset + 10);
      // Select with filter;
      () =>;
        supabase;
          from('performance_test_data');
          select('*');
          gte('test_number', randomOffset);
          lt('test_number', randomOffset + 100);
      // Select with text search;
      () =>;
        supabase;
          from('performance_test_data');
          select('*');
          textSearch('test_data', `record ${randomOffset}`);
      // Aggregate query;
      () => supabasefrom('performance_test_data')select('test_numbercount(), test_numberavg()');
      // JSON query;
      () => supabasefrom('performance_test_data')select('*')eq('test_json->id', randomOffset);
    ];
    const query = queries[Mathfloor(Mathrandom() * querieslength)];
    return await query();
  };

  private async executeInsertQuery(): Promise<unknown> {;
    const testId = `perf_test_${Datenow()}_${Mathrandom()}`;
    return await supabasefrom('performance_test_data')insert({;
      test_id: testId;
      test_data: `Performance test insert ${Datenow()}`;
      test_number: Mathfloor(Mathrandom() * 1000000);
      test_timestamp: new Date()toISOString();
      test_json: {;
        id: Datenow();
        data: `Insert test data`;
        nested: {;
          value: Mathrandom() * 1000;
          text: `Nested insert value`;
        ;
};
      };
    });
  };

  private async executeUpdateQuery(): Promise<unknown> {;
    const randomId = Mathfloor(Mathrandom() * 1000);
    return await supabase;
      from('performance_test_data');
      update({;
        test_data: `Updated at ${Datenow()}`;
        test_timestamp: new Date()toISOString();
      });
      eq('test_number', randomId);
  };

  private async executeDeleteQuery(): Promise<unknown> {;
    // Delete records that were inserted during the test;
    return await supabase;
      from('performance_test_data');
      delete();
      like('test_id', 'perf_test_%');
      limit(1);
  };

  private async getConnectionPoolMetrics(): Promise<ConnectionPoolMetrics> {;
    // Since we're using Supabase, we can't directly access connection pool metrics;
    // We'll simulate based on our tracking;
    return {;
      total_connections: thismaxConnections;
      active_connections: thisactiveConnections;
      idle_connections: thismaxConnections - thisactiveConnections;
      waiting_connections: 0;
      connectionerrors: thismetricsfilter((m) => !msuccess)length;
      average_wait_time: 0;
      max_wait_time: 0;
      pool_exhausted_count: 0;
    ;
};
  };

  private calculateAggregatedMetrics() {;
    const successfulQueries = thismetricsfilter((m) => msuccess);
    const queryTimes = successfulQueriesmap((m) => mqueryExecutionTime);
    queryTimessort((a, b) => a - b);
    const totalTime =;
      thismetricslength > 0;
        ? (thismetrics[thismetricslength - 1]timestamp - thismetrics[0]timestamp) / 1000;
        : 1;
    return {;
      averageQueryTime: queryTimesreduce((sum, time) => sum + time, 0) / queryTimeslength || 0;
      maxQueryTime: Mathmax(..queryTimes) || 0;
      minQueryTime: Mathmin(..queryTimes) || 0;
      successRate: (successfulQuerieslength / thismetricslength) * 100 || 0;
      queriesPerSecond: thismetricslength / totalTime;
      p95ResponseTime: thiscalculatePercentile(queryTimes, 95);
      p99ResponseTime: thiscalculatePercentile(queryTimes, 99);
    };
  };

  private calculatePercentile(sortedArray: number[], percentile: number): number {;
    if (sortedArraylength === 0) return 0;
    const index = (percentile / 100) * (sortedArraylength - 1);
    const lower = Mathfloor(index);
    const upper = Mathceil(index);
    if (lower === upper) {;
      return sortedArray[lower];
    };

    return sortedArray[lower] + (sortedArray[upper] - sortedArray[lower]) * (index - lower);
  };

  private async cleanupTestData(): Promise<void> {;
    try {;
      // Clean up test data that was created during the test;
      await supabasefrom('performance_test_data')delete()like('test_id', 'perf_test_%');
      loggerinfo('Test data cleanup completed');
    } catch (error) {;
      loggererror('Failed to cleanup test data:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  public stop(): void {;
    thisisRunning = false;
    thisemit('test-stopped');
  ;
};
};

// Migration test;
export async function testMigrationPerformance(): Promise<{;
  migrationTime: number;
  rollbackTime: number;
  dataIntegrity: boolean;
}> {;
  const startTime = performancenow();
  try {;
    // Test migration performance;
    // This would require actual migration scripts;
    await new Promise((resolve) => setTimeout(TIME_1000MS)); // Simulate migration;
    const migrationEndTime = performancenow();
    const migrationTime = migrationEndTime - startTime;
    // Test rollback performance;
    const rollbackStartTime = performancenow();
    await new Promise((resolve) => setTimeout(TIME_500MS)); // Simulate rollback;
    const rollbackEndTime = performancenow();
    const rollbackTime = rollbackEndTime - rollbackStartTime;
    // Test data integrity;
    const dataIntegrity = true; // This would involve actual data validation;

    return {;
      migrationTime;
      rollbackTime;
      dataIntegrity;
    };
  } catch (error) {;
    loggererror('Migration performance test failed:', error instanceof Error ? errormessage : String(error);
    throw error instanceof Error ? errormessage : String(error);
  };
};

// Backup operation performance test;
export async function testBackupPerformance(): Promise<{;
  backupTime: number;
  backupSize: number;
  compressionRatio: number;
  restoreTime: number;
}> {;
  const startTime = performancenow();
  try {;
    // This would integrate with the actual backup service;
    // For now, we'll simulate the backup process;
    await new Promise((resolve) => setTimeout(resolve, 2000)); // Simulate backup;
    const backupEndTime = performancenow();
    const backupTime = backupEndTime - startTime;
    // Simulate restore;
    const restoreStartTime = performancenow();
    await new Promise((resolve) => setTimeout(TIME_500MS)); // Simulate restore;
    const restoreEndTime = performancenow();
    const restoreTime = restoreEndTime - restoreStartTime;
    return {;
      backupTime;
      backupSize: 1024 * 1024 * 100, // 100MB simulated;
      compressionRatio: 0.3, // 30% of original size;
      restoreTime;
    };
  } catch (error) {;
    loggererror('Backup performance test failed:', error instanceof Error ? errormessage : String(error);
    throw error instanceof Error ? errormessage : String(error);
  };
};
