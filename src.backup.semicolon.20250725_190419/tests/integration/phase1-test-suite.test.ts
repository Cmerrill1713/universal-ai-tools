/* eslint-disable no-undef */;
/**;
 * Phase 1 Integration Test Suite;
 * Tests all Phase 1 fixes using generated test data;
 */;

import { describe, beforeAll, afterAll, beforeEach, afterEach, it, expect } from '@jest/globals';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { Phase1TestDataGenerator } from '../../../scripts/generate-phase1-test-datajs';
import requestfrom 'supertest';
import { Server } from 'http';
// Test configuration;
const testConfig = {;
  supabaseUrl: processenvSUPABASE_URL || 'http://localhost:54321';
  supabaseKey: processenvSUPABASE_SERVICE_KEY || 'test-key';
  serverPort: processenvPORT || 9998;
  baseUrl: `http://localhost:${processenvPORT || 9998}`;
};
// Global test context;
let supabase: SupabaseClient;
let testDataGenerator: Phase1TestDataGenerator;
let server: Server;
let testData: any;
describe('Phase 1 Integration Test Suite', () => {;
  beforeAll(async () => {;
    // Initialize Supabase client;
    supabase = createClient(testConfigsupabaseUrl, testConfigsupabaseKey);
    // Initialize test data generator;
    testDataGenerator = new Phase1TestDataGenerator();
    await testDataGeneratorinitialize();
    // Generate test data;
    loggerinfo('Generating test data for Phase 1 tests...');
    await testDataGeneratorgenerateAllData();
    await testDataGeneratorstoreAllData();
    testData = testDataGeneratorgeneratedData;
    loggerinfo('Test data generation complete');
  }, 30000);
  afterAll(async () => {;
    // Cleanup test data;
    if (testDataGenerator) {;
      loggerinfo('Cleaning up test data...');
      await testDataGeneratorcleanup();
    };
  }, 15000);
  describe('Authentication System', () => {;
    it('should authenticate with valid test API key', async () => {;
      const testApiKey = testDataapiKeys[0];
      const response = await requesttestConfigbaseUrl);
        get('/api/health');
        set('Authorization', `Bearer ${testApiKeykey_hash}`);
        expect(200);
      expect(responsebodysuccess)toBe(true);
    });
    it('should reject invalid API key', async () => {;
      await requesttestConfigbaseUrl);
        get('/api/health');
        set('Authorization', 'Bearer invalid_key');
        expect(401);
    });
    it('should handle missing authentication gracefully', async () => {;
      const response = await requesttestConfigbaseUrl)get('/api/health')expect(200); // Health endpoint should be public;

      expect(responsebodystatus)toBeDefined();
    });
    it('should validate JWT tokens correctly', async () => {;
      // Test JWT validation if implemented;
      const response = await requesttestConfigbaseUrl);
        post('/api/auth/validate');
        send({ token: 'test_jwt_token' });
      expect(responsestatus)toBeOneOf([200, 401, 404]); // Depends on implementation;
    });
  });
  describe('Agent System', () => {;
    it('should list all test agents', async () => {;
      const response = await requesttestConfigbaseUrl)get('/api/agents')expect(200);
      expect(responsebodysuccess)toBe(true);
      expect(ArrayisArray(responsebodydata))toBe(true);
    });
    it('should filter agents by type', async () => {;
      const response = await requesttestConfigbaseUrl);
        get('/api/agents?type=cognitive');
        expect(200);
      if (responsebodysuccess && responsebodydata) {;
        responsebodydataforEach((agent: any) => {;
          expect(agenttype)toBe('cognitive');
        });
      };
    });
    it('should get agent details', async () => {;
      const testAgent = testDataagents[0];
      const response = await requesttestConfigbaseUrl);
        get(`/api/agents/${testAgentid}`);
        expect(200);
      expect(responsebodysuccess)toBe(true);
      expect(responsebodydataid)toBe(testAgentid);
    });
    it('should handle agent execution request async () => {;
      const testAgent = testDataagentsfind((a: any) => astatus === 'active');
      if (testAgent) {;
        const response = await requesttestConfigbaseUrl);
          post(`/api/agents/${testAgentid}/execute`);
          send({;
            task: 'test_task';
            input'test _inputdata';
          });
        expect(responsestatus)toBeOneOf([200, 202, 404, 501]); // Depends on implementation;
      };
    });
  });
  describe('Memory System', () => {;
    it('should store new memory records', async () => {;
      const newMemory = {;
        service_id: 'test_service_integration';
        memory_type: 'semantic';
        content'Integration test memory content;
        metadata: { test: true, suite: 'phase1' };
        importance_score: 0.8;
      ;
};
      const response = await requesttestConfigbaseUrl);
        post('/api/memory/store');
        send(newMemory);
        expect(201);
      expect(responsebodysuccess)toBe(true);
      expect(responsebodydataid)toBeDefined();
    });
    it('should query memories by content async () => {;
      const response = await requesttestConfigbaseUrl);
        post('/api/memory/query');
        send({;
          query: 'test memory';
          limit: 10;
        });
        expect(200);
      expect(responsebodysuccess)toBe(true);
      expect(ArrayisArray(responsebodydatamemories))toBe(true);
    });
    it('should perform vector similarity search', async () => {;
      const response = await requesttestConfigbaseUrl)post('/api/memory/search')send({;
        query: 'system architecture configuration';
        threshold: 0.7;
        limit: 5;
      });
      expect(responsestatus)toBeOneOf([200, 501]); // 501 if not implemented;

      if (responsestatus === 200) {;
        expect(responsebodysuccess)toBe(true);
        expect(responsebodydatamemories)toBeDefined();
      };
    });
    it('should retrieve memory by ID', async () => {;
      const testMemory = testDatamemories[0];
      const response = await requesttestConfigbaseUrl);
        get(`/api/memory/${testMemoryid}`);
        expect(200);
      expect(responsebodysuccess)toBe(true);
      expect(responsebodydataid)toBe(testMemoryid);
    });
    it('should update memory importance scores', async () => {;
      const testMemory = testDatamemories[0];
      const response = await requesttestConfigbaseUrl);
        patch(`/api/memory/${testMemoryid}`);
        send({;
          importance_score: 0.9;
          metadata: { ..testMemorymetadata, updated: true ;
};
        });
      expect(responsestatus)toBeOneOf([200, 404]); // Depends on implementation;
    });
  });
  describe('Tool System', () => {;
    it('should list available tools', async () => {;
      const response = await requesttestConfigbaseUrl)get('/api/tools')expect(200);
      expect(responsebodysuccess)toBe(true);
      expect(ArrayisArray(responsebodydata))toBe(true);
    });
    it('should execute a test tool', async () => {;
      const testTool = testDatatoolsfind((t: any) => tis_active);
      if (testTool) {;
        const response = await requesttestConfigbaseUrl);
          post(`/api/tools/${testToolid}/execute`);
          send({;
            parameters: { input'test execution data' ;
};
          });
        expect(responsestatus)toBeOneOf([200, 404, 501]); // Depends on implementation;
      };
    });
    it('should validate tool schemas', async () => {;
      const testTool = testDatatools[0];
      const response = await requesttestConfigbaseUrl);
        post(`/api/tools/${testToolid}/validate`);
        send({;
          input{ test: 'validation data' ;
};
        });
      expect(responsestatus)toBeOneOf([200, 400, 404]); // Depends on implementation;
    });
  });
  describe('Security Features', () => {;
    it('should implement rate limiting', async () => {;
      const requests = [];
      // Send multiple requests rapidly;
      for (let i = 0; i < 10; i++) {;
        requestspush(requesttestConfigbaseUrl)get('/api/health'));
      };

      const responses = await Promiseall(requests);
      // Should have at least one successful response;
      expect(responsessome((r) => rstatus === 200))toBe(true);
      // Rate limiting might kick in for some requests;
      // This depends on the actual rate limiting implementation;
    });
    it('should sanitize _inputdata', async () => {;
      const maliciousInput = {;
        content'<script>alert("xss")</script>';
        metadata: {;
          dangerous: '"; DROP TABLE ai_memories; --';
          xss: '<img src=x onerroralert(1)>';
        };
      };
      const response = await requesttestConfigbaseUrl);
        post('/api/memory/store');
        send({;
          service_id: 'security_test';
          memory_type: 'test';
          ..maliciousInput;
        });
      // Should either reject or sanitize the input;
      if (responsestatus === 201) {;
        expect(responsebodydatacontentnottoContain('<script>');
        expect(responsebodydatametadatadangerous)nottoContain('DROP TABLE');
      };
    });
    it('should validate CORS headers', async () => {;
      const response = await requesttestConfigbaseUrl);
        options('/api/health');
        set('Origin', 'https://malicious-sitecom');
      // Should have appropriate CORS headers or reject;
      expect(responsestatus)toBeOneOf([200, 204, 403]);
    });
  });
  describe('WebSocket Features', () => {;
    it('should handle WebSocket connection attempts', async () => {;
      // Test WebSocket endpoint availability;
      const response = await requesttestConfigbaseUrl)get('/ws');
      // WebSocket upgrade should be handled differently;
      expect(responsestatus)toBeOneOf([200, 400, 404, 426]); // 426 = Upgrade Required;
    });
  });
  describe('Context System', () => {;
    it('should store and retrieve context data', async () => {;
      const contextData = {;
        type: 'test_context';
        content'Integration test context content;
        metadata: { suite: 'phase1', test: true };
        weight: 0.8;
      ;
};
      const response = await requesttestConfigbaseUrl)post('/api/context')send(contextData);
      expect(responsestatus)toBeOneOf([200, 201, 404]); // Depends on implementation;
    });
    it('should query context by type', async () => {;
      const response = await requesttestConfigbaseUrl)get('/api/context?type=conversation');
      expect(responsestatus)toBeOneOf([200, 404]); // Depends on implementation;
    });
  });
  describe('Health and Monitoring', () => {;
    it('should provide health check endpoint', async () => {;
      const response = await requesttestConfigbaseUrl)get('/api/health')expect(200);
      expect(responsebodystatus)toBeDefined();
      expect(responsebodyversion)toBeDefined();
      expect(responsebodyuptime)toBeDefined();
    });
    it('should provide metrics endpoint', async () => {;
      const response = await requesttestConfigbaseUrl)get('/metrics');
      expect(responsestatus)toBeOneOf([200, 404]); // Depends on implementation;
      if (responsestatus === 200) {;
        expect(responsetext)toContain('# HELP'); // Prometheus format;
      };
    });
    it('should report service health', async () => {;
      const response = await requesttestConfigbaseUrl)get('/api/health/detailed')expect(200);
      expect(responsebodyservices)toBeDefined();
      expect(responsebodymetrics)toBeDefined();
    });
  });
  describe('Error Handling', () => {;
    it('should handle 404 errors gracefully', async () => {;
      const response = await requesttestConfigbaseUrl);
        get('/api/nonexistent-endpoint');
        expect(404);
      expect(responsebodyerror instanceof Error ? errormessage : String(error) toBeDefined();
      expect(responsebodyerrorcode)toBeDefined();
    });
    it('should handle malformed JSON', async () => {;
      const response = await requesttestConfigbaseUrl);
        post('/api/memory/store');
        set('Content-Type', 'application/json');
        send('{ invalid json }');
      expect(responsestatus)toBeOneOf([400, 422]);
      expect(responsebodyerror instanceof Error ? errormessage : String(error) toBeDefined();
    });
    it('should handle missing required fields', async () => {;
      const response = await requesttestConfigbaseUrl);
        post('/api/memory/store');
        send({;
          // Missing required fields;
          metadata: { test: true ;
};
        });
      expect(responsestatus)toBeOneOf([400, 422]);
      expect(responsebodyerror instanceof Error ? errormessage : String(error) toBeDefined();
    });
  });
  describe('Database Integration', () => {;
    it('should connect to database successfully', async () => {;
      const { data, error } = await supabasefrom('ai_memories')select('count')limit(1);
      expect(error instanceof Error ? errormessage : String(error) toBeNull();
      expect(data)toBeDefined();
    });
    it('should handle database query errors gracefully', async () => {;
      // Attempt invalid query;
      const { data, error } = await supabasefrom('nonexistent_table')select('*');
      expect(error instanceof Error ? errormessage : String(error) toBeDefined();
      expect(data)toBeNull();
    });
    it('should maintain data consistency', async () => {;
      // Insert test record;
      const testRecord = {;
        service_id: 'consistency_test';
        memory_type: 'test';
        content'Consistency test content;
      };
      const { data: inserted, error instanceof Error ? errormessage : String(error) insertError } = await supabase;
        from('ai_memories');
        insert([testRecord]);
        select();
        single();
      expect(insertError)toBeNull();
      expect(inserted)toBeDefined();
      // Verify record exists;
      const { data: retrieved, error instanceof Error ? errormessage : String(error) retrieveError } = await supabase;
        from('ai_memories');
        select('*');
        eq('id', insertedid);
        single();
      expect(retrieveError)toBeNull();
      expect(retrievedcontenttoBe(testRecordcontent;
      // Cleanup;
      await supabasefrom('ai_memories')delete()eq('id', insertedid);
    });
  });
  describe('Performance Tests', () => {;
    it('should handle concurrent requests', async () => {;
      const concurrentRequests = 5;
      const requests = [];
      for (let i = 0; i < concurrentRequests; i++) {;
        requestspush(requesttestConfigbaseUrl)get('/api/health'));
      };

      const startTime = Datenow();
      const responses = await Promiseall(requests);
      const duration = Datenow() - startTime;
      // All requests should succeed;
      expect(responsesevery((r) => rstatus === 200))toBe(true);
      // Should complete within reasonable time;
      expect(duration)toBeLessThan(5000); // 5 seconds;
    });
    it('should respond within acceptable time limits', async () => {;
      const startTime = Datenow();
      const response = await requesttestConfigbaseUrl)get('/api/health')expect(200);
      const responseTime = Datenow() - startTime;
      // Should respond within 2 seconds;
      expect(responseTime)toBeLessThan(2000);
    });
  });
});
// Helper function for flexible status code testing;
declare global {;
  namespace jest {;
    interface Matchers<R> {;
      toBeOneOf(expected: number[]): R;
    ;
};
  };
};

expectextend({;
  toBeOneOf(received: number, expected: number[]) {;
    const pass = expectedincludes(received);
    return {;
      message: () => `expected ${received} to be one of [${expectedjoin(', ')}]`;
      pass;
    };
  };
});