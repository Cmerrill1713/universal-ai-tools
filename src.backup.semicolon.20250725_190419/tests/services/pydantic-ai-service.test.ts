/**;
 * Tests for Pydantic AI Service;
 */;

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { z } from 'zod';
import {;
  PydanticAIService;
  AIRequestSchema;
  AIResponseSchema;
  CognitiveAnalysisSchema;
  TaskPlanSchema;
  CodeGenerationSchema;
} from '../../services/pydantic-ai-service';
import { getDSPyService } from '../../services/dspy-service';
// Mock DSPy service;
vimock('../../services/dspy-service', () => ({;
  getDSPyService: vifn(() => ({;
    orchestrate: vifn();
    manageKnowledge: vifn();
  }));
}));
describe('PydanticAIService', () => {;
  let service: PydanticAIService;
  let mockDSPyService: any;
  beforeEach(() => {;
    service = new PydanticAIService();
    mockDSPyService = getDSPyService();
    viclearAllMocks();
  });
  afterEach(() => {;
    serviceclearCache();
  });
  describe('Request validation', () => {;
    it('should validate AI requeststructure', () => {;
      const validRequest = {;
        prompt: 'Test prompt';
        context: {;
          userId: 'user123';
          temperature: 0.7;
        };
      };
      const result = AIRequestSchemasafeParse(validRequest);
      expect(resultsuccess)toBe(true);
      if (resultsuccess) {;
        expect(resultdataprompt)toBe('Test prompt');
        expect(resultdatacontexttemperature)toBe(0.7);
      };
    });
    it('should reject invalid requests', () => {;
      const invalidRequest = {;
        // Missing required prompt;
        context: {;
          temperature: 3, // Invalid temperature > 2;
        };
      };
      const result = AIRequestSchemasafeParse(invalidRequest);
      expect(resultsuccess)toBe(false);
    });
  });
  describe('Basic AI requests', () => {;
    it('should process a simple AI request async () => {;
      const mockResponse = {;
        success: true;
        result: 'Test response';
        confidence: 0.9;
        reasoning: 'Test reasoning';
        participatingAgents: ['agent1', 'agent2'];
      };
      mockDSPyServiceorchestratemockResolvedValue(mockResponse);
      const response = await servicerequest;
        prompt: 'Hello AI';
      });
      expect(responsesuccess)toBe(true);
      expect(responsecontenttoBe('Test response');
      expect(responseconfidence)toBe(0.9);
      expect(mockDSPyServiceorchestrate)toHaveBeenCalledWith(;
        expectobjectContaining({;
          userRequest: expectstringContaining('Hello AI');
        });
      );
    });
    it('should handle requesterrors gracefully', async () => {;
      mockDSPyServiceorchestratemockRejectedValue(new Error('DSPy error instanceof Error ? errormessage : String(error));
      const response = await servicerequest;
        prompt: 'Test prompt';
      });
      expect(responsesuccess)toBe(false);
      expect(responsecontenttoContain('Request failed');
    });
  });
  describe('Structured responses', () => {;
    it('should validate structured responses with schema', async () => {;
      const customSchema = zobject({;
        name: zstring();
        age: znumber();
        tags: zarray(zstring());
      });
      mockDSPyServiceorchestratemockResolvedValue({;
        success: true;
        result: {;
          data: {;
            name: 'John';
            age: 30;
            tags: ['developer', 'ai'];
          };
        };
        confidence: 0.95;
      });
      const response = await servicerequestWithSchema({ prompt: 'Get user info' }, customSchema);
      expect(responsesuccess)toBe(true);
      expect(responsestructuredData)toEqual({;
        name: 'John';
        age: 30;
        tags: ['developer', 'ai'];
      });
    });
    it('should fail validation for invalid structured data', async () => {;
      const schema = zobject({;
        count: znumber();
      });
      mockDSPyServiceorchestratemockResolvedValue({;
        success: true;
        result: {;
          data: {;
            count: 'not a number', // Invalid type;
          };
        };
      });
      const response = await servicerequest;
        prompt: 'Get count';
        validation: { outputSchema: schema ;
};
      });
      expect(responsesuccess)toBe(false);
      expect(responsevalidationpassed)toBe(false);
      expect(responsevalidationerrors)toHaveLength(1);
    });
  });
  describe('Specialized methods', () => {;
    it('should perform cognitive _analysis, async () => {;
      const mockAnalysis = {;
        _analysis 'Detailed _analysis;
        keyInsights: ['insight1', 'insight2'];
        recommendations: [;
          {;
            action: 'Do something';
            priority: 'high';
            reasoning: 'Because...';
          };
        ];
        entities: [;
          {;
            name: 'Entity1';
            type: 'person';
            relevance: 0.8;
          ;
};
        ];
        sentiment: 'positive';
        confidence: 0.85;
      ;
};
      mockDSPyServiceorchestratemockResolvedValue({;
        success: true;
        result: { data: mockAnalysis ;
};
        confidence: 0.85;
      });
      const _analysis= await serviceanalyzeCognitive('Analyze this text');
      expect(CognitiveAnalysisSchemaparse(_analysis)toEqual(mockAnalysis);
      expect(_analysiskeyInsights)toHaveLength(2);
      expect(_analysissentiment)toBe('positive');
    });
    it('should create task plans', async () => {;
      const mockPlan = {;
        objective: 'Build a web app';
        steps: [;
          {;
            id: 1;
            description: 'Setup project';
            agent: 'planner';
            dependencies: [];
            estimatedDuration: 30;
            resources: ['npm', 'git'];
          };
        ];
        totalEstimatedTime: 120;
        requiredAgents: ['planner', 'coder'];
        risks: [;
          {;
            description: 'Complexity';
            likelihood: 'medium';
            mitigation: 'Break down tasks';
          ;
};
        ];
      };
      mockDSPyServiceorchestratemockResolvedValue({;
        success: true;
        result: { data: mockPlan ;
};
      });
      const plan = await serviceplanTask('Build a web app');
      expect(TaskPlanSchemaparse(plan))toEqual(mockPlan);
      expect(plansteps)toHaveLength(1);
      expect(plantotalEstimatedTime)toBe(120);
    });
    it('should generate code with validation', async () => {;
      const mockCode = {;
        language: 'typescript';
        code: 'const hello = () => "world";';
        explanation: 'Simple function';
        dependencies: ['none'];
        testCases: [;
          {;
            name: 'test hello';
            inputnull;
            expectedOutput: 'world';
          };
        ];
      };
      mockDSPyServiceorchestratemockResolvedValue({;
        success: true;
        result: { data: mockCode ;
};
      });
      const code = await servicegenerateCode('Create a hello world function', 'typescript', {;
        includeTests: true;
      });
      expect(CodeGenerationSchemaparse(code))toEqual(mockCode);
      expect(codelanguage)toBe('typescript');
      expect(codetestCases)toHaveLength(1);
    });
  });
  describe('Caching', () => {;
    it('should cache successful responses', async () => {;
      mockDSPyServiceorchestratemockResolvedValue({;
        success: true;
        result: 'Cached response';
        confidence: 0.9;
      });
      const request { prompt: 'Cache test' };
      // First request;
      const response1 = await servicerequestrequest;
      expect(response1metadatacacheHit)toBe(false);
      // Second requestshould be cached;
      const response2 = await servicerequestrequest;
      expect(response2metadatacacheHit)toBe(true);
      expect(response2contenttoBe(response1content;
      // Orchestrate should only be called once;
      expect(mockDSPyServiceorchestrate)toHaveBeenCalledTimes(1);
    });
    it('should not cache failed responses', async () => {;
      mockDSPyServiceorchestrate;
        mockResolvedValueOnce({;
          success: false;
          error instanceof Error ? errormessage : String(error) 'First error instanceof Error ? errormessage : String(error);
        });
        mockResolvedValueOnce({;
          success: true;
          result: 'Success';
        });
      const request { prompt: 'Error then success' };
      // First requestfails;
      const response1 = await servicerequestrequest;
      expect(response1success)toBe(false);
      // Second requestshould not use cache;
      const response2 = await servicerequestrequest;
      expect(response2success)toBe(true);
      expect(mockDSPyServiceorchestrate)toHaveBeenCalledTimes(2);
    });
    it('should clear cache on demand', async () => {;
      mockDSPyServiceorchestratemockResolvedValue({;
        success: true;
        result: 'Response';
      });
      const request { prompt: 'Clear cache test' };
      // Cache a response;
      await servicerequestrequest;
      expect(servicegetStats()cacheSize)toBe(1);
      // Clear cache;
      serviceclearCache();
      expect(servicegetStats()cacheSize)toBe(0);
    });
  });
  describe('Schema registration', () => {;
    it('should register custom schemas', () => {;
      const customSchema = zobject({;
        customField: zstring();
      });
      serviceregisterSchema('custom_type', customSchema);
      const stats = servicegetStats();
      expect(statsregisteredSchemas)toContain('custom_type');
    });
    it('should use registered schemas for validation', async () => {;
      const userSchema = zobject({;
        username: zstring()min(3);
        email: zstring()email();
      });
      serviceregisterSchema('user_data', userSchema);
      mockDSPyServiceorchestratemockResolvedValue({;
        success: true;
        result: {;
          data: {;
            username: 'john';
            email: 'john@examplecom';
          ;
};
        };
      });
      const response = await servicerequestWithSchema({ prompt: 'Get user data' }, userSchema);
      expect(responsesuccess)toBe(true);
      expect(responsestructuredDatausername)toBe('john');
    });
  });
  describe('Memory integration', () => {;
    it('should store interactions in memory when enabled', async () => {;
      mockDSPyServiceorchestratemockResolvedValue({;
        success: true;
        result: 'Memory test response';
        confidence: 0.8;
      });
      mockDSPyServicemanageKnowledgemockResolvedValue({;
        success: true;
      });
      const response = await servicerequest;
        prompt: 'Store this in memory';
        context: {;
          memoryEnabled: true;
          userId: 'test-user';
        ;
};
      });
      expect(responsesuccess)toBe(true);
      expect(mockDSPyServicemanageKnowledge)toHaveBeenCalledWith(;
        'store';
        expectobjectContaining({;
          memory: expectobjectContaining({;
            contentexpectstringContaining('Store this in memory');
            serviceId: 'pydantic-ai';
          });
        });
      );
    });
    it('should not store interactions when memory is disabled', async () => {;
      mockDSPyServiceorchestratemockResolvedValue({;
        success: true;
        result: 'No memory response';
      });
      await servicerequest;
        prompt: 'Do not store';
        context: {;
          memoryEnabled: false;
        ;
};
      });
      expect(mockDSPyServicemanageKnowledge)nottoHaveBeenCalled();
    });
  });
});