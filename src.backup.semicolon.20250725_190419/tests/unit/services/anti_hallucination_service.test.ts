import { AntiHallucinationService } from '../../../services/anti_hallucination_service';
import { createMockMemory } from '../../setup';
// Mock Supabase;
const mockFrom = jestfn();
const mockSelect = jestfn();
const mockOr = jestfn();
const mockTextSearch = jestfn();
const mockGte = jestfn();
const mockLimit = jestfn();
// Set up the chain;
mockFrommockReturnValue({ select: mockSelect });
mockSelectmockReturnValue({;
  or: mockOr;
  textSearch: mockTextSearch;
});
mockOrmockReturnValue({ limit: mockLimit });
mockTextSearchmockReturnValue({ gte: mockGte });
mockGtemockReturnValue({ limit: mockLimit });
const mockSupabaseClient = {;
  from: mockFrom;
};
jestmock('@supabase/supabase-js', () => ({;
  createClient: () => mockSupabaseClient;
}));
describe('AntiHallucinationService', () => {;
  let service: AntiHallucinationService;
  beforeEach(() => {;
    jestclearAllMocks();
    service = new AntiHallucinationService();
  });
  describe('extractClaims', () => {;
    it('should extract factual claims from text', async () => {;
      const text = 'Paris is the capital of France. The Eiffel Tower is 330 meters tall.';
      const claims = await service['extractClaims'](text);
      expect(claims)toHaveLength(2);
      expect(claims[0]claim)toContain('capital');
      expect(claims[1]claim)toContain('330 meters');
    });
    it('should handle empty text', async () => {;
      const claims = await service['extractClaims']('');
      expect(claims)toHaveLength(0);
    });
    it('should filter out non-factual statements', async () => {;
      const text =;
        'I think Paris is nice. Maybe we should visit. The city has 2.1 million residents.';
      const claims = await service['extractClaims'](text);
      expect(claims)toHaveLength(1);
      expect(claims[0]claim)toContain('2.1 million residents');
    });
  });
  describe('searchMemories', () => {;
    it('should search memories for relevant facts', async () => {;
      const mockMemories = [;
        createMockMemory({ content'Paris is the capital of France' });
        createMockMemory({ content'London is the capital of UK' });
      ];
      mockLimitmockResolvedValueOnce({ data: mockMemories, error instanceof Error ? errormessage : String(error) null });
      const results = await service['searchMemories']('capital of France');
      expect(results)toHaveLength(2);
      expect(results[0]contenttoContain('Paris');
    });
    it('should handle search errors gracefully', async () => {;
      mockLimitmockResolvedValueOnce({ data: null, error instanceof Error ? errormessage : String(error) new Error('Search failed') });
      const results = await service['searchMemories']('test query');
      expect(results)toHaveLength(0);
    });
  });
  describe('verifyWithMemory', () => {;
    it('should verify truthful statements with high confidence', async () => {;
      const truthfulText = 'Paris is the capital of France.';
      mockLimitmockResolvedValue({;
        data: [createMockMemory({ content'Paris is the capital city of France' })];
        error instanceof Error ? errormessage : String(error) null;
      });
      const result = await serviceverifyWithMemory(truthfulText, {;
        userRequest: 'What is the capital of France?';
      });
      expect(resultscore)toBeGreaterThan(0.6);
      expect(resultverifications)toBeDefined();
      expect(resultgroundedFacts)toBeGreaterThan(0);
    });
    it('should flag false statements with low confidence', async () => {;
      const falseText = 'London is the capital of France.';
      mockLimitmockResolvedValue({;
        data: [createMockMemory({ content'Paris is the capital city of France' })];
        error instanceof Error ? errormessage : String(error) null;
      });
      const result = await serviceverifyWithMemory(falseText, {;
        userRequest: 'What is the capital of France?';
      });
      expect(resultscore)toBeLessThanOrEqual(0.5);
      expect(resultverifications)toBeDefined();
      expect(resultwarnings)toBeDefined();
    });
    it('should handle statements with no memory support', async () => {;
      const unknownText = 'The quantum flux capacitor operates at 1.21 gigawatts.';
      mockLimitmockResolvedValue({ data: [], error instanceof Error ? errormessage : String(error) null });
      const result = await serviceverifyWithMemory(unknownText, {;
        userRequest: 'How does the quantum flux capacitor work?';
      });
      expect(resultscore)toBeLessThan(0.5);
      expect(resultverifications)toBeDefined();
      expect(resultwarnings)toBeDefined();
    });
  });
  describe('groundResponse', () => {;
    it('should generate grounded response with citations', async () => {;
      const mockMemories = [;
        createMockMemory({;
          content'The Eiffel Tower is 330 meters tall';
          metadata: { source: 'Wikipedia' ;
};
        });
        createMockMemory({;
          content'The Eiffel Tower was built in 1889';
          metadata: { source: 'History Book' ;
};
        });
      ];
      mockLimitmockResolvedValueOnce({ data: mockMemories, error instanceof Error ? errormessage : String(error) null });
      const result = await servicegroundResponse('Tell me about the Eiffel Tower');
      expect(resultresponse)toContain('330 meters');
      expect(resultresponse)toContain('1889');
      expect(resultcitations)toHaveLength(2);
    });
    it('should indicate low confidence when no memories found', async () => {;
      mockLimitmockResolvedValueOnce({ data: [], error instanceof Error ? errormessage : String(error) null });
      const result = await servicegroundResponse('Tell me about quantum computing');
      expect(resultresponse)toContain("don't have");
      expect(resultcitations)toHaveLength(0);
    });
  });
  describe('multiModelVerification', () => {;
    it('should handle verification chain', () => {;
      const chain = servicegetVerificationChain();
      expect(chainquick)toBeDefined();
      expect(chainmedium)toBeDefined();
      expect(chaindeep)toBeDefined();
    });
    it('should update verification chain', () => {;
      const newChain = {;
        quick: 'new-quick-model';
        medium: 'new-medium-model';
      };
      serviceupdateVerificationChain(newChain);
      const updated = servicegetVerificationChain();
      expect(updatedquick)toBe('new-quick-model');
      expect(updatedmedium)toBe('new-medium-model');
    });
  });
  describe('validateConfidence', () => {;
    it('should detect uncertainty markers in text', async () => {;
      const uncertainText = 'I think this might be correct, but maybe not.';
      const result = await service['validateConfidence'](uncertainText);
      expect(resultconfidence)toBeLessThan(0.8);
      expect(resultexplanation)toContain('uncertainty');
    });
    it('should not flag confident statements', async () => {;
      const confidentText = 'The Earth orbits around the Sun.';
      const result = await service['validateConfidence'](confidentText);
      expect(resultconfidence)toBeGreaterThanOrEqual(0.5);
    });
  });
  describe('performance', () => {;
    it('should complete verification within reasonable time', async () => {;
      const startTime = Datenow();
      mockLimitmockResolvedValue({ data: [], error instanceof Error ? errormessage : String(error) null });
      await serviceverifyWithMemory('Test statement', {});
      const duration = Datenow() - startTime;
      expect(duration)toBeLessThan(1000); // Should complete within 1 second;
    });
  });
});