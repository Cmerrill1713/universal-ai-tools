/* eslint-disable no-undef */;
#!/usr/bin/env node;
import { createClient } from '@supabase/supabase-js';
import { config } from '../config';
import { createBackupRecoveryService } from '../services/backup-recovery-service';
import { LogContext, logger } from '../utils/enhanced-logger';
import { program } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
// Initialize Supabase client;
const supabase = createClient(;
  configdatabasesupabaseUrl;
  configdatabasesupabaseServiceKey || '';
);
// Initialize backup service;
const backupService = createBackupRecoveryService(supabase, {;
  enabled: true;
  schedule: '0 2 * * *', // 2 AM daily;
  retention: {;
    daily: 7;
    weekly: 4;
    monthly: 12;
  ;
};
  storage: {;
    local: {;
      enabled: true;
      path: processenvBACKUP_PATH || './backups';
    ;
};
    supabase: {;
      enabled: true;
      bucket: 'backups';
    ;
};
    s3: {;
      enabled: false;
    ;
};
  };
  encryption: {;
    enabled: true;
    algorithm: 'aes-256-gcm';
    keyDerivation: 'scrypt';
  ;
};
  tables: ['backup_metadata'];
});
program;
  name('backup');
  description('Backup and recovery management for Universal AI Tools');
  version('1.0.0');
// Create backup command;
program;
  command('create');
  description('Create a new backup');
  option('-t, --type <type>', 'Backup type (full, incremental, differential)', 'full');
  option('--tables <tables>', 'Comma-separated list of tables to backup');
  option('--no-compress', 'Disable compression');
  option('--no-encrypt', 'Disable encryption');
  action(async (options) => {;
    const spinner = ora('Creating backup...')start();
    try {;
      const tables = optionstables;
        ? optionstablessplit(',')map((t: string) => ttrim());
        : undefined;
      const result = await backupServicecreateBackup({;
        type: optionstype;
        tables;
        compress: optionscompress;
      });
      spinnersucceed(chalkgreen(`Backup created successfully!`));
      loggerinfo(`\n${chalkbold('Backup Details:')}`);
      loggerinfo(chalkgray('─'repeat(50)));
      loggerinfo(`${chalkcyan('ID:')} ${resultid}`);
      loggerinfo(`${chalkcyan('Type:')} ${resulttype}`);
      loggerinfo(`${chalkcyan('Size:')} ${formatBytes(resultsize)}`);
      loggerinfo(`${chalkcyan('Duration:')} ${resultduration}ms`);
      loggerinfo(`${chalkcyan('Tables:')} ${resulttableslength}`);
      loggerinfo(`${chalkcyan('Rows:')} ${resultrowCounttoLocaleString()}`);
      loggerinfo(`${chalkcyan('Storage:')} ${resultstoragejoin(', ')}`);
      loggerinfo(`${chalkcyan('Encrypted:')} ${resultencrypted ? '✓' : '✗'}`);
      loggerinfo(`${chalkcyan('Compressed:')} ${resultcompressed ? '✓' : '✗'}`);
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      spinnerfail(chalkred('Backup failed'));
      loggererror`Backup operation failed: ${errormessage}`, LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred(`Error: ${errormessage}`));
      processexit(1);
    };
  });
// List backups command;
program;
  command('list');
  description('List available backups');
  option('-l, --limit <number>', 'Number of backups to show', '10');
  option('-s, --status <status>', 'Filter by status (completed, failed, in_progress)');
  action(async (options) => {;
    try {;
      const { backups, total } = await backupServicelistBackups({;
        limit: parseInt(optionslimit, 10);
        status: optionsstatus;
      });
      if (backupslength === 0) {;
        loggerinfo(chalkyellow('No backups found'));
        return;
      };

      loggerinfo(chalkbold(`\nBackups (${backupslength} of ${total}):`));
      loggerinfo(chalkgray('─'repeat(120)));
      loggerinfo(;
        chalkbold(;
          `${`;
            'ID'padEnd(40) +;
            'Type'padEnd(12) +;
            'Status'padEnd(12) +;
            'Size'padEnd(12) +;
            'Rows'padEnd(12) +;
            'Duration'padEnd(10);
          }Created``;
        );
      );
      loggerinfo(chalkgray('─'repeat(120)));
      backupsforEach((backup) => {;
        const statusColor =;
          backupstatus === 'completed';
            ? chalkgreen;
            : backupstatus === 'failed';
              ? chalkred;
              : chalkyellow;
        loggerinfo(;
          backupidsubstring(0, 37)padEnd(40) +;
            backuptypepadEnd(12) +;
            statusColor(backupstatuspadEnd(12)) +;
            formatBytes(backupsize)padEnd(12) +;
            backuprowCounttoLocaleString()padEnd(12) +;
            `${backupduration}ms`padEnd(10) +;
            new Date(backuptimestamp)toLocaleString();
        );
      });
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror`Backup operation failed: ${errormessage}`, LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred(`Error: ${errormessage}`));
      processexit(1);
    };
  });
// Restore backup command;
program;
  command('restore <backupId>');
  description('Restore from a backup');
  option('--tables <tables>', 'Comma-separated list of tables to restore');
  option('--dry-run', 'Perform a dry run without making changes');
  option('--skip-constraints', 'Skip foreign key constraints');
  action(async (backupId, options) => {;
    const spinner = ora('Restoring backup...')start();
    try {;
      const tables = optionstables;
        ? optionstablessplit(',')map((t: string) => ttrim());
        : undefined;
      if (!optionsdryRun) {;
        // Confirm restore;
        loggerinfo(chalkyellow('\n⚠️  Warning: This will overwrite existing data!'));
        loggerinfo('Press Ctrl+C to cancel or any key to continue...');
        await new Promise((resolve) => processstdinonce('data', resolve));
      };

      const result = await backupServicerestoreBackup({;
        backupId;
        tables;
        dryRun: optionsdryRun;
        skipConstraints: optionsskipConstraints;
      });
      spinnersucceed(;
        chalkgreen(`Restore ${optionsdryRun ? 'dry run' : ''} completed successfully!`);
      );
      loggerinfo(`\n${chalkbold('Restore Details:')}`);
      loggerinfo(chalkgray('─'repeat(50)));
      loggerinfo(`${chalkcyan('Tables Restored:')} ${resulttablesRestoredlength}`);
      loggerinfo(`${chalkcyan('Rows Restored:')} ${resultrowsRestoredtoLocaleString()}`);
      loggerinfo(`${chalkcyan('Duration:')} ${resultduration}ms`);
      if (resulttablesRestoredlength > 0) {;
        loggerinfo(`\n${chalkcyan('Tables:')}`);
        resulttablesRestoredforEach((table) => {;
          loggerinfo(`  - ${table}`);
        });
      };
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      spinnerfail(chalkred('Restore failed'));
      loggererror`Backup operation failed: ${errormessage}`, LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred(`Error: ${errormessage}`));
      processexit(1);
    };
  });
// Delete backup command;
program;
  command('delete <backupId>');
  description('Delete a backup');
  action(async (backupId) => {;
    try {;
      // Confirm deletion;
      loggerinfo(chalkyellow('\n⚠️  Warning: This action cannot be undone!'));
      loggerinfo(`Delete backup ${backupId}?`);
      loggerinfo('Press Ctrl+C to cancel or any key to continue...');
      await new Promise((resolve) => processstdinonce('data', resolve));
      const spinner = ora('Deleting backup...')start();
      await backupServicedeleteBackup(backupId);
      spinnersucceed(chalkgreen('Backup deleted successfully!'));
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror`Backup operation failed: ${errormessage}`, LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred(`Error: ${errormessage}`));
      processexit(1);
    };
  });
// Verify backup command;
program;
  command('verify <backupId>');
  description('Verify backup integrity');
  action(async (backupId) => {;
    const spinner = ora('Verifying backup...')start();
    try {;
      const result = await backupServiceverifyBackup(backupId);
      if (resultvalid) {;
        spinnersucceed(chalkgreen('Backup is valid!'));
      } else {;
        spinnerfail(chalkred('Backup validation failed'));
        loggerinfo(`\n${chalkred('Validation Errors:')}`);
        resulterrorsforEach((error instanceof Error ? errormessage : String(error)=> {;
          loggerinfo(chalkred(`  - ${error instanceof Error ? errormessage : String(error)));`;
        });
      };
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      spinnerfail(chalkred('Verification failed'));
      loggererror`Backup operation failed: ${errormessage}`, LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred(`Error: ${errormessage}`));
      processexit(1);
    };
  });
// Cleanup command;
program;
  command('cleanup');
  description('Clean up old backups based on retention policy');
  action(async () => {;
    const spinner = ora('Cleaning up old backups...')start();
    try {;
      const deletedCount = await backupServicecleanupOldBackups();
      spinnersucceed(chalkgreen(`Cleanup completed! Deleted ${deletedCount} old backups.`));
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      spinnerfail(chalkred('Cleanup failed'));
      loggererror`Backup operation failed: ${errormessage}`, LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred(`Error: ${errormessage}`));
      processexit(1);
    };
  });
// Status command;
program;
  command('status');
  description('Show backup system status');
  action(async () => {;
    try {;
      const status = await backupServicegetBackupStatus();
      loggerinfo(`\n${chalkbold('Backup System Status:')}`);
      loggerinfo(chalkgray('─'repeat(50)));
      loggerinfo(;
        `${chalkcyan('Last Backup:')} ${statuslastBackup ? statuslastBackuptoLocaleString() : 'Never'}`;
      );
      loggerinfo(;
        `${chalkcyan('Next Backup:')} ${statusnextBackup ? statusnextBackuptoLocaleString() : 'Not scheduled'}`;
      );
      loggerinfo(;
        `${chalkcyan('Running:')} ${statusisRunning ? chalkyellow('Yes') : chalkgreen('No')}`;
      );
      loggerinfo(`${chalkcyan('Total Backups:')} ${statustotalBackups}`);
      loggerinfo(`${chalkcyan('Total Size:')} ${formatBytes(statustotalSize)}`);
      if (Objectkeys(statusstorageUsage)length > 0) {;
        loggerinfo(`\n${chalkcyan('Storage Usage:')}`);
        Objectentries(statusstorageUsage)forEach(([storage, size]) => {;
          loggerinfo(`  ${storage}: ${formatBytes(size)}`);
        });
      };

      // Check health;
      const { data: health } = await supabaserpc('check_backup_health');
      if (health) {;
        loggerinfo(;
          `\n${chalkcyan('Health Status:')} ${`;
            healthhealth_status === 'healthy';
              ? chalkgreen('Healthy');
              : healthhealth_status === 'warning';
                ? chalkyellow('Warning');
                : chalkred('Critical');
          }``;
        );
        if (healthrecommendations?length > 0) {;
          loggerinfo(`\n${chalkyellow('Recommendations:')}`);
          healthrecommendationsforEach((rec: string) => {;
            loggerinfo(`  - ${rec}`);
          });
        };
      };
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror`Backup operation failed: ${errormessage}`, LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred(`Error: ${errormessage}`));
      processexit(1);
    };
  });
// Schedule command;
program;
  command('schedule');
  description('Manage backup schedules');
  option('-l, --list', 'List schedules');
  option('-c, --create <name>', 'Create a new schedule');
  option('-s, --schedule <cron>', 'Cron expression (with --create)');
  option('-t, --type <type>', 'Backup type (with --create)', 'full');
  action(async (options) => {;
    try {;
      if (optionslist) {;
        const { data: schedules } = await supabase;
          from('backup_schedules');
          select('*');
          order('name');
        if (!schedules || scheduleslength === 0) {;
          loggerinfo(chalkyellow('No schedules found'));
          return;
        };

        loggerinfo(`\n${chalkbold('Backup Schedules:')}`);
        loggerinfo(chalkgray('─'repeat(100)));
        loggerinfo(;
          chalkbold(;
            `${`;
              'Name'padEnd(25) +;
              'Schedule'padEnd(20) +;
              'Type'padEnd(12) +;
              'Enabled'padEnd(10) +;
              'Last Run'padEnd(25);
            }Next Run``;
          );
        );
        loggerinfo(chalkgray('─'repeat(100)));
        schedulesforEach((schedule) => {;
          loggerinfo(;
            schedulenamepadEnd(25) +;
              scheduleschedulepadEnd(20) +;
              schedulebackup_typepadEnd(12) +;
              (scheduleenabled ? chalkgreen('Yes') : chalkred('No'))padEnd(10) +;
              (schedulelast_run ? new Date(schedulelast_run)toLocaleString() : 'Never')padEnd(;
                25;
              ) +;
              (schedulenext_run ? new Date(schedulenext_run)toLocaleString() : 'Not set');
          );
        });
      } else if (optionscreate) {;
        if (!optionsschedule) {;
          consoleerrorchalkred('Error: --schedule is required when creating a schedule'));
          processexit(1);
        ;
};

        const { data, error } = await supabaserpc('schedule_backup', {;
          p_name: optionscreate;
          p_schedule: optionsschedule;
          p_type: optionstype;
        });
        if (error instanceof Error ? errormessage : String(error) throw error instanceof Error ? errormessage : String(error);

        loggerinfo(chalkgreen(`✓ Schedule '${optionscreate}' created successfully!`));
        loggerinfo(chalkgray(`  Schedule: ${optionsschedule}`));
        loggerinfo(chalkgray(`  Type: ${optionstype}`));
      };
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      loggererror`Backup operation failed: ${errormessage}`, LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred(`Error: ${errormessage}`));
      processexit(1);
    };
  });
// Helper function to format bytes;
function formatBytes(bytes: number): string {;
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Mathfloor(Mathlog(bytes) / Mathlog(k));
  return `${parseFloat((bytes / Mathpow(k, i))toFixed(2))} ${sizes[i]}`;
};

// Parse command line arguments;
programparse();
// Show help if no command provided;
if (!processargvslice(2)length) {;
  programoutputHelp();
};
