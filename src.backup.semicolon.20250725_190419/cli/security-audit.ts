/* eslint-disable no-undef */;
#!/usr/bin/env node;
import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { LogContext, logger } from '../utils/enhanced-logger';
// import Table from 'cli-table3'; // Package not available, using simple table implementation;
interface TableOptions {;
  head?: string[];
  colWidths?: number[];
  style?: any; // Ignore style properties for now;
};
class SimpleTable {;
  private options: TableOptions;
  private rows: string[][] = [];
  constructor(options: TableOptions = {}) {;
    thisoptions = options;
  };

  push(..args: any[]) {;
    if (argslength === 1 && ArrayisArray(args[0])) {;
      thisrowspush(args[0]);
    } else {;
      thisrowspush(argsmap(String));
    };
  };

  toString(): string {;
    const { head = [], colWidths = [] } = thisoptions;
    let result = '';
    if (headlength > 0) {;
      result += `${headmap((h, i) => hpadEnd(colWidths[i] || 20))join(' | ')}\n`;
      result += `${headmap((_, i) => '-'repeat(colWidths[i] || 20))join('-+-')}\n`;
    };

    for (const row of thisrows) {;
      result += `${rowmap((cell, i) => String(cell)padEnd(colWidths[i] || 20))join(' | ')}\n`;
    };

    return result;
  };
};
const Table = SimpleTable;
import { securityHardeningService } from '../services/security-hardening';
import { config } from '../config';
// Removed duplicate logger import - using enhanced-logger instead;
import * as fs from 'fs/promises';
import * as path from 'path';
const program = new Command();
program;
  name('security-audit');
  description('Security audit and hardening CLI for Universal AI Tools');
  version('1.0.0');
// Run security audit;
program;
  command('audit');
  description('Run a comprehensive security audit');
  option('-v, --verbose', 'Show detailed output');
  option('-o, --output <file>', 'Save report to file');
  action(async (options) => {;
    const spinner = ora('Running security audit...')start();
    try {;
      const result = await securityHardeningServicerunSecurityAudit();
      spinnersucceed('Security audit completed');
      // Display results;
      loggerinfo(`\n${chalkbold('Security Audit Report')}`);
      loggerinfo('='repeat(50));
      loggerinfo(`Timestamp: ${resulttimestamptoISOString()}`);
      loggerinfo(;
        `Overall Score: ${getScoreColor(resultoverallScore)(`${resultoverallScore}/100`)}\n`;
      );
      // Vulnerabilities table;
      if (resultvulnerabilitieslength > 0) {;
        loggerinfo(chalkboldred('Vulnerabilities Found:'));
        const vulnTable = new Table({;
          head: ['Severity', 'Package', 'Vulnerability', 'Fix Available'];
          style: { head: ['cyan'] ;
};
        });
        resultvulnerabilitiesforEach((vuln) => {;
          vulnTablepush([;
            getSeverityColor(vulnseverity)(vulnseverity);
            vulnpackage;
            vulnvulnerability;
            vulnfixAvailable ? chalkgreen('Yes') : chalkred('No');
          ]);
        });
        loggerinfo(vulnTabletoString());
      } else {;
        loggerinfo(chalkgreen('✓ No vulnerabilities found'));
      };

      // Security headers;
      loggerinfo(`\n${chalkbold('Security Headers:')}`);
      const headerTable = new Table({;
        head: ['Header', 'Status', 'Value'];
        style: { head: ['cyan'] ;
};
      });
      resultsecurityHeadersforEach((header) => {;
        headerTablepush([;
          headerheader;
          headerpresent ? chalkgreen('✓') : chalkred('✗');
          headervalue || '-';
        ]);
      });
      loggerinfo(headerTabletoString());
      // API Key Status;
      loggerinfo(`\n${chalkbold('API Key Rotation Status:')}`);
      const keyTable = new Table({;
        head: ['Key Type', 'Last Rotated', 'Status', 'Expires In'];
        style: { head: ['cyan'] ;
};
      });
      resultapiKeyStatusforEach((key) => {;
        keyTablepush([;
          keykeyName;
          keylastRotatedtoLocaleDateString();
          keyneedsRotation ? chalkred('Needs Rotation') : chalkgreen('OK');
          `${keyexpiresIn} days`;
        ]);
      });
      loggerinfo(keyTabletoString());
      // Recommendations;
      if (resultrecommendationslength > 0) {;
        loggerinfo(`\n${chalkbold('Recommendations:')}`);
        resultrecommendationsforEach((rec, index) => {;
          const isUrgent = recincludes('URGENT');
          const prefix = isUrgent ? chalkred('!') : chalkyellow('•');
          loggerinfo(`${prefix} ${rec}`);
        });
      };

      // Save to file if requested;
      if (optionsoutput) {;
        await fswriteFile(optionsoutput, JSONstringify(result, null, 2));
        loggerinfo(`\n${chalkgreen('✓')} Report saved to ${optionsoutput}`);
      };
    } catch (error) {;
      spinnerfail('Security audit failed');
      loggererror`Security audit operation failed`, LogContextSECURITY, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred('Error:'), error instanceof Error ? errormessage : String(error) processexit(1);
    ;
};
  });
// Check for vulnerabilities;
program;
  command('check-deps');
  description('Check dependencies for known vulnerabilities');
  option('--fix', 'Attempt to fix vulnerabilities automatically');
  option('--dry-run', 'Show what would be fixed without making changes');
  action(async (options) => {;
    const spinner = ora('Scanning dependencies...')start();
    try {;
      const vulnerabilities = await securityHardeningServicescanDependencies();
      spinnersucceed(`Found ${vulnerabilitieslength} vulnerabilities`);
      if (vulnerabilitieslength === 0) {;
        loggerinfo(chalkgreen('✓ No vulnerabilities found!'));
        return;
      };

      // Group by severity;
      const bySeverity = vulnerabilitiesreduce(;
        (acc: Record<string, number>, vuln: any) => {;
          acc[vulnseverity] = (acc[vulnseverity] || 0) + 1;
          return acc;
        };
        {} as Record<string, number>;
      );
      loggerinfo('\nVulnerability Summary:');
      Objectentries(bySeverity)forEach(([severity, count]) => {;
        loggerinfo(`  ${getSeverityColor(severity)(`${severity}: ${count}`)}`);
      });
      // Fix if requested;
      if (optionsfix || optionsdryRun) {;
        loggerinfo(`\n${chalkbold('Attempting to fix vulnerabilities...')}`);
        const { fixed, failed } = await securityHardeningServicefixVulnerabilities(optionsdryRun);
        if (fixedlength > 0) {;
          loggerinfo(chalkgreen('\n✓ Fixed:'));
          fixedforEach((f: string) => loggerinfo(`  - ${f}`));
        };

        if (failedlength > 0) {;
          loggerinfo(chalkred('\n✗ Failed:'));
          failedforEach((f: string) => loggerinfo(`  - ${f}`));
        };
      };
    } catch (error) {;
      spinnerfail('Dependency scan failed');
      loggererror`Security audit operation failed`, LogContextSECURITY, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred('Error:'), error instanceof Error ? errormessage : String(error) processexit(1);
    ;
};
  });
// Rotate API keys;
program;
  command('rotate-key <keyType>');
  description('Rotate an API key');
  option('--force', 'Force rotation even if not expired');
  action(async (keyType, options) => {;
    const spinner = ora(`Rotating ${keyType}...`)start();
    try {;
      const newKey = await securityHardeningServicerotateApiKey(keyType);
      spinnersucceed(`${keyType} rotated successfully`);
      loggerinfo(`\n${chalkbold('New Key Generated:')}`);
      loggerinfo(chalkgray('Key (first 16 chars):'), `${newKeysubstring(0, 16)}...`);
      loggerinfo(chalkyellow('\n⚠️  Save this key securely. It will not be shown again.'));
      // Update environment file reminder;
      loggerinfo(`\n${chalkbold('Next Steps:')}`);
      loggerinfo('1. Update your env file with the new key');
      loggerinfo('2. Restart the service to apply changes');
      loggerinfo('3. Update any external services using this key');
    } catch (error) {;
      spinnerfail('Key rotation failed');
      loggererror`Security audit operation failed`, LogContextSECURITY, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred('Error:'), error instanceof Error ? errormessage : String(error) processexit(1);
    ;
};
  });
// Check common vulnerabilities;
program;
  command('check-common');
  description('Check for common security issues');
  action(async () => {;
    const spinner = ora('Checking common vulnerabilities...')start();
    try {;
      const result = await securityHardeningServicecheckCommonVulnerabilities();
      spinnersucceed('Check completed');
      if (resultpassed) {;
        loggerinfo(chalkgreen('\n✓ No common vulnerabilities found!'));
      } else {;
        loggerinfo(chalkred(`\n✗ Found ${resultissueslength} issues:`));
        resultissuesforEach((issue: string, index: number) => {;
          loggerinfo(`  ${index + 1}. ${issue}`);
        });
      };
    } catch (error) {;
      spinnerfail('Check failed');
      loggererror`Security audit operation failed`, LogContextSECURITY, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred('Error:'), error instanceof Error ? errormessage : String(error) processexit(1);
    ;
};
  });
// Generate security report;
program;
  command('report');
  description('Generate a comprehensive security report');
  option('-f, --format <format>', 'Output format (json, html, markdown)', 'markdown');
  option('-o, --output <file>', 'Save report to file');
  action(async (options) => {;
    const spinner = ora('Generating security report...')start();
    try {;
      const audit = await securityHardeningServicerunSecurityAudit();
      spinnersucceed('Report generated');
      let report = '';
      switch (optionsformat) {;
        case 'markdown':;
          report = generateMarkdownReport(audit);
          break;
        case 'html':;
          report = generateHTMLReport(audit);
          break;
        case 'json':;
          report = JSONstringify(audit, null, 2);
          break;
        default:;
          throw new Error(`Unknown format: ${optionsformat}`);
      };

      if (optionsoutput) {;
        await fswriteFile(optionsoutput, report);
        loggerinfo(`\n${chalkgreen('✓')} Report saved to ${optionsoutput}`);
      } else {;
        loggerinfo(`\n${report}`);
      };
    } catch (error) {;
      spinnerfail('Report generation failed');
      loggererror`Security audit operation failed`, LogContextSECURITY, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred('Error:'), error instanceof Error ? errormessage : String(error) processexit(1);
    ;
};
  });
// Configuration validation;
program;
  command('validate-config');
  description('Validate security configuration');
  action(async () => {;
    const spinner = ora('Validating security configuration...')start();
    try {;
      const issues: string[] = [];
      // Check JWT secret strength;
      if (configsecurityjwtSecretlength < 32) {;
        issuespush('JWT secret is too short (minimum 32 characters)');
      };

      // Check encryption key strength;
      if (configsecurityencryptionKeylength < 32) {;
        issuespush('Encryption key is too short (minimum 32 characters)');
      };

      // Check CORS origins in production;
      if (configserverisProduction && configsecuritycorsOriginsincludes('localhost')) {;
        issuespush('Localhost is allowed in CORS origins in production');
      };

      // Check rate limiting;
      if (!configrateLimitingenabled && configserverisProduction) {;
        issuespush('Rate limiting is disabled in production');
      };

      spinnersucceed('Configuration validated');
      if (issueslength === 0) {;
        loggerinfo(chalkgreen('\n✓ Security configuration is valid'));
      } else {;
        loggerinfo(chalkred(`\n✗ Found ${issueslength} configuration issues:`));
        issuesforEach((issue, index) => {;
          loggerinfo(`  ${index + 1}. ${issue}`);
        });
      };
    } catch (error) {;
      spinnerfail('Validation failed');
      loggererror`Security audit operation failed`, LogContextSECURITY, { error instanceof Error ? errormessage : String(error));
      consoleerrorchalkred('Error:'), error instanceof Error ? errormessage : String(error) processexit(1);
    ;
};
  });
// Helper functions;
function getScoreColor(score: number): (text: string) => string {;
  if (score >= 90) return chalkgreen;
  if (score >= 70) return chalkyellow;
  if (score >= 50) return chalkmagenta;
  return chalkred;
};

function getSeverityColor(severity: string): (text: string) => string {;
  switch (severitytoLowerCase()) {;
    case 'critical':;
      return chalkredbold;
    case 'high':;
      return chalkred;
    case 'moderate':;
      return chalkyellow;
    case 'low':;
      return chalkblue;
    default:;
      return chalkgray;
  };
};

function generateMarkdownReport(audit: any): string {;
  let report = `# Security Audit Report\n\n`;
  report += `**Generated:** ${audittimestamptoISOString()}\n`;
  report += `**Overall Score:** ${auditoverallScore}/100\n\n`;
  report += `## Vulnerabilities\n\n`;
  if (auditvulnerabilitieslength === 0) {;
    report += `✓ No vulnerabilities found\n\n`;
  } else {;
    report += `| Severity | Package | Vulnerability | Fix Available |\n`;
    report += `|----------|---------|---------------|---------------|\n`;
    auditvulnerabilitiesforEach((vuln: any) => {;
      report += `| ${vulnseverity} | ${vulnpackage} | ${vulnvulnerability} | ${vulnfixAvailable ? 'Yes' : 'No'} |\n`;
    });
    report += `\n`;
  };

  report += `## Security Headers\n\n`;
  report += `| Header | Present | Value |\n`;
  report += `|--------|---------|-------|\n`;
  auditsecurityHeadersforEach((header: any) => {;
    report += `| ${headerheader} | ${headerpresent ? '✓' : '✗'} | ${headervalue || '-'} |\n`;
  });
  report += `\n`;
  report += `## API Key Rotation Status\n\n`;
  report += `| Key Type | Last Rotated | Status | Expires In |\n`;
  report += `|----------|--------------|--------|------------|\n`;
  auditapiKeyStatusforEach((key: any) => {;
    report += `| ${keykeyName} | ${keylastRotatedtoLocaleDateString()} | ${keyneedsRotation ? 'Needs Rotation' : 'OK'} | ${keyexpiresIn} days |\n`;
  });
  report += `\n`;
  if (auditrecommendationslength > 0) {;
    report += `## Recommendations\n\n`;
    auditrecommendationsforEach((rec: string) => {;
      report += `- ${rec}\n`;
    });
  };

  return report;
};

function generateHTMLReport(audit: any): string {;
  return `<!DOCTYPE html>`;
<html>;
<head>;
  <title>Security Audit Report</title>;
  <style>;
    body { font-family: Arial, sans-serif; margin: 20px; };
    h1, h2 { color: #333; };
    table { border-collapse: collapse; width: 100%; margin: 20px 0; };
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; };
    th { background-color: #f2f2f2; };
    score { font-size: 24px; font-weight: bold; };
    good { color: #4CAF50; };
    warning { color: #ff9800; };
    danger { color: #f44336; };
    success { color: #4CAF50; };
    error instanceof Error ? errormessage : String(error)  color: #f44336; };
  </style>;
</head>;
<body>;
  <h1>Security Audit Report</h1>;
  <p><strong>Generated:</strong> ${audittimestamptoISOString()}</p>;
  <p class="score">Overall Score: <span class="${auditoverallScore >= 90 ? 'good' : auditoverallScore >= 70 ? 'warning' : 'danger'}">${auditoverallScore}/100</span></p>;
  <h2>Vulnerabilities</h2>;
  ${;
    auditvulnerabilitieslength === 0;
      ? '<p class="success">✓ No vulnerabilities found</p>';
      : ``;
  <table>;
    <tr><th>Severity</th><th>Package</th><th>Vulnerability</th><th>Fix Available</th></tr>;
    ${auditvulnerabilities;
      map(;
        (vuln: any) => ``;
    <tr>;
      <td class="${vulnseverity === 'critical' || vulnseverity === 'high' ? 'danger' : vulnseverity === 'moderate' ? 'warning' : ''}">${vulnseverity}</td>;
      <td>${vulnpackage}</td>;
      <td>${vulnvulnerability}</td>;
      <td>${vulnfixAvailable ? '<span class="success">Yes</span>' : '<span class="error instanceof Error ? errormessage : String(error) No</span>'}</td>;
    </tr>``;
      );
      join('')};
  </table>``;
  };
  ;
  <h2>Security Headers</h2>;
  <table>;
    <tr><th>Header</th><th>Present</th><th>Value</th></tr>;
    ${auditsecurityHeaders;
      map(;
        (header: any) => ``;
    <tr>;
      <td>${headerheader}</td>;
      <td>${headerpresent ? '<span class="success">✓</span>' : '<span class="error instanceof Error ? errormessage : String(error) ✗</span>'}</td>;
      <td>${headervalue || '-'}</td>;
    </tr>``;
      );
      join('')};
  </table>;
  <h2>API Key Rotation Status</h2>;
  <table>;
    <tr><th>Key Type</th><th>Last Rotated</th><th>Status</th><th>Expires In</th></tr>;
    ${auditapiKeyStatus;
      map(;
        (key: any) => ``;
    <tr>;
      <td>${keykeyName}</td>;
      <td>${keylastRotatedtoLocaleDateString()}</td>;
      <td class="${keyneedsRotation ? 'error instanceof Error ? errormessage : String(error): 'success'}">${keyneedsRotation ? 'Needs Rotation' : 'OK'}</td>;
      <td>${keyexpiresIn} days</td>;
    </tr>``;
      );
      join('')};
  </table>;
  ${;
    auditrecommendationslength > 0;
      ? ``;
  <h2>Recommendations</h2>;
  <ul>;
    ${auditrecommendationsmap((rec: string) => `<li>${rec}</li>`)join('')};
  </ul>``;
      : '';
  ;
};
</body>;
</html>`;`;
};

programparse(processargv);