/* eslint-disable no-undef */;
#!/usr/bin/env node;
import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { resourceManager } from '../services/resource-manager';
import { connectionPoolManager } from '../services/connection-pool-manager';
import { memoryManager } from '../services/memory-manager';
import { logger } from '../utils/logger';
// import Table from 'cli-table3'; // Package not available, using simple table implementation;
interface TableOptions {;
  head?: string[];
  colWidths?: number[];
  style?: any; // Ignore style properties for now;
};
class SimpleTable {;
  private options: TableOptions;
  private rows: string[][] = [];
  constructor(options: TableOptions = {}) {;
    thisoptions = options;
  };

  push(..args: any[]) {;
    if (argslength === 1 && ArrayisArray(args[0])) {;
      thisrowspush(args[0]);
    } else {;
      thisrowspush(argsmap(String));
    };
  };

  toString(): string {;
    const { head = [], colWidths = [] } = thisoptions;
    let result = '';
    if (headlength > 0) {;
      result += `${headmap((h, i) => hpadEnd(colWidths[i] || 20))join(' | ')}\n`;
      result += `${headmap((_, i) => '-'repeat(colWidths[i] || 20))join('-+-')}\n`;
    };

    for (const row of thisrows) {;
      result += `${rowmap((cell, i) => String(cell)padEnd(colWidths[i] || 20))join(' | ')}\n`;
    };

    return result;
  };
};
const Table = SimpleTable;
// @ts-ignore - blessed types are not available;
import blessed from 'blessed';
// @ts-ignore - blessed-contrib types are not available;
import contrib from 'blessed-contrib';
const program = new Command();
program;
  name('resource-monitor');
  description('Monitor and manage Universal AI Tools resources');
  version('1.0.0');
// Real-time monitoring command;
program;
  command('monitor');
  description('Start real-time resource monitoring dashboard');
  option('-i, --interval <ms>', 'Update interval in milliseconds', '1000');
  action(async (options) => {;
    const interval = parseInt(optionsinterval, 10);
    await startDashboard(interval);
  });
// Resource usage report;
program;
  command('report');
  description('Generate resource usage report');
  option('-f, --format <format>', 'Output format (json|table)', 'table');
  action(async (options) => {;
    await generateReport(optionsformat);
  });
// Performance profiling;
program;
  command('profile');
  description('Start performance profiling');
  option('-d, --duration <seconds>', 'Profiling duration in seconds', '60');
  option('-o, --output <file>', 'Output file for profile data');
  action(async (options) => {;
    await startProfiling(parseInt(optionsduration, 10), optionsoutput);
  });
// Resource allocation adjustment;
program;
  command('adjust');
  description('Adjust resource allocations');
  option('--max-memory <mb>', 'Set maximum memory limit (MB)');
  option('--max-connections <n>', 'Set maximum connections');
  option('--max-requests <n>', 'Set maximum requests per minute');
  action(async (options) => {;
    await adjustResources(options);
  });
// Health status check;
program;
  command('health');
  description('Check system health status');
  option('-v, --verbose', 'Show detailed health information');
  action(async (options) => {;
    await checkHealth(optionsverbose);
  });
// Memory commands;
program;
  command('memory');
  description('Memory management commands');
  command('gc');
  description('Force garbage collection');
  action(async () => {;
    await forceGC();
  });
program;
  command('memory');
  command('snapshot');
  description('Take heap snapshot');
  action(async () => {;
    await takeHeapSnapshot();
  });
program;
  command('memory');
  command('leaks');
  description('Check for memory leaks');
  action(async () => {;
    await checkMemoryLeaks();
  });
// Connection pool commands;
program;
  command('connections');
  description('Connection pool management');
  command('status');
  description('Show connection pool status');
  option('-p, --pool <name>', 'Pool name', 'default');
  action(async (options) => {;
    await showConnectionStatus(optionspool);
  });
program;
  command('connections');
  command('reset');
  description('Reset connection pool');
  option('-p, --pool <name>', 'Pool name', 'default');
  action(async (options) => {;
    await resetConnectionPool(optionspool);
  });
// Dashboard implementation;
async function startDashboard(interval: number) {;
  const screen = blessedscreen({;
    smartCSR: true;
    title: 'Universal AI Tools - Resource Monitor';
  });
  const grid = new contribgrid({ rows: 12, cols: 12, screen });
  // CPU gauge;
  const cpuGauge = gridset(0, 0, 4, 3, contribgauge, {;
    label: 'CPU Usage';
    stroke: 'green';
    fill: 'white';
  });
  // Memory gauge;
  const memoryGauge = gridset(0, 3, 4, 3, contribgauge, {;
    label: 'Memory Usage';
    stroke: 'cyan';
    fill: 'white';
  });
  // Connection gauge;
  const connectionGauge = gridset(0, 6, 4, 3, contribgauge, {;
    label: 'Connections';
    stroke: 'yellow';
    fill: 'white';
  });
  // Request gauge;
  const requestGauge = gridset(0, 9, 4, 3, contribgauge, {;
    label: 'Requests/min';
    stroke: 'magenta';
    fill: 'white';
  });
  // CPU line chart;
  const cpuLine = gridset(4, 0, 4, 6, contribline, {;
    style: { line: 'yellow', text: 'green', baseline: 'black' ;
};
    xLabelPadding: 3;
    xPadding: 5;
    showLegend: true;
    label: 'CPU History';
  });
  // Memory line chart;
  const memoryLine = gridset(4, 6, 4, 6, contribline, {;
    style: { line: 'green', text: 'green', baseline: 'black' ;
};
    xLabelPadding: 3;
    xPadding: 5;
    showLegend: true;
    label: 'Memory History';
  });
  // Log display;
  const log = gridset(8, 0, 4, 6, contriblog, {;
    fg: 'green';
    selectedFg: 'green';
    label: 'System Log';
  });
  // Allocations table;
  const allocTable = gridset(8, 6, 4, 6, contribtable, {;
    keys: true;
    fg: 'white';
    selectedFg: 'white';
    selectedBg: 'blue';
    interactive: false;
    label: 'Resource Allocations';
    width: '100%';
    height: '100%';
    border: { type: 'line', fg: 'cyan' ;
};
    columnSpacing: 2;
    columnWidth: [10, 10, 10, 10];
  });
  // Data storage for charts;
  const cpuData: number[] = [];
  const memoryData: number[] = [];
  const timestamps: string[] = [];
  const maxDataPoints = 60;
  // Update function;
  const update = () => {;
    const usage = resourceManagergetResourceUsage();
    const allocations = resourceManagergetAllocations();
    const timestamp = new Date()toLocaleTimeString();
    // Update gauges;
    cpuGaugesetPercent(Mathround(usagecpupercentage));
    memoryGaugesetPercent(Mathround(usagememorypercentage));
    connectionGaugesetPercent(Mathround((usageconnectionstotal / 100) * 100));
    requestGaugesetPercent(Mathround((usagerequestsperMinute / 1000) * 100));
    // Update chart data;
    cpuDatapush(usagecpupercentage);
    memoryDatapush(usagememorypercentage);
    timestampspush(timestamp);
    if (cpuDatalength > maxDataPoints) {;
      cpuDatashift();
      memoryDatashift();
      timestampsshift();
    };

    // Update line charts;
    cpuLinesetData([;
      {;
        title: 'CPU %';
        x: timestamps;
        y: cpuData;
        style: { line: 'yellow' ;
};
      };
    ]);
    memoryLinesetData([;
      {;
        title: 'Memory %';
        x: timestamps;
        y: memoryData;
        style: { line: 'green' ;
};
      };
      {;
        title: 'Heap %';
        x: timestamps;
        y: memoryDatamap((_, i) => (usagememoryheapused / usagememoryheaplimit) * 100);
        style: { line: 'cyan' ;
};
      };
    ]);
    // Update allocations table;
    const tableData = allocations;
      slice(0, 10);
      map((a) => [;
        atype;
        aowner;
        aamounttoString();
        new Date(aallocatedAt)toLocaleTimeString();
      ]);
    allocTablesetData({;
      headers: ['Type', 'Owner', 'Amount', 'Time'];
      data: tableData;
    });
    // Add log entry;
    if (usagecpupercentage > 80 || usagememorypercentage > 80) {;
      loglog(`${timestamp} - Warning: High resource usage detected`);
    ;
};

    screenrender();
  };
  // Set up update interval;
  const updateInterval = setInterval(update, interval);
  // Initial update;
  update();
  // Key bindings;
  screenkey(['escape', 'q', 'C-c'], () => {;
    clearInterval(updateInterval);
    return processexit(0);
  });
  screenrender();
};

// Report generation;
async function generateReport(format: string) {;
  const spinner = ora('Generating resource report...')start();
  try {;
    const usage = resourceManagergetResourceUsage();
    const allocations = resourceManagergetAllocations();
    const poolStatus = connectionPoolManagergetPoolStatus();
    const memoryProfile = memoryManagergetMemoryProfile();
    const report = {;
      timestamp: new Date()toISOString();
      usage;
      allocations: {;
        total: allocationslength;
        byType: allocationsreduce(;
          (acc, a) => {;
            acc[atype] = (acc[atype] || 0) + 1;
            return acc;
          };
          {} as Record<string, number>;
        );
      };
      connectionPools: poolStatus;
      memory: memoryProfile;
      health: resourceManagergetHealthStatus();
    ;
};
    spinnersucceed('Report generated');
    if (format === 'json') {;
      loggerinfo(JSONstringify(report, null, 2));
    } else {;
      displayReportTable(report);
    };
  } catch (error) {;
    spinnerfail(`Failed to generate report: ${error instanceof Error ? errormessage : String(error));`;
    processexit(1);
  };
};

function displayReportTable(report: any) {;
  // System overview;
  const overviewTable = new Table({;
    head: ['Metric', 'Value'];
    colWidths: [30, 50];
  });
  overviewTablepush(;
    ['Timestamp', reporttimestamp];
    ['Health Status', reporthealth];
    ['CPU Usage', `${reportusagecpupercentagetoFixed(1)}%`];
    ['Memory Usage', `${reportusagememorypercentagetoFixed(1)}%`];
    ['Active Connections', reportusageconnectionsactive];
    ['Requests/min', reportusagerequestsperMinute];
  );
  loggerinfo(chalkcyan('\n=== System Overview ==='));
  loggerinfo(overviewTabletoString());
  // Resource allocations;
  const allocTable = new Table({;
    head: ['Type', 'Count'];
    colWidths: [20, 20];
  });
  Objectentries(reportallocationsbyType)forEach(([type, count]) => {;
    allocTablepush([type, count]);
  });
  loggerinfo(chalkcyan('\n=== Resource Allocations ==='));
  loggerinfo(allocTabletoString());
  // Memory details;
  const memoryTable = new Table({;
    head: ['Memory Metric', 'Value'];
    colWidths: [30, 50];
  });
  memoryTablepush(;
    ['Heap Used', `${(reportmemorycurrentheapUsed / 1024 / 1024)toFixed(2)} MB`];
    ['Heap Total', `${(reportmemorycurrentheapTotal / 1024 / 1024)toFixed(2)} MB`];
    ['RSS', `${(reportmemorycurrentrss / 1024 / 1024)toFixed(2)} MB`];
    ['External', `${(reportmemorycurrentexternal / 1024 / 1024)toFixed(2)} MB`];
    ['Caches', reportmemorycacheslength];
    ['Potential Leaks', reportmemoryleakslength];
  );
  loggerinfo(chalkcyan('\n=== Memory Details ==='));
  loggerinfo(memoryTabletoString());
};

// Performance profiling;
async function startProfiling(duration: number, outputFile?: string) {;
  const spinner = ora(`Starting performance profiling for ${duration} seconds...`)start();
  const startTime = Datenow();
  const samples: any[] = [];
  const sampleInterval = setInterval(() => {;
    const usage = resourceManagergetResourceUsage();
    const memoryProfile = memoryManagergetMemoryProfile();
    samplespush({;
      timestamp: Datenow() - startTime;
      cpu: usagecpu;
      memory: usagememory;
      connections: usageconnections;
      requests: usagerequests;
      heap: memoryProfilecurrent;
    });
  }, 100); // Sample every 100ms;
  setTimeout(async () => {;
    clearInterval(sampleInterval);
    spinnersucceed('Profiling completed');
    const profile = {;
      duration;
      samples;
      summary: calculateProfileSummary(samples);
    };
    if (outputFile) {;
      const fs = await import('fs/promises');
      await fswriteFile(outputFile, JSONstringify(profile, null, 2));
      loggerinfo(chalkgreen(`Profile saved to ${outputFile}`));
    } else {;
      displayProfileSummary(profilesummary);
    };

    processexit(0);
  }, duration * 1000);
};

function calculateProfileSummary(samples: any[]): any {;
  const cpuValues = samplesmap((s) => scpupercentage);
  const memoryValues = samplesmap((s) => smemorypercentage);
  const requestValues = samplesmap((s) => srequestsperMinute);
  return {;
    cpu: {;
      min: Mathmin(..cpuValues);
      max: Mathmax(..cpuValues);
      avg: cpuValuesreduce((a, b) => a + b, 0) / cpuValueslength;
    };
    memory: {;
      min: Mathmin(..memoryValues);
      max: Mathmax(..memoryValues);
      avg: memoryValuesreduce((a, b) => a + b, 0) / memoryValueslength;
    };
    requests: {;
      min: Mathmin(..requestValues);
      max: Mathmax(..requestValues);
      avg: requestValuesreduce((a, b) => a + b, 0) / requestValueslength;
    };
  };
};

function displayProfileSummary(summary: any) {;
  const table = new Table({;
    head: ['Metric', 'Min', 'Max', 'Average'];
    colWidths: [20, 15, 15, 15];
  });
  tablepush(;
    ['CPU %', summarycpumintoFixed(1), summarycpumaxtoFixed(1), summarycpuavgtoFixed(1)];
    [;
      'Memory %';
      summarymemorymintoFixed(1);
      summarymemorymaxtoFixed(1);
      summarymemoryavgtoFixed(1);
    ];
    [;
      'Requests/min';
      summaryrequestsmintoFixed(0);
      summaryrequestsmaxtoFixed(0);
      summaryrequestsavgtoFixed(0);
    ];
  );
  loggerinfo(chalkcyan('\n=== Performance Profile Summary ==='));
  loggerinfo(tabletoString());
};

// Resource adjustment;
async function adjustResources(options: any) {;
  const spinner = ora('Adjusting resource limits...')start();
  try {;
    const adjustments: string[] = [];
    if (optionsmaxMemory) {;
      processenvMAX_MEMORY_MB = optionsmaxMemory;
      adjustmentspush(`Max memory: ${optionsmaxMemory} MB`);
    };

    if (optionsmaxConnections) {;
      processenvMAX_CONNECTIONS = optionsmaxConnections;
      adjustmentspush(`Max connections: ${optionsmaxConnections}`);
    };

    if (optionsmaxRequests) {;
      processenvMAX_REQUESTS_PER_MINUTE = optionsmaxRequests;
      adjustmentspush(`Max requests/min: ${optionsmaxRequests}`);
    };

    spinnersucceed('Resource limits adjusted');
    if (adjustmentslength > 0) {;
      loggerinfo(chalkgreen('\nAdjustments made:'));
      adjustmentsforEach((a) => loggerinfo(`  - ${a}`));
      loggerinfo(chalkyellow('\nNote: Some changes may require a restart to take effect.'));
    ;
};
  } catch (error) {;
    spinnerfail(`Failed to adjust resources: ${error instanceof Error ? errormessage : String(error));`;
    processexit(1);
  };
};

// Health check;
async function checkHealth(verbose: boolean) {;
  const spinner = ora('Checking system health...')start();
  try {;
    const health = resourceManagergetHealthStatus();
    const usage = resourceManagergetResourceUsage();
    const memoryCheck = memoryManagercheckMemoryUsage();
    spinnerstop();
    // Display health status with appropriate color;
    const statusColor =;
if (      health === 'healthy') { return chalkgreen; } else if (health === 'degraded') { return chalkyellow; } else { return chalkred; };

    loggerinfo(`\nSystem Health: ${statusColor(healthtoUpperCase())}`);
    if (verbose) {;
      const table = new Table({;
        head: ['Component', 'Status', 'Details'];
        colWidths: [20, 15, 45];
      });
      // CPU status;
      const cpuStatus =;
if (        usagecpupercentage < 60) { return 'OK'; } else if (usagecpupercentage < 80) { return 'WARNING'; } else { return 'CRITICAL'; };
      tablepush([;
        'CPU';
        cpuStatus;
        `${usagecpupercentagetoFixed(1)}% (${usagecpucores} cores)`;
      ]);
      // Memory status;
      tablepush([;
        'Memory';
        memoryCheckstatustoUpperCase();
        `${memoryCheckdetailsheapUsedPercent}% heap, ${memoryCheckdetailsrss} RSS`;
      ]);
      // Connection status;
      const connStatus = usageconnectionstotal < 80 ? 'OK' : 'WARNING';
      tablepush([;
        'Connections';
        connStatus;
        `${usageconnectionsactive} active, ${usageconnectionsidle} idle`;
      ]);
      // Request rate status;
      const reqStatus = usagerequestsperMinute < 800 ? 'OK' : 'WARNING';
      tablepush(['Request Rate', reqStatus, `${usagerequestsperMinute}/min`]);
      loggerinfo(`\n${tabletoString()}`);
    };
  } catch (error) {;
    spinnerfail(`Health check failed: ${error instanceof Error ? errormessage : String(error));`;
    processexit(1);
  };
};

// Memory management commands;
async function forceGC() {;
  const spinner = ora('Forcing garbage collection...')start();
  try {;
    memoryManagerforceGC();
    spinnersucceed('Garbage collection completed');
    const usage = memoryManagercheckMemoryUsage();
    loggerinfo(`Current memory usage: ${usagedetailsheapUsedPercent}%`);
  } catch (error) {;
    spinnerfail(`Failed to force GC: ${error instanceof Error ? errormessage : String(error));`;
  };
};

async function takeHeapSnapshot() {;
  const spinner = ora('Taking heap snapshot...')start();
  try {;
    const filepath = await memoryManagertakeHeapSnapshot();
    spinnersucceed(`Heap snapshot saved to ${filepath}`);
  } catch (error) {;
    spinnerfail(`Failed to take heap snapshot: ${error instanceof Error ? errormessage : String(error));`;
  };
};

async function checkMemoryLeaks() {;
  const spinner = ora('Checking for memory leaks...')start();
  try {;
    const profile = memoryManagergetMemoryProfile();
    spinnerstop();
    if (profileleakslength === 0) {;
      loggerinfo(chalkgreen('No memory leaks detected'));
    } else {;
      loggerinfo(chalkyellow(`\nPotential memory leaks detected: ${profileleakslength}`));
      const table = new Table({;
        head: ['Location', 'Growth Rate', 'Current Size', 'First Detected'];
        colWidths: [20, 15, 15, 25];
      });
      profileleaksforEach((leak: any) => {;
        tablepush([;
          leakid;
          `${(leakgrowthRate * 100)toFixed(1)}%`;
          `${(leaksize / 1024 / 1024)toFixed(2)} MB`;
          new Date(leakfirstDetected)toLocaleString();
        ]);
      });
      loggerinfo(tabletoString());
    };
  } catch (error) {;
    spinnerfail(`Failed to check for leaks: ${error instanceof Error ? errormessage : String(error));`;
  };
};

// Connection pool commands;
async function showConnectionStatus(poolName: string) {;
  const spinner = ora('Fetching connection pool status...')start();
  try {;
    const status = connectionPoolManagergetPoolStatus(poolName);
    spinnerstop();
    loggerinfo(chalkcyan(`\n=== Connection Pool: ${poolName} ===\n`));
    // Supabase connections;
    loggerinfo(chalkyellow('Supabase Connections:'));
    loggerinfo(`  Total: ${statussupabasetotal}`);
    loggerinfo(`  Active: ${statussupabaseactive}`);
    loggerinfo(`  Idle: ${statussupabaseidle}`);
    loggerinfo(`  Waiting: ${statussupabasewaiting}`);
    // Redis connections;
    loggerinfo(chalkyellow('\nRedis Connections:'));
    loggerinfo(`  Total: ${statusredistotal}`);
    loggerinfo(`  Active: ${statusredisactive}`);
    loggerinfo(`  Idle: ${statusredisidle}`);
    loggerinfo(`  Waiting: ${statusrediswaiting}`);
    // Connection details;
    if (statussupabaseconnectionslength > 0 || statusredisconnectionslength > 0) {;
      const table = new Table({;
        head: ['Type', 'ID', 'In Use', 'Use Count', 'Errors', 'Age (min)'];
        colWidths: [10, 20, 10, 12, 10, 12];
      });
      [;
        ..statussupabaseconnectionsmap((c: any) => ({ ..c, type: 'Supabase' }));
        ..statusredisconnectionsmap((c: any) => ({ ..c, type: 'Redis' }));
      ]forEach((conn) => {;
        const age = (Datenow() - new Date(conncreatedAt)getTime()) / 60000;
        tablepush([;
          conntype;
          `${connidsubstring(0, 18)}...`;
          conninUse ? 'Yes' : 'No';
          connuseCounttoString();
          connerrorstoString();
          agetoFixed(1);
        ]);
      });
      loggerinfo(`\n${tabletoString()}`);
    };
  } catch (error) {;
    spinnerfail(`Failed to get connection status: ${error instanceof Error ? errormessage : String(error));`;
  };
};

async function resetConnectionPool(poolName: string) {;
  const spinner = ora(`Resetting connection pool: ${poolName}...`)start();
  try {;
    // This would require adding a reset method to the connection pool manager;
    spinnerwarn('Connection pool reset not yet implemented');
    loggerinfo(chalkyellow('Please restart the service to reset connection pools'));
  } catch (error) {;
    spinnerfail(`Failed to reset connection pool: ${error instanceof Error ? errormessage : String(error));`;
  };
};

// Parse arguments and run;
programparse(processargv);
// If no command specified, show help;
if (!processargvslice(2)length) {;
  programoutputHelp();
};
