name: Rust/Go Code Quality CI/CD

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master]
  schedule:
    # Run code quality checks daily at 2 AM UTC
    - cron: "0 2 * * *"
  workflow_dispatch:
    inputs:
      check_type:
        description: "Type of quality check to run"
        required: true
        default: "all"
        type: choice
        options:
          - rust
          - go
          - all
      memory_mode:
        description: "Enable memory persistence"
        required: false
        default: true
        type: boolean

jobs:
  rust-quality:
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'rust' || github.event.inputs.check_type == 'all' || github.event_name != 'workflow_dispatch'

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          components: rustfmt, clippy

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            crates/* -> Cargo.toml
            rust-services/* -> Cargo.toml

      - name: Configure Supabase (if available)
        if: ${{ vars.SUPABASE_URL != '' && secrets.SUPABASE_ANON_KEY != '' }}
        run: |
          echo "SUPABASE_URL=${{ vars.SUPABASE_URL }}" >> $GITHUB_ENV
          echo "SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}" >> $GITHUB_ENV
          echo "✅ Supabase configured for memory persistence"

      - name: Run Rust clippy analysis (before)
        run: |
          echo "## 📊 Rust Clippy Analysis Before Fixes" >> $GITHUB_STEP_SUMMARY
          cargo clippy --all-targets --all-features -- -D warnings 2>&1 | grep -E "(warning|error)" | wc -l > before_count.txt
          BEFORE_COUNT=$(cat before_count.txt)
          echo "**Issues before fixes:** $BEFORE_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "BEFORE_COUNT=$BEFORE_COUNT" >> $GITHUB_ENV

      - name: Run Rust clippy autofix
        run: |
          echo "🔧 Running Rust clippy autofix..." >> $GITHUB_STEP_SUMMARY
          cargo clippy --fix --allow-dirty --allow-staged 2>&1 | tee rust_clippy_log.txt
          echo "### Rust Clippy Results" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -10 rust_clippy_log.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Format Rust code
        run: |
          echo "🎨 Formatting Rust code..." >> $GITHUB_STEP_SUMMARY
          cargo fmt --all || true

      - name: Run Rust tests
        run: |
          echo "🧪 Running Rust tests..." >> $GITHUB_STEP_SUMMARY
          cargo test --all 2>&1 | tee rust_test_log.txt
          echo "### Rust Test Results" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -10 rust_test_log.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Run Rust clippy analysis (after)
        run: |
          echo "## 📈 Rust Clippy Analysis After Fixes" >> $GITHUB_STEP_SUMMARY
          cargo clippy --all-targets --all-features -- -D warnings 2>&1 | grep -E "(warning|error)" | wc -l > after_count.txt
          AFTER_COUNT=$(cat after_count.txt)
          IMPROVEMENT=$((BEFORE_COUNT - AFTER_COUNT))
          echo "**Issues after fixes:** $AFTER_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "**Issues fixed:** $IMPROVEMENT" >> $GITHUB_STEP_SUMMARY
          echo "AFTER_COUNT=$AFTER_COUNT" >> $GITHUB_ENV
          echo "IMPROVEMENT=$IMPROVEMENT" >> $GITHUB_ENV

          if [ $IMPROVEMENT -gt 0 ]; then
            echo "🎉 **Rust fixes successful!** Fixed $IMPROVEMENT issues" >> $GITHUB_STEP_SUMMARY
          else
            echo "ℹ️ No new Rust issues fixed this run" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check for changes
        id: changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if [ -n "$(git status --porcelain)" ]; then
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "📝 Changes detected in codebase" >> $GITHUB_STEP_SUMMARY
          else
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "✨ No changes needed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Generate quality report
        if: steps.changes.outputs.changes == 'true'
        run: |
          cat > quality_report.md << EOF
          # 🦀 Rust Code Quality Improvements

          ## Summary
          - **Issues before:** $BEFORE_COUNT
          - **Issues after:** $AFTER_COUNT
          - **Issues fixed:** $IMPROVEMENT
          - **Success rate:** $(echo "scale=1; $IMPROVEMENT * 100 / $BEFORE_COUNT" | bc -l)%

          ## Changes Applied
          - ✅ Rust clippy autofix
          - ✅ Code formatting with rustfmt
          - ✅ Test execution
          - ✅ Memory learning integration

          ## Memory Learning
          $(if [ -n "$SUPABASE_URL" ]; then echo "🧠 All fixes stored in Supabase for continuous learning"; else echo "📝 Running in offline mode"; fi)

          ## Next Steps
          - Review the changes in this PR
          - Merge if the improvements look good
          - The system will continue learning from these patterns

          *Generated by Rust/Go Quality System* 🚀
          EOF

      - name: Create Pull Request
        if: steps.changes.outputs.changes == 'true' && github.event_name != 'pull_request'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            🦀 Automated Rust code quality improvements

            - Fixed multiple clippy warnings
            - Applied rustfmt formatting
            - Enhanced code quality and performance

            Generated with Rust/Go Quality System
          title: "🦀 Automated Rust Code Quality Improvements"
          body-path: quality_report.md
          branch: rust-quality/run-${{ github.run_number }}
          delete-branch: true
          labels: |
            rust
            code-quality
            automated

      - name: Comment on existing PR
        if: steps.changes.outputs.changes == 'true' && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('quality_report.md', 'utf8');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: report
            });

      - name: Update learning metrics
        if: ${{ always() && vars.SUPABASE_URL != '' && secrets.SUPABASE_ANON_KEY != '' }}
        run: |
          cat > update_metrics.mjs << 'EOF'
          import { createClient } from '@supabase/supabase-js';

          const supabase = createClient(
            process.env.SUPABASE_URL,
            process.env.SUPABASE_ANON_KEY
          );

          try {
            await supabase
              .from('memories')
              .insert({
                content: `Rust quality check run: ${process.env.IMPROVEMENT} issues fixed`,
                metadata: {
                  memory_type: 'rust_quality_run',
                  before_count: process.env.BEFORE_COUNT,
                  after_count: process.env.AFTER_COUNT,
                  improvement: process.env.IMPROVEMENT,
                  workflow: 'rust-go-quality',
                  git_ref: process.env.GITHUB_REF,
                  run_id: process.env.GITHUB_RUN_ID,
                  tags: ['ci-cd', 'rust', 'quality', 'metrics']
                },
                user_id: 'github-actions'
              });

            console.log('✅ Metrics stored in Supabase');
          } catch (error) {
            console.log(`⚠️ Failed to store metrics: ${error.message}`);
          }
          EOF

          node update_metrics.mjs

      - name: Archive logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: rust-quality-logs
          path: |
            *_log.txt
            quality_report.md
          retention-days: 30

  go-quality:
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'go' || github.event.inputs.check_type == 'all' || github.event_name != 'workflow_dispatch'

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.21"

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Configure Supabase (if available)
        if: ${{ vars.SUPABASE_URL != '' && secrets.SUPABASE_ANON_KEY != '' }}
        run: |
          echo "SUPABASE_URL=${{ vars.SUPABASE_URL }}" >> $GITHUB_ENV
          echo "SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}" >> $GITHUB_ENV
          echo "✅ Supabase configured for memory persistence"

      - name: Run Go vet analysis (before)
        run: |
          echo "## 📊 Go Vet Analysis Before Fixes" >> $GITHUB_STEP_SUMMARY
          go vet ./... 2>&1 | grep -E "(warning|error)" | wc -l > go_before_count.txt
          GO_BEFORE_COUNT=$(cat go_before_count.txt)
          echo "**Go issues before fixes:** $GO_BEFORE_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "GO_BEFORE_COUNT=$GO_BEFORE_COUNT" >> $GITHUB_ENV

      - name: Run Go fmt
        run: |
          echo "🎨 Formatting Go code..." >> $GITHUB_STEP_SUMMARY
          go fmt ./... || true

      - name: Run Go vet
        run: |
          echo "🔧 Running Go vet..." >> $GITHUB_STEP_SUMMARY
          go vet ./... 2>&1 | tee go_vet_log.txt
          echo "### Go Vet Results" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -10 go_vet_log.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Run Go tests
        run: |
          echo "🧪 Running Go tests..." >> $GITHUB_STEP_SUMMARY
          go test ./... 2>&1 | tee go_test_log.txt
          echo "### Go Test Results" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -10 go_test_log.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Run Go vet analysis (after)
        run: |
          echo "## 📈 Go Vet Analysis After Fixes" >> $GITHUB_STEP_SUMMARY
          go vet ./... 2>&1 | grep -E "(warning|error)" | wc -l > go_after_count.txt
          GO_AFTER_COUNT=$(cat go_after_count.txt)
          GO_IMPROVEMENT=$((GO_BEFORE_COUNT - GO_AFTER_COUNT))
          echo "**Go issues after fixes:** $GO_AFTER_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "**Go issues fixed:** $GO_IMPROVEMENT" >> $GITHUB_STEP_SUMMARY
          echo "GO_AFTER_COUNT=$GO_AFTER_COUNT" >> $GITHUB_ENV
          echo "GO_IMPROVEMENT=$GO_IMPROVEMENT" >> $GITHUB_ENV

          if [ $GO_IMPROVEMENT -gt 0 ]; then
            echo "🎉 **Go fixes successful!** Fixed $GO_IMPROVEMENT issues" >> $GITHUB_STEP_SUMMARY
          else
            echo "ℹ️ No new Go issues fixed this run" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check for changes
        id: go_changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if [ -n "$(git status --porcelain)" ]; then
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "📝 Changes detected in Go codebase" >> $GITHUB_STEP_SUMMARY
          else
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "✨ No Go changes needed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Generate Go quality report
        if: steps.go_changes.outputs.changes == 'true'
        run: |
          cat > go_quality_report.md << EOF
          # 🐹 Go Code Quality Improvements

          ## Summary
          - **Issues before:** $GO_BEFORE_COUNT
          - **Issues after:** $GO_AFTER_COUNT
          - **Issues fixed:** $GO_IMPROVEMENT
          - **Success rate:** $(echo "scale=1; $GO_IMPROVEMENT * 100 / $GO_BEFORE_COUNT" | bc -l)%

          ## Changes Applied
          - ✅ Go vet analysis
          - ✅ Code formatting with go fmt
          - ✅ Test execution
          - ✅ Memory learning integration

          ## Memory Learning
          $(if [ -n "$SUPABASE_URL" ]; then echo "🧠 All fixes stored in Supabase for continuous learning"; else echo "📝 Running in offline mode"; fi)

          ## Next Steps
          - Review the changes in this PR
          - Merge if the improvements look good
          - The system will continue learning from these patterns

          *Generated by Rust/Go Quality System* 🚀
          EOF

      - name: Create Go Pull Request
        if: steps.go_changes.outputs.changes == 'true' && github.event_name != 'pull_request'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            🐹 Automated Go code quality improvements

            - Fixed multiple vet warnings
            - Applied go fmt formatting
            - Enhanced code quality and performance

            Generated with Rust/Go Quality System
          title: "🐹 Automated Go Code Quality Improvements"
          body-path: go_quality_report.md
          branch: go-quality/run-${{ github.run_number }}
          delete-branch: true
          labels: |
            go
            code-quality
            automated

      - name: Archive Go logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: go-quality-logs
          path: |
            *_log.txt
            go_quality_report.md
          retention-days: 30
