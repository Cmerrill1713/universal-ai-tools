/**
 * Photo Organization Template Implementation - Universal AI Tools
 * Advanced AI-powered photo organization with computer vision capabilities
 * Leverages PyVision bridge and SDXL refiner for intelligent photo processing
 */

import { LogContext, log } from '@/utils/logger';
import { type ProjectTaskTemplate, type ProjectTemplate, ProjectTemplateService } from './project-template-service';
import type { ProjectType, TaskPriority, TaskType } from './project-orchestrator';
import type { PyVisionBridge } from './pyvision-bridge';
import type { VisionResourceManager } from './vision-resource-manager';

export interface PhotoOrganizationConfig {
  enableAIEnhancement: boolean;
  enableFaceRecognition: boolean;
  enableObjectDetection: boolean;
  enableLocationExtraction: boolean;
  duplicateThreshold: number;
  qualityThreshold: number;
  enhancementStrength: number;
  batchSize: number;
  maxConcurrentJobs: number;
}

export interface PhotoMetadata {
  id: string;
  filename: string;
  path: string;
  size: number;
  dimensions: { width: number; height: number; };
  exifData: Record<string, any>;
  dateCreated: Date;
  dateTaken?: Date;
  location?: {
    latitude: number;
    longitude: number;
    address?: string;
  };
  cameraInfo?: {
    make: string;
    model: string;
    settings: Record<string, any>;
  };
  aiAnalysis?: {
    objects: Array<{ name: string; confidence: number; bbox: number[]; }>;
    faces: Array<{ id: string; confidence: number; bbox: number[]; }>;
    scene: string;
    qualityScore: number;
    aestheticScore: number;
    tags: string[];
  };
  duplicateGroup?: string;
  enhancementSuggestions?: Array<{
    type: 'brightness' | 'contrast' | 'sharpness' | 'color_correction' | 'noise_reduction';
    confidence: number;
    parameters: Record<string, number>;
  }>;
}

export interface PhotoAlbum {
  id: string;
  name: string;
  description: string;
  type: 'event' | 'person' | 'location' | 'date' | 'theme' | 'quality';
  criteria: Record<string, any>;
  photoIds: string[];
  coverPhotoId?: string;
  createdAt: Date;
  metadata: {
    autoGenerated: boolean;
    confidence: number;
    tags: string[];
  };
}

export interface OrganizationReport {
  summary: {
    totalPhotos: number;
    duplicatesFound: number;
    duplicatesRemoved: number;
    albumsCreated: number;
    enhancementsApplied: number;
    processingTime: number;
  };
  insights: {
    mostCommonSubjects: Array<{ name: string; count: number; }>;
    timeSpanAnalysis: {
      oldestPhoto: Date;
      newestPhoto: Date;
      yearDistribution: Record<string, number>;
    };
    qualityAnalysis: {
      averageQuality: number;
      lowQualityCount: number;
      enhancementCandidates: number;
    };
    locationAnalysis?: {
      topLocations: Array<{ location: string; count: number; }>;
      geographicSpread: string;
    };
  };
  recommendations: Array<{
    type: 'organization' | 'enhancement' | 'cleanup' | 'backup';
    priority: 'high' | 'medium' | 'low';
    description: string;
    actionItems: string[];
  }>;
}

export class PhotoOrganizationTemplateService extends ProjectTemplateService {
  private pyVisionBridge: PyVisionBridge;
  private visionResourceManager: VisionResourceManager;
  private config: PhotoOrganizationConfig;

  constructor(
    pyVisionBridge: PyVisionBridge,
    visionResourceManager: VisionResourceManager,
    config: Partial<PhotoOrganizationConfig> = {}
  ) {
    super();
    this.pyVisionBridge = pyVisionBridge;
    this.visionResourceManager = visionResourceManager;
    this.config = {
      enableAIEnhancement: true,
      enableFaceRecognition: true,
      enableObjectDetection: true,
      enableLocationExtraction: true,
      duplicateThreshold: 0.95,
      qualityThreshold: 0.7,
      enhancementStrength: 0.3,
      batchSize: 50,
      maxConcurrentJobs: 4,
      ...config
    };
  }

  /**
   * Create comprehensive photo organization template with AI capabilities
   */
  createAdvancedPhotoOrganizationTemplate(): ProjectTemplate {
    log.info('üéØ Creating advanced photo organization template', LogContext.PROJECT, {
      aiEnhancement: this.config.enableAIEnhancement,
      faceRecognition: this.config.enableFaceRecognition,
      objectDetection: this.config.enableObjectDetection
    });

    return {
      id: 'photo-org-ai-advanced',
      name: 'AI-Powered Photo Organization Pro',
      type: 'photo_organization' as ProjectType,
      description: 'Advanced photo organization with computer vision, face recognition, and AI enhancement',
      category: 'ai_enhanced',
      complexity: 'complex',
      estimatedDuration: { min: 30, max: 240, unit: 'minutes' },
      requiredCapabilities: [
        'computer_vision',
        'face_recognition', 
        'object_detection',
        'image_enhancement',
        'metadata_extraction',
        'duplicate_detection',
        'geolocation',
        'batch_processing'
      ],
      taskTemplates: this.createAdvancedTaskTemplates(),
      agentRecommendations: [
        {
          agent: 'retriever',
          useCase: 'Photo discovery, metadata extraction, and initial analysis',
          confidence: 0.92,
          reasoning: 'Excellent at systematic file analysis and comprehensive data extraction',
          alternativeAgents: ['personal_assistant']
        },
        {
          agent: 'synthesizer',
          useCase: 'AI analysis integration, duplicate detection, and quality assessment',
          confidence: 0.88,
          reasoning: 'Strong analytical capabilities for complex image comparison and pattern recognition',
          alternativeAgents: ['retriever']
        },
        {
          agent: 'planner',
          useCase: 'Album organization strategy and enhancement workflow planning',
          confidence: 0.85,
          reasoning: 'Excellent at creating logical organizational structures and coordinating complex workflows',
          alternativeAgents: ['personal_assistant']
        },
        {
          agent: 'personal_assistant',
          useCase: 'User interaction, progress reporting, and final delivery coordination',
          confidence: 0.80,
          reasoning: 'Great at user communication and coordinating final deliverable preparation',
          alternativeAgents: ['synthesizer']
        }
      ],
      successMetrics: [
        {
          name: 'AI Categorization Accuracy',
          description: 'Percentage of photos correctly categorized by AI',
          measurementType: 'percentage',
          target: 92,
          critical: true
        },
        {
          name: 'Duplicate Detection Precision',
          description: 'Accuracy of duplicate photo identification',
          measurementType: 'percentage',
          target: 96,
          critical: true
        },
        {
          name: 'Face Recognition Accuracy',
          description: 'Accuracy of face identification and grouping',
          measurementType: 'percentage',
          target: 89,
          critical: false
        },
        {
          name: 'Processing Speed',
          description: 'Photos processed per minute with AI analysis',
          measurementType: 'count',
          target: 25,
          critical: false
        },
        {
          name: 'Enhancement Quality Score',
          description: 'Average quality improvement from AI enhancement',
          measurementType: 'quality_score',
          target: 15,
          critical: false
        }
      ],
      commonVariations: [
        {
          name: 'Professional Photography Studio',
          description: 'Optimized for professional RAW photo workflows',
          modifications: {
            adjustComplexity: 'enterprise',
            addTasks: [
              {
                name: 'RAW File Processing',
                type: 'optimization' as TaskType,
                priority: 'high' as TaskPriority,
                description: 'Process and optimize RAW photography files',
                requiredCapabilities: ['raw_processing', 'color_grading', 'professional_enhancement'],
                estimatedDuration: 1800000,
                dependencies: ['Advanced AI Analysis'],
                acceptanceCriteria: ['RAW files processed with professional settings'],
                agentHints: { preferred: ['synthesizer'], alternative: ['code_assistant'] },
                automationLevel: 'assisted'
              }
            ]
          }
        },
        {
          name: 'Family Archive Digitization',
          description: 'Specialized for digitizing and organizing family photo archives',
          modifications: {
            addTasks: [
              {
                name: 'Historical Photo Restoration',
                type: 'optimization' as TaskType,
                priority: 'medium' as TaskPriority,
                description: 'Restore and enhance old family photographs',
                requiredCapabilities: ['photo_restoration', 'age_detection', 'historical_enhancement'],
                estimatedDuration: 2400000,
                dependencies: ['AI Enhancement Processing'],
                acceptanceCriteria: ['Historical photos restored and enhanced'],
                agentHints: { preferred: ['synthesizer'], alternative: ['personal_assistant'] },
                automationLevel: 'assisted'
              }
            ]
          }
        },
        {
          name: 'Enterprise Asset Management',
          description: 'Corporate photo asset management with compliance features',
          modifications: {
            adjustComplexity: 'enterprise',
            addTasks: [
              {
                name: 'Compliance and Rights Management',
                type: 'validation' as TaskType,
                priority: 'critical' as TaskPriority,
                description: 'Ensure photo compliance and manage usage rights',
                requiredCapabilities: ['compliance_checking', 'rights_management', 'audit_trail'],
                estimatedDuration: 1200000,
                dependencies: ['Smart Album Creation'],
                acceptanceCriteria: ['All photos compliance-checked and rights documented'],
                agentHints: { preferred: ['planner'], alternative: ['synthesizer'] },
                automationLevel: 'assisted'
              }
            ]
          }
        }
      ]
    };
  }

  /**
   * Create advanced task templates for AI-powered photo organization
   */
  private createAdvancedTaskTemplates(): ProjectTaskTemplate[] {
    return [
      {
        name: 'Comprehensive Photo Discovery and Indexing',
        type: 'analysis' as TaskType,
        priority: 'critical' as TaskPriority,
        description: 'Deep scan and comprehensive indexing of all photo files with metadata extraction',
        requiredCapabilities: ['file_system_access', 'metadata_reading', 'exif_extraction', 'format_detection'],
        estimatedDuration: 600000, // 10 minutes
        dependencies: [],
        acceptanceCriteria: [
          'All photo files discovered across all formats (JPEG, PNG, RAW, HEIC, etc.)',
          'Complete EXIF metadata extracted and validated',
          'File integrity verified and corruption detected',
          'Basic photo properties cataloged (dimensions, size, color space)',
          'Preliminary file organization structure created'
        ],
        agentHints: {
          preferred: ['retriever', 'personal_assistant'],
          alternative: ['planner']
        },
        automationLevel: 'automated'
      },
      {
        name: 'Advanced AI Analysis',
        type: 'analysis' as TaskType,
        priority: 'high' as TaskPriority,
        description: 'Comprehensive AI analysis including object detection, scene recognition, and aesthetic scoring',
        requiredCapabilities: ['computer_vision', 'object_detection', 'scene_analysis', 'aesthetic_evaluation'],
        estimatedDuration: 1800000, // 30 minutes
        dependencies: ['Comprehensive Photo Discovery and Indexing'],
        acceptanceCriteria: [
          'Objects identified with >90% confidence scores',
          'Scene types classified (indoor/outdoor, event type, setting)',
          'Aesthetic quality scores calculated using AI models',
          'Visual similarity vectors generated for each photo',
          'Content tags automatically generated and applied'
        ],
        agentHints: {
          preferred: ['synthesizer', 'retriever'],
          alternative: ['personal_assistant']
        },
        automationLevel: 'automated'
      },
      {
        name: 'Intelligent Face Recognition and People Grouping',
        type: 'analysis' as TaskType,
        priority: 'high' as TaskPriority,
        description: 'Advanced face detection, recognition, and people clustering with privacy controls',
        requiredCapabilities: ['face_detection', 'face_recognition', 'clustering', 'privacy_protection'],
        estimatedDuration: 1200000, // 20 minutes
        dependencies: ['Advanced AI Analysis'],
        acceptanceCriteria: [
          'Faces detected with precision >95%',
          'Unique individuals identified and clustered',
          'People groups created with confidence scores',
          'Privacy-safe face encoding (no raw biometric storage)',
          'Age and demographic estimation (optional)'
        ],
        agentHints: {
          preferred: ['synthesizer'],
          alternative: ['retriever', 'personal_assistant']
        },
        automationLevel: 'automated'
      },
      {
        name: 'Perceptual Duplicate Detection and Management',
        type: 'analysis' as TaskType,
        priority: 'high' as TaskPriority,
        description: 'Advanced duplicate detection using perceptual hashing and similarity analysis',
        requiredCapabilities: ['perceptual_hashing', 'similarity_analysis', 'duplicate_detection', 'batch_comparison'],
        estimatedDuration: 900000, // 15 minutes
        dependencies: ['Advanced AI Analysis'],
        acceptanceCriteria: [
          'Exact duplicates identified with 100% accuracy',
          'Near-duplicates detected with configurable thresholds',
          'Similar photos grouped with confidence scores',
          'Duplicate resolution recommendations provided',
          'Best version of each duplicate group automatically selected'
        ],
        agentHints: {
          preferred: ['synthesizer', 'retriever'],
          alternative: ['personal_assistant']
        },
        automationLevel: 'automated'
      },
      {
        name: 'Geolocation and Temporal Analysis',
        type: 'analysis' as TaskType,
        priority: 'medium' as TaskPriority,
        description: 'Extract and enhance location data with temporal pattern analysis',
        requiredCapabilities: ['gps_extraction', 'reverse_geocoding', 'temporal_analysis', 'location_clustering'],
        estimatedDuration: 600000, // 10 minutes
        dependencies: ['Comprehensive Photo Discovery and Indexing'],
        acceptanceCriteria: [
          'GPS coordinates extracted from EXIF data',
          'Locations reverse-geocoded to addresses',
          'Location clusters identified (home, work, travel)',
          'Temporal patterns analyzed (daily, seasonal)',
          'Travel timelines and trip detection completed'
        ],
        agentHints: {
          preferred: ['retriever', 'synthesizer'],
          alternative: ['personal_assistant']
        },
        automationLevel: 'automated'
      },
      {
        name: 'Intelligent Album Generation',
        type: 'execution' as TaskType,
        priority: 'high' as TaskPriority,
        description: 'Create smart albums using AI insights and user patterns',
        requiredCapabilities: ['album_creation', 'pattern_recognition', 'event_detection', 'smart_grouping'],
        estimatedDuration: 900000, // 15 minutes
        dependencies: ['Intelligent Face Recognition and People Grouping', 'Geolocation and Temporal Analysis'],
        acceptanceCriteria: [
          'Event-based albums created automatically',
          'People-focused albums generated for family/friends',
          'Location-based travel albums created',
          'Time-based albums (years, seasons, holidays)',
          'Theme-based albums (pets, food, nature, etc.)',
          'Smart album cover photos selected automatically'
        ],
        agentHints: {
          preferred: ['planner', 'personal_assistant'],
          alternative: ['synthesizer']
        },
        automationLevel: 'assisted'
      },
      {
        name: 'AI Enhancement Processing',
        type: 'optimization' as TaskType,
        priority: 'medium' as TaskPriority,
        description: 'Apply AI-powered enhancements to improve photo quality',
        requiredCapabilities: ['image_enhancement', 'ai_upscaling', 'noise_reduction', 'color_correction'],
        estimatedDuration: 2400000, // 40 minutes
        dependencies: ['Advanced AI Analysis', 'Perceptual Duplicate Detection and Management'],
        acceptanceCriteria: [
          'Low-quality photos enhanced using AI models',
          'Appropriate enhancement techniques applied per photo type',
          'Original photos preserved with enhanced versions linked',
          'Enhancement quality metrics tracked and reported',
          'Batch processing optimized for available GPU resources'
        ],
        agentHints: {
          preferred: ['synthesizer'],
          alternative: ['personal_assistant', 'retriever']
        },
        automationLevel: 'assisted'
      },
      {
        name: 'Smart Organization Structure Creation',
        type: 'execution' as TaskType,
        priority: 'high' as TaskPriority,
        description: 'Create intelligent folder structure and file organization',
        requiredCapabilities: ['file_organization', 'folder_structure', 'naming_conventions', 'metadata_integration'],
        estimatedDuration: 600000, // 10 minutes
        dependencies: ['Intelligent Album Generation'],
        acceptanceCriteria: [
          'Logical folder hierarchy created',
          'Consistent naming conventions applied',
          'Metadata integrated into file organization',
          'Duplicate folders consolidated',
          'Backup and original file structure preserved'
        ],
        agentHints: {
          preferred: ['planner', 'personal_assistant'],
          alternative: ['retriever']
        },
        automationLevel: 'automated'
      },
      {
        name: 'Quality Assessment and Curation',
        type: 'validation' as TaskType,
        priority: 'medium' as TaskPriority,
        description: 'Comprehensive quality assessment with curation recommendations',
        requiredCapabilities: ['quality_assessment', 'curation', 'ranking', 'recommendation_engine'],
        estimatedDuration: 600000, // 10 minutes
        dependencies: ['AI Enhancement Processing'],
        acceptanceCriteria: [
          'Quality scores assigned to all photos',
          'Best photos identified for each category/event',
          'Curation recommendations provided',
          'Low-quality photos flagged for review or deletion',
          'Enhancement effectiveness measured and reported'
        ],
        agentHints: {
          preferred: ['synthesizer'],
          alternative: ['personal_assistant', 'retriever']
        },
        automationLevel: 'assisted'
      },
      {
        name: 'Comprehensive Analytics and Reporting',
        type: 'delivery' as TaskType,
        priority: 'high' as TaskPriority,
        description: 'Generate detailed analytics report with insights and recommendations',
        requiredCapabilities: ['analytics', 'data_visualization', 'report_generation', 'insight_extraction'],
        estimatedDuration: 600000, // 10 minutes
        dependencies: ['Quality Assessment and Curation', 'Smart Organization Structure Creation'],
        acceptanceCriteria: [
          'Comprehensive organization report generated',
          'Visual analytics and charts created',
          'Processing statistics and performance metrics included',
          'Actionable recommendations provided',
          'Export formats available (PDF, JSON, CSV)',
          'Future organization suggestions included'
        ],
        agentHints: {
          preferred: ['synthesizer', 'personal_assistant'],
          alternative: ['planner']
        },
        automationLevel: 'automated'
      }
    ];
  }

  /**
   * Execute photo analysis using AI capabilities
   */
  async executePhotoAnalysis(photoPath: string): Promise<PhotoMetadata> {
    log.info('üîç Executing AI photo analysis', LogContext.PROJECT, { photoPath });

    try {
      // Basic metadata extraction
      const basicMetadata = await this.extractBasicMetadata(photoPath);
      
      // AI-powered analysis
      const aiAnalysis = await this.pyVisionBridge.analyzeImage(photoPath, {
        enableObjectDetection: this.config.enableObjectDetection,
        enableFaceDetection: this.config.enableFaceRecognition,
        enableSceneAnalysis: true,
        enableQualityAssessment: true
      });

      // Enhancement suggestions
      const enhancementSuggestions = await this.generateEnhancementSuggestions(
        photoPath, 
        aiAnalysis.qualityMetrics
      );

      const metadata: PhotoMetadata = {
        ...basicMetadata,
        aiAnalysis: {
          objects: aiAnalysis.objects || [],
          faces: aiAnalysis.faces?.map(face => ({
            id: face.id || `face_${Date.now()}`,
            confidence: face.confidence,
            bbox: face.bbox
          })) || [],
          scene: aiAnalysis.scene || 'unknown',
          qualityScore: aiAnalysis.qualityMetrics?.overall || 0.5,
          aestheticScore: aiAnalysis.aestheticScore || 0.5,
          tags: aiAnalysis.tags || []
        },
        enhancementSuggestions
      };

      log.info('‚úÖ Photo analysis completed', LogContext.PROJECT, {
        photoPath,
        objectsDetected: metadata.aiAnalysis.objects.length,
        facesDetected: metadata.aiAnalysis.faces.length,
        qualityScore: metadata.aiAnalysis.qualityScore
      });

      return metadata;

    } catch (error) {
      log.error('‚ùå Photo analysis failed', LogContext.PROJECT, {
        photoPath,
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Generate organization report
   */
  async generateOrganizationReport(
    photos: PhotoMetadata[],
    albums: PhotoAlbum[],
    processingStats: Record<string, any>
  ): Promise<OrganizationReport> {
    log.info('üìä Generating organization report', LogContext.PROJECT, {
      photoCount: photos.length,
      albumCount: albums.length
    });

    const duplicatesFound = photos.filter(p => p.duplicateGroup).length;
    const enhancementsApplied = photos.filter(p => 
      p.enhancementSuggestions && p.enhancementSuggestions.length > 0
    ).length;

    const report: OrganizationReport = {
      summary: {
        totalPhotos: photos.length,
        duplicatesFound,
        duplicatesRemoved: processingStats.duplicatesRemoved || 0,
        albumsCreated: albums.length,
        enhancementsApplied,
        processingTime: processingStats.totalTime || 0
      },
      insights: {
        mostCommonSubjects: this.analyzeMostCommonSubjects(photos),
        timeSpanAnalysis: this.analyzeTimeSpan(photos),
        qualityAnalysis: this.analyzeQuality(photos),
        locationAnalysis: this.analyzeLocations(photos)
      },
      recommendations: this.generateRecommendations(photos, albums)
    };

    log.info('‚úÖ Organization report generated', LogContext.PROJECT, {
      totalPhotos: report.summary.totalPhotos,
      duplicatesFound: report.summary.duplicatesFound,
      albumsCreated: report.summary.albumsCreated
    });

    return report;
  }

  // Helper methods for metadata extraction and analysis
  private async extractBasicMetadata(photoPath: string): Promise<Partial<PhotoMetadata>> {
    // This would integrate with actual file system and EXIF libraries
    return {
      id: `photo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      filename: photoPath.split('/').pop() || 'unknown',
      path: photoPath,
      size: 0, // Would be actual file size
      dimensions: { width: 0, height: 0 }, // Would be actual dimensions
      exifData: {},
      dateCreated: new Date(),
      dateTaken: new Date()
    };
  }

  private async generateEnhancementSuggestions(
    photoPath: string,
    qualityMetrics: any
  ): Promise<PhotoMetadata['enhancementSuggestions']> {
    const suggestions = [];

    if (qualityMetrics?.brightness < 0.4) {
      suggestions.push({
        type: 'brightness' as const,
        confidence: 0.8,
        parameters: { adjustment: 0.2 }
      });
    }

    if (qualityMetrics?.sharpness < 0.6) {
      suggestions.push({
        type: 'sharpness' as const,
        confidence: 0.7,
        parameters: { amount: 0.3 }
      });
    }

    return suggestions;
  }

  private analyzeMostCommonSubjects(photos: PhotoMetadata[]): Array<{ name: string; count: number; }> {
    const subjectCounts = new Map<string, number>();
    
    photos.forEach(photo => {
      photo.aiAnalysis?.objects.forEach(obj => {
        const current = subjectCounts.get(obj.name) || 0;
        subjectCounts.set(obj.name, current + 1);
      });
    });

    return Array.from(subjectCounts.entries())
      .map(([name, count]) => ({ name, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
  }

  private analyzeTimeSpan(photos: PhotoMetadata[]): OrganizationReport['insights']['timeSpanAnalysis'] {
    const dates = photos
      .map(p => p.dateTaken || p.dateCreated)
      .filter(Boolean)
      .sort();

    const yearCounts = new Map<string, number>();
    dates.forEach(date => {
      const year = date.getFullYear().toString();
      yearCounts.set(year, (yearCounts.get(year) || 0) + 1);
    });

    return {
      oldestPhoto: dates[0] || new Date(),
      newestPhoto: dates[dates.length - 1] || new Date(),
      yearDistribution: Object.fromEntries(yearCounts)
    };
  }

  private analyzeQuality(photos: PhotoMetadata[]): OrganizationReport['insights']['qualityAnalysis'] {
    const qualityScores = photos
      .map(p => p.aiAnalysis?.qualityScore || 0.5)
      .filter(score => score > 0);

    const averageQuality = qualityScores.reduce((sum, score) => sum + score, 0) / qualityScores.length;
    const lowQualityCount = qualityScores.filter(score => score < this.config.qualityThreshold).length;
    const enhancementCandidates = photos.filter(p => 
      p.enhancementSuggestions && p.enhancementSuggestions.length > 0
    ).length;

    return {
      averageQuality: Math.round(averageQuality * 100),
      lowQualityCount,
      enhancementCandidates
    };
  }

  private analyzeLocations(photos: PhotoMetadata[]): OrganizationReport['insights']['locationAnalysis'] | undefined {
    const locationCounts = new Map<string, number>();
    
    photos.forEach(photo => {
      if (photo.location?.address) {
        const current = locationCounts.get(photo.location.address) || 0;
        locationCounts.set(photo.location.address, current + 1);
      }
    });

    if (locationCounts.size === 0) return undefined;

    const topLocations = Array.from(locationCounts.entries())
      .map(([location, count]) => ({ location, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    return {
      topLocations,
      geographicSpread: `${locationCounts.size} unique locations detected`
    };
  }

  private generateRecommendations(
    photos: PhotoMetadata[],
    albums: PhotoAlbum[]
  ): OrganizationReport['recommendations'] {
    const recommendations = [];

    // Quality recommendations
    const lowQualityPhotos = photos.filter(p => 
      (p.aiAnalysis?.qualityScore || 0.5) < this.config.qualityThreshold
    );
    
    if (lowQualityPhotos.length > 0) {
      recommendations.push({
        type: 'enhancement' as const,
        priority: 'medium' as const,
        description: `${lowQualityPhotos.length} photos could benefit from AI enhancement`,
        actionItems: [
          'Review low-quality photos for enhancement',
          'Apply AI enhancement to selected photos',
          'Consider deleting very poor quality images'
        ]
      });
    }

    // Organization recommendations
    if (albums.length < Math.floor(photos.length / 100)) {
      recommendations.push({
        type: 'organization' as const,
        priority: 'low' as const,
        description: 'Consider creating more specific albums for better organization',
        actionItems: [
          'Create event-specific albums',
          'Group photos by themes or subjects',
          'Use face recognition to create people-based albums'
        ]
      });
    }

    return recommendations;
  }
}

// Export factory function
export function createPhotoOrganizationTemplateService(
  pyVisionBridge: PyVisionBridge,
  visionResourceManager: VisionResourceManager,
  config?: Partial<PhotoOrganizationConfig>
): PhotoOrganizationTemplateService {
  return new PhotoOrganizationTemplateService(pyVisionBridge, visionResourceManager, config);
}