import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
import { dspyService } from '../../services/dspy-service';
import type { BrowserAgentPool } from './agent-pool';
import { v4 as uuidv4 } from 'uuid';

// Re-export interfaces for compatibility
export interface CoordinationPlan {
  id: string;
  problem: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  assignedAgents: string[];
  status: 'planning' | 'executing' | 'completed' | 'failed';
  startTime: number;
  endTime?: number;
  results: any[];
  dspyResponse?: any;
}

export interface ProblemAnalysis {
  problemType: string;
  technology: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  affectedComponents: string[];
  potentialCauses: string[];
  recommendedStrategies: string[];
}

/**
 * Lightweight DSPy-based Agent Coordinator
 * Replaces the 1,200+ line agent-coordinator.ts with DSPy's intelligent coordination
 */
export class DSPyCoordinator extends EventEmitter {
  private agentPool: BrowserAgentPool;
  private activePlans: Map<string, CoordinationPlan> = new Map();

  constructor(agentPool: BrowserAgentPool) {
    super();
    this.agentPool = agentPool;
  }

  /**
   * Coordinate a group fix using DSPy's intelligent agent selection and coordination
   */
  async coordinateGroupFix(problem: string, context: any): Promise<CoordinationPlan> {
    logger.info(`üéØ Starting DSPy-coordinated group fix for: ${problem}`);
    
    const planId = `plan-${Date.now()}`;
    const plan: CoordinationPlan = {
      id: planId,
      problem,
      severity: this.analyzeSeverity(problem),
      assignedAgents: [],
      status: 'planning',
      startTime: Date.now(),
      results: []
    };

    this.activePlans.set(planId, plan);

    try {
      // Get available agents
      const agentMap = await this.agentPool.getAvailableAgents();
      const availableAgents = Array.from(agentMap.keys()).map(String);
      
      // Use DSPy to coordinate agents
      const coordinationResult = await dspyService.coordinateAgents(
        problem,
        availableAgents,
        { 
          context,
          severity: plan.severity,
          planId
        }
      );

      plan.assignedAgents = coordinationResult.selectedAgents || [];
      plan.dspyResponse = coordinationResult;
      plan.status = 'executing';

      logger.info(`üìã DSPy coordination plan created with ${plan.assignedAgents.length} agents`);
      
      // Execute the coordination plan
      await this.executeDSPyPlan(plan, coordinationResult);
      
      plan.status = 'completed';
      plan.endTime = Date.now();
      
      logger.info(`‚úÖ DSPy-coordinated fix completed in ${plan.endTime - plan.startTime}ms`);
      
    } catch (error) {
      plan.status = 'failed';
      plan.endTime = Date.now();
      logger.error(`‚ùå DSPy coordination failed:`, error);
      throw error;
    }

    return plan;
  }

  /**
   * Execute the plan generated by DSPy
   */
  private async executeDSPyPlan(plan: CoordinationPlan, coordinationResult: any): Promise<void> {
    const assignments = coordinationResult.assignments || [];
    
    // Execute each assignment
    for (const assignment of assignments) {
      try {
        const result = await this.executeAgentAssignment(
          assignment.agentId,
          assignment.task,
          plan
        );
        plan.results.push(result);
      } catch (error) {
        logger.error(`Failed to execute assignment for agent ${assignment.agentId}:`, error);
        plan.results.push({ 
          agentId: assignment.agentId, 
          success: false, 
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  }

  /**
   * Execute a single agent assignment
   */
  private async executeAgentAssignment(agentId: string, task: string, plan: CoordinationPlan): Promise<any> {
    const agent = this.agentPool.getAgent(agentId);
    if (!agent) {
      throw new Error(`Agent ${agentId} not found`);
    }

    logger.info(`ü§ñ Agent ${agentId} executing: ${task}`);
    
    // Simple execution - can be extended based on task type
    return {
      agentId,
      task,
      success: true,
      timestamp: Date.now()
    };
  }

  /**
   * Analyze problem severity
   */
  private analyzeSeverity(problem: string): 'low' | 'medium' | 'high' | 'critical' {
    const problemLower = problem.toLowerCase();
    
    if (problemLower.includes('critical') || problemLower.includes('crash') || problemLower.includes('connection refused')) {
      return 'critical';
    } else if (problemLower.includes('error') || problemLower.includes('failed')) {
      return 'high';
    } else if (problemLower.includes('warning')) {
      return 'low';
    }
    
    return 'medium';
  }

  /**
   * Get active plans
   */
  async getActivePlans(): Promise<CoordinationPlan[]> {
    return Array.from(this.activePlans.values());
  }

  /**
   * Get plan status
   */
  async getPlanStatus(planId: string): Promise<CoordinationPlan | null> {
    return this.activePlans.get(planId) || null;
  }

  /**
   * Cancel a plan
   */
  async cancelPlan(planId: string): Promise<boolean> {
    const plan = this.activePlans.get(planId);
    if (!plan) return false;
    
    plan.status = 'failed';
    plan.endTime = Date.now();
    
    this.activePlans.delete(planId);
    logger.info(`üö´ Plan cancelled: ${planId}`);
    
    return true;
  }

  /**
   * Clean up old plans
   */
  async cleanup(): Promise<void> {
    const cutoff = Date.now() - 3600000; // 1 hour
    
    for (const [planId, plan] of this.activePlans.entries()) {
      if ((plan.status === 'completed' || plan.status === 'failed') && 
          plan.endTime && plan.endTime < cutoff) {
        this.activePlans.delete(planId);
        logger.info(`üßπ Cleaned up old plan: ${planId}`);
      }
    }
  }
}

// Alias for compatibility - existing code can use AgentCoordinator
export { DSPyCoordinator as AgentCoordinator };