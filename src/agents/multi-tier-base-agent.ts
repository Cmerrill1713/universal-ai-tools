/**
 * Multi-Tier Base Agent - No More Mocks!
 * Uses local LLM orchestra for all agent responses
 * Competitive advantage: Real AI at every tier
 */

import { BaseAgent } from './base-agent';
import type { AgentConfig, AgentContext, AgentResponse } from '@/types';
import { LogContext, log } from '@/utils/logger';
import { multiTierLLM } from '@/services/multi-tier-llm-service';
import { kokoroTTS } from '@/services/kokoro-tts-service';

export abstract class MultiTierBaseAgent extends BaseAgent {
  protected preferredTier = 2; // Default to tier 2
  protected voiceEnabled = false;
  protected preferredVoice?: string;

  constructor(config: AgentConfig) {
    super(config);
    this.voiceEnabled = process.env.ENABLE_VOICE_COMMANDS === 'true'; // TODO: Refactor nested ternary
  }

  /**
   * Execute using multi-tier LLM system
   */
  protected async process(context: AgentContext): Promise<AgentResponse> {
    const startTime = Date.now();

    try {
      // Build the prompt for this agent
      const systemPrompt = this.buildSystemPrompt();
      const userPrompt = this.buildUserPrompt(context);
      const fullPrompt = `${systemPrompt}\n\nUser Request: ${userPrompt}`;

      // Get agent-specific context
      const agentContext = {
        agentName: this.config.name,
        capabilities: this.config.capabilities.map((c) => c.name),
        preferredTier: this.preferredTier,
        domain: this.getDomain(),
        ...context,
      };

      // Execute using multi-tier system
      const result = await multiTierLLM.execute(fullPrompt, agentContext);

      // Generate voice response if enabled
      let audioPath: string | undefined;
      if (this.voiceEnabled) {
        try {
          const ttsResponse = await kokoroTTS.speakAgentResponse(
            this.config.name,
            result.response,
            this.preferredVoice
          );
          audioPath = ttsResponse.audioPath;
        } catch (error) {
          log.warn('⚠️ Voice generation failed', LogContext.AGENT, { agentName: this.config.name });
        }
      }

      // Calculate confidence based on tier and execution
      const confidence = this.calculateTierConfidence(
        result.metadata.tier,
        result.metadata.executionTime,
        result.metadata.classification.complexity
      );

      const executionTime = Date.now() - startTime;

      // Create agent response
      const agentResponse = this.createSuccessResponse(
        this.parseAgentResponse(result.response),
        `Response generated by ${this.config.name} using ${result.metadata.modelUsed}`,
        confidence,
        `Multi-tier response using ${result.metadata.modelUsed} (tier ${result.metadata.tier})`
      );

      log.info(`✅ Multi-tier agent execution completed`, LogContext.AGENT, {
        agentName: this.config.name,
        tier: result.metadata.tier,
        model: result.metadata.modelUsed,
        executionTime: `${executionTime}ms`,
        confidence,
      });

      return agentResponse;
    } catch (error) {
      log.error(`❌ Multi-tier agent execution failed`, LogContext.AGENT, {
        agentName: this.config.name,
        error: error instanceof Error ? error.message : String(error),
      });

      // Return error response instead of mock
      return this.createErrorResponse(
        `Agent execution failed: ${error instanceof Error ? error.message : String(error)}`,
        {
          agentName: this.config.name,
          timestamp: new Date().toISOString(),
          executionTime: Date.now() - startTime,
          error: true,
        }
      );
    }
  }

  /**
   * Agent-specific system prompt
   */
  protected abstract buildSystemPrompt(): string;

  /**
   * Build user prompt from context
   */
  protected buildUserPrompt(context: AgentContext): string {
    let prompt = context.userRequest || 'Please provide assistance.';

    // Add context information
    if (context.workingDirectory) {
      prompt += `\n\nWorking Directory: ${context.workingDirectory}`;
    }

    if (context.userId) {
      prompt += `\nUser ID: ${context.userId}`;
    }

    // Add agent-specific context
    const additionalContext = this.getAdditionalContext(context);
    if (additionalContext) {
      prompt += `\n\nAdditional Context: ${additionalContext}`;
    }

    return prompt;
  }

  /**
   * Get domain for tier optimization
   */
  protected getDomain(): string {
    // Determine domain based on agent capabilities
    const capabilities = this.config.capabilities.map((c) => c.name);

    if (capabilities.some((c) => c.includes('code'))) return 'code';
    if (capabilities.some((c) => c.includes('reasoning') || c.includes('analysis')))
      return 'reasoning';
    if (capabilities.some((c) => c.includes('creative'))) return 'creative';

    return 'general';
  }

  /**
   * Get additional context for the agent
   */
  protected getAdditionalContext(context: AgentContext): string | null {
    return null; // Override in specific agents
  }

  /**
   * Parse and structure the LLM response
   */
  protected parseAgentResponse(response: string): unknown {
    // Try to parse as JSON first
    try {
      return JSON.parse(response);
    } catch {
      // Return as structured text response
      return {
        type: 'text',
        content: response,
        summary: this.extractSummary(response),
      };
    }
  }

  /**
   * Extract summary from response
   */
  protected extractSummary(response: string): string {
    const sentences = response.split(/[.!?]+/).filter((s) => s.trim().length > 0);
    return sentences.length > 0 ? `${sentences[0]?.trim()}.` : 'Response generated';
  }

  /**
   * Calculate confidence based on tier performance
   */
  protected calculateTierConfidence(
    tier: number,
    executionTime: number,
    complexity: string
  ): number {
    let baseConfidence = 0.7;

    // Tier-based confidence
    switch (tier) {
      case 1:
        baseConfidence = 0.8;
        break; // Fast, simple tasks
      case 2:
        baseConfidence = 0.85;
        break; // General purpose
      case 3:
        baseConfidence = 0.9;
        break; // Advanced models
      case 4:
        baseConfidence = 0.95;
        break; // Expert models
    }

    // Adjust for execution time (faster = more confident for simple tasks)
    if (complexity === 'simple' && executionTime < 1000) {
      baseConfidence += 0.05;
    } else if (complexity === 'complex' && executionTime > 5000) {
      baseConfidence += 0.03; // Complex tasks taking time = thorough
    }

    return Math.max(0.1, Math.min(1.0, baseConfidence));
  }

  /**
   * Create error response
   */
  protected createErrorResponse(message: string, metadata: unknown): AgentResponse {
    return {
      success: false,
      data: null,
      confidence: 0,
      message,
      reasoning: `Error in ${this.config.name}: ${message}`,
      metadata: {
        ...metadata,
        error: true,
      },
    };
  }

  /**
   * Enable voice responses for this agent
   */
  public enableVoice(voiceId?: string): void {
    this.voiceEnabled = true;
    this.preferredVoice = voiceId;
    log.info(`🎤 Voice enabled for ${this.config.name}`, LogContext.AGENT, { voice: voiceId });
  }

  /**
   * Set preferred tier for this agent
   */
  public setPreferredTier(tier: number): void {
    this.preferredTier = Math.max(1, Math.min(4, tier));
    log.info(`🎯 Preferred tier set for ${this.config.name}`, LogContext.AGENT, {
      tier: this.preferredTier,
    });
  }

  /**
   * Get agent performance metrics
   */
  public getPerformanceMetrics(): {
    averageExecutionTime: number;
    preferredTier: number;
    voiceEnabled: boolean;
    successRate: number;
  } {
    // In a real implementation, track these metrics
    return {
      averageExecutionTime: 2000, // Mock for now
      preferredTier: this.preferredTier,
      voiceEnabled: this.voiceEnabled,
      successRate: 0.95,
    };
  }
}

export default MultiTierBaseAgent;
