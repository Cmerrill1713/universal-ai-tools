import type { NextFunction, Request, Response } from 'express';
import { LogContext, logger } from '../utils/enhanced-logger';
export interface FallbackPerformanceOptions {;
  slowRequestThreshold?: number;
  requestTimeoutMs?: number;
  maxMetricsHistory?: number;
  enableRequestTiming?: boolean;
;
};

interface RequestMetric {;
  url: string;
  method: string;
  statusCode: number;
  responseTime: number;
  timestamp: number;
  userAgent?: string;
  ip?: string;
;
};

interface RateLimitEntry {;
  count: number;
  resetTime: number;
;
};

/**;
 * Lightweight performance middleware that works without Redis;
 * Uses in-memory storage with automatic cleanup;
 */;
export class FallbackPerformanceMiddleware {;
  private requestMetrics: RequestMetric[] = [];
  private rateLimitMap = new Map<string, RateLimitEntry>();
  private options: Required<FallbackPerformanceOptions>;
  private cleanupInterval: NodeJSTimeout;
  private metricsCleanupInterval = 300000; // 5 minutes;
  constructor(options: FallbackPerformanceOptions = {}) {;
    thisoptions = {;
      slowRequestThreshold: optionsslowRequestThreshold ?? 2000;
      requestTimeoutMs: optionsrequestTimeoutMs ?? 5000, // 5 second max as requested;
      maxMetricsHistory: optionsmaxMetricsHistory ?? 5000;
      enableRequestTiming: optionsenableRequestTiming ?? true;
    ;
};
    // Start cleanup interval;
    thiscleanupInterval = setInterval(() => {;
      thiscleanupOldMetrics();
      thiscleanupRateLimits();
    }, thismetricsCleanupInterval);
    loggerinfo('Fallback performance middleware initialized', LogContextPERFORMANCE, {;
      options: thisoptions;
    });
  };

  private cleanupOldMetrics(): void {;
    const oneHourAgo = Datenow() - 3600000;
    const beforeCleanup = thisrequestMetricslength;
    // Remove metrics older than 1 hour;
    thisrequestMetrics = thisrequestMetricsfilter((m) => mtimestamp > oneHourAgo);
    // Keep only the most recent metrics if exceeding max;
    if (thisrequestMetricslength > thisoptionsmaxMetricsHistory) {;
      thisrequestMetrics = thisrequestMetricsslice(-thisoptionsmaxMetricsHistory);
    };
;
    const removed = beforeCleanup - thisrequestMetricslength;
    if (removed > 0) {;
      loggerdebug(`Cleaned up ${removed} old metrics`, LogContextPERFORMANCE);
    };
  };

  private cleanupRateLimits(): void {;
    const now = Datenow();
    let cleaned = 0;
    for (const [key, entry] of thisrateLimitMapentries()) {;
      if (now > entryresetTime) {;
        thisrateLimitMapdelete(key);
        cleaned++;
      };
    };

    if (cleaned > 0) {;
      loggerdebug(`Cleaned up ${cleaned} expired rate limit entries`, LogContextPERFORMANCE);
    };
  };

  /**;
   * Request timing middleware with timeout protection;
   */;
  public requestTimer() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!thisoptionsenableRequestTiming) {;
        return next();
      };

      const startTime = processhrtimebigint();
      // Set requesttimeout;
      const timeout = setTimeout(() => {;
        if (!resheadersSent) {;
          resstatus(408)json({;
            error instanceof Error ? errormessage : String(error) 'Request timeout';
            message: `Request exceeded ${thisoptionsrequestTimeoutMs}ms timeout`;
          });
          loggerwarn('Request timeout', LogContextPERFORMANCE, {;
            method: reqmethod;
            url: reqoriginalUrl || requrl;
            timeout: thisoptionsrequestTimeoutMs;
          });
        };
      }, thisoptionsrequestTimeoutMs);
      // Override resend to capture metrics;
      const originalEnd = resend;
      const self = this;
      resend = function (this: Response, ..args: any[]) {;
        clearTimeout(timeout);
        const endTime = processhrtimebigint();
        const responseTime = Number(endTime - startTime) / 1000000; // Convert to milliseconds;

        // Record metric;
        const metric: RequestMetric = {;
          url: reqoriginalUrl || requrl;
          method: reqmethod;
          statusCode: resstatusCode;
          responseTime;
          timestamp: Datenow();
          userAgent: reqheaders['user-agent'];
          ip: reqip || reqsocketremoteAddress;
        ;
};
        selfrequestMetricspush(metric);
        // Log slow requests;
        if (responseTime > selfoptionsslowRequestThreshold) {;
          loggerwarn('Slow requestdetected', LogContextPERFORMANCE, {;
            ..metric;
            threshold: selfoptionsslowRequestThreshold;
          });
        };

        // Log errors;
        if (resstatusCode >= 400) {;
          loggererror('Request error instanceof Error ? errormessage : String(error)  LogContextPERFORMANCE, metric);';
        };

        // Add performance headers;
        resset('X-Response-Time', `${responseTimetoFixed(2)}ms`);
        resset('X-Performance-Mode', 'fallback');
        return originalEndapply(this, args as any);
      };
      next();
    };
  };

  /**;
   * Simple in-memory rate limiter;
   */;
  public rateLimiter(windowMs = 900000, max = 1000) {;
    return (req: Request, res: Response, next: NextFunction) => {;
      const identifier = reqip || reqsocketremoteAddress || 'unknown';
      const now = Datenow();
      const userRequests = thisrateLimitMapget(identifier);
      if (!userRequests || now > userRequestsresetTime) {;
        thisrateLimitMapset(identifier, {;
          count: 1;
          resetTime: now + windowMs;
        });
        return next();
      };

      if (userRequestscount >= max) {;
        return resstatus(429)json({;
          error instanceof Error ? errormessage : String(error) 'Too many requests';
          retryAfter: Mathceil((userRequestsresetTime - now) / 1000);
        });
      };

      userRequestscount++;
      next();
    };
  };

  /**;
   * Generate a simple performance report;
   */;
  public async generatePerformanceReport(): Promise<string> {;
    const metrics = thisgetMetrics();
    const now = new Date()toISOString();
    return ``;
=== Universal AI Tools Performance Report (Fallback Mode) ===;
Generated: ${now;
};

=== System Status ===;
Mode: ${metricsmodetoUpperCase();
};
Total Metrics Tracked: ${metricstotalMetrics;
};
Active Rate Limit Entries: ${metricsrateLimitEntries;
};

=== Request Statistics (Last 5 Minutes) ===;
Total Requests: ${metricslast5Minutescount;
};
Average Response Time: ${metricslast5MinutesavgResponseTimetoFixed(2)}ms;
P95 Response Time: ${metricslast5Minutesp95ResponseTimetoFixed(2)}ms;
P99 Response Time: ${metricslast5Minutesp99ResponseTimetoFixed(2)}ms;
Error Rate: ${metricslast5MinuteserrorRatetoFixed(2)}%;
=== Request Statistics (Last Hour) ===;
Total Requests: ${metricslast1Hourcount;
};
Average Response Time: ${metricslast1HouravgResponseTimetoFixed(2)}ms;
P95 Response Time: ${metricslast1Hourp95ResponseTimetoFixed(2)}ms;
P99 Response Time: ${metricslast1Hourp99ResponseTimetoFixed(2)}ms;
Error Rate: ${metricslast1HourerrorRatetoFixed(2)}%;
=== Performance Issues ===;
Slow Requests (>${thisoptionsslowRequestThreshold}ms): ${metricsslowRequests;
};

=== Notes ===;
• Running in fallback mode without Redis;
• Limited to in-memory metrics storage;
• Metrics are cleared on server restart;
• Maximum ${thisoptionsmaxMetricsHistory} metrics retained;
• Request timeout protection: ${thisoptionsrequestTimeoutMs}ms;
`;`;
  };

  /**;
   * Get current metrics summary;
   */;
  public getMetrics() {;
    const now = Datenow();
    const last5Minutes = thisrequestMetricsfilter((m) => mtimestamp > now - 300000);
    const last1Hour = thisrequestMetricsfilter((m) => mtimestamp > now - 3600000);
    const calculateStats = (metrics: RequestMetric[]) => {;
      if (metricslength === 0) {;
        return {;
          count: 0;
          avgResponseTime: 0;
          errorRate: 0;
          p95ResponseTime: 0;
          p99ResponseTime: 0;
        ;
};
      };

      const responseTimes = metricsmap((m) => mresponseTime)sort((a, b) => a - b);
      const totalTime = responseTimesreduce((sum, time) => sum + time, 0);
      const errors = metricsfilter((m) => mstatusCode >= 400)length;
      const p95Index = Mathfloor(responseTimeslength * 0.95);
      const p99Index = Mathfloor(responseTimeslength * 0.99);
      return {;
        count: metricslength;
        avgResponseTime: totalTime / metricslength;
        errorRate: (errors / metricslength) * 100;
        p95ResponseTime: responseTimes[p95Index] || 0;
        p99ResponseTime: responseTimes[p99Index] || 0;
      ;
};
    };
    return {;
      mode: 'fallback';
      last5Minutes: calculateStats(last5Minutes);
      last1Hour: calculateStats(last1Hour);
      totalMetrics: thisrequestMetricslength;
      rateLimitEntries: thisrateLimitMapsize;
      slowRequests: thisrequestMetricsfilter(;
        (m) => mresponseTime > thisoptionsslowRequestThreshold;
      )length;
      timestamp: Datenow();
    ;
};
  };

  /**;
   * Cleanup resources;
   */;
  public close(): void {;
    if (thiscleanupInterval) {;
      clearInterval(thiscleanupInterval);
    };
    thisrequestMetrics = [];
    thisrateLimitMapclear();
    loggerinfo('Fallback performance middleware closed', LogContextPERFORMANCE);
  };
};

/**;
 * Factory function to create fallback middleware instance;
 */;
export function createFallbackPerformanceMiddleware(options?: FallbackPerformanceOptions) {;
  return new FallbackPerformanceMiddleware(options);
};
