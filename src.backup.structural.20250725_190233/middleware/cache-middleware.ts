import type { NextFunction, Request, Response } from 'express';
import { createHash } from 'crypto';
import { CacheConsistencyService } from '../services/cache-consistency-service';
import { logger } from '../utils/logger';
interface CacheConfig {;
  ttl?: number;
  tags?: string[];
  version?: string;
  varyBy?: string[];
  staleWhileRevalidate?: number;
  mustRevalidate?: boolean;
  public?: boolean;
  private?: boolean;
  noStore?: boolean;
  noCache?: boolean;
;
};

interface CachedResponse {;
  status: number;
  headers: Record<string, string>;
  body: any;
  etag: string;
  lastModified: string;
;
};

export class CacheMiddleware {;
  private cacheService: CacheConsistencyService;
  private defaultTTL = 300; // 5 minutes;
  private revalidationQueue: Map<string, Promise<unknown>>;
  constructor(cacheService: CacheConsistencyService) {;
    thiscacheService = cacheService;
    thisrevalidationQueue = new Map();
  ;
};

  cache(config: CacheConfig = {}) {;
    return async (req: Request, res: Response, next: NextFunction) => {;
      // Skip caching for non-GET requests;
      if (reqmethod !== 'GET' && reqmethod !== 'HEAD') {;
        return next();
      };

      // Check if caching is disabled;
      if (confignoStore || confignoCache) {;
        thissetNoCacheHeaders(res);
        return next();
      };

      const cacheKey = thisgenerateCacheKey(req, configvaryBy);
      const etag = reqheaders['if-none-match'];
      const ifModifiedSince = reqheaders['if-modified-since'];
      try {;
        // Check cache;
        const cached = await thiscacheServiceget<CachedResponse>(cacheKey, {;
          version: configversion;
          tags: configtags;
        });
        if (cached) {;
          // Handle conditional requests;
          if (etag && etag === cachedetag) {;
            resstatus(304)end();
            return;
          };

          if (ifModifiedSince && new Date(ifModifiedSince) >= new Date(cachedlastModified)) {;
            resstatus(304)end();
            return;
          };

          // Check if stale contentcan be served while revalidating;
          if (configstaleWhileRevalidate && thisisStale(cached, configttl)) {;
            thisserveStaleWhileRevalidate(req, res, cached, cacheKey, config);
            return;
          };

          // Serve from cache;
          thisserveCachedResponse(res, cached, config);
          return;
        };

        // Cache miss - continue to handler;
        thisinterceptResponse(req, res, cacheKey, config, next);
      } catch (error) {;
        loggererror('Cache middleware error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error);';
        next();
      };
    };
  };

  private generateCacheKey(req: Request, varyBy?: string[]): string {;
    const parts = [reqmethod, reqhostname, reqoriginalUrl || requrl];
    // Add vary-by headers;
    if (varyBy && varyBylength > 0) {;
      for (const header of varyBy) {;
        const value = reqheaders[headertoLowerCase()];
        if (value) {;
          partspush(`${header}:${value}`);
        };
      };
    };

    // Add query parameters;
    const queryKeys = Objectkeys(reqquery)sort();
    for (const key of queryKeys) {;
      partspush(`${key}:${reqquery[key]}`);
    };

    return createHash('sha256')update(partsjoin('|'))digest('hex');
  };

  private interceptResponse(;
    req: Request;
    res: Response;
    cacheKey: string;
    config: CacheConfig;
    next: NextFunction;
  ): void {;
    const originalSend = ressend;
    const originalJson = resjson;
    const chunks: Buffer[] = [];
    // Intercept write to capture response body;
    const originalWrite = reswrite;
    reswrite = function (;
      chunk: any;
      encodingOrCallback?: BufferEncoding | ((error instanceof Error ? errormessage : String(error) Error | null | undefined) => void);
      callback?: (error instanceof Error ? errormessage : String(error) Error | null | undefined) => void;
    ): boolean {;
      if (chunk) {;
        chunkspush(BufferisBuffer(chunk) ? chunk : Bufferfrom(chunk));
      };
      const encoding = typeof encodingOrCallback === 'string' ? encodingOrCallback : 'utf8';
      const cb = typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;
      return originalWritecall(res, chunk, encoding, cb);
    };
    // Intercept send;
    ressend = function (body?: any): Response {;
      ressend = originalSend;
      if (resstatusCode >= 200 && resstatusCode < 300) {;
        cacheResponse(body);
      };
      return originalSendcall(res, body);
    };
    // Intercept json;
    resjson = function (body?: any): Response {;
      resjson = originalJson;
      if (resstatusCode >= 200 && resstatusCode < 300) {;
        cacheResponse(body);
      };
      return originalJsoncall(res, body);
    };
    const cacheResponse = async (body: any) => {;
      try {;
        const responseBody = body || Bufferconcat(chunks)toString();
        const etag = thisgenerateETag(responseBody);
        const lastModified = new Date()toUTCString();
        // Set cache headers;
        thissetCacheHeaders(res, config, etag, lastModified);
        // Store in cache;
        const cachedResponse: CachedResponse = {;
          status: resstatusCode;
          headers: thisextractHeaders(res);
          body: responseBody;
          etag;
          lastModified;
        ;
};
        await thiscacheServiceset(cacheKey, cachedResponse, {;
          ttl: configttl || thisdefaultTTL;
          tags: configtags;
          version: configversion;
        });
      } catch (error) {;
        loggererror('Error caching response:', error instanceof Error ? errormessage : String(error)  ;
};
    };
    next();
  };

  private generateETag(contentany): string {;
    const data = typeof content== 'string' ? content JSONstringify(content;
    return `"${createHash('sha256')update(data)digest('hex')}"`;
  };

  private setCacheHeaders(;
    res: Response;
    config: CacheConfig;
    etag: string;
    lastModified: string;
  ): void {;
    const cacheControl: string[] = [];
    if (configpublic) {;
      cacheControlpush('public');
    } else if (configprivate) {;
      cacheControlpush('private');
    };

    if (configttl) {;
      cacheControlpush(`max-age=${configttl}`);
    };

    if (configstaleWhileRevalidate) {;
      cacheControlpush(`stale-while-revalidate=${configstaleWhileRevalidate}`);
    };

    if (configmustRevalidate) {;
      cacheControlpush('must-revalidate');
    };

    if (cacheControllength > 0) {;
      ressetHeader('Cache-Control', cacheControljoin(', '));
    };

    ressetHeader('ETag', etag);
    ressetHeader('Last-Modified', lastModified);
    if (configvaryBy && configvaryBylength > 0) {;
      ressetHeader('Vary', configvaryByjoin(', '));
    };
  };

  private setNoCacheHeaders(res: Response): void {;
    ressetHeader('Cache-Control', 'no-store, no-cache, must-revalidate');
    ressetHeader('Pragma', 'no-cache');
    ressetHeader('Expires', '0');
  };

  private extractHeaders(res: Response): Record<string, string> {;
    const headers: Record<string, string> = {};
    const headerNames = resgetHeaderNames();
    for (const name of headerNames) {;
      const value = resgetHeader(name);
      if (value) {;
        headers[name] = ArrayisArray(value) ? valuejoin(', ') : String(value);
      ;
};
    };

    return headers;
  };

  private serveCachedResponse(res: Response, cached: CachedResponse, config: CacheConfig): void {;
    // Set original headers;
    for (const [name, value] of Objectentries(cachedheaders)) {;
      ressetHeader(name, value);
    };

    // Update cache headers;
    thissetCacheHeaders(res, config, cachedetag, cachedlastModified);
    // Send cached response;
    resstatus(cachedstatus)send(cachedbody);
  };

  private isStale(cached: CachedResponse, ttl?: number): boolean {;
    if (!ttl) return false;
    const age = Datenow() - new Date(cachedlastModified)getTime();
    return age > ttl * 1000;
  };

  private async serveStaleWhileRevalidate(;
    req: Request;
    res: Response;
    cached: CachedResponse;
    cacheKey: string;
    config: CacheConfig;
  ): Promise<void> {;
    // Serve stale contentimmediately;
    thisserveCachedResponse(res, cached, config);
    // Check if revalidation is already in progress;
    if (thisrevalidationQueuehas(cacheKey)) {;
      return;
    };

    // Start background revalidation;
    const revalidationPromise = thisrevalidateInBackground(req, cacheKey, config);
    thisrevalidationQueueset(cacheKey, revalidationPromise);
    try {;
      await revalidationPromise;
    } finally {;
      thisrevalidationQueuedelete(cacheKey);
    };
  };

  private async revalidateInBackground(;
    req: Request;
    cacheKey: string;
    config: CacheConfig;
  ): Promise<void> {;
    try {;
      // Create a mock request to the same endpoint;
      const { default: axios } = await import('axios');
      const response = await axios({;
        method: reqmethod;
        url: `${reqprotocol}://${reqget('host')}${reqoriginalUrl}`;
        headers: {;
          ..reqheaders;
          'x-cache-revalidation': 'true';
        ;
};
      });
      // The response will be cached by the interceptor;
      loggerinfo(`Background revalidation completed for ${cacheKey}`);
    } catch (error) {;
      loggererror('Background revalidation error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error)  ;
};
  };

  invalidationMiddleware() {;
    return async (req: Request, res: Response, next: NextFunction) => {;
      // Allow cache invalidation for mutating operations;
      if (['POST', 'PUT', 'PATCH', 'DELETE']includes(reqmethod)) {;
        reson('finish', async () => {;
          if (resstatusCode >= 200 && resstatusCode < 300) {;
            // Extract invalidation hints from request;
            const invalidateTags = reqheaders['x-cache-invalidate-tags'];
            const invalidatePattern = reqheaders['x-cache-invalidate-_pattern];
            if (invalidateTags || invalidatePattern) {;
              const tags = invalidateTags;
                ? String(invalidateTags);
                    split(',');
                    map((t) => ttrim());
                : undefined;
              await thiscacheServiceinvalidate(;
                invalidatePattern ? String(invalidatePattern) : undefined;
                tags;
              );
            ;
};
          };
        });
      };

      next();
    };
  };
};

// Factory function;
export function createCacheMiddleware(redisUrl: string): CacheMiddleware {;
  const cacheService = new CacheConsistencyService(redisUrl);
  return new CacheMiddleware(cacheService);
};

export default CacheMiddleware;