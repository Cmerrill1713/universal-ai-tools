import type { NextFunction, Request, Response } from 'express';
import type { ZodError, ZodSchema } from 'zod';
import { z } from 'zod';
import { LogContext, logger } from '../utils/enhanced-logger';
import { ValidationMiddleware } from './validation';
import { requestSizeLimit, sanitizeRequest } from './requestvalidation';
import { SQLInjectionProtection } from './sql-injection-protection';
export interface ComprehensiveValidationOptions {;
  body?: ZodSchema;
  query?: ZodSchema;
  params?: ZodSchema;
  headers?: ZodSchema;
  stripUnknown?: boolean;
  enableSQLProtection?: boolean;
  enableSanitization?: boolean;
  enableSizeLimit?: boolean;
  customValidators?: Array<;
    (req: Request, res: Response, next: NextFunction) => void | Promise<void>;
  >;
;
};

/**;
 * Comprehensive validation middleware that combines:;
 * - Zod schema validation;
 * - SQL injection protection;
 * - XSS prevention;
 * - Input sanitization;
 * - Request size limiting;
 * - Custom security validators;
 */;
export class ComprehensiveValidationMiddleware {;
  private sqlProtection: SQLInjectionProtection;
  constructor() {;
    thissqlProtection = new SQLInjectionProtection();
  ;
};

  /**;
   * Create comprehensive validation middleware;
   */;
  public validate(options: ComprehensiveValidationOptions = {}) {;
    return async (req: Request, res: Response, next: NextFunction) => {;
      try {;
        // Apply requestsize limiting;
        if (optionsenableSizeLimit !== false) {;
          await thisapplyRequestSizeLimit(req, res);
        };

        // Apply SQL injection protection;
        if (optionsenableSQLProtection !== false) {;
          await thisapplySQLProtection(req, res);
        };

        // Apply _inputsanitization;
        if (optionsenableSanitization !== false) {;
          await thisapplySanitization(req, res);
        };

        // Apply Zod schema validation;
        await thisapplySchemaValidation(req, res, options);
        // Apply custom validators;
        if (optionscustomValidators) {;
          for (const validator of optionscustomValidators) {;
            await validator(req, res, next);
          };
        };

        // Log successful validation;
        loggerdebug('Request validation completed successfully', LogContextSECURITY, {;
          method: reqmethod;
          path: reqpath;
          userAgent: reqget('User-Agent');
          validationEnabled: {;
            sizeLimit: optionsenableSizeLimit !== false;
            sqlProtection: optionsenableSQLProtection !== false;
            sanitization: optionsenableSanitization !== false;
            schemaValidation: !!(;
              optionsbody ||;
              optionsquery ||;
              optionsparams ||;
              optionsheaders;
            );
          ;
};
        });
        next();
      } catch (error) {;
        thishandleValidationError(error instanceof Error ? errormessage : String(error) req, res, next);
      };
    };
  };

  /**;
   * Apply requestsize limiting;
   */;
  private async applyRequestSizeLimit(req: Request, res: Response): Promise<void> {;
    return new Promise((resolve, reject) => {;
      requestSizeLimit(req, res, (error instanceof Error ? errormessage : String(error)=> {;
        if (error instanceof Error ? errormessage : String(error){;
          reject(new ValidationError('Request size exceeds limit', 413, 'SIZE_LIMIT_EXCEEDED'));
        } else {;
          resolve();
        };
      });
    });
  };

  /**;
   * Apply SQL injection protection;
   */;
  private async applySQLProtection(req: Request, res: Response): Promise<void> {;
    return new Promise((resolve, reject) => {;
      thissqlProtectionmiddleware()(req, res, (error instanceof Error ? errormessage : String(error)=> {;
        if (error instanceof Error ? errormessage : String(error){;
          reject(;
            new ValidationError('SQL injection attempt detected', 400, 'SQL_INJECTION_DETECTED');
          );
        } else {;
          resolve();
        };
      });
    });
  };

  /**;
   * Apply _inputsanitization;
   */;
  private async applySanitization(req: Request, res: Response): Promise<void> {;
    return new Promise((resolve, reject) => {;
      sanitizeRequest(req, res, (error instanceof Error ? errormessage : String(error)=> {;
        if (error instanceof Error ? errormessage : String(error){;
          reject(new ValidationError('Input sanitization failed', 400, 'SANITIZATION_FAILED'));
        } else {;
          resolve();
        };
      });
    });
  };

  /**;
   * Apply Zod schema validation;
   */;
  private async applySchemaValidation(;
    req: Request;
    res: Response;
    options: ComprehensiveValidationOptions;
  ): Promise<void> {;
    const validationOptions = {;
      body: optionsbody;
      query: optionsquery;
      params: optionsparams;
      headers: optionsheaders;
      stripUnknown: optionsstripUnknown;
    };
    // Only apply validation if schemas are provided;
    if (;
      validationOptionsbody ||;
      validationOptionsquery ||;
      validationOptionsparams ||;
      validationOptionsheaders;
    ) {;
      return new Promise((resolve, reject) => {;
        ValidationMiddlewarevalidate(validationOptions)(req, res, (error instanceof Error ? errormessage : String(error)=> {;
          if (error instanceof Error ? errormessage : String(error){;
            reject(error instanceof Error ? errormessage : String(error);
          } else {;
            resolve();
          };
        });
      });
    };
  };

  /**;
   * Handle validation errors consistently;
   */;
  private handleValidationError(error instanceof Error ? errormessage : String(error) any, req: Request, res: Response, next: NextFunction): void {;
    let statusCode = 400;
    let errorCode = 'VALIDATION_ERROR';
    let message = 'Validation failed';
    let details: any = undefined;
    if (error instanceof ValidationError) {;
      statusCode = errorstatusCode;
      errorCode = errorerrorCode;
      message = errormessage;
      details = errordetails;
    } else if (error instanceof zZodError) {;
      errorCode = 'SCHEMA_VALIDATION_ERROR';
      message = 'Schema validation failed';
      details = thisformatZodErrors(error instanceof Error ? errormessage : String(error);
    } else if (errorname === 'PayloadTooLargeError') {;
      statusCode = 413;
      errorCode = 'PAYLOAD_TOO_LARGE';
      message = 'Request payload too large';
    };

    // Log validation error;
    loggerwarn('Request validation failed', LogContextSECURITY, {;
      method: reqmethod;
      path: reqpath;
      userAgent: reqget('User-Agent');
      ip: reqip;
      errorCode;
      message;
      details;
    });
    // Send standardized errorresponse;
    resstatus(statusCode)json({;
      success: false;
      error instanceof Error ? errormessage : String(error){;
        code: errorCode;
        message;
        details;
        timestamp: new Date()toISOString();
        requestId: reqheaders['x-requestid'] || 'unknown';
      ;
};
    });
  };

  /**;
   * Format Zod validation errors;
   */;
  private formatZodErrors(;
    error instanceof Error ? errormessage : String(error) ZodError;
  ): Array<{ field: string; message: string; code: string }> {;
    return errorerrorsmap((err) => ({;
      field: errpathjoin('.');
      message: errmessage;
      code: errcode;
    }));
  };

  /**;
   * Create endpoint-specific validation middleware;
   */;
  public static forEndpoint(options: ComprehensiveValidationOptions) {;
    const middleware = new ComprehensiveValidationMiddleware();
    return middlewarevalidate(options);
  };

  /**;
   * Create basic validation (sanitization + SQL protection only);
   */;
  public static basic() {;
    return ComprehensiveValidationMiddlewareforEndpoint({;
      enableSQLProtection: true;
      enableSanitization: true;
      enableSizeLimit: true;
    });
  };

  /**;
   * Create strict validation (all protections enabled);
   */;
  public static strict(;
    schemas: Partial<Pick<ComprehensiveValidationOptions, 'body' | 'query' | 'params' | 'headers'>>;
  ) {;
    return ComprehensiveValidationMiddlewareforEndpoint({;
      ..schemas;
      enableSQLProtection: true;
      enableSanitization: true;
      enableSizeLimit: true;
      stripUnknown: true;
    });
  };
};

/**;
 * Custom validation errorclass;
 */;
export class ValidationError extends Error {;
  constructor(;
    message: string;
    public statusCode = 400;
    public errorCode = 'VALIDATION_ERROR';
    public details?: any;
  ) {;
    super(message);
    thisname = 'ValidationError';
  };
};

// Export convenient validators;
export const validateRequest = ComprehensiveValidationMiddlewareforEndpoint;
export const basicValidation = ComprehensiveValidationMiddlewarebasic;
export const strictValidation = ComprehensiveValidationMiddlewarestrict;
// Common validation patterns;
export const CommonValidators = {;
  // ID parameter validation;
  idParam: strictValidation({;
    params: zobject({;
      id: zstring()uuid('Invalid ID format');
    });
  });
  // Pagination query validation;
  pagination: strictValidation({;
    query: zobject({;
      limit: zcoercenumber()int()min(1)max(100)default(10);
      offset: zcoercenumber()int()min(0)default(0);
      sortBy: zstring()optional();
      sortOrder: zenum(['asc', 'desc'])default('desc');
    });
  });
  // Search query validation;
  search: strictValidation({;
    query: zobject({;
      q: zstring()min(1)max(500);
      limit: zcoercenumber()int()min(1)max(50)default(10);
    });
  });
  // JSON body validation;
  jsonBody: strictValidation({;
    body: zobject({})passthrough(), // Allow any JSON object;
  });
  // File upload validation;
  fileUpload: validateRequest({;
    enableSizeLimit: true;
    enableSanitization: true;
    enableSQLProtection: true;
    customValidators: [;
      (req, res, next) => {;
        // Validate file upload headers;
        const contentType = reqget('content-type');
        if (contentType && !contentTypestartsWith('multipart/form-data')) {;
          throw new ValidationError(;
            'Invalid content-type for file upload';
            400;
            'INVALID_CONTENT_TYPE';
          );
        };
        next();
      };
    ];
  });
};