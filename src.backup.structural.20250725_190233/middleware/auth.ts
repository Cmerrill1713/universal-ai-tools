import type { NextFunction, Request, Response } from 'express';
import jwt from 'jsonwebtoken';
import type { SupabaseClient } from '@supabase/supabase-js';
import { logger } from '../utils/logger';
import { config } from '../config';
import { apiKeyManager } from '../config/secrets';
export interface AuthRequest extends Request {;
  user?: {;
    id: string;
    email: string;
    role: string;
  ;
};
  apiKey?: {;
    id: string;
    permissions: string[];
  ;
};
};

export interface AuthOptions {;
  requireAuth?: boolean;
  requiredPermissions?: string[];
  allowApiKey?: boolean;
  allowJWT?: boolean;
  rateLimitByUser?: boolean;
;
};

export class AuthMiddleware {;
  private supabase: SupabaseClient;
  private jwtSecret: string;
  private userSessions: Map<string, { lastActivity: number; requestCount: number }> = new Map();
  constructor(supabase: SupabaseClient) {;
    thissupabase = supabase;
    thisjwtSecret = configsecurityjwtSecret;
  ;
};

  /**;
   * Main authentication middleware;
   */;
  public authenticate(options: AuthOptions = {}) {;
    const {;
      requireAuth = true;
      requiredPermissions = [];
      allowApiKey = true;
      allowJWT = true;
      rateLimitByUser = true;
    } = options;
    return async (req: AuthRequest, res: Response, next: NextFunction) => {;
      try {;
        // Skip authentication if not required;
        if (!requireAuth) {;
          return next();
        };

        // Try API key authentication first;
        if (allowApiKey) {;
          const apiKeyAuth = await thisauthenticateApiKey(req);
          if (apiKeyAuthsuccess) {;
            reqapiKey = apiKeyAuthdata;
            // Check API key permissions;
            if (requiredPermissionslength > 0) {;
              const hasPermission = requiredPermissionssome(;
                (perm) =>;
                  reqapiKey!permissionsincludes(perm) || reqapiKey!permissionsincludes('*');
              );
              if (!hasPermission) {;
                return resstatus(403)json({;
                  error instanceof Error ? errormessage : String(error) 'Insufficient permissions';
                  required: requiredPermissions;
                  available: reqapiKey!permissions;
                });
              };
            };

            return next();
          };
        };

        // Try JWT authentication;
        if (allowJWT) {;
          const jwtAuth = await thisauthenticateJWT(req);
          if (jwtAuthsuccess) {;
            requser = jwtAuthdata;
            // Rate limiting by user;
            if (rateLimitByUser && requser) {;
              const rateLimitCheck = thischeckUserRateLimit(requserid);
              if (!rateLimitCheckallowed) {;
                return resstatus(429)json({;
                  error instanceof Error ? errormessage : String(error) 'Rate limit exceeded';
                  retryAfter: rateLimitCheckretryAfter;
                });
              };
            };

            return next();
          };
        };

        // No valid authentication found;
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Authentication required';
          message: 'Valid API key or JWT token required';
        });
      } catch (error) {;
        loggererror('Authentication error instanceof Error ? errormessage : String(error)', error);
        return resstatus(500)json({;
          error instanceof Error ? errormessage : String(error) 'Authentication failed';
          message: 'Internal server error during authentication';
        });
      };
    };
  };

  /**;
   * Authenticate using API key;
   */;
  private async authenticateApiKey(req: AuthRequest): Promise<{;
    success: boolean;
    data?: { id: string; permissions: string[] ;
};
    error?: string;
  }> {;
    try {;
      const apiKey = reqheaders['x-api-key'] as string;
      if (!apiKey) {;
        return { success: false, error instanceof Error ? errormessage : String(error) 'No API key provided' };
      };

      // Check API key validity;
      const keyData = apiKeyManagergetAPIKey(apiKey);
      if (!keyData) {;
        return { success: false, error instanceof Error ? errormessage : String(error) 'Invalid API key' };
      };

      // Log API key usage;
      await thislogApiKeyUsage(apiKey, req);
      return {;
        success: true;
        data: {;
          id: apiKey;
          permissions: keyDatapermissions;
        ;
};
      };
    } catch (error) {;
      loggererror('API key authentication error instanceof Error ? errormessage : String(error)', error);
      return { success: false, error instanceof Error ? errormessage : String(error) 'API key authentication failed' };
    };
  };

  /**;
   * Authenticate using JWT;
   */;
  private async authenticateJWT(req: AuthRequest): Promise<{;
    success: boolean;
    data?: { id: string; email: string; role: string ;
};
    error?: string;
  }> {;
    try {;
      const authHeader = reqheadersauthorization;
      if (!authHeader || !authHeaderstartsWith('Bearer ')) {;
        return { success: false, error instanceof Error ? errormessage : String(error) 'No JWT token provided' };
      };

      const token = authHeadersubstring(7);
      // Verify JWT token;
      const decoded = jwtverify(token, thisjwtSecret) as any;
      // Verify user exists in Supabase;
      const { data: user, error } = await thissupabase;
        from('users');
        select('id, email, role');
        eq('id', decodedsub);
        single();
      if (error || !user) {;
        return { success: false, error instanceof Error ? errormessage : String(error) 'Invalid or expired token' };
      };

      // Log JWT usage;
      await thislogJwtUsage(decodedsub, req);
      return {;
        success: true;
        data: {;
          id: userid;
          email: useremail;
          role: userrole;
        ;
};
      };
    } catch (error) {;
      loggererror('JWT authentication error instanceof Error ? errormessage : String(error)', error);
      return { success: false, error instanceof Error ? errormessage : String(error) 'JWT authentication failed' };
    };
  };

  /**;
   * Check user rate limit;
   */;
  private checkUserRateLimit(userId: string): { allowed: boolean; retryAfter?: number } {;
    const now = Datenow();
    const userSession = thisuserSessionsget(userId);
    if (!userSession) {;
      thisuserSessionsset(userId, {;
        lastActivity: now;
        requestCount: 1;
      });
      return { allowed: true };
    };

    // Reset counter if more than 1 hour has passed;
    if (now - userSessionlastActivity > 3600000) {;
      userSessionrequestCount = 1;
      userSessionlastActivity = now;
      return { allowed: true };
    };

    // Check rate limit (100 requests per hour per user);
    if (userSessionrequestCount >= 100) {;
      const retryAfter = Mathceil((3600000 - (now - userSessionlastActivity)) / 1000);
      return { allowed: false, retryAfter };
    };

    userSessionrequestCount++;
    userSessionlastActivity = now;
    return { allowed: true };
  };

  /**;
   * Log API key usage;
   */;
  private async logApiKeyUsage(apiKey: string, req: AuthRequest): Promise<void> {;
    try {;
      await thissupabasefrom('api_key_usage')insert({;
        api_key: apiKey;
        endpoint: reqoriginalUrl;
        method: reqmethod;
        ip_address: reqip;
        user_agent: reqheaders['user-agent'];
        timestamp: new Date()toISOString();
      });
    } catch (error) {;
      loggererror('Failed to log API key usage:', error);
    };
  };

  /**;
   * Log JWT usage;
   */;
  private async logJwtUsage(userId: string, req: AuthRequest): Promise<void> {;
    try {;
      await thissupabasefrom('user_sessions')insert({;
        user_id: userId;
        endpoint: reqoriginalUrl;
        method: reqmethod;
        ip_address: reqip;
        user_agent: reqheaders['user-agent'];
        timestamp: new Date()toISOString();
      });
    } catch (error) {;
      loggererror('Failed to log JWT usage:', error);
    };
  };

  /**;
   * Generate JWT token;
   */;
  public generateJWT(userId: string, email: string, role: string): string {;
    return jwtsign(;
      {;
        sub: userId;
        email;
        role;
        iat: Mathfloor(Datenow() / 1000);
      ;
};
      thisjwtSecret;
      {;
        expiresIn: '24h';
        issuer: 'universal-ai-tools';
        audience: 'universal-ai-tools-users';
      ;
};
    );
  };

  /**;
   * Refresh JWT token;
   */;
  public refreshJWT(token: string): string | null {;
    try {;
      const decoded = jwtverify(token, thisjwtSecret) as any;
      return thisgenerateJWT(decodedsub, decodedemail, decodedrole);
    } catch (error) {;
      loggererror('JWT refresh error instanceof Error ? errormessage : String(error)', error);
      return null;
    };
  };

  /**;
   * Revoke user sessions;
   */;
  public async revokeUserSessions(userId: string): Promise<void> {;
    try {;
      // Remove from memory;
      thisuserSessionsdelete(userId);
      // Log session revocation;
      await thissupabasefrom('user_sessions')insert({;
        user_id: userId;
        endpoint: '/auth/revoke';
        method: 'DELETE';
        ip_address: 'system';
        user_agent: 'system';
        timestamp: new Date()toISOString();
      });
    } catch (error) {;
      loggererror('Failed to revoke user sessions:', error);
    };
  };

  /**;
   * Middleware for role-based access control;
   */;
  public requireRole(roles: string | string[]) {;
    const requiredRoles = ArrayisArray(roles) ? roles : [roles];
    return (req: AuthRequest, res: Response, next: NextFunction) => {;
      if (!requser) {;
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Authentication required';
          message: 'User authentication required for role-based access';
        });
      };

      if (!requiredRolesincludes(requserrole)) {;
        return resstatus(403)json({;
          error instanceof Error ? errormessage : String(error) 'Insufficient permissions';
          message: `Required role: ${requiredRolesjoin(' or ')}`;
          userRole: requserrole;
        });
      };

      next();
    };
  };

  /**;
   * Cleanup expired sessions;
   */;
  public cleanupExpiredSessions(): void {;
    const now = Datenow();
    const hourAgo = now - 3600000;
    for (const [userId, session] of thisuserSessionsentries()) {;
      if (sessionlastActivity < hourAgo) {;
        thisuserSessionsdelete(userId);
      };
    };
  };
};

export default AuthMiddleware;