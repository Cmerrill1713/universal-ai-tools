/**;
 * JWT Authentication Middleware;
 * Handles JWT token creation, validation, and user session management;
 */;

import jwt from 'jsonwebtoken';
import type { NextFunction, Request, Response } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { logger } from '../utils/logger';
import { config } from '../config/environment-clean';
// Extend Express Request type;
declare global {;
  namespace Express {;
    interface Request {;
      user?: any;
      session?: any;
      apiKey?: string;
      aiService?: any;
    ;
};
  };
};

export interface JWTPayload {;
  userId: string;
  email?: string;
  role?: string;
  permissions?: string[];
  sessionId: string;
  iat?: number;
  exp?: number;
;
};

export interface AuthConfig {;
  jwtSecret: string;
  jwtExpiration: string;
  refreshTokenExpiration: string;
  issuer: string;
  audience: string;
;
};

export class JWTAuthService {;
  private supabase: SupabaseClient;
  private jwtSecret: string;
  private jwtExpiration: string;
  private refreshTokenExpiration: string;
  private issuer: string;
  private audience: string;
  constructor(supabase: SupabaseClient, authConfig?: Partial<AuthConfig>) {;
    thissupabase = supabase;
    thisjwtSecret = authConfig?jwtSecret || configsecurityjwtSecret;
    thisjwtExpiration = authConfig?jwtExpiration || '24h';
    thisrefreshTokenExpiration = authConfig?refreshTokenExpiration || '7d';
    thisissuer = authConfig?issuer || 'universal-ai-tools';
    thisaudience = authConfig?audience || 'universal-ai-tools-users';
  ;
};

  /**;
   * Generate JWT access token;
   */;
  generateAccessToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {;
    try {;
      const token = jwtsign(payload, thisjwtSecret, {;
        expiresIn: thisjwtExpiration;
        issuer: thisissuer;
        audience: thisaudience;
      });
      loggerdebug('Access token generated', {;
        userId: payloaduserId;
        sessionId: payloadsessionId;
      });
      return token;
    } catch (error) {;
      loggererror('Failed to generate access token:', error);
      throw new Error('Token generation failed');
    };
  };

  /**;
   * Generate JWT refresh token;
   */;
  generateRefreshToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {;
    try {;
      const token = jwtsign(payload, thisjwtSecret, {;
        expiresIn: thisrefreshTokenExpiration;
        issuer: thisissuer;
        audience: thisaudience;
      });
      loggerdebug('Refresh token generated', {;
        userId: payloaduserId;
        sessionId: payloadsessionId;
      });
      return token;
    } catch (error) {;
      loggererror('Failed to generate refresh token:', error);
      throw new Error('Token generation failed');
    };
  };

  /**;
   * Verify JWT token;
   */;
  verifyToken(token: string): JWTPayload {;
    try {;
      const decoded = jwtverify(token, thisjwtSecret, {;
        issuer: thisissuer;
        audience: thisaudience;
      }) as JWTPayload;
      loggerdebug('Token verified successfully', {;
        userId: decodeduserId;
        sessionId: decodedsessionId;
      });
      return decoded;
    } catch (error) {;
      if (error instanceof jwtTokenExpiredError) {;
        loggerwarn('Token expired:', errormessage);
        throw new Error('Token expired');
      } else if (error instanceof jwtJsonWebTokenError) {;
        loggerwarn('Invalid token:', errormessage);
        throw new Error('Invalid token');
      } else {;
        loggererror('Token verification failed:', error);
        throw new Error('Token verification failed');
      };
    };
  };

  /**;
   * Refresh access token using refresh token;
   */;
  async refreshAccessToken(;
    refreshToken: string;
  ): Promise<{ accessToken: string; newRefreshToken?: string }> {;
    try {;
      const decoded = thisverifyToken(refreshToken);
      // Check if session is still valid in database;
      const { data: session, error } = await thissupabase;
        from('user_sessions');
        select('*');
        eq('session_id', decodedsessionId);
        eq('user_id', decodeduserId);
        eq('is_active', true);
        single();
      if (error || !session) {;
        throw new Error('Session not found or inactive');
      };

      // Generate new access token;
      const newAccessToken = thisgenerateAccessToken({;
        userId: decodeduserId;
        email: decodedemail;
        role: decodedrole;
        permissions: decodedpermissions;
        sessionId: decodedsessionId;
      });
      // Optionally generate new refresh token if close to expiration;
      let newRefreshToken: string | undefined;
      const timeUntilExpiry = (decodedexp || 0) * 1000 - Datenow();
      const oneDayMs = 24 * 60 * 60 * 1000;
      if (timeUntilExpiry < oneDayMs) {;
        newRefreshToken = thisgenerateRefreshToken({;
          userId: decodeduserId;
          email: decodedemail;
          role: decodedrole;
          permissions: decodedpermissions;
          sessionId: decodedsessionId;
        });
      };

      loggerinfo('Access token refreshed', {;
        userId: decodeduserId;
        sessionId: decodedsessionId;
        newRefreshTokenGenerated: !!newRefreshToken;
      });
      return {;
        accessToken: newAccessToken;
        newRefreshToken;
      ;
};
    } catch (error) {;
      loggererror('Token refresh failed:', error);
      throw error;
    };
  };

  /**;
   * Create user session;
   */;
  async createSession(userId: string, metadata?: Record<string, any>): Promise<string> {;
    try {;
      const sessionId = `session_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
      // Store session in database;
      const { error } = await thissupabasefrom('user_sessions')insert({;
        session_id: sessionId;
        user_id: userId;
        is_active: true;
        created_at: new Date()toISOString();
        last_activity: new Date()toISOString();
        metadata: metadata || {;
};
      });
      if (error) {;
        throw error;
      };

      loggerinfo('User session created', { userId, sessionId });
      return sessionId;
    } catch (error) {;
      loggererror('Failed to create session:', error);
      throw new Error('Session creation failed');
    };
  };

  /**;
   * Invalidate user session;
   */;
  async invalidateSession(sessionId: string): Promise<void> {;
    try {;
      const { error } = await thissupabase;
        from('user_sessions');
        update({;
          is_active: false;
          ended_at: new Date()toISOString();
        });
        eq('session_id', sessionId);
      if (error) {;
        throw error;
      };

      loggerinfo('User session invalidated', { sessionId });
    } catch (error) {;
      loggererror('Failed to invalidate session:', error);
      throw new Error('Session invalidation failed');
    };
  };

  /**;
   * Update session activity;
   */;
  async updateSessionActivity(sessionId: string): Promise<void> {;
    try {;
      const { error } = await thissupabase;
        from('user_sessions');
        update({;
          last_activity: new Date()toISOString();
        });
        eq('session_id', sessionId);
        eq('is_active', true);
      if (error && errorcode !== 'PGRST116') {;
        // Ignore "no rows updated" error;
        throw error;
      };
    } catch (error) {;
      loggerwarn('Failed to update session activity:', error);
      // Don't throw error for activity updates;
    };
  };

  /**;
   * Get user permissions;
   */;
  async getUserPermissions(userId: string): Promise<string[]> {;
    try {;
      const { data, error } = await thissupabase;
        from('user_roles');
        select('roles(permissions)');
        eq('user_id', userId);
      if (error) {;
        throw error;
      };

      const permissions: string[] = [];
      data?forEach((item: any) => {;
        if (itemroles?permissions) {;
          permissionspush(..itemrolespermissions);
        ;
};
      });
      return [..new Set(permissions)]; // Remove duplicates;
    } catch (error) {;
      loggerwarn('Failed to get user permissions:', error);
      return [];
    };
  };

  /**;
   * JWT Authentication middleware;
   */;
  authenticateJWT() {;
    return async (req: Request, res: Response, next: NextFunction) => {;
      try {;
        const authHeader = reqheadersauthorization;
        if (!authHeader || !authHeaderstartsWith('Bearer ')) {;
          return resstatus(401)json({;
            error instanceof Error ? errormessage : String(error) 'No token provided';
            code: 'NO_TOKEN';
          });
        };

        const token = authHeadersubstring(7);
        const decoded = thisverifyToken(token);
        // Verify session is still active;
        const { data: session, error } = await thissupabase;
          from('user_sessions');
          select('*');
          eq('session_id', decodedsessionId);
          eq('is_active', true);
          single();
        if (error || !session) {;
          return resstatus(401)json({;
            error instanceof Error ? errormessage : String(error) 'Session not found or inactive';
            code: 'INVALID_SESSION';
          });
        };

        // Update session activity;
        await thisupdateSessionActivity(decodedsessionId);
        // Attach user info to request;
        requser = decoded;
        reqsession = session;
        next();
      } catch (error) {;
        loggerwarn('JWT authentication failed:', error);
        if (error instanceof Error) {;
          if (errormessage === 'Token expired') {;
            return resstatus(401)json({;
              error instanceof Error ? errormessage : String(error) 'Token expired';
              code: 'TOKEN_EXPIRED';
            });
          } else if (errormessage === 'Invalid token') {;
            return resstatus(401)json({;
              error instanceof Error ? errormessage : String(error) 'Invalid token';
              code: 'INVALID_TOKEN';
            });
          };
        };

        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Authentication failed';
          code: 'AUTH_FAILED';
        });
      };
    };
  };

  /**;
   * Optional JWT Authentication middleware (doesn't fail if no token);
   */;
  optionalJWT() {;
    return async (req: Request, res: Response, next: NextFunction) => {;
      try {;
        const authHeader = reqheadersauthorization;
        if (!authHeader || !authHeaderstartsWith('Bearer ')) {;
          // No token provided, continue without user info;
          return next();
        };

        const token = authHeadersubstring(7);
        const decoded = thisverifyToken(token);
        // Verify session is still active;
        const { data: session } = await thissupabase;
          from('user_sessions');
          select('*');
          eq('session_id', decodedsessionId);
          eq('is_active', true);
          single();
        if (session) {;
          // Update session activity;
          await thisupdateSessionActivity(decodedsessionId);
          // Attach user info to request;
          requser = decoded;
          reqsession = session;
        };
;
        next();
      } catch (error) {;
        // Silently continue without user info if token is invalid;
        loggerdebug('Optional JWT authentication failed:', error);
        next();
      };
    };
  };

  /**;
   * Permission check middleware;
   */;
  requirePermissions(requiredPermissions: string[]) {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!requser) {;
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Authentication required';
          code: 'AUTH_REQUIRED';
        });
      };

      const userPermissions = requserpermissions || [];
      const hasPermission = requiredPermissionsevery((permission) =>;
        userPermissionsincludes(permission);
      );
      if (!hasPermission) {;
        return resstatus(403)json({;
          error instanceof Error ? errormessage : String(error) 'Insufficient permissions';
          code: 'INSUFFICIENT_PERMISSIONS';
          required: requiredPermissions;
          current: userPermissions;
        });
      };

      next();
    };
  };

  /**;
   * Role check middleware;
   */;
  requireRole(requiredRoles: string[]) {;
    return (req: Request, res: Response, next: NextFunction) => {;
      if (!requser) {;
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Authentication required';
          code: 'AUTH_REQUIRED';
        });
      };

      const userRole = requserrole;
      if (!requiredRolesincludes(userRole)) {;
        return resstatus(403)json({;
          error instanceof Error ? errormessage : String(error) 'Insufficient role';
          code: 'INSUFFICIENT_ROLE';
          required: requiredRoles;
          current: userRole;
        });
      };

      next();
    };
  };
};

export default JWTAuthService;