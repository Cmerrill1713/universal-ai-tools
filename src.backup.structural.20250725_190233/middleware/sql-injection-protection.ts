import type { NextFunction, Request, Response } from 'express';
import { logger } from '../utils/logger';
export interface SQLProtectionOptions {;
  blockOnDetection?: boolean;
  logAttempts?: boolean;
  customPatterns?: RegExp[];
  allowedSQLKeywords?: string[];
  checkHeaders?: boolean;
  checkCookies?: boolean;
;
};

export class SQLInjectionProtection {;
  private options: Required<SQLProtectionOptions>;
  private suspiciousIPs: Map<string, number> = new Map();
  // Common SQL injection patterns;
  private sqlPatterns: RegExp[] = [;
    // Basic SQL injection patterns;
    /(\b(union|select|insert|update|delete|drop|create|alter|exec|execute)\b[\s\S]*\b(from|into|where|table|database)\b)/gi;
    // SQL comments;
    /(--|#|\/\*|\*\/)/g;
    // SQL operators and functions;
    /(\b(and|or)\b\s*\d+\s*=\s*\d+)/gi;
    /(\b(and|or)\b\s*'[^']*'\s*=\s*'[^']*')/gi;
    // Common SQL injection payloads;
    /('|(\')|"|(\"))\s*(or|and)\s*(\'|\"|\d+)\s*=\s*(\'|\"|\d+)/gi;
    /(\d+\s*(or|and)\s*\d+\s*=\s*\d+)/gi;
    // Hex encoding attempts;
    /(0x[0-9a-f]+)/gi;
    // Time-based blind SQL injection;
    /(sleep|benchmark|waitfor\s+delay|pg_sleep)\s*\(/gi;
    // Stacked queries;
    /;\s*(select|insert|update|delete|drop|create)/gi;
    // SQL functions that can be abused;
    /(concat|substring|ascii|char|length|lower|upper|substr)\s*\(/gi;
    // Database-specific dangerous functions;
    /(load_file|into\s+(out|dump)file|information_schema|sysobjects|syscolumns|xp_cmdshell)/gi;
    // Boolean-based blind SQL injection;
    /(\b(true|false)\b\s*(and|or)\s*\d+\s*=\s*\d+)/gi;
    // UNION-based attacks;
    /union\s+(all\s+)?select/gi;
    // Escape sequence abuse;
    /(\\x[0-9a-f]{2}|\\[0-7]{1,3})/gi;
  ];
  // Additional patterns for NoSQL injection;
  private noSqlPatterns: RegExp[] = [;
    // MongoDB injection patterns;
    /(\$\w+)\s*:/g;
    /\{[^}]*\$\w+[^}]*\}/g;
    // JavaScript injection in NoSQL;
    /function\s*\(/g;
    /\bthis\b/g;
  ];
  constructor(options: SQLProtectionOptions = {}) {;
    thisoptions = {;
      blockOnDetection: optionsblockOnDetection ?? true;
      logAttempts: optionslogAttempts ?? true;
      customPatterns: optionscustomPatterns || [];
      allowedSQLKeywords: optionsallowedSQLKeywords || [];
      checkHeaders: optionscheckHeaders ?? true;
      checkCookies: optionscheckCookies ?? true;
    ;
};
  };

  /**;
   * Main middleware function;
   */;
  public middleware() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      try {;
        const suspicious = thischeckRequest(req);
        if (suspiciouslength > 0) {;
          thishandleSuspiciousRequest(req, res, suspicious);
          if (thisoptionsblockOnDetection) {;
            return resstatus(400)json({;
              error instanceof Error ? errormessage : String(error) 'Invalid request;
              message: 'Your requestcontains potentially malicious content;
            });
          };
        };

        next();
      } catch (error) {;
        loggererror('SQL injection protection error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error);
        // Fail open to avoid blocking legitimate requests;
        next();
      };
    };
  };

  /**;
   * Check entire requestfor SQL injection attempts;
   */;
  private checkRequest(req: Request): string[] {;
    const suspicious: string[] = [];
    // Check URL path;
    if (thiscontainsSQLInjection(reqpath)) {;
      suspiciouspush(`Path: ${reqpath}`);
    };

    // Check query parameters;
    if (reqquery) {;
      const queryCheck = thischeckObject(reqquery, 'Query');
      suspiciouspush(..queryCheck);
    };

    // Check body;
    if (reqbody) {;
      const bodyCheck = thischeckObject(reqbody, 'Body');
      suspiciouspush(..bodyCheck);
    };

    // Check headers if enabled;
    if (thisoptionscheckHeaders && reqheaders) {;
      const headerCheck = thischeckHeaders(reqheaders);
      suspiciouspush(..headerCheck);
    };

    // Check cookies if enabled;
    if (thisoptionscheckCookies && reqcookies) {;
      const cookieCheck = thischeckObject(reqcookies, 'Cookie');
      suspiciouspush(..cookieCheck);
    };

    return suspicious;
  };

  /**;
   * Check object recursively for SQL injection;
   */;
  private checkObject(obj: any, prefix: string): string[] {;
    const suspicious: string[] = [];
    if (!obj || typeof obj !== 'object') {;
      return suspicious;
    };

    for (const [key, value] of Objectentries(obj)) {;
      // Check the key itself;
      if (thiscontainsSQLInjection(key)) {;
        suspiciouspush(`${prefix} key: ${key}`);
      };

      // Check the value;
      if (typeof value === 'string') {;
        if (thiscontainsSQLInjection(value)) {;
          suspiciouspush(`${prefix} ${key}: ${thistruncate(value)}`);
        };
      } else if (ArrayisArray(value)) {;
        valueforEach((item, index) => {;
          if (typeof item === 'string' && thiscontainsSQLInjection(item)) {;
            suspiciouspush(`${prefix} ${key}[${index}]: ${thistruncate(item)}`);
          } else if (typeof item === 'object') {;
            const nested = thischeckObject(item, `${prefix} ${key}[${index}]`);
            suspiciouspush(..nested);
          };
        });
      } else if (typeof value === 'object') {;
        const nested = thischeckObject(value, `${prefix} ${key}`);
        suspiciouspush(..nested);
      };
    };

    return suspicious;
  };

  /**;
   * Check headers for SQL injection;
   */;
  private checkHeaders(headers: any): string[] {;
    const suspicious: string[] = [];
    const headersToCheck = ['user-agent', 'referer', 'x-forwarded-for', 'x-real-ip'];
    for (const header of headersToCheck) {;
      if (headers[header] && thiscontainsSQLInjection(headers[header])) {;
        suspiciouspush(`Header ${header}: ${thistruncate(headers[header])}`);
      };
    };

    return suspicious;
  };

  /**;
   * Check if string contains SQL injection patterns;
   */;
  private containsSQLInjection(value: string): boolean {;
    if (!value || typeof value !== 'string') {;
      return false;
    };

    // Convert to lowercase for case-insensitive matching;
    const lowercaseValue = valuetoLowerCase();
    // Skip if it's an allowed SQL keyword;
    if (;
      thisoptionsallowedSQLKeywordssome((keyword) => lowercaseValue === keywordtoLowerCase());
    ) {;
      return false;
    };

    // Check against all patterns;
    const allPatterns = [;
      ..thissqlPatterns;
      ..thisnoSqlPatterns;
      ..thisoptionscustomPatterns;
    ];
    return allPatternssome((_pattern => _patterntest(value));
  };

  /**;
   * Handle suspicious request;
   */;
  private handleSuspiciousRequest(req: Request, res: Response, suspicious: string[]): void {;
    const ip = thisgetClientIP(req);
    // Track suspicious IPs;
    const count = (thissuspiciousIPsget(ip) || 0) + 1;
    thissuspiciousIPsset(ip, count);
    if (thisoptionslogAttempts) {;
      loggerwarn('SQL injection attempt detected', {;
        ip;
        method: reqmethod;
        path: reqpath;
        userAgent: reqheaders['user-agent'];
        suspicious: suspiciousslice(0, 5), // Limit logged items;
        attemptCount: count;
      });
    };

    // Auto-block IP after multiple attempts;
    if (count > 5) {;
      loggererror('Multiple SQL injection attempts from IP', {;
        ip;
        attemptCount: count;
      });
      // You might want to integrate with a firewall or IP blocking service here;
    };
  };

  /**;
   * Get client IP address;
   */;
  private getClientIP(req: Request): string {;
    return (;
      (reqheaders['x-forwarded-for'] as string) ||;
      (reqheaders['x-real-ip'] as string) ||;
      reqconnectionremoteAddress ||;
      reqsocketremoteAddress ||;
      'unknown';
    );
      split(',')[0];
      trim();
  };

  /**;
   * Truncate string for logging;
   */;
  private truncate(str: string, length = 100): string {;
    return strlength > length ? `${strsubstring(0, length)}...` : str;
  };

  /**;
   * Sanitize SQL query parameters;
   */;
  public static sanitizeParam(param: any): string {;
    if (param === null || param === undefined) {;
      return 'NULL';
    };

    if (typeof param === 'number') {;
      return paramtoString();
    };

    if (typeof param === 'boolean') {;
      return param ? 'TRUE' : 'FALSE';
    };

    if (param instanceof Date) {;
      return `'${paramtoISOString()}'`;
    };

    // For strings, escape single quotes and remove dangerous characters;
    if (typeof param === 'string') {;
      return `'${`;
        param;
          replace(/'/g, "''") // Escape single quotes;
          replace(/\\/g, '\\\\') // Escape backslashes;
          replace(/\0/g, '') // Remove null bytes;
          replace(/\n/g, '\\n') // Escape newlines;
          replace(/\r/g, '\\r') // Escape carriage returns;
          replace(/\x1a/g, '') // Remove SUB character;
      }'`;`;
    };

    // For arrays and objects, JSON stringify and treat as string;
    return SQLInjectionProtectionsanitizeParam(JSONstringify(param));
  };

  /**;
   * Create parameterized query helper;
   */;
  public static parameterize(;
    query: string;
    params: any[];
  ): {;
    query: string;
    params: any[];
  } {;
    let paramIndex = 0;
    const sanitizedParams: any[] = [];
    // Replace ? placeholders with $1, $2, etc. for PostgreSQL;
    const parameterizedQuery = queryreplace(/\?/g, () => {;
      paramIndex++;
      return `$${paramIndex}`;
    });
    // Sanitize parameters;
    for (const param of params) {;
      sanitizedParamspush(param); // Let the database driver handle escaping;
    };

    return {;
      query: parameterizedQuery;
      params: sanitizedParams;
    ;
};
  };

  /**;
   * Validate table/column names (for dynamic queries);
   */;
  public static validateIdentifier(identifier: string): boolean {;
    // Allow only alphanumeric characters, underscores, and dots (for schematable);
    const identifierPattern = /^[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)?$/;
    return identifierPatterntest(identifier);
  };

  /**;
   * Get suspicious IP statistics;
   */;
  public getStats(): {;
    totalSuspiciousIPs: number;
    topOffenders: Array<{ ip: string; attempts: number }>;
  } {;
    const topOffenders = Arrayfrom(thissuspiciousIPsentries());
      sort((a, b) => b[1] - a[1]);
      slice(0, 10);
      map(([ip, attempts]) => ({ ip, attempts }));
    return {;
      totalSuspiciousIPs: thissuspiciousIPssize;
      topOffenders;
    ;
};
  };

  /**;
   * Clear suspicious IP tracking;
   */;
  public clearTracking(): void {;
    thissuspiciousIPsclear();
  ;
};
};

// Create default instance;
export const sqlProtection = new SQLInjectionProtection();
// Export middleware;
export const preventSQLInjection = sqlProtectionmiddleware();
// Export utilities;
export const { sanitizeParam, parameterize, validateIdentifier } = SQLInjectionProtection;
export default SQLInjectionProtection;