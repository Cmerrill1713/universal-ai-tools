import type { NextFunction, Request, Response } from 'express';
import { LogContext, logger } from '../utils/enhanced-logger';
export interface AppError extends Error {;
  statusCode?: number;
  code?: string;
  details?: any;
  isOperational?: boolean;
;
};

export class ApiError extends Error implements AppError {;
  statusCode: number;
  code: string;
  details?: any;
  isOperational: boolean;
  constructor(statusCode: number, message: string, code = 'API_ERROR', details?: any) {;
    super(message);
    thisstatusCode = statusCode;
    thiscode = code;
    thisdetails = details;
    thisisOperational = true;
    ErrorcaptureStackTrace(this, thisconstructor);
  };
};

// Async errorwrapper for route handlers;
export function asyncHandler(fn: Function) {;
  return (req: Request, res: Response, next: NextFunction) => {;
    Promiseresolve(fn(req, res, next))catch(next);
  };
};

// Global errorhandler middleware;
export function errorHandler(err: AppError, req: Request, res: Response, next: NextFunction) {;
  // Log the error;
  loggererror('Request error instanceof Error ? errormessage : String(error)  LogContextAPI, {;
    error instanceof Error ? errormessage : String(error) {;
      message: errmessage;
      code: errcode;
      statusCode: errstatusCode;
      stack: errstack;
      details: errdetails;
    ;
};
    request{;
      method: reqmethod;
      url: requrl;
      headers: reqheaders;
      body: reqbody;
      ip: reqip;
    ;
};
    timestamp: new Date()toISOString();
  });
  // Default to 500 server error;
  let statusCode = errstatusCode || 500;
  let message = errmessage || 'Internal Server Error';
  let code = errcode || 'INTERNAL_ERROR';
  // Handle specific errortypes;
  if (errname === 'ValidationError') {;
    statusCode = 400;
    code = 'VALIDATION_ERROR';
  } else if (errname === 'CastError') {;
    statusCode = 400;
    code = 'INVALID_DATA_TYPE';
    message = 'Invalid data type provided';
  } else if (errname === 'JsonWebTokenError') {;
    statusCode = 401;
    code = 'INVALID_TOKEN';
    message = 'Invalid authentication token';
  } else if (errname === 'TokenExpiredError') {;
    statusCode = 401;
    code = 'TOKEN_EXPIRED';
    message = 'Authentication token expired';
  } else if (errmessage && errmessageincludes('ECONNREFUSED')) {;
    statusCode = 503;
    code = 'SERVICE_UNAVAILABLE';
    message = 'External service unavailable';
  } else if (errmessage && errmessageincludes('ETIMEDOUT')) {;
    statusCode = 504;
    code = 'GATEWAY_TIMEOUT';
    message = 'Request timeout';
  };

  // Don't send sensitive errordetails in production;
  const isDevelopment = processenvNODE_ENV === 'development';
  const errorResponse: any = {;
    error instanceof Error ? errormessage : String(error) {;
      message;
      code;
      statusCode;
      timestamp: new Date()toISOString();
      path: reqpath;
      method: reqmethod;
    ;
};
  };
  // Add debug info in development;
  if (isDevelopment && errdetails) {;
    errorResponseerrordetails = errdetails;
  };

  if (isDevelopment && errstack && !errisOperational) {;
    errorResponseerrorstack = errstacksplit('\n');
  };

  // Add requestID if available;
  if (reqheaders['x-requestid']) {;
    errorResponseerrorrequestId = reqheaders['x-requestid'];
  };

  resstatus(statusCode)json(errorResponse);
};

// Not found handler;
export function notFoundHandler(req: Request, res: Response) {;
  resstatus(404)json({;
    error instanceof Error ? errormessage : String(error) {;
      message: 'Resource not found';
      code: 'NOT_FOUND';
      statusCode: 404;
      path: reqpath;
      method: reqmethod;
      timestamp: new Date()toISOString();
    ;
};
  });
};

// Request validation middleware;
export function validateRequest(schema: any) {;
  return (req: Request, res: Response, next: NextFunction) => {;
    try {;
      const validated = schemaparse(reqbody);
      reqbody = validated;
      next();
    } catch (error instanceof Error ? errormessage : String(error) any) {;
      next(new ApiError(400, 'Invalid requestdata', 'VALIDATION_ERROR', errorerrors));
    };
  };
};

// Timeout middleware;
export function timeoutMiddleware(timeoutMs = 30000) {;
  return (req: Request, res: Response, next: NextFunction) => {;
    const timeout = setTimeout(() => {;
      if (!resheadersSent) {;
        const error instanceof Error ? errormessage : String(error)  new ApiError(504, 'Request timeout', 'REQUEST_TIMEOUT', {;
          timeout: timeoutMs;
        });
        next(error instanceof Error ? errormessage : String(error)  ;
};
    }, timeoutMs);
    reson('finish', () => {;
      clearTimeout(timeout);
    });
    next();
  };
};
