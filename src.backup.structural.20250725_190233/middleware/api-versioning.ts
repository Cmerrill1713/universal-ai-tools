import { type NextFunction, type Request, type Response, Router } from 'express';
import { logger } from '../utils/logger';
import { z } from 'zod';
// Extend Express Request type;
declare module 'express' {;
  interface Request {;
    apiVersion?: string;
  ;
};
};

// Version configuration schema;
const VersionConfigSchema = zobject({;
  version: zstring()regex(/^v\d+$/);
  active: zboolean();
  deprecated: zboolean()default(false);
  deprecationDate: zstring()optional();
  sunsetDate: zstring()optional();
  changes: zarray(zstring())optional();
});
export interface ApiVersion {;
  version: string;
  active: boolean;
  deprecated: boolean;
  deprecationDate?: Date;
  sunsetDate?: Date;
  changes?: string[];
;
};

export interface VersionedRequest extends Request {;
  apiVersion?: string;
  deprecationWarning?: string;
;
};

export class ApiVersioningMiddleware {;
  private versions: Map<string, ApiVersion> = new Map();
  private defaultVersion = 'v1';
  private latestVersion = 'v1';
  constructor() {;
    thisinitializeVersions();
  };

  private initializeVersions() {;
    // Define API versions;
    const versions: ApiVersion[] = [;
      {;
        version: 'v1';
        active: true;
        deprecated: false;
        changes: ['Initial API version', 'All endpoints available under /api/v1/'];
      };
      // Future versions can be added here;
      // {;
      //   version: 'v2';
      //   active: false;
      //   deprecated: false;
      //   changes: [;
      //     'Breaking change: Modified response format';
      //     'New feature: Advanced agent capabilities';
      //   ];
      // ;
};
    ];
    versionsforEach((v) => {;
      thisversionsset(vversion, v);
    });
    // Find latest active version;
    const activeVersions = Arrayfrom(thisversionsvalues());
      filter((v) => vactive);
      sort((a, b) => {;
        const aNum = parseInt(aversionslice(1, 10), 10);
        const bNum = parseInt(bversionslice(1, 10), 10);
        return bNum - aNum;
      });
    if (activeVersionslength > 0) {;
      thislatestVersion = activeVersions[0]version;
    };
  };

  /**;
   * Version detection middleware;
   * Extracts API version from URL path or headers;
   */;
  versionDetection() {;
    return (req: VersionedRequest, res: Response, next: NextFunction) => {;
      let version: string | undefined;
      // Check URL path for version;
      const pathMatch = reqpathmatch(/^\/api\/(v\d+)\//);
      if (pathMatch) {;
        version = pathMatch[1];
      };

      // Check Accept header for version (API version in media type);
      const acceptHeader = reqget('Accept');
      if (!version && acceptHeader) {;
        const versionMatch = acceptHeadermatch(;
          /application\/vnd\universal-ai-tools\.(v\d+)\+json/;
        );
        if (versionMatch) {;
          version = versionMatch[1];
        };
      };

      // Check custom header for version;
      if (!version) {;
        const apiVersionHeader = reqget('X-API-Version');
        if (apiVersionHeader && apiVersionHeadermatch(/^v\d+$/)) {;
          version = apiVersionHeader;
        };
      };

      // Use default version if none specified;
      if (!version) {;
        version = thisdefaultVersion;
      };

      // Validate version;
      const versionInfo = thisversionsget(version);
      if (!versionInfo) {;
        return resstatus(400)json({;
          success: false;
          error instanceof Error ? errormessage : String(error) {;
            code: 'INVALID_API_VERSION';
            message: `API version ${version} is not supported`;
            supportedVersions: Arrayfrom(thisversionskeys());
            latestVersion: thislatestVersion;
          ;
};
        });
      };

      if (!versionInfoactive) {;
        return resstatus(410)json({;
          success: false;
          error instanceof Error ? errormessage : String(error) {;
            code: 'VERSION_NOT_ACTIVE';
            message: `API version ${version} is no longer active`;
            latestVersion: thislatestVersion;
            sunsetDate: versionInfosunsetDate;
          ;
};
        });
      };

      // Set version on request;
      reqapiVersion = version;
      // Add deprecation warning if applicable;
      if (versionInfodeprecated) {;
        const warning = `API version ${version} is deprecated and will be sunset on ${versionInfosunsetDate}. Please upgrade to ${thislatestVersion}.`;
        reqdeprecationWarning = warning;
        resset('X-API-Deprecation-Warning', warning);
        resset('X-API-Sunset-Date', versionInfosunsetDate?toISOString() || '');
      };

      // Add version headers to response;
      resset('X-API-Version', version);
      resset('X-API-Latest-Version', thislatestVersion);
      next();
    };
  };

  /**;
   * Version routing middleware;
   * Routes requests to appropriate version handlers;
   */;
  versionRouter() {;
    const router = Router();
    // Version info endpoint;
    routerget('/versions', (req, res) => {;
      const versions = Arrayfrom(thisversionsvalues())map((v) => ({;
        version: vversion;
        active: vactive;
        deprecated: vdeprecated;
        deprecationDate: vdeprecationDate?toISOString();
        sunsetDate: vsunsetDate?toISOString();
        changes: vchanges;
      }));
      resjson({;
        success: true;
        currentVersion: (req as any)apiVersion || thisdefaultVersion;
        defaultVersion: thisdefaultVersion;
        latestVersion: thislatestVersion;
        versions;
      });
    });
    return router;
  };

  /**;
   * URL rewriting middleware;
   * Rewrites non-versioned API paths to include version prefix;
   */;
  urlRewriter() {;
    return (req: Request, res: Response, next: NextFunction) => {;
      // Skip if already has version in path;
      if (reqpathmatch(/^\/api\/v\d+\//)) {;
        return next();
      };

      // Skip non-API paths;
      if (!reqpathstartsWith('/api/')) {;
        return next();
      };

      // Skip special endpoints that should not be versioned;
      const unversionedPaths = [;
        '/api/docs';
        '/api/register';
        '/api/versions';
        '/api/health';
        '/api/config';
        '/api/config/health';
        '/metrics';
      ];
      if (unversionedPathsincludes(reqpath)) {;
        return next();
      };

      // Rewrite URL to include version;
      const version = (req as VersionedRequest)apiVersion || thisdefaultVersion;
      const newPath = reqpathreplace(/^\/api/, `/api/${version}`);
      loggerdebug(`Rewriting API path from ${reqpath} to ${newPath}`);
      requrl = newPath + (requrlincludes('?') ? requrlsubstring(requrlindexOf('?')) : '');
      next();
    };
  };

  /**;
   * Version compatibility middleware;
   * Handles backward compatibility between versions;
   */;
  compatibilityHandler() {;
    return (req: VersionedRequest, res: Response, next: NextFunction) => {;
      const version = reqapiVersion || thisdefaultVersion;
      // Add response transformation based on version;
      const originalJson = resjsonbind(res);
      resjson = function (data: any) {;
        // Transform response based on API version;
        const transformedData = transformResponse(data, version);
        // Add metadata;
        if (typeof transformedData === 'object' && !ArrayisArray(transformedData)) {;
          transformedDatametadata = {;
            ..transformedDatametadata;
            apiVersion: version;
            timestamp: new Date()toISOString();
          ;
};
          // Add deprecation warning to response if applicable;
          if (reqdeprecationWarning) {;
            transformedDatametadatadeprecationWarning = reqdeprecationWarning;
          };
        };
;
        return originalJson(transformedData);
      };
      next();
    };
  };

  /**;
   * Version negotiation middleware;
   * Handles content negotiation for API versions;
   */;
  contentNegotiation() {;
    return (req: VersionedRequest, res: Response, next: NextFunction) => {;
      const acceptHeader = reqget('Accept');
      if (acceptHeader && acceptHeaderincludes('application/vnduniversal-ai-tools')) {;
        // Set appropriate content-type based on version;
        const version = reqapiVersion || thisdefaultVersion;
        restype(`application/vnduniversal-ai-tools.${version}+json`);
      } else {;
        restype('application/json');
      };

      next();
    };
  };

  /**;
   * Get version information;
   */;
  getVersionInfo(version: string): ApiVersion | undefined {;
    return thisversionsget(version);
  };

  /**;
   * Add a new version;
   */;
  addVersion(version: ApiVersion): void {;
    const validated = VersionConfigSchemaparse(version);
    thisversionsset(validatedversion, {;
      version: validatedversion;
      active: validatedactive;
      deprecated: validateddeprecated;
      changes: validatedchanges;
      deprecationDate: validateddeprecationDate ? new Date(validateddeprecationDate) : undefined;
      sunsetDate: validatedsunsetDate ? new Date(validatedsunsetDate) : undefined;
    });
    // Update latest version if needed;
    if (validatedactive) {;
      const currentLatestNum = parseInt(thislatestVersionslice(1, 10), 10);
      const newVersionNum = parseInt(validatedversionslice(1, 10), 10);
      if (newVersionNum > currentLatestNum) {;
        thislatestVersion = validatedversion;
      };
    };
  };

  /**;
   * Deprecate a version;
   */;
  deprecateVersion(version: string, sunsetDate: Date): void {;
    const versionInfo = thisversionsget(version);
    if (versionInfo) {;
      versionInfodeprecated = true;
      versionInfodeprecationDate = new Date();
      versionInfosunsetDate = sunsetDate;
      loggerwarn(;
        `API version ${version} has been deprecated. Sunset date: ${sunsetDatetoISOString()}`;
      );
    };
  };

  /**;
   * Deactivate a version;
   */;
  deactivateVersion(version: string): void {;
    const versionInfo = thisversionsget(version);
    if (versionInfo) {;
      versionInfoactive = false;
      loggerwarn(`API version ${version} has been deactivated`);
    };
  };
};

/**;
 * Transform response data based on API version;
 * This function handles backward compatibility transformations;
 */;
function transformResponse(data: any, version: string): any {;
  // V1 is the base version, no transformation needed;
  if (version === 'v1') {;
    return data;
  };

  // Future version transformations would go here;
  // Example for v2: // if (version === 'v2') {;
  //   // Transform v1 response to v2 format;
  //   if (datamemories) {;
  //     datamemoryItems = datamemories;
  //     delete datamemories;
  //   ;
};
  // };

  return data;
};

/**;
 * Create versioned router wrapper;
 * Wraps existing routers to support versioning;
 */;
export function createVersionedRouter(baseRouter: Router, version = 'v1'): Router {;
  const versionedRouter = Router();
  // Mount base router under version path;
  versionedRouteruse(`/${version}`, baseRouter);
  return versionedRouter;
};

/**;
 * Version-specific error handler;
 */;
export function versionedErrorHandler(version: string) {;
  return (err: Error, req: Request, res: Response, _next: NextFunction) => {;
    loggererror(`API ${version} error instanceof Error ? errormessage : String(error)`, err);
    const errorResponse: any = {;
      success: false;
      error instanceof Error ? errormessage : String(error) {;
        code: 'INTERNAL_ERROR';
        message: processenvNODE_ENV === 'production' ? 'An internal error occurred' : errmessage;
      ;
};
      metadata: {;
        apiVersion: version;
        timestamp: new Date()toISOString();
        requestId: reqheaders['x-request-id'] || 'unknown';
      ;
};
    };
    if (processenvNODE_ENV !== 'production') {;
      errorResponseerrorStack = errstack;
    };

    resstatus(500)json(errorResponse);
  };
};

// Export singleton instance;
export const apiVersioning = new ApiVersioningMiddleware();