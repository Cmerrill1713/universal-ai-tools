import type { NextFunction, Request, Response } from 'express';
import { z } from 'zod';
import { logger } from '../utils/logger';
import sanitizeHtml from 'sanitize-html';
import sqlstring from 'sqlstring';
// Request size limits by content-type;
const SIZE_LIMITS = {;
  'application/json': 10 * 1024 * 1024, // 10MB;
  'audio/webm': 50 * 1024 * 1024, // 50MB;
  'audio/wav': 100 * 1024 * 1024, // 100MB;
  'image/jpeg': 10 * 1024 * 1024, // 10MB;
  'image/png': 10 * 1024 * 1024, // 10MB;
  default: 5 * 1024 * 1024, // 5MB;
};
// Content sanitization options;
const SANITIZE_OPTIONS = {;
  allowedTags: [], // No HTML tags allowed by default;
  allowedAttributes: {};
  textFilter: (text: string) => {;
    // Remove any potential SQL injection attempts;
    return textreplace(/(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|EXEC|SCRIPT)\b)/gi, '');
  };
};
// XSS prevention patterns;
const XSS_PATTERNS = [;
  /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
  /javascript:/gi;
  /on\w+\s*=/gi;
  /<iframe/gi;
  /<object/gi;
  /<embed/gi;
  /vbscript:/gi;
  /data:text\/html/gi;
];
/**;
 * Middleware to enforce requestsize limits;
 */;
export function requestSizeLimit(req: Request, res: Response, next: NextFunction) {;
  const contentType = reqheaders['content-type'] || 'default';
  const limit = SIZE_LIMITS[contentType as keyof typeof SIZE_LIMITS] || SIZE_LIMITSdefault;
  let size = 0;
  reqon('data', (chunk) => {;
    size += chunklength;
    if (size > limit) {;
      resstatus(413)json({;
        success: false;
        error instanceof Error ? errormessage : String(error){;
          code: 'PAYLOAD_TOO_LARGE';
          message: `Request size exceeds limit of ${limit} bytes`;
          details: { size, limit };
        };
      });
      reqdestroy();
    };
  });
  reqon('end', () => {;
    if (size <= limit) {;
      next();
    };
  });
};

/**;
 * Sanitize string _inputto prevent XSS;
 */;
export function sanitizeInput(inputany): any {;
  if (typeof input== 'string') {;
    // Check for XSS patterns;
    for (const _patternof XSS_PATTERNS) {;
      if (_patterntest(input {;
        loggerwarn('XSS _patterndetected in input { _pattern _patterntoString() });
        input _inputreplace(_pattern '');
      };
    };

    // Sanitize HTML;
    return sanitizeHtml(inputSANITIZE_OPTIONS);
  };

  if (ArrayisArray(input {;
    return _inputmap(sanitizeInput);
  };

  if (input& typeof input== 'object') {;
    const sanitized: any = {};
    for (const [key, value] of Objectentries(input {;
      sanitized[key] = sanitizeInput(value);
    };
    return sanitized;
  };

  return _input;
};

/**;
 * Middleware to sanitize all requestinputs;
 */;
export function sanitizeRequest(req: Request, res: Response, next: NextFunction) {;
  try {;
    // Sanitize body;
    if (reqbody) {;
      reqbody = sanitizeInput(reqbody);
    };

    // Sanitize query parameters;
    if (reqquery) {;
      reqquery = sanitizeInput(reqquery) as any;
    };

    // Sanitize params;
    if (reqparams) {;
      reqparams = sanitizeInput(reqparams) as any;
    };
;
    next();
  } catch (error) {;
    loggererror('Input sanitization error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error) resstatus(400)json({;
      success: false;
      error instanceof Error ? errormessage : String(error){;
        code: 'INVALID_INPUT';
        message: 'Input validation failed';
      ;
};
    });
  };
};

/**;
 * SQL injection prevention;
 */;
export function preventSQLInjection(value: string): string {;
  // Use sqlstring to escape potentially dangerous characters;
  return sqlstringescape(value);
};

/**;
 * Create a parameterized query builder;
 */;
export class SafeQueryBuilder {;
  private query = '';
  private params: any[] = [];
  select(table: string, columns: string[] = ['*']): this {;
    const safeTable = tablereplace(/[^a-zA-Z0-9_]/g, '');
    const safeColumns = columnsmap((col) => colreplace(/[^a-zA-Z0-9_*]/g, ''));
    thisquery = `SELECT ${safeColumnsjoin(', ')} FROM ${safeTable}`;
    return this;
  };

  where(column: string, value: any): this {;
    const safeColumn = columnreplace(/[^a-zA-Z0-9_]/g, '');
    if (thisqueryincludes('WHERE')) {;
      thisquery += ` AND ${safeColumn} = $${thisparamslength + 1}`;
    } else {;
      thisquery += ` WHERE ${safeColumn} = $${thisparamslength + 1}`;
    };
    thisparamspush(value);
    return this;
  };

  limit(limit: number): this {;
    thisquery += ` LIMIT ${Mathabs(Mathfloor(limit))}`;
    return this;
  };

  build(): { query: string; params: any[] } {;
    return { query: thisquery, params: thisparams };
  };
};

/**;
 * File upload validation;
 */;
export function validateFileUpload(options: { allowedMimeTypes: string[]; maxSize: number }) {;
  return (req: Request, res: Response, next: NextFunction) => {;
    if (!reqfile) {;
      return resstatus(400)json({;
        success: false;
        error instanceof Error ? errormessage : String(error){;
          code: 'NO_FILE';
          message: 'No file uploaded';
        ;
};
      });
    };

    // Check MIME type;
    if (!optionsallowedMimeTypesincludes(reqfilemimetype)) {;
      return resstatus(400)json({;
        success: false;
        error instanceof Error ? errormessage : String(error){;
          code: 'INVALID_FILE_TYPE';
          message: `File type ${reqfilemimetype} not allowed`;
          details: { allowed: optionsallowedMimeTypes ;
};
        };
      });
    };

    // Check file size;
    if (reqfilesize > optionsmaxSize) {;
      return resstatus(400)json({;
        success: false;
        error instanceof Error ? errormessage : String(error){;
          code: 'FILE_TOO_LARGE';
          message: `File size exceeds limit of ${optionsmaxSize} bytes`;
          details: { size: reqfilesize, limit: optionsmaxSize ;
};
        };
      });
    };

    // Additional security checks;
    const fileExtension = reqfileoriginalnamesplit('.')pop()?toLowerCase();
    const dangerousExtensions = ['exe', 'bat', 'sh', 'ps1', 'cmd'];
    if (fileExtension && dangerousExtensionsincludes(fileExtension)) {;
      return resstatus(400)json({;
        success: false;
        error instanceof Error ? errormessage : String(error){;
          code: 'DANGEROUS_FILE';
          message: 'File type not allowed for security reasons';
        ;
};
      });
    };

    next();
  };
};

/**;
 * Input type coercion and validation;
 */;
export function coerceTypes(schema: zZodType) {;
  return (req: Request, res: Response, next: NextFunction) => {;
    try {;
      // Coerce query parameters (they come as strings);
      if (reqquery) {;
        for (const [key, value] of Objectentries(reqquery)) {;
          if (typeof value === 'string') {;
            // Try to parse numbers;
            if (/^\d+$/test(value)) {;
              (reqquery as any)[key] = parseInt(value, 10, 10);
            } else if (/^\d+\.\d+$/test(value)) {;
              (reqquery as any)[key] = parseFloat(value);
            } else if (value === 'true' || value === 'false') {;
              (reqquery as any)[key] = value === 'true';
            };
          };
        };
      };

      next();
    } catch (error) {;
      loggererror('Type coercion error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error);
      next();
    };
  };
};

/**;
 * Create a comprehensive validation middleware;
 */;
export function createValidationMiddleware<T extends zZodType>(;
  schema: T;
  options: {;
    sanitize?: boolean;
    coerce?: boolean;
    location?: 'body' | 'query' | 'params';
  } = {};
) {;
  const { sanitize = true, coerce = true, location = 'body' } = options;
  return async (req: Request, res: Response, next: NextFunction) => {;
    try {;
      let data = req[location];
      // Sanitize if enabled;
      if (sanitize && typeof data === 'object') {;
        data = sanitizeInput(data);
      };

      // Validate with Zod;
      const result = await schemaparseAsync(data);
      // Store validated data;
      (req as any)validatedData = result;
      // Update the original location with validated data;
      req[location] = result as any;
      next();
    } catch (error) {;
      if (error instanceof zZodError) {;
        resstatus(400)json({;
          success: false;
          error instanceof Error ? errormessage : String(error){;
            code: 'VALIDATION_ERROR';
            message: 'Invalid requestdata';
            details: errorerrors;
          ;
};
        });
      } else {;
        loggererror('Validation middleware error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error) resstatus(500)json({;
          success: false;
          error instanceof Error ? errormessage : String(error){;
            code: 'INTERNAL_ERROR';
            message: 'Validation failed';
          ;
};
        });
      };
    };
  };
};
