/**;
 * Contextual Memory Enricher;
 * Extracts entities, concepts, and intent to create context-aware embeddings;
 * Enhances memory quality and search relevance through semantic understanding;
 */;

export interface EntityExtraction {;
  type: | 'person';
    | 'organization';
    | 'location';
    | 'date';
    | 'time';
    | 'email';
    | 'url';
    | 'phone';
    | 'money';
    | 'percentage';
    | 'other';
  value: string;
  confidence?: number;
  start?: number;
  end?: number;
;
};

export interface ConceptExtraction {;
  concept: string;
  category: 'action' | 'object' | 'attribute' | 'domain' | 'temporal' | 'emotional' | 'technical';
  relevance: number;
  keywords: string[];
;
};

export interface IntentClassification {;
  intent: string;
  confidence: number;
  category:;
    | 'request;
    | 'information';
    | 'action';
    | 'question';
    | 'complaint';
    | 'compliment';
    | 'other';
  urgency?: 'low' | 'medium' | 'high' | 'critical';
;
};

export interface TemporalContext {;
  hasTimeReference: boolean;
  timeExpressions: string[];
  temporalType?: 'past' | 'present' | 'future' | 'recurring';
  urgency?: 'immediate' | 'soon' | 'scheduled' | 'flexible';
;
};

export interface ContextualEnrichment {;
  entities: EntityExtraction[];
  concepts: ConceptExtraction[];
  intent: IntentClassification;
  temporal: TemporalContext;
  sentiment?: {;
    polarity: number; // -1 to 1;
    subjectivity: number; // 0 to 1;
    confidence: number;
  ;
};
  complexity: {;
    readabilityScore: number;
    technicalLevel: 'basic' | 'intermediate' | 'advanced' | 'expert';
    abstractionLevel: 'concrete' | 'mixed' | 'abstract';
  ;
};
  relationships: {;
    dependsOn: string[];
    relatedTo: string[];
    conflicts: string[];
  ;
};
};

export class ContextualMemoryEnricher {;
  private static readonly ENTITY_PATTERNS = {;
    email: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2}\b/g;
    url: /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/g;
    phone: /(\+?\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g;
    money: /\$\d{1,3}(,\d{3})*(\.\d{2})?|\d{1,3}(,\d{3})*(\.\d{2})?\s*(dollars?|USD|cents?)/gi;
    percentage: /\d+(\.\d+)?%/g;
    date: /\b\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}\b|\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{1,2},?\s+\d{4}\b/gi;
    time: /\b\d{1,2}:\d{2}(\s?[AaPp][Mm])?\b/g;
  };
  private static readonly INTENT_PATTERNS = {;
    request[;
      /please\s+(help|assist|do|make|create|build|fix|solve)/i;
      /can\s+you\s+(help|do|make|create|show)/i;
      /i\s+need\s+(help|assistance|support)/i;
      /would\s+you\s+(mind|please)/i;
    ];
    question: [;
      /\b(what|how|when|where|why|who|which)\b.*\?/i;
      /\bis\s+.*\?/i;
      /\bdo\s+you\s+know/i;
      /can\s+you\s+tell\s+me/i;
    ];
    action: [;
      /\b(schedule|book|create|make|build|send|call|email|remind)/i;
      /\blet's\s+(do|make|create|start)/i;
      /\bi\s+want\s+to\s+(do|make|create|start)/i;
    ];
    information: [/\btell\s+me\s+about/i, /\bshow\s+me/i, /\bexplain/i, /\bdescribe/i];
  };
  private static readonly TEMPORAL_PATTERNS = {;
    immediate: /\b(now|immediately|asap|urgent|right\s+away)\b/i;
    soon: /\b(soon|shortly|quickly|in\s+a\s+(few|couple)\s+(minutes?|hours?))\b/i;
    today: /\b(today|this\s+(morning|afternoon|evening))\b/i;
    tomorrow: /\b(tomorrow|next\s+day)\b/i;
    future: /\b(next\s+(week|month|year)|later|eventually|someday)\b/i;
    recurring: /\b(daily|weekly|monthly|every\s+(day|week|month|year))\b/i;
  ;
};
  private static readonly CONCEPT_CATEGORIES = {;
    action: [;
      'create';
      'make';
      'build';
      'develop';
      'design';
      'implement';
      'execute';
      'perform';
      'do';
      'schedule';
      'organize';
      'manage';
    ];
    object: [;
      'file';
      'document';
      'project';
      'meeting';
      'task';
      'component';
      'system';
      'application';
      'database';
      'report';
    ];
    domain: [;
      'technology';
      'business';
      'education';
      'health';
      'finance';
      'marketing';
      'operations';
      'development';
      'design';
    ];
    temporal: [;
      'deadline';
      'schedule';
      'timeline';
      'urgent';
      'priority';
      'immediate';
      'future';
      'past';
      'recurring';
    ];
    emotional: [;
      'excited';
      'frustrated';
      'happy';
      'concerned';
      'confident';
      'worried';
      'satisfied';
      'disappointed';
    ];
    technical: [;
      'code';
      'api';
      'database';
      'server';
      'algorithm';
      'framework';
      'library';
      'protocol';
      'interface';
    ];
  ;
};
  /**;
   * Extract entities from text using _patternmatching and NLP techniques;
   */;
  extractEntities(text: string): EntityExtraction[] {;
    const entities: EntityExtraction[] = [];
    // Extract using regex patterns;
    Objectentries(ContextualMemoryEnricherENTITY_PATTERNS)forEach(([type, _pattern) => {;
      const matches = textmatchAll(_pattern;
      for (const match of matches) {;
        entitiespush({;
          type: type as EntityExtraction['type'];
          value: match[0];
          confidence: 0.8, // High confidence for regex matches;
          start: matchindex;
          end: matchindex ? matchindex + match[0]length : undefined;
        });
      };
    });
    // Extract names (capitalized words that aren't common words);
    const namePattern = /\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g;
    const commonWords = new Set([;
      'The';
      'This';
      'That';
      'And';
      'Or';
      'But';
      'For';
      'With';
      'From';
      'To';
      'In';
      'On';
      'At';
      'By';
    ]);
    const nameMatches = textmatchAll(namePattern);
    for (const match of nameMatches) {;
      if (!commonWordshas(match[0]) && match[0]length > 2) {;
        const isProbablyName =;
          match[0]split(' ')length <= 3 && !entitiessome(;
            (e) =>;
              estart !== undefined && matchindex !== undefined && estart <= matchindex && matchindex < estart + evaluelength;
          );
        if (isProbablyName) {;
          entitiespush({;
            type: 'person';
            value: match[0];
            confidence: 0.6;
            start: matchindex;
            end: matchindex ? matchindex + match[0]length : undefined;
          });
        };
      };
    };

    return entities;
  };

  /**;
   * Extract concepts and categorize them;
   */;
  extractConcepts(text: string): ConceptExtraction[] {;
    const concepts: ConceptExtraction[] = [];
    const words = text;
      toLowerCase();
      split(/\W+/);
      filter((word) => wordlength > 2);
    const wordFreq = new Map<string, number>();
    // Count word frequencies;
    wordsforEach((word) => {;
      wordFreqset(word, (wordFreqget(word) || 0) + 1);
    });
    // Extract concepts based on categories;
    Objectentries(ContextualMemoryEnricherCONCEPT_CATEGORIES)forEach(([category, keywords]) => {;
      keywordsforEach((keyword) => {;
        const keywordLower = keywordtoLowerCase();
        if (wordsincludes(keywordLower)) {;
          const relevance = Mathmin(1.0, ((wordFreqget(keywordLower) || 0) / wordslength) * 10);
          conceptspush({;
            concept: keyword;
            category: category as ConceptExtraction['category'];
            relevance;
            keywords: [keywordLower];
          });
        };
      });
    });
    // Extract compound concepts (phrases);
    const phrases = thisextractPhrases(text);
    phrasesforEach((phrase) => {;
      const category = thisclassifyPhrase(phrase);
      if (category) {;
        conceptspush({;
          concept: phrase;
          category;
          relevance: 0.7;
          keywords: phrasetoLowerCase()split(/\s+/);
        });
      };
    });
    // Sort by relevance and remove duplicates;
    return concepts;
      sort((a, b) => brelevance - arelevance);
      filter(;
        (concept, index, arr) =>;
          arrfindIndex((c) => cconcepttoLowerCase() === conceptconcepttoLowerCase()) === index;
      );
      slice(0, 15); // Top 15 concepts;
  };

  /**;
   * Classify intent from text;
   */;
  classifyIntent(text: string): IntentClassification {;
    const textLower = texttoLowerCase();
    const intents: Array<{;
      intent: string;
      category: IntentClassification['category'];
      confidence: number;
    }> = [];
    // Check against intent patterns;
    Objectentries(ContextualMemoryEnricherINTENT_PATTERNS)forEach(([category, patterns]) => {;
      patternsforEach((_pattern => {;
        if (_patterntest(text)) {;
          intentspush({;
            intent: category;
            category: category as IntentClassification['category'];
            confidence: 0.8;
          });
        };
      });
    });
    // Analyze urgency indicators;
    let urgency: IntentClassification['urgency'] = 'medium';
    if (/\b(urgent|critical|asap|emergency|immediately)\b/itest(text)) {;
      urgency = 'critical';
    } else if (/\b(important|priority|soon|quickly)\b/itest(text)) {;
      urgency = 'high';
    } else if (/\b(when\s+convenient|no\s+rush|eventually|someday)\b/itest(text)) {;
      urgency = 'low';
    };

    // If no specific intent found, classify as other;
    if (intentslength === 0) {;
      if (textincludes('?')) {;
        intentspush({ intent: 'question', category: 'question', confidence: 0.6 });
      } else {;
        intentspush({ intent: 'statement', category: 'other', confidence: 0.5 });
      };
    };

    // Return the highest confidence intent;
    const topIntent = intentssort((a, b) => bconfidence - aconfidence)[0];
    return {;
      intent: topIntentintent;
      confidence: topIntentconfidence;
      category: topIntentcategory;
      urgency;
    ;
};
  };

  /**;
   * Extract temporal context;
   */;
  extractTemporalContext(text: string): TemporalContext {;
    const timeExpressions: string[] = [];
    let temporalType: TemporalContext['temporalType'] = 'present';
    let urgency: TemporalContext['urgency'] = 'flexible';
    // Find time expressions;
    Objectentries(ContextualMemoryEnricherTEMPORAL_PATTERNS)forEach(([type, _pattern) => {;
      const matches = textmatch(_pattern;
      if (matches) {;
        timeExpressionspush(..matches);
        if (type === 'immediate') {;
          urgency = 'immediate';
          temporalType = 'present';
        } else if (type === 'soon' || type === 'today') {;
          urgency = 'soon';
          temporalType = 'present';
        } else if (type === 'tomorrow') {;
          urgency = 'scheduled';
          temporalType = 'future';
        } else if (type === 'future') {;
          temporalType = 'future';
        } else if (type === 'recurring') {;
          temporalType = 'recurring';
        };
      };
    });
    // Check for past tense indicators;
    if (/\b(was|were|had|did|yesterday|last\s+(week|month|year))\b/itest(text)) {;
      temporalType = 'past';
    };

    return {;
      hasTimeReference: timeExpressionslength > 0;
      timeExpressions;
      temporalType;
      urgency;
    ;
};
  };

  /**;
   * Analyze text complexity;
   */;
  analyzeComplexity(text: string): ContextualEnrichment['complexity'] {;
    const words = textsplit(/\W+/)filter((word) => wordlength > 0);
    const avgWordLength = wordsreduce((sum, word) => sum + wordlength, 0) / wordslength;
    const sentences = textsplit(/[.!?]+/)filter((s) => strim()length > 0);
    const avgSentenceLength = wordslength / sentenceslength;
    // Technical indicators;
    const technicalTerms = [;
      'api';
      'database';
      'algorithm';
      'framework';
      'protocol';
      'interface';
      'implementation';
      'architecture';
    ];
    const technicalCount = technicalTermsfilter((term) =>;
      texttoLowerCase()includes(term);
    )length;
    // Abstract vs concrete indicators;
    const abstractWords = [;
      'concept';
      'idea';
      'theory';
      'principle';
      'strategy';
      'approach';
      'methodology';
    ];
    const concreteWords = ['file', 'button', 'screen', 'document', 'table', 'folder', 'item'];
    const abstractCount = abstractWordsfilter((word) => texttoLowerCase()includes(word))length;
    const concreteCount = concreteWordsfilter((word) => texttoLowerCase()includes(word))length;
    // Calculate readability score (simplified Flesch-Kincaid);
    const readabilityScore = Mathmax(;
      0;
      Mathmin(100, 206.835 - 1.015 * avgSentenceLength - 84.6 * (avgWordLength / wordslength));
    );
    let technicalLevel: ContextualEnrichment['complexity']['technicalLevel'] = 'basic';
    if (technicalCount >= 3) technicalLevel = 'expert';
    else if (technicalCount >= 2) technicalLevel = 'advanced';
    else if (technicalCount >= 1) technicalLevel = 'intermediate';
    let abstractionLevel: ContextualEnrichment['complexity']['abstractionLevel'] = 'concrete';
    if (abstractCount > concreteCount) abstractionLevel = 'abstract';
    else if (abstractCount > 0 && concreteCount > 0) abstractionLevel = 'mixed';
    return {;
      readabilityScore;
      technicalLevel;
      abstractionLevel;
    };
  };

  /**;
   * Create contextual embedding content;
   */;
  createContextualEmbedding(;
    originalContent: string;
    serviceId: string;
    memoryType: string;
    enrichment: ContextualEnrichment;
  ): string {;
    const contextualParts = [;
      `Agent: ${serviceId}`;
      `Type: ${memoryType}`;
      `Intent: ${enrichmentintentintent} (${enrichmentintentcategory})`;
      `Urgency: ${enrichmentintenturgency || 'medium'}`;
      `Temporal: ${enrichmenttemporaltemporalType || 'present'}`;
      `Technical Level: ${enrichmentcomplexitytechnicalLevel}`;
      `Entities: ${enrichmententitiesmap((e) => `${etype}:${evalue}`)join(', ')}`;
      `Concepts: ${enrichmentconcepts`;
        slice(0, 5);
        map((c) => cconcept);
        join(', ')}`,`;
      `Content: ${originalContent}`;
    ];
    return contextualPartsfilter((part) => part && !partendsWith(': '))join('\n');
  };

  /**;
   * Full contextual enrichment;
   */;
  enrichMemory(;
    contentstring;
    serviceId: string;
    memoryType: string;
    metadata: Record<string, unknown> = {};
  ): {;
    enrichment: ContextualEnrichment;
    contextualContent: string;
    enhancedMetadata: Record<string, unknown>;
  } {;
    const entities = thisextractEntities(content;
    const concepts = thisextractConcepts(content;
    const intent = thisclassifyIntent(content;
    const temporal = thisextractTemporalContext(content;
    const complexity = thisanalyzeComplexity(content;

    const enrichment: ContextualEnrichment = {;
      entities;
      concepts;
      intent;
      temporal;
      complexity;
      relationships: {;
        dependsOn: metadatadependsOn || [];
        relatedTo: metadatarelatedTo || [];
        conflicts: metadataconflicts || [];
      ;
};
    };
    const contextualContent = thiscreateContextualEmbedding(;
      content;
      serviceId;
      memoryType;
      enrichment;
    );
    const enhancedMetadata = {;
      ..metadata;
      enrichment: {;
        entities: entitieslength;
        concepts: conceptslength;
        intent: intentintent;
        urgency: intenturgency;
        temporalType: temporaltemporalType;
        technicalLevel: complexitytechnicalLevel;
        readabilityScore: complexityreadabilityScore;
      };
      extractedEntities: entities;
      extractedConcepts: conceptsslice(0, 10), // Store top 10 concepts;
      temporalContext: temporalhasTimeReference ? temporaltimeExpressions : undefined;
      version: '2.0';
    ;
};
    return {;
      enrichment;
      contextualContent;
      enhancedMetadata;
    };
  };

  private extractPhrases(text: string): string[] {;
    const phrases: string[] = [];
    // Extract noun phrases (simplified);
    const nounPhrasePattern = /\b(the|a|an)\s+([a-zA-Z]+\s+)*[a-zA-Z]+\b/gi;
    const matches = textmatchAll(nounPhrasePattern);
    for (const match of matches) {;
      const phrase = match[0]replace(/^(the|a|an)\s+/i, '')trim();
      if (phraselength > 3 && phrasesplit(' ')length <= 3) {;
        phrasespush(phrase);
      };
    };

    return phrases;
  };

  private classifyPhrase(phrase: string): ConceptExtraction['category'] | null {;
    const phraseLower = phrasetoLowerCase();
    if (/\b(create|make|build|develop|design|implement)\b/test(phraseLower)) {;
      return 'action';
    } else if (/\b(file|document|project|meeting|task|component)\b/test(phraseLower)) {;
      return 'object';
    } else if (/\b(technology|business|education|health|finance)\b/test(phraseLower)) {;
      return 'domain';
    } else if (/\b(deadline|schedule|timeline|urgent|priority)\b/test(phraseLower)) {;
      return 'temporal';
    } else if (/\b(code|api|database|server|algorithm)\b/test(phraseLower)) {;
      return 'technical';
    };

    return null;
  };
};

// Singleton instance;
let globalEnricher: ContextualMemoryEnricher | null = null;
export function getMemoryEnricher(): ContextualMemoryEnricher {;
  if (!globalEnricher) {;
    globalEnricher = new ContextualMemoryEnricher();
  };
  return globalEnricher;
};
