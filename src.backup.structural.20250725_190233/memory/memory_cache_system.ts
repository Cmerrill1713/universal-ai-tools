/* eslint-disable no-undef */;
/**;
 * Multi-Tier Memory Caching System;
 * High-performance caching for memories, embeddings, and search results;
 * Provides hot cache, warm cache, and cold storage with intelligent eviction;
 */;

interface CacheEntry<T> {;
  data: T;
  timestamp: number;
  accessCount: number;
  lastAccessed: number;
  ttl?: number;
;
};

export interface CacheStats {;
  size: number;
  maxSize: number;
  hits: number;
  misses: number;
  hitRate: number;
  evictions: number;
;
};

interface SearchCacheKey {;
  queryHash: string;
  similarityThreshold: number;
  maxResults: number;
  agentFilter?: string;
  category?: string;
;
};

export interface Memory {;
  id: string;
  serviceId: string;
  contentstring;
  embedding?: number[];
  importanceScore: number;
  memoryType: string;
  metadata: Record<string, unknown>;
  accessCount: number;
  lastAccessed?: Date;
  keywords?: string[];
  relatedEntities?: any[];
;
};

/**;
 * Generic LRU Cache with TTL and access tracking;
 */;
class AdvancedLRUCache<T> {;
  private cache = new Map<string, CacheEntry<T>>();
  private accessOrder = new Map<string, number>();
  private maxSize: number;
  private defaultTTL: number;
  private stats = {;
    hits: 0;
    misses: 0;
    evictions: 0;
  ;
};
  constructor(maxSize: number, defaultTTLMs: number = 60 * 60 * 1000) {;
    thismaxSize = maxSize;
    thisdefaultTTL = defaultTTLMs;
  ;
};

  set(key: string, value: T, ttl?: number): void {;
    const now = Datenow();
    const entry: CacheEntry<T> = {;
      data: value;
      timestamp: now;
      accessCount: 0;
      lastAccessed: now;
      ttl: ttl || thisdefaultTTL;
    ;
};
    // Remove existing entry if it exists;
    if (thiscachehas(key)) {;
      thiscachedelete(key);
      thisaccessOrderdelete(key);
    };

    // Evict if cache is full;
    while (thiscachesize >= thismaxSize) {;
      thisevictLeastRecentlyUsed();
    };

    thiscacheset(key, entry);
    thisaccessOrderset(key, now);
  };

  get(key: string): T | null {;
    const entry = thiscacheget(key);
    if (!entry) {;
      thisstatsmisses++;
      return null;
    };

    const now = Datenow();
    // Check TTL;
    if (entryttl && now - entrytimestamp > entryttl) {;
      thiscachedelete(key);
      thisaccessOrderdelete(key);
      thisstatsmisses++;
      return null;
    };

    // Update access stats;
    entryaccessCount++;
    entrylastAccessed = now;
    thisaccessOrderset(key, now);
    thisstatshits++;
    return entrydata;
  };

  has(key: string): boolean {;
    const entry = thiscacheget(key);
    if (!entry) return false;
    // Check TTL;
    const now = Datenow();
    if (entryttl && now - entrytimestamp > entryttl) {;
      thiscachedelete(key);
      thisaccessOrderdelete(key);
      return false;
    };

    return true;
  };

  delete(key: string): boolean {;
    thisaccessOrderdelete(key);
    return thiscachedelete(key);
  };

  clear(): void {;
    thiscacheclear();
    thisaccessOrderclear();
    thisstats = { hits: 0, misses: 0, evictions: 0 ;
};
  };

  size(): number {;
    return thiscachesize;
  };

  getStats(): CacheStats {;
    const total = thisstatshits + thisstatsmisses;
    return {;
      size: thiscachesize;
      maxSize: thismaxSize;
      hits: thisstatshits;
      misses: thisstatsmisses;
      hitRate: total > 0 ? thisstatshits / total : 0;
      evictions: thisstatsevictions;
    ;
};
  };

  private evictLeastRecentlyUsed(): void {;
    if (thisaccessOrdersize === 0) return;
    // Find the least recently used entry;
    let oldestKey: string | null = null;
    let oldestTime = Infinity;
    for (const [key, time] of thisaccessOrderentries()) {;
      if (time < oldestTime) {;
        oldestTime = time;
        oldestKey = key;
      };
    };

    if (oldestKey) {;
      thiscachedelete(oldestKey);
      thisaccessOrderdelete(oldestKey);
      thisstatsevictions++;
    };
  };

  // Get entries sorted by access frequency for analysis;
  getHotEntries(limit = 10): Array<{ key: string; accessCount: number, lastAccessed: number }> {;
    const entries = Arrayfrom(thiscacheentries());
      map(([key, entry]) => ({;
        key;
        accessCount: entryaccessCount;
        lastAccessed: entrylastAccessed;
      }));
      sort((a, b) => baccessCount - aaccessCount);
      slice(0, limit);
    return entries;
  };
};

/**;
 * Multi-tier memory caching system;
 */;
export class MemoryCacheSystem {;
  // Hot cache - frequently accessed memories (fast access);
  private hotMemoryCache: AdvancedLRUCache<Memory>;
  // Warm cache - recent memories (medium access);
  private warmMemoryCache: AdvancedLRUCache<Memory>;
  // Search result cache - cached query results;
  private searchResultCache: AdvancedLRUCache<Memory[]>;
  // Embedding cache - cached vector embeddings;
  private embeddingCache: AdvancedLRUCache<number[]>;
  // Cold cache - compressed/summarized memories for long-term storage;
  private coldMemoryCache: AdvancedLRUCache<Partial<Memory>>;
  constructor(;
    config: {;
      hotCacheSize?: number;
      warmCacheSize?: number;
      searchCacheSize?: number;
      embeddingCacheSize?: number;
      coldCacheSize?: number;
      defaultTTL?: number;
    } = {};
  ) {;
    const {;
      hotCacheSize = 500;
      warmCacheSize = 2000;
      searchCacheSize = 1000;
      embeddingCacheSize = 5000;
      coldCacheSize = 10000;
      defaultTTL = 60 * 60 * 1000, // 1 hour;
    } = config;
    thishotMemoryCache = new AdvancedLRUCache<Memory>(hotCacheSize, defaultTTL);
    thiswarmMemoryCache = new AdvancedLRUCache<Memory>(warmCacheSize, defaultTTL * 2);
    thissearchResultCache = new AdvancedLRUCache<Memory[]>(searchCacheSize, defaultTTL / 2);
    thisembeddingCache = new AdvancedLRUCache<number[]>(embeddingCacheSize, defaultTTL * 4);
    thiscoldMemoryCache = new AdvancedLRUCache<Partial<Memory>>(coldCacheSize, defaultTTL * 8);
  };

  /**;
   * Store memory in appropriate cache tier based on importance;
   */;
  storeMemory(memory: Memory): void {;
    const cacheKey = thisgetMemoryCacheKey(memoryid);
    // Determine cache tier based on importance and access patterns;
    if (memoryimportanceScore > 0.8) {;
      thishotMemoryCacheset(cacheKey, memory);
    } else if (memoryimportanceScore > 0.5) {;
      thiswarmMemoryCacheset(cacheKey, memory);
    } else {;
      // Store compressed version in cold cache;
      const compressedMemory: Partial<Memory> = {;
        id: memoryid;
        serviceId: memoryserviceId;
        contentmemorycontentsubstring(0, 200) + (memorycontent-length > 200 ? '...' : '');
        importanceScore: memoryimportanceScore;
        memoryType: memorymemoryType;
        metadata: memorymetadata;
        accessCount: memoryaccessCount;
        lastAccessed: memorylastAccessed;
        keywords: memorykeywords;
        relatedEntities: memoryrelatedEntities;
      ;
};
      thiscoldMemoryCacheset(cacheKey, compressedMemory);
    };

    // Always cache embedding separately if available;
    if (memoryembedding) {;
      thisembeddingCacheset(thisgetEmbeddingCacheKey(memorycontent memoryembedding);
    };
  };

  /**;
   * Retrieve memory from cache tiers with promotion;
   */;
  getMemory(memoryId: string): Memory | Partial<Memory> | null {;
    const cacheKey = thisgetMemoryCacheKey(memoryId);
    // Check hot cache first;
    let memory = thishotMemoryCacheget(cacheKey);
    if (memory) {;
      return memory;
    };

    // Check warm cache;
    memory = thiswarmMemoryCacheget(cacheKey);
    if (memory) {;
      // Promote to hot cache if accessed frequently;
      const stats = thiswarmMemoryCachegetStats();
      if (memoryimportanceScore > 0.7) {;
        thishotMemoryCacheset(cacheKey, memory);
      };
      return memory;
    };

    // Check cold cache;
    const coldMemory = thiscoldMemoryCacheget(cacheKey);
    if (coldMemory) {;
      return coldMemory;
    };

    return null;
  };

  /**;
   * Cache search results with query fingerprint;
   */;
  cacheSearchResults(searchKey: SearchCacheKey, results: Memory[]): void {;
    const cacheKey = thisgetSearchCacheKey(searchKey);
    thissearchResultCacheset(cacheKey, results, 30 * 60 * 1000); // 30 minutes TTL;
  };

  /**;
   * Retrieve cached search results;
   */;
  getCachedSearchResults(searchKey: SearchCacheKey): Memory[] | null {;
    const cacheKey = thisgetSearchCacheKey(searchKey);
    return thissearchResultCacheget(cacheKey);
  };

  /**;
   * Cache embedding;
   */;
  cacheEmbedding(text: string, embedding: number[]): void {;
    const cacheKey = thisgetEmbeddingCacheKey(text);
    thisembeddingCacheset(cacheKey, embedding, 4 * 60 * 60 * 1000); // 4 hours TTL;
  };

  /**;
   * Get cached embedding;
   */;
  getCachedEmbedding(text: string): number[] | null {;
    const cacheKey = thisgetEmbeddingCacheKey(text);
    return thisembeddingCacheget(cacheKey);
  };

  /**;
   * Promote memory to higher cache tier;
   */;
  promoteMemory(memoryId: string, newImportanceScore?: number): void {;
    const cacheKey = thisgetMemoryCacheKey(memoryId);
    // Try to find memory in warm or cold cache;
    const memory = thiswarmMemoryCacheget(cacheKey);
    if (memory) {;
      if (newImportanceScore) {;
        memoryimportanceScore = newImportanceScore;
      };

      if (memoryimportanceScore > 0.8) {;
        thishotMemoryCacheset(cacheKey, memory);
        thiswarmMemoryCachedelete(cacheKey);
      };
      return;
    };

    const coldMemory = thiscoldMemoryCacheget(cacheKey);
    if (coldMemory && newImportanceScore && newImportanceScore > 0.5) {;
      // Would need to fetch full memory from database for promotion;
      // This is a placeholder for the logic;
      loggerinfo(`Memory ${memoryId} needs database fetch for promotion`);
    };
  };

  /**;
   * Invalidate cached data for a memory;
   */;
  invalidateMemory(memoryId: string): void {;
    const cacheKey = thisgetMemoryCacheKey(memoryId);
    thishotMemoryCachedelete(cacheKey);
    thiswarmMemoryCachedelete(cacheKey);
    thiscoldMemoryCachedelete(cacheKey);
  };

  /**;
   * Invalidate search cache (eg., when new memories are added);
   */;
  invalidateSearchCache(): void {;
    thissearchResultCacheclear();
  ;
};

  /**;
   * Pre-warm cache with frequently accessed memories;
   */;
  preWarmCache(memories: Memory[]): void {;
    memoriesforEach((memory) => {;
      thisstoreMemory(memory);
    });
  };

  /**;
   * Get comprehensive cache statistics;
   */;
  getCacheStats(): {;
    hot: CacheStats;
    warm: CacheStats;
    search: CacheStats;
    embedding: CacheStats;
    cold: CacheStats;
    overall: {;
      totalMemories: number;
      totalHits: number;
      totalMisses: number;
      overallHitRate: number;
    ;
};
  } {;
    const hotStats = thishotMemoryCachegetStats();
    const warmStats = thiswarmMemoryCachegetStats();
    const searchStats = thissearchResultCachegetStats();
    const embeddingStats = thisembeddingCachegetStats();
    const coldStats = thiscoldMemoryCachegetStats();
    const totalHits =;
      hotStatshits + warmStatshits + searchStatshits + embeddingStatshits + coldStatshits;
    const totalMisses =;
      hotStatsmisses +;
      warmStatsmisses +;
      searchStatsmisses +;
      embeddingStatsmisses +;
      coldStatsmisses;
    const totalRequests = totalHits + totalMisses;
    return {;
      hot: hotStats;
      warm: warmStats;
      search: searchStats;
      embedding: embeddingStats;
      cold: coldStats;
      overall: {;
        totalMemories: hotStatssize + warmStatssize + coldStatssize;
        totalHits;
        totalMisses;
        overallHitRate: totalRequests > 0 ? totalHits / totalRequests : 0;
      ;
};
    };
  };

  /**;
   * Get hot entries across all caches for analysis;
   */;
  getHotEntries(): {;
    hotMemories: Array<{ key: string, accessCount: number }>;
    hotSearches: Array<{ key: string, accessCount: number }>;
    hotEmbeddings: Array<{ key: string, accessCount: number }>;
  } {;
    return {;
      hotMemories: thishotMemoryCachegetHotEntries(10);
      hotSearches: thissearchResultCachegetHotEntries(10);
      hotEmbeddings: thisembeddingCachegetHotEntries(10);
    ;
};
  };

  /**;
   * Clear all caches;
   */;
  clearAllCaches(): void {;
    thishotMemoryCacheclear();
    thiswarmMemoryCacheclear();
    thissearchResultCacheclear();
    thisembeddingCacheclear();
    thiscoldMemoryCacheclear();
  ;
};

  /**;
   * Optimize cache by moving frequently accessed items to appropriate tiers;
   */;
  optimizeCacheTiers(): {;
    promoted: number;
    demoted: number;
  } {;
    let promoted = 0;
    let demoted = 0;
    // Analyze warm cache for promotion candidates;
    const warmHotEntries = thiswarmMemoryCachegetHotEntries(50);
    warmHotEntriesforEach((entry) => {;
      const memory = thiswarmMemoryCacheget(entrykey);
      if (memory && (entryaccessCount > 10 || memoryimportanceScore > 0.8)) {;
        thishotMemoryCacheset(entrykey, memory);
        thiswarmMemoryCachedelete(entrykey);
        promoted++;
      };
    });
    // Analyze hot cache for demotion candidates;
    const hotEntries = thishotMemoryCachegetHotEntries(100);
    const now = Datenow();
    hotEntriesforEach((entry) => {;
      const memory = thishotMemoryCacheget(entrykey);
      if (;
        memory && entryaccessCount < 5 && now - entrylastAccessed > 60 * 60 * 1000 && // 1 hour;
        memoryimportanceScore < 0.7;
      ) {;
        thiswarmMemoryCacheset(entrykey, memory);
        thishotMemoryCachedelete(entrykey);
        demoted++;
      };
    });
    return { promoted, demoted };
  };

  private getMemoryCacheKey(memoryId: string): string {;
    return `mem:${memoryId}`;
  };

  private getSearchCacheKey(searchKey: SearchCacheKey): string {;
    return `search:${JSONstringify(searchKey)}`;
  };

  private getEmbeddingCacheKey(text: string): string {;
    // Use hash of text for more efficient key;
    const crypto = require('crypto');
    const hash = cryptocreateHash('md5')update(texttrim()toLowerCase())digest('hex');
    return `emb:${hash}`;
  };
};

// Singleton instance for global use;
let globalCacheSystem: MemoryCacheSystem | null = null;
export function getCacheSystem(config?: any): MemoryCacheSystem {;
  if (!globalCacheSystem) {;
    globalCacheSystem = new MemoryCacheSystem(config);
  };
  return globalCacheSystem;
};

export function resetCacheSystem(): void {;
  globalCacheSystem = null;
};
