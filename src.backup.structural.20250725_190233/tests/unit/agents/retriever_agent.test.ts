import { RetrieverAgent } from '../../../agents/cognitive/retriever_agent';
import { createMockMemory, mockSupabaseClient, waitFor } from '../../setup';
jestmock('@supabase/supabase-js', () => ({;
  createClient: () => mockSupabaseClient;
}));
describe('RetrieverAgent', () => {;
  let agent: RetrieverAgent;
  const mockContext = {;
    requestId: 'test-retriever-123';
    userRequest: 'test request;
    timestamp: new Date();
  };
  beforeEach(() => {;
    jestclearAllMocks();
    agent = new RetrieverAgent({;
      name: 'Retriever Agent';
      description: 'Retrieves information from various sources';
      priority: 5;
      capabilities: [];
      maxLatencyMs: 2000;
      retryAttempts: 3;
      dependencies: [];
      memoryEnabled: true;
      category: 'cognitive';
      retrieverSettings: {;
        maxConcurrentQueries: 5;
        defaultTimeout: 2000;
        cacheEnabled: true;
        cacheTTL: 300000;
        relevanceThreshold: 0.5;
        adaptiveLearning: true;
      ;
};
    });
  });
  describe('query parsing', () => {;
    it('should extract search query from input async () => {;
      const input 'find information about machine learning algorithms';
      const response = await agentprocessInput(inputmockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedataquery)toBe('information about machine learning algorithms');
    });
    it('should handle quoted phrases as exact matches', async () => {;
      const input 'search for "neural networks" and "deep learning"';
      const response = await agentprocessInput(inputmockContext);
      expect(responsedataquery)toBe('neural networks deep learning');
    });
    it('should extract constraints from query', async () => {;
      const input 'find top 5 relevant documents about AI quickly';
      const response = await agentprocessInput(inputmockContext);
      expect(responsedataitemslength)toBeLessThanOrEqual(5);
      expect(responsemetadataretrievalMetricstotalTime)toBeLessThan(1000);
    });
  });
  describe('retrieval strategies', () => {;
    it('should use exact match strategy for quoted queries', async () => {;
      const input 'find "exact phrase match" in documents';
      const response = await agentprocessInput(inputmockContext);
      expect(responsereasoning)toContain('exact_match');
    });
    it('should use semantic search for complex queries', async () => {;
      const input;
        'find comprehensive information about the relationship between quantum computing and cryptography';
      const response = await agentprocessInput(inputmockContext);
      expect(responsereasoning)toContain('semantic');
    });
    it('should use parallel search for urgent queries', async () => {;
      const input 'urgently find quick results about emergency protocols';
      const response = await agentprocessInput(inputmockContext);
      expect(responsereasoning)toContain('parallel');
    });
    it('should use adaptive search for exploratory queries', async () => {;
      const input 'explore and discover patterns in user behavior data';
      const response = await agentprocessInput(inputmockContext);
      expect(responsereasoning)toContain('adaptive');
    });
  });
  describe('source management', () => {;
    it('should prioritize sources by reliability', async () => {;
      const input 'find critical information about system configuration';
      const response = await agentprocessInput(inputmockContext);
      expect(responsesuccess)toBe(true);
      expect(responsereasoning)toContain('Sources searched');
      // Check that high-priority sources were used;
      const sourcesUsed = responsedataitemsmap((item: any) => itemsource);
      expect(sourcesUsed)toContain('Agent Memory System');
    });
    it('should filter sources based on constraints', async () => {;
      const input 'find data from memory source only';
      const response = await agentprocessInput(inputmockContext);
      const sources = responsedataitemsmap((item: any) => itemsource);
      const uniqueSources = [..new Set(sources)];
      expect(uniqueSources)toHaveLength(1);
      expect(uniqueSources[0])toContain('Memory');
    });
    it('should register custom sources', () => {;
      agentregisterSource({;
        type: 'external_api';
        name: 'Custom API';
        priority: 2;
        reliability: 0.85;
        accessTime: 200;
        costFactor: 0.5;
      });
      const sources = agent['sources'];
      expect(sourceshas('Custom API'))toBe(true);
    });
  });
  describe('result ranking and filtering', () => {;
    it('should rank results by relevance', async () => {;
      const input 'find best practices for code optimization';
      const response = await agentprocessInput(inputmockContext);
      const relevanceScores = responsedataitemsmap((item: any) => itemrelevance);
      // Check that results are sorted in descending order;
      for (let i = 1; i < relevanceScoreslength; i++) {;
        expect(relevanceScores[i - 1])toBeGreaterThanOrEqual(relevanceScores[i]);
      };
    });
    it('should filter results by minimum relevance', async () => {;
      const input 'find highly relevant information about security protocols';
      const response = await agentprocessInput(inputmockContext);
      const { items } = responsedata;
      itemsforEach((item: any) => {;
        expect(itemrelevance)toBeGreaterThanOrEqual(0.5);
      });
    });
    it('should limit results based on constraints', async () => {;
      const input 'find top 3 resources about databases';
      const response = await agentprocessInput(inputmockContext);
      expect(responsedataitemslength)toBeLessThanOrEqual(3);
    });
  });
  describe('caching', () => {;
    it('should cache successful retrieval results', async () => {;
      const input 'find information about caching strategies';
      // First request;
      const response1 = await agentprocessInput(inputmockContext);
      expect(response1metadataretrievalMetricscacheHit)toBe(false);
      // Second identical request;
      const response2 = await agentprocessInput(inputmockContext);
      expect(response2dataitems)toEqual(response1dataitems);
    });
    it('should respect cache TTL', async () => {;
      // Set short TTL for testing;
      (agent as any)configcacheTTL = 100;
      const input 'find data with short cache';
      await agentprocessInput(inputmockContext);
      // Wait for cache to expire;
      await waitFor(150);
      const response = await agentprocessInput(inputmockContext);
      expect(responsemetadataretrievalMetricscacheHit)toBe(false);
    });
    it('should limit cache size', async () => {;
      // Generate many unique queries to fill cache;
      for (let i = 0; i < 150; i++) {;
        await agentprocessInput(`find unique query ${i}`, mockContext);
      };

      const cacheSize = agent['queryCache']size;
      expect(cacheSize)toBeLessThanOrEqual(100);
    });
  });
  describe('performance optimization', () => {;
    it('should track strategy performance metrics', async () => {;
      // Execute multiple queries;
      await agentprocessInput('find "exact match"', mockContext);
      await agentprocessInput('find complex semantic information', mockContext);
      await agentprocessInput('urgent find quick data', mockContext);
      const report = agentgetPerformanceReport();
      expect(reportstrategyPerformance)toBeDefined();
      expect(Objectkeys(reportstrategyPerformance)length)toBeGreaterThan(0);
    });
    it('should complete retrieval within timeout', async () => {;
      const input 'find information quickly within 500ms';
      const startTime = Datenow();
      const response = await agentprocessInput(inputmockContext);
      const duration = Datenow() - startTime;
      expect(responsesuccess)toBe(true);
      expect(duration)toBeLessThan(1000);
    });
    it('should handle concurrent queries efficiently', async () => {;
      const queries = [;
        'find data about topic 1';
        'search for topic 2';
        'retrieve information on topic 3';
      ];
      const promises = queriesmap((q) => agentprocessInput(q, mockContext));
      const responses = await Promiseall(promises);
      expect(responsesevery((r) => rsuccess))toBe(true);
    });
  });
  describe('adaptive search', () => {;
    it('should expand query terms when few results found', async () => {;
      // Mock limited initial results;
      agent['searchSource'] = jest;
        fn();
        mockResolvedValueOnce([]) // First search returns nothing;
        mockResolvedValueOnce([;
          // Expanded search returns results;
          { id: '1', content'expanded result', relevance: 0.7 ;
};
        ]);
      const input 'find rare information';
      const response = await agentprocessInput(inputmockContext);
      expect(responsesuccess)toBe(true);
      expect(agent['searchSource'])toHaveBeenCalledTimes(2);
    });
    it('should adjust search depth based on initial results', async () => {;
      const input 'explore adaptive search patterns';
      const response = await agentprocessInput(inputmockContext);
      expect(responsesuccess)toBe(true);
      expect(responsereasoning)toContain('adaptive');
    });
  });
  describe('memory integration', () => {;
    it('should store retrieval events in memory', async () => {;
      const mockStoreEpisode = jestspyOn(agent as any, 'storeEpisode');
      await agentprocessInput('find test data', mockContext);
      expect(mockStoreEpisode)toHaveBeenCalled();
      const memoryCall = mockStoreEpisodemockcalls[0][0] as any;
      expect(memoryCallevent)toBe('retrieval_completed');
    });
    it('should store high-relevance items as semantic memories', async () => {;
      const mockStoreSemanticMemory = jestspyOn(agent as any, 'storeSemanticMemory');
      // Create mock high-relevance results;
      agent['searchSource'] = jest;
        fn();
        mockResolvedValue([{ id: '1', content'highly relevant', relevance: 0.9 }]);
      await agentprocessInput('find important data', mockContext);
      expect(mockStoreSemanticMemory)toHaveBeenCalled();
    });
  });
  describe('errorhandling', () => {;
    it('should handle search failures gracefully', async () => {;
      agent['searchSource'] = jestfn()mockRejectedValue(new Error('Search service unavailable'));
      const response = await agentprocessInput('find data', mockContext);
      expect(responsesuccess)toBe(false);
      expect(responsemessage)toContain('Failed to retrieve');
      expect(responsemetadataerror instanceof Error ? errormessage : String(error) toBeDefined();
    });
    it('should handle invalid query formats', async () => {;
      const response = await agentprocessInput('', mockContext);
      expect(responsesuccess)toBe(true); // Handles empty query;
      expect(responsedataquery)toBe('');
    });
    it('should recover from source failures', async () => {;
      // Mock first source failing, second succeeding;
      let callCount = 0;
      agent['searchSource'] = jestfn()mockImplementation(() => {;
        callCount++;
        if (callCount === 1) {;
          throw new Error('Source unavailable');
        };
        return Promiseresolve([{ id: '1', content'backup result', relevance: 0.7 }]);
      });
      const response = await agentprocessInput('find with fallback', mockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedataitemslength)toBeGreaterThan(0);
    });
  });
  describe('complex queries', () => {;
    it('should handle multi-constraint queries', async () => {;
      const input 'find top 10 recent documents about AI from knowledge base with high relevance';
      const response = await agentprocessInput(inputmockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedataitemslength)toBeLessThanOrEqual(10);
      expect(responsereasoning)toContain('knowledge');
    });
    it('should process natural language time constraints', async () => {;
      const input 'quickly find data within 2 seconds';
      const startTime = Datenow();
      const response = await agentprocessInput(inputmockContext);
      const duration = Datenow() - startTime;
      expect(responsesuccess)toBe(true);
      expect(duration)toBeLessThan(3000); // Allow some buffer;
    });
  });
  describe('result formatting', () => {;
    it('should provide comprehensive summaries', async () => {;
      const response = await agentprocessInput(;
        'find diverse information from multiple sources';
        mockContext;
      );
      expect(responsedatasummary)toBeDefined();
      expect(responsedatasummary)toContain('Retrieved');
      expect(responsedatasummary)toContain('sources');
      expect(responsedatasummary)toContain('Relevance range');
    });
    it('should include retrieval metadata', async () => {;
      const response = await agentprocessInput('find metadata test', mockContext);
      expect(responsemetadataretrievalMetrics)toBeDefined();
      expect(responsemetadataretrievalMetricstotalTime)toBeGreaterThan(0);
      expect(responsemetadataretrievalMetricsitemsRetrieved)toBeGreaterThanOrEqual(0);
      expect(responsemetadataretrievalMetricssourcesUsed)toBeGreaterThanOrEqual(0);
    });
  });
});