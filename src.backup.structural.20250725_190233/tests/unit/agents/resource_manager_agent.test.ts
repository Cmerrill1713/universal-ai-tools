import { ResourceManagerAgent } from '../../../agents/cognitive/resource_manager_agent';
import { createMockMemory, waitFor } from '../../setup';
describe('ResourceManagerAgent', () => {;
  let agent: ResourceManagerAgent;
  const mockContext = {;
    requestId: 'test-request23';
    userRequest: 'test request;
    timestamp: new Date();
  };
  beforeEach(() => {;
    jestclearAllMocks();
    agent = new ResourceManagerAgent({;
      name: 'Resource Manager';
      description: 'Manages system resources';
      priority: 5;
      capabilities: [];
      maxLatencyMs: 5000;
      retryAttempts: 3;
      dependencies: [];
      memoryEnabled: true;
      category: 'cognitive';
      resourceSettings: {;
        maxConcurrentAllocations: 10;
        allocationTimeout: 5000;
        optimizationInterval: 60000;
        oversubscriptionRatio: 1.2;
        priorityLevels: 5;
        enablePreemption: true;
      ;
};
    });
  });
  describe('resource allocation', () => {;
    it('should allocate resources for valid requests', async () => {;
      const input 'allocate 100 cores of compute for data processing';
      const response = await agentprocessInput(inputmockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedata)toHaveProperty('allocationId');
      expect(responsedataamountAllocated)toBe(100);
      expect(responsedataresourceName)toContain('Compute');
      expect(responsemessage)toContain('Successfully allocated');
    });
    it('should handle priority allocations', async () => {;
      const input 'urgently need 500MB memory for critical task';
      const response = await agentprocessInput(inputmockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedataamountAllocated)toBe(500);
      const allocation = agent['allocations']get(responsedataallocationId);
      expect(allocation?priority)toBe(5); // High priority;
    });
    it('should queue requests when resources unavailable', async () => {;
      // Allocate all available compute;
      await agentprocessInput('allocate 1000 cores of compute', mockContext);
      // Try to allocate more;
      const response = await agentprocessInput('allocate 500 cores of compute', mockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedatastatus)toBe('pending');
      expect(responsedataqueuePosition)toBeGreaterThan(0);
      expect(responsemessage)toContain('queued');
    });
    it('should enforce resource limits', async () => {;
      const input 'allocate 50000 cores of compute'; // Exceeds capacity;
      const response = await agentprocessInput(inputmockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedatastatus)toBe('pending');
      expect(responsereasoning)toContain('Insufficient capacity');
    });
  });
  describe('resource release', () => {;
    it('should release allocated resources', async () => {;
      // First allocate;
      const allocResponse = await agentprocessInput('allocate 200 cores of compute', mockContext);
      const { allocationId } = allocResponsedata;
      // Then release;
      const releaseResponse = await agentprocessInput(;
        `release allocation ${allocationId}`;
        mockContext;
      );
      expect(releaseResponsesuccess)toBe(true);
      expect(releaseResponsedataallocationId)toBe(allocationId);
      expect(releaseResponsedataamountReleased)toBe(200);
      expect(releaseResponsemessage)toContain('Successfully released');
    });
    it('should auto-release after duration expires', async () => {;
      const response = await agentprocessInput(;
        'allocate 100 cores for 100 milliseconds';
        mockContext;
      );
      expect(responsesuccess)toBe(true);
      const { allocationId } = responsedata;
      // Wait for auto-release;
      await waitFor(150);
      const allocation = agent['allocations']get(allocationId);
      expect(allocation?status)toBe('completed');
    });
    it('should process pending requests after release', async () => {;
      // Fill capacity;
      await agentprocessInput('allocate 900 cores', mockContext);
      // Queue a request;
      const pendingResponse = await agentprocessInput('allocate 200 cores', mockContext);
      expect(pendingResponsedatastatus)toBe('pending');
      // Release some resources;
      await agentprocessInput('release allocation for test-agent', mockContext);
      // Check if pending requestwas processed;
      await waitFor(50);
      const pendingRequests = agent['pendingRequests'];
      expect(pendingRequests)toHaveLength(0);
    });
  });
  describe('resource optimization', () => {;
    it('should optimize resource distribution', async () => {;
      // Create suboptimal allocations;
      await agentprocessInput('allocate 300 cores', mockContext);
      await agentprocessInput('allocate 200 cores', { ..mockContext, requestId: 'agent2' });
      await agentprocessInput('allocate 100 cores', { ..mockContext, requestId: 'agent3' });
      const response = await agentprocessInput('optimize resources', mockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedatastrategy)toBeDefined();
      expect(responsedataallocationsOptimized)toBeGreaterThan(0);
      expect(responsereasoning)toContain('optimization');
    });
    it('should select appropriate optimization strategy', async () => {;
      // Create high priority spread;
      await agentprocessInput('allocate 100 cores with high priority', mockContext);
      await agentprocessInput('allocate 100 cores with low priority', mockContext);
      const response = await agentprocessInput('optimize', mockContext);
      expect(responsedatastrategy)toContain('priority');
    });
    it('should calculate optimization improvements', async () => {;
      // Setup for cost optimization;
      await agentprocessInput('allocate 500 storage', mockContext);
      const response = await agentprocessInput('optimize for cost', mockContext);
      expect(responsedataimprovements)toBeDefined();
      expect(responsedataimprovements)toHaveProperty('costImprovement');
      expect(responsedataimprovements)toHaveProperty('loadBalanceImprovement');
    });
  });
  describe('resource status and monitoring', () => {;
    it('should provide comprehensive status report', async () => {;
      // Create some allocations;
      await agentprocessInput('allocate 200 cores', mockContext);
      await agentprocessInput('allocate 1000 MB memory', mockContext);
      const response = await agentprocessInput('show resource status', mockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedatasummary)toBeDefined();
      expect(responsedatasummarytotalResources)toBeGreaterThan(0);
      expect(responsedatasummaryactiveAllocations)toBe(2);
      expect(responsedataresources)toBeInstanceOf(Array);
      expect(responsedatatopConsumers)toBeInstanceOf(Array);
    });
    it('should track resource metrics', async () => {;
      // Perform multiple allocations and releases;
      for (let i = 0; i < 5; i++) {;
        const allocResponse = await agentprocessInput(;
          `allocate ${100 + i * 50} cores`;
          mockContext;
        );
        await agentprocessInput(`release ${allocResponsedataallocationId}`, mockContext);
      };

      const metrics = agentgetMetricsReport();
      expect(metrics)toBeDefined();
      expect(Objectkeys(metrics)length)toBeGreaterThan(0);
    });
    it('should provide utilization insights', async () => {;
      const response = await agentprocessInput('what is the current utilization?', mockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedatainsights)toBeDefined();
      expect(responsedatainsightssome((i: any) => itype === 'capacity'))toBe(true);
    });
  });
  describe('resource forecasting', () => {;
    it('should generate resource forecasts', async () => {;
      // Create historical data;
      for (let i = 0; i < 10; i++) {;
        await agentprocessInput(`allocate ${50 + i * 10} cores`, mockContext);
      };

      const response = await agentprocessInput(;
        'forecast resource usage for next 24 hours';
        mockContext;
      );
      expect(responsesuccess)toBe(true);
      expect(responsedatahorizon)toBe('24 hours');
      expect(responsedatapredictions)toBeDefined();
      expect(responsedatapredictionspeakUtilization)toBeDefined();
      expect(responsedatapredictionsresourceShortages)toBeDefined();
      expect(responsedatarecommendations)toBeInstanceOf(Array);
    });
    it('should identify usage trends', async () => {;
      // Simulate increasing usage;
      for (let hour = 0; hour < 5; hour++) {;
        await agentprocessInput(`allocate ${100 * (hour + 1)} cores`, {;
          ..mockContext;
          requestId: `trend-${hour}`;
          timestamp: new Date(Datenow() + hour * 3600000);
        });
      };

      const response = await agentprocessInput('analyze usage trends', mockContext);
      expect(responsesuccess)toBe(true);
      expect(;
        responsedatainsightssome(;
          (i: any) => itype === 'trends' && idetailsweeklyGrowthincludes('+');
        );
      )toBe(true);
    });
    it('should project costs', async () => {;
      // Create allocations with costs;
      await agentprocessInput('allocate 1000 cores', mockContext);
      await agentprocessInput('allocate 5000 MB memory', mockContext);
      const response = await agentprocessInput('forecast costs for next week', mockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedatapredictionscostProjection)toBeDefined();
      expect(responsedatapredictionscostProjectionprojected)toBeDefined();
    });
  });
  describe('advanced resource management', () => {;
    it('should handle exclusive access requests', async () => {;
      const response = await agentprocessInput(;
        'allocate 500 cores with exclusive access';
        mockContext;
      );
      expect(responsesuccess)toBe(true);
      // Try to allocate same resource;
      const response2 = await agentprocessInput('allocate 100 cores', {;
        ..mockContext;
        requestId: 'other-agent';
      });
      // Should be queued or use different resource;
      expect(response2dataresourceId)nottoBe(responsedataresourceId);
    });
    it('should respect minimum allocation amounts', async () => {;
      const response = await agentprocessInput(;
        'allocate compute with at least 300 cores';
        mockContext;
      );
      expect(responsesuccess)toBe(true);
      expect(responsedataamountAllocated)toBeGreaterThanOrEqual(300);
    });
    it('should handle preferred resources', async () => {;
      const response = await agentprocessInput(;
        'allocate 100 cores from Primary Compute Pool';
        mockContext;
      );
      expect(responsesuccess)toBe(true);
      expect(responsedataresourceName)toContain('Primary Compute Pool');
    });
  });
  describe('resource types', () => {;
    it('should manage compute resources', async () => {;
      const response = await agentprocessInput('allocate 250 compute cores', mockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedataunit)toBe('cores');
    });
    it('should manage memory resources', async () => {;
      const response = await agentprocessInput('allocate 4096 MB of memory', mockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedataunit)toBe('MB');
      expect(responsedataamountAllocated)toBe(4096);
    });
    it('should manage API quota', async () => {;
      const response = await agentprocessInput('allocate 1000 API calls', mockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedataunit)toBe('calls/hour');
    });
    it('should manage token budget', async () => {;
      const response = await agentprocessInput(;
        'allocate 50000 tokens for processing';
        mockContext;
      );
      expect(responsesuccess)toBe(true);
      expect(responsedataunit)toBe('tokens');
    });
  });
  describe('errorhandling', () => {;
    it('should handle invalid allocation requests', async () => {;
      const response = await agentprocessInput('allocate invalid resource type', mockContext);
      expect(responsesuccess)toBe(true); // Gracefully handles by defaulting;
      expect(responsedata)toBeDefined();
    });
    it('should handle release of non-existent allocations', async () => {;
      const response = await agentprocessInput('release allocation invalid-id', mockContext);
      expect(responsesuccess)toBe(false);
      expect(responsemessage)toContain('not found');
    });
    it('should recover from optimization failures', async () => {;
      // Force an optimization with no allocations;
      const response = await agentprocessInput('optimize resources', mockContext);
      expect(responsesuccess)toBe(true);
      expect(responsedataallocationsOptimized)toBe(0);
    });
  });
  describe('performance', () => {;
    it('should handle concurrent allocations efficiently', async () => {;
      const promises = [];
      for (let i = 0; i < 10; i++) {;
        promisespush(;
          agentprocessInput(`allocate ${50 + i * 10} cores`, {;
            ..mockContext;
            requestId: `agent-${i}`;
          });
        );
      };

      const responses = await Promiseall(promises);
      const successCount = responsesfilter((r) => rsuccess)length;
      expect(successCount)toBe(10);
    });
    it('should complete operations within timeout', async () => {;
      const startTime = Datenow();
      await agentprocessInput('allocate 500 cores for complex computation', mockContext);
      const duration = Datenow() - startTime;
      expect(duration)toBeLessThan(1000); // Should complete within 1 second;
    });
  });
});