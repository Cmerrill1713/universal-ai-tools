/**;
 * Tests for Task-Aware Temperature Controller;
 */;

import { TemperatureController } from '../../services/temperature_controller';
// Mock dependencies;
jestmock('../../utils/logger');
// Track mock function calls;
const mockSelect = jestfn();
const mockUpsert = jestfn();
const mockFrom = jestfn();
// Configure mock behavior;
mockFrommockReturnValue({;
  select: mockSelect;
  upsert: mockUpsert;
});
mockSelectmockResolvedValue({ data: [], error instanceof Error ? errormessage : String(error) null });
mockUpsertmockResolvedValue({ error instanceof Error ? errormessage : String(error) null });
jestmock('../../services/supabase_service', () => ({;
  SupabaseService: {;
    getInstance: () => ({;
      client: {;
        from: mockFrom;
      ;
};
    });
  };
}));
describe('TemperatureController', () => {;
  let temperatureController: TemperatureController;
  let originalRandom: () => number;
  beforeEach(() => {;
    jestclearAllMocks();
    // Save original Mathrandom;
    originalRandom = Mathrandom;
    // Mock Mathrandom to disable A/B testing by default;
    Mathrandom = () => 0.5; // Greater than 0.1 sample rate;
    // Reset singleton instance;
    (TemperatureController as any)instance = undefined;
    temperatureController = TemperatureControllergetInstance();
  });
  afterEach(() => {;
    jestclearAllMocks();
    // Restore original Mathrandom;
    Mathrandom = originalRandom;
  });
  describe('Task-Specific Temperature Profiles', () => {;
    it('should return correct temperature ranges for different task types', async () => {;
      const testCases = [;
        { task: 'creative_writing', minTemp: 0.7, maxTemp: 1.0, defaultTemp: 0.85 ;
};
        { task: 'code_generation', minTemp: 0.0, maxTemp: 0.3, defaultTemp: 0.1 ;
};
        { task: 'factual_qa', minTemp: 0.0, maxTemp: 0.2, defaultTemp: 0.1 ;
};
        { task: 'brainstorming', minTemp: 0.6, maxTemp: 0.9, defaultTemp: 0.75 ;
};
        { task: '_analysis, minTemp: 0.2, maxTemp: 0.4, defaultTemp: 0.3 ;
};
      ];
      for (const { task, minTemp, maxTemp, defaultTemp } of testCases) {;
        const params = await temperatureControllergetOptimalParams(task);
        expect(paramstemperature)toBeGreaterThanOrEqual(minTemp);
        expect(paramstemperature)toBeLessThanOrEqual(maxTemp);
        expect(paramstemperature)toBeCloseTo(defaultTemp, 1);
      };
    });
    it('should handle unknown task types with general profile', async () => {;
      const params = await temperatureControllergetOptimalParams('unknown_task');
      expect(paramstemperature)toBeGreaterThanOrEqual(0.3);
      expect(paramstemperature)toBeLessThanOrEqual(0.7);
    });
  });
  describe('Context-Based Adjustments', () => {;
    it('should adjust temperature based on complexity', async () => {;
      const baseParams = await temperatureControllergetOptimalParams('_analysis);
      const lowComplexity = await temperatureControllergetOptimalParams('_analysis, {;
        complexity: 'low';
      });
      const highComplexity = await temperatureControllergetOptimalParams('_analysis, {;
        complexity: 'high';
      });
      // For _analysistasks, low complexity reduces temperature, high complexity increases it;
      expect(lowComplexitytemperature)toBeLessThan(baseParamstemperature);
      expect(highComplexitytemperature)toBeGreaterThan(baseParamstemperature);
    });
    it('should respect user preferences within bounds', async () => {;
      const params = await temperatureControllergetOptimalParams('code_generation', {;
        userPreference: 0.5;
      });
      // Should clamp to max allowed for code generation (0.3);
      expect(paramstemperature)toBeLessThanOrEqual(0.3);
    });
    it('should increase temperature for retry attempts', async () => {;
      const firstAttempt = await temperatureControllergetOptimalParams('general');
      const secondAttempt = await temperatureControllergetOptimalParams('general', {;
        previousAttempts: 1;
      });
      const thirdAttempt = await temperatureControllergetOptimalParams('general', {;
        previousAttempts: 2;
      });
      expect(secondAttempttemperature)toBeGreaterThan(firstAttempttemperature);
      expect(thirdAttempttemperature)toBeGreaterThan(secondAttempttemperature);
    });
    it('should adjust for quality requirements', async () => {;
      const speed = await temperatureControllergetOptimalParams('general', {;
        qualityRequirement: 'speed';
      });
      const balanced = await temperatureControllergetOptimalParams('general', {;
        qualityRequirement: 'balanced';
      });
      const quality = await temperatureControllergetOptimalParams('general', {;
        qualityRequirement: 'quality';
      });
      expect(speedtemperature)toBeLessThan(balancedtemperature);
      expect(qualitytemperature)toBeGreaterThan(balancedtemperature);
    });
  });
  describe('Complementary Parameters', () => {;
    it('should calculate appropriate complementary parameters', async () => {;
      const creativeParams = await temperatureControllergetOptimalParams('creative_writing');
      const codeParams = await temperatureControllergetOptimalParams('code_generation');
      // Creative writing should have higher top-k and repetition penalty;
      expect(creativeParamstopK)toBeGreaterThan(codeParamstopK!);
      expect(creativeParamsrepetitionPenalty)toBeGreaterThan(codeParamsrepetitionPenalty!);
      // Code generation should have no repetition penalty;
      expect(codeParamsrepetitionPenalty)toBe(1.0);
      // Both should have top-p values;
      expect(creativeParamstopP)toBeDefined();
      expect(codeParamstopP)toBeDefined();
    });
    it('should set presence/frequency penalties for high temperatures', async () => {;
      const highTempParams = await temperatureControllergetOptimalParams('creative_writing');
      const lowTempParams = await temperatureControllergetOptimalParams('code_generation');
      expect(highTempParamspresencePenalty)toBeDefined();
      expect(highTempParamsfrequencyPenalty)toBeDefined();
      expect(lowTempParamspresencePenalty)toBeUndefined();
      expect(lowTempParamsfrequencyPenalty)toBeUndefined();
    });
  });
  describe('Learning and Optimization', () => {;
    it('should record results for future optimization', async () => {;
      await temperatureControllerrecordResult('code_generation', 0.1, true, 0.9);
      await temperatureControllerrecordResult('code_generation', 0.2, false, 0.3);
      await temperatureControllerrecordResult('code_generation', 0.15, true, 0.95);
      // Get recommendations to see if learning was applied;
      const recommendations = temperatureControllergetRecommendations();
      const codeRec = recommendationsfind((r) => rtaskType === 'code_generation');
      expect(codeRec?performance)toBeDefined();
      expect(codeRec?performance?successRate)toBeGreaterThan(0);
      expect(codeRec?performance?totalGenerations)toBe(3);
    });
  });
  describe('Recommendations', () => {;
    it('should provide comprehensive recommendations for all task types', () => {;
      const recommendations = temperatureControllergetRecommendations();
      expect(recommendationslength)toBeGreaterThan(5);
      recommendationsforEach((rec) => {;
        expect(rectaskType)toBeDefined();
        expect(recdescription)toBeDefined();
        expect(recrecommended)toBeGreaterThan(0);
        expect(recrangemin)toBeLessThanOrEqual(recrangemax);
        expect(recrecommended)toBeGreaterThanOrEqual(recrangemin);
        expect(recrecommended)toBeLessThanOrEqual(recrangemax);
      });
    });
    it('should include learned temperatures when available', async () => {;
      // Record multiple successful results;
      for (let i = 0; i < 15; i++) {;
        await temperatureControllerrecordResult('code_generation', 0.15, true, 0.9);
      };

      const recommendations = temperatureControllergetRecommendations();
      const codeRec = recommendationsfind((r) => rtaskType === 'code_generation');
      expect(codeRec?learned)toBeDefined();
      expect(codeRec?learned)toBeGreaterThan(0);
    });
  });
  describe('Edge Cases and Error Handling', () => {;
    it('should handle unknown task types gracefully', async () => {;
      const params = await temperatureControllergetOptimalParams('completely_unknown_task');
      // Should default to general profile;
      expect(paramstemperature)toBeGreaterThanOrEqual(0.3);
      expect(paramstemperature)toBeLessThanOrEqual(0.7);
    });
    it('should handle partial task type matches', async () => {;
      const params1 = await temperatureControllergetOptimalParams('code');
      const params2 = await temperatureControllergetOptimalParams('creative');
      // Should match code_generation and creative_writing profiles respectively;
      expect(params1temperature)toBeLessThanOrEqual(0.3);
      expect(params2temperature)toBeGreaterThanOrEqual(0.7);
    });
    it('should handle extreme user preferences', async () => {;
      const params1 = await temperatureControllergetOptimalParams('code_generation', {;
        userPreference: 10.0, // Way too high;
      });
      const params2 = await temperatureControllergetOptimalParams('code_generation', {;
        userPreference: -5.0, // Negative;
      });
      // Should clamp to profile bounds;
      expect(params1temperature)toBe(0.3); // Max for code_generation;
      expect(params2temperature)toBe(0.0); // Min for code_generation;
    });
    it('should handle excessive retry attempts', async () => {;
      const params = await temperatureControllergetOptimalParams('general', {;
        previousAttempts: 100;
      });
      // Should cap the adjustment;
      const baseParams = await temperatureControllergetOptimalParams('general');
      expect(paramstemperature - baseParamstemperature)toBeLessThanOrEqual(0.1);
    });
    it('should handle null quality scores in recordResult', async () => {;
      // Should not throw;
      await expect(temperatureControllerrecordResult('general', 0.5, true))resolvesnottoThrow();
      await expect(;
        temperatureControllerrecordResult('general', 0.5, false);
      )resolvesnottoThrow();
    });
    it('should handle database errors gracefully', async () => {;
      mockFrommockReturnValueOnce({;
        select: jestfn()mockResolvedValue({ data: null, error instanceof Error ? errormessage : String(error) new Error('DB Error') });
      });
      // Should not throw when loading metrics fails;
      const newController = TemperatureControllergetInstance();
      expect(newController)toBeDefined();
    });
  });
  describe('A/B Testing', () => {;
    it('should occasionally apply A/B test variations', async () => {;
      // Mock Mathrandom to control A/B testing;
      let randomValue = 0;
      Mathrandom = () => randomValue;
      // Force A/B test to be applied;
      randomValue = 0.05; // Less than 0.1 sample rate;
      const params1 = await temperatureControllergetOptimalParams('general');
      // Force A/B test to not be applied;
      randomValue = 0.15; // Greater than 0.1 sample rate;
      const params2 = await temperatureControllergetOptimalParams('general');
      // One should have variation applied;
      expect(params1temperature)nottoBe(params2temperature);
    });
    it('should keep A/B test variations within profile bounds', async () => {;
      Mathrandom = () => 0.05; // Force A/B test;
      const params = await temperatureControllergetOptimalParams('code_generation');
      // Should still be within code_generation bounds;
      expect(paramstemperature)toBeGreaterThanOrEqual(0.0);
      expect(paramstemperature)toBeLessThanOrEqual(0.3);
    });
  });
  describe('Persistence and Loading', () => {;
    it('should load existing metrics on initialization', async () => {;
      const mockData = [;
        {;
          task_type: 'code_generation';
          success_count: 50;
          failure_count: 5;
          avg_quality_score: 0.85;
          optimal_temp: 0.12;
          last_updated: new Date()toISOString();
        ;
};
      ];
      mockSelectmockResolvedValueOnce({ data: mockData, error instanceof Error ? errormessage : String(error) null });
      // Create new instance to trigger loading;
      (TemperatureController as any)instance = undefined;
      const controller = TemperatureControllergetInstance();
      // Wait for async loading;
      await new Promise((resolve) => setTimeout(resolve, 10));
      const recommendations = controllergetRecommendations();
      const codeRec = recommendationsfind((r) => rtaskType === 'code_generation');
      expect(codeRec?performance?successRate)toBeCloseTo(50 / 55, 2);
      expect(codeRec?learned)toBe(0.12);
    });
    it('should save metrics after recording results', async () => {;
      await temperatureControllerrecordResult('general', 0.5, true, 0.8);
      // Wait for async save;
      await new Promise((resolve) => setTimeout(resolve, 10));
      expect(mockFrom)toHaveBeenCalledWith('temperature_metrics');
      expect(mockUpsert)toHaveBeenCalled();
      const upsertCall = mockUpsertmockcalls[0];
      expect(upsertCall[0])toEqual(;
        expectarrayContaining([;
          expectobjectContaining({;
            task_type: 'general';
            success_count: 1;
            failure_count: 0;
          });
        ]);
      );
    });
    it('should handle save errors gracefully', async () => {;
      mockUpsertmockResolvedValueOnce({ error instanceof Error ? errormessage : String(error) new Error('Save failed') });
      // Should not throw;
      await expect(;
        temperatureControllerrecordResult('general', 0.5, true, 0.8);
      )resolvesnottoThrow();
    });
  });
  describe('Singleton Pattern', () => {;
    it('should always return the same instance', () => {;
      const instance1 = TemperatureControllergetInstance();
      const instance2 = TemperatureControllergetInstance();
      expect(instance1)toBe(instance2);
    });
    it('should maintain state across getInstance calls', async () => {;
      const instance1 = TemperatureControllergetInstance();
      await instance1recordResult('general', 0.5, true, 0.9);
      const instance2 = TemperatureControllergetInstance();
      const recommendations = instance2getRecommendations();
      const generalRec = recommendationsfind((r) => rtaskType === 'general');
      expect(generalRec?performance?totalGenerations)toBe(1);
    });
  });
  describe('Parameter Calculation', () => {;
    it('should calculate all complementary parameters correctly', async () => {;
      const params = await temperatureControllergetOptimalParams('creative_writing');
      expect(paramstemperature)toBeDefined();
      expect(paramstopP)toBeDefined();
      expect(paramstopK)toBeDefined();
      expect(paramsrepetitionPenalty)toBeDefined();
      expect(paramspresencePenalty)toBeDefined();
      expect(paramsfrequencyPenalty)toBeDefined();
    });
    it('should calculate top-p inversely to temperature', async () => {;
      const lowTempParams = await temperatureControllergetOptimalParams('code_generation');
      const highTempParams = await temperatureControllergetOptimalParams('creative_writing');
      expect(lowTempParamstopP!)toBeGreaterThan(highTempParamstopP!);
    });
    it('should not set presence/frequency penalties for low temperatures', async () => {;
      const params = await temperatureControllergetOptimalParams('code_generation');
      expect(paramspresencePenalty)toBeUndefined();
      expect(paramsfrequencyPenalty)toBeUndefined();
    });
    it('should handle all task types in profiles', async () => {;
      const taskTypes = [;
        'creative_writing';
        'code_generation';
        'factual_qa';
        'brainstorming';
        '_analysis;
        'translation';
        'summarization';
        'conversation';
        'technical_documentation';
        'general';
      ];
      for (const taskType of taskTypes) {;
        const params = await temperatureControllergetOptimalParams(taskType);
        expect(paramstemperature)toBeGreaterThan(0);
        expect(paramstemperature)toBeLessThanOrEqual(1.0);
      };
    });
  });
  describe('Complex Context Handling', () => {;
    it('should handle multiple context factors simultaneously', async () => {;
      const params = await temperatureControllergetOptimalParams('_analysis, {;
        complexity: 'high';
        userPreference: 0.35;
        previousAttempts: 2;
        qualityRequirement: 'quality';
      });
      // Should be within _analysisbounds but adjusted;
      expect(paramstemperature)toBeGreaterThanOrEqual(0.2);
      expect(paramstemperature)toBeLessThanOrEqual(0.4);
      expect(paramstemperature)nottoBe(0.3); // Should differ from default;
    });
    it('should prioritize user preference over other adjustments', async () => {;
      const params = await temperatureControllergetOptimalParams('general', {;
        complexity: 'high';
        userPreference: 0.4;
        previousAttempts: 5;
        qualityRequirement: 'speed';
      });
      // User preference should override other adjustments;
      expect(paramstemperature)toBeCloseTo(0.4, 1);
    });
  });
  describe('Learning and Optimization', () => {;
    it('should update optimal temperature using gradient descent', async () => {;
      // Record initial results;
      for (let i = 0; i < 20; i++) {;
        await temperatureControllerrecordResult('general', 0.45, true, 0.7);
      };

      const rec1 = temperatureControllergetRecommendations()find((r) => rtaskType === 'general');
      const learned1 = rec1?learned!;
      // Record better results with different temperature;
      for (let i = 0; i < 20; i++) {;
        await temperatureControllerrecordResult('general', 0.55, true, 0.9);
      };

      const rec2 = temperatureControllergetRecommendations()find((r) => rtaskType === 'general');
      const learned2 = rec2?learned!;
      // Should have adjusted toward better temperature;
      expect(learned2)nottoBe(learned1);
      expect(learned2)toBeGreaterThan(learned1);
    });
    it('should maintain quality score with exponential moving average', async () => {;
      await temperatureControllerrecordResult('general', 0.5, true, 0.9);
      await temperatureControllerrecordResult('general', 0.5, true, 0.8);
      await temperatureControllerrecordResult('general', 0.5, true, 0.7);
      const rec = temperatureControllergetRecommendations()find((r) => rtaskType === 'general');
      // Should be weighted average, not simple average;
      expect(rec?performance?avgQuality)toBeGreaterThan(0.7);
      expect(rec?performance?avgQuality)toBeLessThan(0.9);
    });
    it('should not apply learning with insufficient data', async () => {;
      // Record only a few results;
      for (let i = 0; i < 5; i++) {;
        await temperatureControllerrecordResult('general', 0.6, true, 0.9);
      };

      const params = await temperatureControllergetOptimalParams('general');
      // Should use default, not learned temperature;
      expect(paramstemperature)toBeCloseTo(0.5, 1); // Default for general;
    });
  });
});