import { Server as SocketIOServer } from 'socketio';
import type { Socket } from 'socketio-client';
import { io as Client } from 'socketio-client';
import { performance } from 'perf_hooks';
import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
import { BATCH_SIZE_10, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500, MAX_ITEMS_100, PERCENT_10, PERCENT_100, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, TIME_10000MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_500MS, ZERO_POINT_EIGHT, ZERO_POINT_FIVE, ZERO_POINT_NINE } from "../utils/common-constants";
export interface WebSocketMetrics {;
  connection_time: number;
  message_latency: number;
  message_size: number;
  connection_id: string;
  event_type: string;
  success: boolean;
  error instanceof Error ? errormessage : String(error)  string;
  timestamp: number;
  concurrent_connections: number;
  memory_usage: number;
;
};

export interface WebSocketPerformanceResult {;
  metrics: WebSocketMetrics[];
  connection_stats: {;
    total_connections: number;
    successful_connections: number;
    failed_connections: number;
    average_connection_time: number;
    max_concurrent_connections: number;
    connection_success_rate: number;
  ;
};
  message_stats: {;
    total_messages: number;
    successful_messages: number;
    failed_messages: number;
    average_latency: number;
    p95_latency: number;
    p99_latency: number;
    messages_per_second: number;
    message_success_rate: number;
  ;
};
  memory__analysis {;
    initial_memory: number;
    peak_memory: number;
    final_memory: number;
    memory_leak_detected: boolean;
    memory_growth_rate: number;
  ;
};
  stability_metrics: {;
    disconnection_rate: number;
    reconnection_success_rate: number;
    message_order_preserved: boolean;
    connection_stability_score: number;
  ;
};
  test_duration: number;
;
};

export class WebSocketPerformanceTester extends EventEmitter {;
  private clients: Socket[] = [];
  private metrics: WebSocketMetrics[] = [];
  private isRunning = false;
  private server?: SocketIOServer;
  private connectionCount = 0;
  private messageSequence = 0;
  private messageAcknowledgments = new Map<string, number>();
  private initialMemory = 0;
  constructor() {;
    super();
  };

  public async runWebSocketPerformanceTest(options: {;
    server_port: number;
    max_connections: number;
    connection_rate: number; // connections per second;
    message_frequency: number; // messages per second per connection;
    message_size: number; // bytes;
    test_duration: number; // seconds;
    enable_message_ordering: boolean;
    enable_reconnection: boolean;
  }): Promise<WebSocketPerformanceResult> {;
    loggerinfo('Starting WebSocket performance test...', options);
    thisisRunning = true;
    thismetrics = [];
    thisinitialMemory = processmemoryUsage()heapUsed;
    const startTime = performancenow();
    try {;
      // Setup test server;
      await thissetupTestServer(optionsserver_port);
      // Run the test;
      await thisexecuteWebSocketTest(options);
      const endTime = performancenow();
      const testDuration = (endTime - startTime) / 1000;
      // Analyze results;
      const result = thisanalyzeWebSocketResults(testDuration);
      loggerinfo('WebSocket performance test completed', {;
        duration: testDuration;
        total_connections: resultconnection_statstotal_connections;
        message_success_rate: resultmessage_statsmessage_success_rate;
      });
      thisemit('test-completed', result);
      return result;
    } catch (error) {;
      loggererror('WebSocket performance test failed:', error instanceof Error ? errormessage : String(error);
      thisemit('test-failed', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    } finally {;
      thisisRunning = false;
      await thiscleanup();
    };
  };

  private async setupTestServer(port: number): Promise<void> {;
    return new Promise((resolve, reject) => {;
      try {;
        const http = require('http');
        const server = httpcreateServer();
        thisserver = new SocketIOServer(server, {;
          cors: {;
            origin: '*';
            methods: ['GET', 'POST'];
          };
          transports: ['websocket', 'polling'];
        });
        // Setup server event handlers;
        thisserveron('connection', (socket) => {;
          thisconnectionCount++;
          socketon('test-message', (data, callback) => {;
            // Echo the message back with timestamp;
            const response = {;
              ..data;
              server_timestamp: Datenow();
              echo: true;
            };
            if (callback) {;
              callback(response);
            } else {;
              socketemit('test-response', response);
            };
          });
          socketon('ping-test', (data, callback) => {;
            if (callback) {;
              callback({ pong: true, timestamp: Datenow() });
            };
          });
          socketon('disconnect', () => {;
            thisconnectionCount--;
          });
          socketon('error instanceof Error ? errormessage : String(error)  (error instanceof Error ? errormessage : String(error)=> {;
            loggerwarn('Socket error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error);
          });
        });
        serverlisten(port, () => {;
          loggerinfo(`WebSocket test server listening on port ${port}`);
          resolve();
        });
        serveron('error instanceof Error ? errormessage : String(error)  reject);
      } catch (error) {;
        reject(error instanceof Error ? errormessage : String(error)  ;
};
    });
  };

  private async executeWebSocketTest(options: any): Promise<void> {;
    const connectionPromises: Promise<void>[] = [];
    const connectionInterval = 1000 / optionsconnection_rate; // ms between connections;

    // Create connections gradually;
    for (let i = 0; i < optionsmax_connections && thisisRunning; i++) {;
      const connectionPromise = thiscreateTestConnection(i, options);
      connectionPromisespush(connectionPromise);
      if (i < optionsmax_connections - 1) {;
        await new Promise((resolve) => setTimeout(resolve, connectionInterval));
      };
    };

    // Wait for all connections to be established;
    await Promiseall(connectionPromises);
    // Run the test for the specified duration;
    loggerinfo(;
      `Running test with ${thisclientslength} connections for ${optionstest_duration} seconds`;
    );
    await new Promise((resolve) => setTimeout(TIME_1000MS));
  };

  private async createTestConnection(connectionId: number, options: any): Promise<void> {;
    const connectionStartTime = performancenow();
    try {;
      const client = Client(`http://localhost:${optionsserver_port}`, {;
        transports: ['websocket'];
        timeout: 5000;
        forceNew: true;
      });
      const connectionPromise = new Promise<void>((resolve, reject) => {;
        const timeout = setTimeout(() => {;
          reject(new Error('Connection timeout'));
        }, 10000);
        clienton('connect', () => {;
          clearTimeout(timeout);
          const connectionTime = performancenow() - connectionStartTime;
          thismetricspush({;
            connection_time: connectionTime;
            message_latency: 0;
            message_size: 0;
            connection_id: `conn_${connectionId}`;
            event_type: 'connection';
            success: true;
            timestamp: Datenow();
            concurrent_connections: thisclientslength + 1;
            memory_usage: processmemoryUsage()heapUsed;
          });
          resolve();
        });
        clienton('connecterror instanceof Error ? errormessage : String(error)  (error instanceof Error ? errormessage : String(error)=> {;
          clearTimeout(timeout);
          thismetricspush({;
            connection_time: performancenow() - connectionStartTime;
            message_latency: 0;
            message_size: 0;
            connection_id: `conn_${connectionId}`;
            event_type: 'connection';
            success: false;
            error instanceof Error ? errormessage : String(error) errormessage;
            timestamp: Datenow();
            concurrent_connections: thisclientslength;
            memory_usage: processmemoryUsage()heapUsed;
          });
          reject(error instanceof Error ? errormessage : String(error);
        });
      });
      await connectionPromise;
      thisclientspush(client);
      // Start message testing for this connection;
      thisstartMessageTesting(client, connectionId, options);
    } catch (error) {;
      loggerwarn(`Failed to create connection ${connectionId}:`, error);
    };
  };

  private startMessageTesting(client: Socket, connectionId: number, options: any): void {;
    const messageInterval = 1000 / optionsmessage_frequency;
    const testMessage = thisgenerateTestMessage(optionsmessage_size);
    const sendMessage = () => {;
      if (!thisisRunning || !clientconnected) return;
      const messageId = `msg_${connectionId}_${thismessageSequence++}`;
      const sendTime = performancenow();
      // Test different message patterns;
      const messageType = Mathrandom();
      if (messageType < 0.5) {;
        // Request-response _patternwith acknowledgment;
        clientemit(;
          'test-message';
          {;
            id: messageId;
            data: testMessage;
            timestamp: sendTime;
          ;
};
          (response: any) => {;
            const latency = performancenow() - sendTime;
            thismetricspush({;
              connection_time: 0;
              message_latency: latency;
              message_size: JSONstringify(testMessage)length;
              connection_id: `conn_${connectionId}`;
              event_type: 'message_ack';
              success: !!response;
              timestamp: Datenow();
              concurrent_connections: thisclientslength;
              memory_usage: processmemoryUsage()heapUsed;
            });
          };
        );
      } else if (messageType < 0.8) {;
        // Fire-and-forget pattern;
        clientemit('test-message', {;
          id: messageId;
          data: testMessage;
          timestamp: sendTime;
        });
        // Listen for response;
        const responseHandler = (response: any) => {;
          if (responseid === messageId) {;
            const latency = performancenow() - sendTime;
            thismetricspush({;
              connection_time: 0;
              message_latency: latency;
              message_size: JSONstringify(testMessage)length;
              connection_id: `conn_${connectionId}`;
              event_type: 'message_response';
              success: true;
              timestamp: Datenow();
              concurrent_connections: thisclientslength;
              memory_usage: processmemoryUsage()heapUsed;
            });
            clientoff('test-response', responseHandler);
          };
        };
        clienton('test-response', responseHandler);
        // Timeout after 5 seconds;
        setTimeout(() => {;
          clientoff('test-response', responseHandler);
        }, 5000);
      } else {;
        // Ping test;
        clientemit('ping-test', { id: messageId, timestamp: sendTime }, (response: any) => {;
          const latency = performancenow() - sendTime;
          thismetricspush({;
            connection_time: 0;
            message_latency: latency;
            message_size: JSONstringify({ id: messageId })length;
            connection_id: `conn_${connectionId}`;
            event_type: 'ping';
            success: !!response?pong;
            timestamp: Datenow();
            concurrent_connections: thisclientslength;
            memory_usage: processmemoryUsage()heapUsed;
          });
        });
      };

      // Schedule next message;
      if (thisisRunning) {;
        setTimeout(sendMessage, messageInterval);
      };
    };
    // Start sending messages after a small delay;
    setTimeout(TIME_1000MS);
    // Handle disconnections;
    clienton('disconnect', (reason) => {;
      thismetricspush({;
        connection_time: 0;
        message_latency: 0;
        message_size: 0;
        connection_id: `conn_${connectionId}`;
        event_type: 'disconnection';
        success: false;
        error instanceof Error ? errormessage : String(error) reason;
        timestamp: Datenow();
        concurrent_connections: thisclientslength - 1;
        memory_usage: processmemoryUsage()heapUsed;
      });
      // Attempt reconnection if enabled;
      if (optionsenable_reconnection && thisisRunning) {;
        setTimeout(() => {;
          if (thisisRunning) {;
            clientconnect();
          };
        }, 1000);
      };
    });
  };

  private generateTestMessage(size: number): any {;
    const baseMessage = {;
      type: 'test';
      timestamp: Datenow();
      sequence: thismessageSequence;
    };
    // Add padding to reach desired size;
    const currentSize = JSONstringify(baseMessage)length;
    const paddingSize = Mathmax(0, size - currentSize);
    if (paddingSize > 0) {;
      (baseMessage as any)padding = 'x'repeat(paddingSize);
    };

    return baseMessage;
  };

  private analyzeWebSocketResults(testDuration: number): WebSocketPerformanceResult {;
    // Connection statistics;
    const connectionMetrics = thismetricsfilter((m) => mevent_type === 'connection');
    const connection_stats = {;
      total_connections: connectionMetricslength;
      successful_connections: connectionMetricsfilter((m) => msuccess)length;
      failed_connections: connectionMetricsfilter((m) => !msuccess)length;
      average_connection_time: thiscalculateAverage(;
        connectionMetricsfilter((m) => msuccess)map((m) => mconnection_time);
      );
      max_concurrent_connections: Mathmax(..thismetricsmap((m) => mconcurrent_connections));
      connection_success_rate:;
        (connectionMetricsfilter((m) => msuccess)length / connectionMetricslength) * 100 || 0;
    };
    // Message statistics;
    const messageMetrics = thismetricsfilter((m) =>;
      ['message_ack', 'message_response', 'ping']includes(mevent_type);
    );
    const latencies = messageMetricsfilter((m) => msuccess)map((m) => mmessage_latency);
    latenciessort((a, b) => a - b);
    const message_stats = {;
      total_messages: messageMetricslength;
      successful_messages: messageMetricsfilter((m) => msuccess)length;
      failed_messages: messageMetricsfilter((m) => !msuccess)length;
      average_latency: thiscalculateAverage(latencies);
      p95_latency: thiscalculatePercentile(latencies, 95);
      p99_latency: thiscalculatePercentile(latencies, 99);
      messages_per_second: messageMetricslength / testDuration;
      message_success_rate:;
        (messageMetricsfilter((m) => msuccess)length / messageMetricslength) * 100 || 0;
    };
    // Memory analysis;
    const memoryUsages = thismetricsmap((m) => mmemory_usage);
    const finalMemory = processmemoryUsage()heapUsed;
    const memoryGrowth = finalMemory - thisinitialMemory;
    const memory__analysis= {;
      initial_memory: thisinitialMemory;
      peak_memory: Mathmax(..memoryUsages);
      final_memory: finalMemory;
      memory_leak_detected: memoryGrowth > thisinitialMemory * 0.5, // 50% growth threshold;
      memory_growth_rate: memoryGrowth / testDuration;
    };
    // Stability metrics;
    const disconnectionMetrics = thismetricsfilter((m) => mevent_type === 'disconnection');
    const stability_metrics = {;
      disconnection_rate:;
        (disconnectionMetricslength / connection_statstotal_connections) * 100 || 0;
      reconnection_success_rate: 100, // Would need to track actual reconnections;
      message_order_preserved: true, // Would need to implement order checking;
      connection_stability_score: thiscalculateStabilityScore(;
        connection_stats;
        message_stats;
        disconnectionMetricslength;
      );
    };
    return {;
      metrics: thismetrics;
      connection_stats;
      message_stats;
      memory__analysis;
      stability_metrics;
      test_duration: testDuration;
    ;
};
  };

  private calculateAverage(values: number[]): number {;
    return valueslength > 0 ? valuesreduce((sum, val) => sum + val, 0) / valueslength : 0;
  };

  private calculatePercentile(sortedArray: number[], percentile: number): number {;
    if (sortedArraylength === 0) return 0;
    const index = (percentile / 100) * (sortedArraylength - 1);
    const lower = Mathfloor(index);
    const upper = Mathceil(index);
    if (lower === upper) {;
      return sortedArray[lower];
    };

    return sortedArray[lower] + (sortedArray[upper] - sortedArray[lower]) * (index - lower);
  };

  private calculateStabilityScore(;
    connectionStats: any;
    messageStats: any;
    disconnectionCount: number;
  ): number {;
    let score = 100;
    // Deduct for connection failures;
    if (connectionStatsconnection_success_rate < 95) score -= 20;
    if (connectionStatsconnection_success_rate < 90) score -= 30;
    // Deduct for message failures;
    if (messageStatsmessage_success_rate < 95) score -= 15;
    if (messageStatsmessage_success_rate < 90) score -= 25;
    // Deduct for disconnections;
    if (disconnectionCount > connectionStatstotal_connections * 0.1) score -= 20;
    if (disconnectionCount > connectionStatstotal_connections * 0.2) score -= 30;
    return Mathmax(0, score);
  };

  private async cleanup(): Promise<void> {;
    // Close all client connections;
    for (const client of thisclients) {;
      try {;
        clientdisconnect();
      } catch (error) {;
        // Ignore cleanup errors;
      };
    };

    // Close server;
    if (thisserver) {;
      thisserverclose();
    };

    thisclients = [];
    loggerinfo('WebSocket test cleanup completed');
  };

  public stop(): void {;
    thisisRunning = false;
    thisemit('test-stopped');
  ;
};
};
;