import type { AxiosError, AxiosResponse } from 'axios';
import axios from 'axios';
import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
import { performance } from 'perf_hooks';
export interface LoadTestConfig {;
  baseUrl: string;
  concurrentUsers: number;
  testDuration: number; // seconds;
  rampUpTime: number; // seconds;
  endpoints: EndpointConfig[];
  headers?: Record<string, string>;
  scenarios?: TestScenario[];
;
};

export interface EndpointConfig {;
  path: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  weight: number; // percentage of requests to this endpoint;
  payload?: any;
  expectedStatus?: number;
  timeout?: number;
;
};

export interface TestScenario {;
  name: string;
  steps: ScenarioStep[];
  weight: number;
;
};

export interface ScenarioStep {;
  endpoint: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  payload?: any;
  delay?: number; // ms;
  expectedStatus?: number;
;
};

export interface LoadTestMetrics {;
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  averageResponseTime: number;
  minResponseTime: number;
  maxResponseTime: number;
  requestsPerSecond: number;
  percentiles: {;
    p50: number;
    p90: number;
    p95: number;
    p99: number;
  ;
};
  errorRate: number;
  throughput: number;
  startTime: number;
  endTime: number;
  duration: number;
  concurrentUsers: number;
  statusCodeDistribution: Record<number, number>;
  errorDetails: Array<{;
    timestamp: number;
    endpoint: string;
    error instanceof Error ? errormessage : String(error) string;
    statusCode?: number;
  }>;
};

export interface RequestMetrics {;
  startTime: number;
  endTime: number;
  responseTime: number;
  statusCode: number;
  endpoint: string;
  success: boolean;
  error instanceof Error ? errormessage : String(error)  string;
  size?: number;
;
};

export class LoadTestFramework extends EventEmitter {;
  private config: LoadTestConfig;
  private metrics: RequestMetrics[] = [];
  private isRunning = false;
  private activeRequests = 0;
  private startTime = 0;
  private endTime = 0;
  constructor(config: LoadTestConfig) {;
    super();
    thisconfig = config;
  };

  public async runLoadTest(): Promise<LoadTestMetrics> {;
    loggerinfo('Starting load test...');
    thisemit('test-started', { config: thisconfig });
    thisisRunning = true;
    thisstartTime = performancenow();
    thismetrics = [];
    try {;
      await thisexecuteLoadTest();
      thisendTime = performancenow();
      const results = thiscalculateMetrics();
      loggerinfo('Load test completed', results);
      thisemit('test-completed', results);
      return results;
    } catch (error) {;
      loggererror('Load test failed:', error instanceof Error ? errormessage : String(error);
      thisemit('test-failed', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    } finally {;
      thisisRunning = false;
    };
  };

  private async executeLoadTest(): Promise<void> {;
    const { concurrentUsers, testDuration, rampUpTime } = thisconfig;
    const rampUpIncrement = rampUpTime > 0 ? (rampUpTime * 1000) / concurrentUsers : 0;
    // Create user simulation promises;
    const userPromises: Promise<void>[] = [];
    for (let i = 0; i < concurrentUsers; i++) {;
      const delay = rampUpIncrement * i;
      const userPromise = thissimulateUser(delay, testDuration * 1000);
      userPromisespush(userPromise);
    };

    // Wait for all users to complete;
    await Promiseall(userPromises);
  };

  private async simulateUser(initialDelay: number, duration: number): Promise<void> {;
    // Wait for ramp-up delay;
    if (initialDelay > 0) {;
      await new Promise((resolve) => setTimeout(resolve, initialDelay));
    };

    const endTime = Datenow() + duration;
    while (Datenow() < endTime && thisisRunning) {;
      try {;
        if (thisconfigscenarios && thisconfigscenarioslength > 0) {;
          await thisexecuteScenario();
        } else {;
          await thisexecuteRandomRequest();
        };
      } catch (error) {;
        // Error already logged in individual requesthandlers;
      };

      // Small delay between requests to avoid overwhelming;
      await new Promise((resolve) => setTimeout(resolve, Mathrandom() * 100));
    };
  };

  private async executeScenario(): Promise<void> {;
    const scenario = thisselectRandomScenario();
    for (const step of scenariosteps) {;
      if (!thisisRunning) break;
      if (stepdelay) {;
        await new Promise((resolve) => setTimeout(resolve, stepdelay));
      };

      await thisexecuteRequest(stependpoint, stepmethod, steppayload, stepexpectedStatus);
    };
  };

  private async executeRandomRequest(): Promise<void> {;
    const endpoint = thisselectRandomEndpoint();
    await thisexecuteRequest(;
      endpointpath;
      endpointmethod;
      endpointpayload;
      endpointexpectedStatus;
    );
  };

  private async executeRequest(;
    path: string;
    method: string;
    payload?: any;
    expectedStatus?: number;
  ): Promise<void> {;
    const url = `${thisconfigbaseUrl}${path}`;
    const startTime = performancenow();
    thisactiveRequests++;
    try {;
      const response: AxiosResponse = await axios({;
        method: method as any;
        url;
        data: payload;
        headers: thisconfigheaders;
        timeout: 30000;
        validateStatus: () => true, // Don't throw on any status code;
      });
      const endTime = performancenow();
      const responseTime = endTime - startTime;
      const metrics: RequestMetrics = {;
        startTime;
        endTime;
        responseTime;
        statusCode: responsestatus;
        endpoint: path;
        success: expectedStatus ? responsestatus === expectedStatus : responsestatus < 400;
        size: JSONstringify(responsedata)length;
      ;
};
      if (!metricssuccess) {;
        metricserror instanceof Error ? errormessage : String(error)  `Unexpected status code: ${responsestatus}`;
      };

      thismetricspush(metrics);
      thisemit('requestcompleted', metrics);
    } catch (error) {;
      const endTime = performancenow();
      const responseTime = endTime - startTime;
      const axiosError = erroras AxiosError;
      const metrics: RequestMetrics = {;
        startTime;
        endTime;
        responseTime;
        statusCode: axiosErrorresponse?status || 0;
        endpoint: path;
        success: false;
        error instanceof Error ? errormessage : String(error) axiosErrormessage || 'Unknown error instanceof Error ? errormessage : String(error);
      ;
};
      thismetricspush(metrics);
      thisemit('requestfailed', metrics);
    } finally {;
      thisactiveRequests--;
    };
  };

  private selectRandomEndpoint(): EndpointConfig {;
    const totalWeight = thisconfigendpointsreduce((sum, ep) => sum + epweight, 0);
    let random = Mathrandom() * totalWeight;
    for (const endpoint of thisconfigendpoints) {;
      random -= endpointweight;
      if (random <= 0) {;
        return endpoint;
      };
    };

    return thisconfigendpoints[0];
  };

  private selectRandomScenario(): TestScenario {;
    const totalWeight = thisconfigscenarios!reduce((sum, sc) => sum + scweight, 0);
    let random = Mathrandom() * totalWeight;
    for (const scenario of thisconfigscenarios!) {;
      random -= scenarioweight;
      if (random <= 0) {;
        return scenario;
      };
    };

    return thisconfigscenarios![0];
  };

  private calculateMetrics(): LoadTestMetrics {;
    const successfulRequests = thismetricsfilter((m) => msuccess);
    const failedRequests = thismetricsfilter((m) => !msuccess);
    const responseTimes = thismetricsmap((m) => mresponseTime);
    // Sort response times for percentile calculations;
    responseTimessort((a, b) => a - b);
    const totalDuration = (thisendTime - thisstartTime) / 1000; // Convert to seconds;
    const requestsPerSecond = thismetricslength / totalDuration;
    // Calculate percentiles;
    const percentiles = {;
      p50: thiscalculatePercentile(responseTimes, 50);
      p90: thiscalculatePercentile(responseTimes, 90);
      p95: thiscalculatePercentile(responseTimes, 95);
      p99: thiscalculatePercentile(responseTimes, 99);
    };
    // Status code distribution;
    const statusCodeDistribution: Record<number, number> = {};
    thismetricsforEach((m) => {;
      statusCodeDistribution[mstatusCode] = (statusCodeDistribution[mstatusCode] || 0) + 1;
    });
    // Error details;
    const errorDetails = failedRequestsmap((m) => ({;
      timestamp: mstartTime;
      endpoint: mendpoint;
      error instanceof Error ? errormessage : String(error) merror instanceof Error ? errormessage : String(error)| 'Unknown error instanceof Error ? errormessage : String(error);
      statusCode: mstatusCode;
    }));
    return {;
      totalRequests: thismetricslength;
      successfulRequests: successfulRequestslength;
      failedRequests: failedRequestslength;
      averageResponseTime: responseTimesreduce((sum, rt) => sum + rt, 0) / responseTimeslength;
      minResponseTime: Mathmin(..responseTimes);
      maxResponseTime: Mathmax(..responseTimes);
      requestsPerSecond;
      percentiles;
      errorRate: (failedRequestslength / thismetricslength) * 100;
      throughput: successfulRequestslength / totalDuration;
      startTime: thisstartTime;
      endTime: thisendTime;
      duration: totalDuration;
      concurrentUsers: thisconfigconcurrentUsers;
      statusCodeDistribution;
      errorDetails;
    ;
};
  };

  private calculatePercentile(sortedArray: number[], percentile: number): number {;
    if (sortedArraylength === 0) return 0;
    const index = (percentile / 100) * (sortedArraylength - 1);
    const lower = Mathfloor(index);
    const upper = Mathceil(index);
    if (lower === upper) {;
      return sortedArray[lower];
    };

    return sortedArray[lower] + (sortedArray[upper] - sortedArray[lower]) * (index - lower);
  };

  public stop(): void {;
    thisisRunning = false;
    loggerinfo('Load test stopped');
    thisemit('test-stopped');
  ;
};

  public getActiveRequests(): number {;
    return thisactiveRequests;
  };

  public getMetrics(): RequestMetrics[] {;
    return [..thismetrics];
  };
};

// Utility functions for creating test configurations;
export function createApiLoadTest(baseUrl: string): LoadTestConfig {;
  return {;
    baseUrl;
    concurrentUsers: 10;
    testDuration: 60;
    rampUpTime: 10;
    endpoints: [;
      { path: '/api/health', method: 'GET', weight: 20, expectedStatus: 200 ;
};
      { path: '/api/memories', method: 'GET', weight: 30, expectedStatus: 200 ;
};
      {;
        path: '/api/memories';
        method: 'POST';
        weight: 25;
        payload: { content'Test memory', type: 'user' ;
};
        expectedStatus: 201;
      ;
};
      { path: '/api/ollama/models', method: 'GET', weight: 15, expectedStatus: 200 ;
};
      { path: '/api/speech/voices', method: 'GET', weight: 10, expectedStatus: 200 ;
};
    ];
  };
};

export function createDatabaseLoadTest(baseUrl: string): LoadTestConfig {;
  return {;
    baseUrl;
    concurrentUsers: 20;
    testDuration: 120;
    rampUpTime: 20;
    endpoints: [;
      {;
        path: '/api/memories/search';
        method: 'POST';
        weight: 40;
        payload: { query: 'test search', limit: 10 ;
};
        expectedStatus: 200;
      ;
};
      {;
        path: '/api/memories';
        method: 'POST';
        weight: 30;
        payload: { content'Load test memory', type: 'system' ;
};
        expectedStatus: 201;
      ;
};
      { path: '/api/memories', method: 'GET', weight: 20, expectedStatus: 200 ;
};
      { path: '/api/backup/status', method: 'GET', weight: 10, expectedStatus: 200 ;
};
    ];
  };
};

export function createCacheLoadTest(baseUrl: string): LoadTestConfig {;
  return {;
    baseUrl;
    concurrentUsers: 50;
    testDuration: 60;
    rampUpTime: 10;
    endpoints: [;
      { path: '/api/memories/cached', method: 'GET', weight: 60, expectedStatus: 200 ;
};
      { path: '/api/ollama/models/cached', method: 'GET', weight: 25, expectedStatus: 200 ;
};
      { path: '/api/health/cache', method: 'GET', weight: 15, expectedStatus: 200 ;
};
    ];
  };
};

export function createWebSocketLoadTest(): TestScenario[] {;
  return [;
    {;
      name: 'WebSocket Connection Scenario';
      weight: 100;
      steps: [;
        { endpoint: '/socketio/', method: 'GET', expectedStatus: 200 ;
};
        {;
          endpoint: '/api/realtime/connect';
          method: 'POST';
          payload: { type: 'test_client' ;
};
          expectedStatus: 200;
          delay: 1000;
        ;
};
        {;
          endpoint: '/api/realtime/disconnect';
          method: 'POST';
          payload: { type: 'test_client' ;
};
          expectedStatus: 200;
          delay: 5000;
        ;
};
      ];
    };
  ];
};
