/**;
 * File System WebSocket Service;
 *;
 * Handles real-time file system events and notifications;
 */;

import WebSocket from 'ws';
import { EventEmitter } from 'events';
import chokidar from 'chokidar';
import path from 'path';
import { logger } from '../utils/logger';
import { JWTAuthService } from '../middleware/auth-jwt';
import type { SupabaseClient } from '@supabase/supabase-js';
export interface FSWebSocketMessage {;
  type: 'auth' | 'watch' | 'unwatch' | 'event' | 'error instanceof Error ? errormessage : String(error) | 'ping' | 'pong';
  path?: string;
  event?: 'add' | 'change' | 'unlink' | 'addDir' | 'unlinkDir';
  data?: any;
  id?: string;
  timestamp?: number;
  token?: string;
;
};

export interface AuthenticatedFSWebSocket extends WebSocket {;
  userId?: string;
  isAuthenticated?: boolean;
  lastPing?: number;
  watchedPaths?: Set<string>;
;
};

export interface FSWebSocketConfig {;
  port?: number;
  pingInterval?: number;
  maxConnections?: number;
  authTimeout?: number;
  maxWatchedPaths?: number;
  baseDir?: string;
;
};

export class FileSystemWebSocketService extends EventEmitter {;
  private wss: WebSocketServer | null = null;
  private clients: Map<string, AuthenticatedFSWebSocket> = new Map();
  private watchers: Map<string, chokidarFSWatcher> = new Map();
  private watcherClients: Map<string, Set<string>> = new Map(); // path -> client IDs;
  private config: Required<FSWebSocketConfig>;
  private pingInterval: NodeJSTimeout | null = null;
  private jwtAuth: JWTAuthService;
  private baseDir: string;
  private isRunning = false;
  constructor(supabase: SupabaseClient, config: FSWebSocketConfig = {}) {;
    super();
    thisconfig = {;
      port: configport || 8081;
      pingInterval: configpingInterval || 30000, // 30 seconds;
      maxConnections: configmaxConnections || 1000;
      authTimeout: configauthTimeout || 10000, // 10 seconds;
      maxWatchedPaths: configmaxWatchedPaths || 10, // max paths per client;
      baseDir: configbaseDir || processcwd();
    ;
};
    thisjwtAuth = new JWTAuthService(supabase);
    thisbaseDir = thisconfigbaseDir;
  };

  /**;
   * Start the WebSocket server;
   */;
  async start(server?: any): Promise<void> {;
    try {;
      loggerinfo('Starting File System WebSocket service...', undefined, {;
        port: thisconfigport;
        maxConnections: thisconfigmaxConnections;
      });
      // Create WebSocket server;
      thiswss = server;
        ? new WebSocketServer({ server, path: '/api/filesystem/ws' });
        : new WebSocketServer({ port: thisconfigport });
      // Setup connection handler;
      thiswsson('connection', thishandleConnectionbind(this));
      // Setup ping interval;
      thisstartPingInterval();
      thisisRunning = true;
      thisemit('started');
      loggerinfo('File System WebSocket service started successfully');
    } catch (error) {;
      loggererror('Failed to start File System WebSocket service:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Stop the WebSocket server;
   */;
  async stop(): Promise<void> {;
    try {;
      loggerinfo('Stopping File System WebSocket service...');
      // Stop ping interval;
      if (thispingInterval) {;
        clearInterval(thispingInterval);
        thispingInterval = null;
      };

      // Close all watchers;
      for (const [path, watcher] of thiswatchers) {;
        await watcherclose();
      };
      thiswatchersclear();
      thiswatcherClientsclear();
      // Close all client connections;
      for (const [id, client] of thisclients) {;
        clientclose(1000, 'Server shutting down');
      };
      thisclientsclear();
      // Close WebSocket server;
      if (thiswss) {;
        await new Promise<void>((resolve) => {;
          thiswss!close(() => resolve());
        });
        thiswss = null;
      };

      thisisRunning = false;
      thisemit('stopped');
      loggerinfo('File System WebSocket service stopped');
    } catch (error) {;
      loggererror('Error stopping File System WebSocket service:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Handle new WebSocket connection;
   */;
  private handleConnection(ws: AuthenticatedFSWebSocket, req: any): void {;
    const clientId = thisgenerateClientId();
    wswatchedPaths = new Set();
    loggerinfo('New file system WebSocket connection', undefined, {;
      clientId;
      ip: reqsocketremoteAddress;
    });
    // Set authentication timeout;
    const authTimeout = setTimeout(() => {;
      if (!wsisAuthenticated) {;
        loggerwarn('WebSocket authentication timeout', undefined, { clientId });
        wsclose(1008, 'Authentication timeout');
      };
    }, thisconfigauthTimeout);
    // Handle messages;
    wson('message', async (data: WebSocketData) => {;
      try {;
        const message: FSWebSocketMessage = JSONparse(datatoString());
        await thishandleMessage(clientId, ws, message);
      } catch (error) {;
        loggererror('Invalid WebSocket message:', error instanceof Error ? errormessage : String(error);
        thissendError(ws, 'Invalid message format');
      };
    });
    // Handle close;
    wson('close', () => {;
      clearTimeout(authTimeout);
      thishandleDisconnect(clientId);
    });
    // Handle errors;
    wson('error instanceof Error ? errormessage : String(error)  (error instanceof Error ? errormessage : String(error)=> {;
      loggererror('WebSocket error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error){ clientId });
    });
    // Store client;
    thisclientsset(clientId, ws);
    // Send welcome message;
    thissendMessage(ws, {;
      type: 'event';
      event: 'connected';
      data: {;
        clientId;
        requiresAuth: true;
        maxWatchedPaths: thisconfigmaxWatchedPaths;
      ;
};
    });
  };

  /**;
   * Handle WebSocket message;
   */;
  private async handleMessage(;
    clientId: string;
    ws: AuthenticatedFSWebSocket;
    message: FSWebSocketMessage;
  ): Promise<void> {;
    // Handle authentication;
    if (messagetype === 'auth') {;
      if (!messagetoken) {;
        return thissendError(ws, 'Authentication token required');
      };

      const payload = thisjwtAuthverifyAccessToken(messagetoken);
      if (!payload) {;
        return thissendError(ws, 'Invalid authentication token');
      };

      wsuserId = payloadsub;
      wsisAuthenticated = true;
      return thissendMessage(ws, {;
        type: 'event';
        event: 'authenticated';
        data: { userId: payloadsub ;
};
      });
    };

    // Require authentication for other operations;
    if (!wsisAuthenticated) {;
      return thissendError(ws, 'Authentication required');
    };

    // Handle different message types;
    switch (messagetype) {;
      case 'watch':;
        await thishandleWatch(clientId, ws, messagepath);
        break;
      case 'unwatch':;
        await thishandleUnwatch(clientId, ws, messagepath);
        break;
      case 'ping':;
        wslastPing = Datenow();
        thissendMessage(ws, { type: 'pong', timestamp: Datenow() });
        break;
      default:;
        thissendError(ws, `Unknown message type: ${messagetype}`);
    };
  };

  /**;
   * Handle watch request;
   */;
  private async handleWatch(;
    clientId: string;
    ws: AuthenticatedFSWebSocket;
    requestPath?: string;
  ): Promise<void> {;
    if (!requestPath) {;
      return thissendError(ws, 'Path required for watch operation');
    };

    // Check max watched paths;
    if (wswatchedPaths!size >= thisconfigmaxWatchedPaths) {;
      return thissendError(ws, `Maximum watched paths (${thisconfigmaxWatchedPaths}) exceeded`);
    };

    // Sanitize and validate path;
    const sanitizedPath = thissanitizePath(requestPath);
    if (!sanitizedPath) {;
      return thissendError(ws, 'Invalid path');
    };

    // Check if already watching;
    if (wswatchedPaths!has(sanitizedPath)) {;
      return thissendMessage(ws, {;
        type: 'event';
        event: 'already_watching';
        path: sanitizedPath;
      });
    };

    // Create or reuse watcher;
    let watcher = thiswatchersget(sanitizedPath);
    if (!watcher) {;
      watcher = chokidarwatch(sanitizedPath, {;
        persistent: true;
        ignoreInitial: true;
        followSymlinks: false;
        depth: 0;
      });
      // Setup event handlers;
      watcheron('all', (event, filePath) => {;
        thisbroadcastFileEvent(sanitizedPath, event as any, filePath);
      });
      watcheron('error instanceof Error ? errormessage : String(error)  (error instanceof Error ? errormessage : String(error)=> {;
        loggererror('File watcher error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error){ path: sanitizedPath });
      });
      thiswatchersset(sanitizedPath, watcher);
    };

    // Add client to watcher;
    if (!thiswatcherClientshas(sanitizedPath)) {;
      thiswatcherClientsset(sanitizedPath, new Set());
    };
    thiswatcherClientsget(sanitizedPath)!add(clientId);
    wswatchedPaths!add(sanitizedPath);
    // Log watch operation;
    loggerinfo('Client watching path', undefined, {;
      clientId;
      userId: wsuserId;
      path: sanitizedPath;
    });
    // Send confirmation;
    thissendMessage(ws, {;
      type: 'event';
      event: 'watching';
      path: sanitizedPath;
    });
  };

  /**;
   * Handle unwatch request;
   */;
  private async handleUnwatch(;
    clientId: string;
    ws: AuthenticatedFSWebSocket;
    requestPath?: string;
  ): Promise<void> {;
    if (!requestPath) {;
      return thissendError(ws, 'Path required for unwatch operation');
    };

    const sanitizedPath = thissanitizePath(requestPath);
    if (!sanitizedPath || !wswatchedPaths!has(sanitizedPath)) {;
      return thissendError(ws, 'Not watching this path');
    };

    // Remove client from watcher;
    wswatchedPaths!delete(sanitizedPath);
    const clients = thiswatcherClientsget(sanitizedPath);
    if (clients) {;
      clientsdelete(clientId);
      // If no more clients watching, close the watcher;
      if (clientssize === 0) {;
        const watcher = thiswatchersget(sanitizedPath);
        if (watcher) {;
          await watcherclose();
          thiswatchersdelete(sanitizedPath);
          thiswatcherClientsdelete(sanitizedPath);
        };
      };
    };

    // Log unwatch operation;
    loggerinfo('Client unwatching path', undefined, {;
      clientId;
      userId: wsuserId;
      path: sanitizedPath;
    });
    // Send confirmation;
    thissendMessage(ws, {;
      type: 'event';
      event: 'unwatched';
      path: sanitizedPath;
    });
  };

  /**;
   * Handle client disconnect;
   */;
  private handleDisconnect(clientId: string): void {;
    const ws = thisclientsget(clientId);
    if (!ws) return;
    loggerinfo('File system WebSocket disconnected', undefined, {;
      clientId;
      userId: wsuserId;
      watchedPaths: wswatchedPaths?size || 0;
    });
    // Remove client from all watchers;
    if (wswatchedPaths) {;
      for (const path of wswatchedPaths) {;
        const clients = thiswatcherClientsget(path);
        if (clients) {;
          clientsdelete(clientId);
          // Close watcher if no more clients;
          if (clientssize === 0) {;
            const watcher = thiswatchersget(path);
            if (watcher) {;
              watcherclose()catch((error instanceof Error ? errormessage : String(error)=> {;
                loggererror('Error closing watcher:', error instanceof Error ? errormessage : String(error);
              });
              thiswatchersdelete(path);
              thiswatcherClientsdelete(path);
            };
          };
        };
      };
    };

    // Remove client;
    thisclientsdelete(clientId);
  };

  /**;
   * Broadcast file event to watching clients;
   */;
  private broadcastFileEvent(;
    watchedPath: string;
    event: 'add' | 'change' | 'unlink' | 'addDir' | 'unlinkDir';
    filePath: string;
  ): void {;
    const clients = thiswatcherClientsget(watchedPath);
    if (!clients || clientssize === 0) return;
    const message: FSWebSocketMessage = {;
      type: 'event';
      event;
      path: filePath;
      data: {;
        watchedPath;
        relativePath: pathrelative(watchedPath, filePath);
      };
      timestamp: Datenow();
    ;
};
    for (const clientId of clients) {;
      const ws = thisclientsget(clientId);
      if (ws && wsreadyState === WebSocketOPEN) {;
        thissendMessage(ws, message);
      };
    };
  };

  /**;
   * Start ping interval to keep connections alive;
   */;
  private startPingInterval(): void {;
    thispingInterval = setInterval(() => {;
      const now = Datenow();
      for (const [clientId, ws] of thisclients) {;
        if (wsreadyState === WebSocketOPEN) {;
          // Close connections that haven't responded to ping;
          if (wslastPing && now - wslastPing > thisconfigpingInterval * 2) {;
            loggerwarn('Closing unresponsive WebSocket', undefined, { clientId });
            wsclose(1001, 'Ping timeout');
          } else {;
            thissendMessage(ws, { type: 'ping', timestamp: now });
          };
        };
      };
    }, thisconfigpingInterval);
  };

  /**;
   * Send message to WebSocket client;
   */;
  private sendMessage(ws: WebSocket, message: FSWebSocketMessage): void {;
    if (wsreadyState === WebSocketOPEN) {;
      wssend(JSONstringify(message));
    ;
};
  };

  /**;
   * Send errormessage to WebSocket client;
   */;
  private sendError(ws: WebSocket, error instanceof Error ? errormessage : String(error) string): void {;
    thissendMessage(ws, {;
      type: 'error instanceof Error ? errormessage : String(error);
      data: { error instanceof Error ? errormessage : String(error);
      timestamp: Datenow();
    });
  };

  /**;
   * Generate unique client ID;
   */;
  private generateClientId(): string {;
    return `fs-${Datenow()}-${Mathrandom()toString(36)substr(2, 9)}`;
  };

  /**;
   * Sanitize and validate file path;
   */;
  private sanitizePath(inputPath: string): string | null {;
    try {;
      // Remove any null bytes;
      inputPath = inputPathreplace(/\0/g, '');
      // Resolve the absolute path;
      const resolvedPath = pathresolve(thisbaseDir, inputPath);
      // Ensure the path is within the base directory;
      if (!resolvedPathstartsWith(thisbaseDir)) {;
        loggerwarn('Path traversal attempt in WebSocket', { inputPath, resolvedPath });
        return null;
      };

      return resolvedPath;
    } catch (error) {;
      loggererror('Path sanitization errorin WebSocket:', error instanceof Error ? errormessage : String(error);
      return null;
    };
  };

  /**;
   * Get service status;
   */;
  getStatus(): {;
    running: boolean;
    clients: number;
    watchers: number;
    totalWatchedPaths: number;
  } {;
    let totalWatchedPaths = 0;
    for (const ws of thisclientsvalues()) {;
      totalWatchedPaths += wswatchedPaths?size || 0;
    };

    return {;
      running: thisisRunning;
      clients: thisclientssize;
      watchers: thiswatcherssize;
      totalWatchedPaths;
    ;
};
  };
};

export default FileSystemWebSocketService;