/**;
 * Supabase Service;
 * Handles all Supabase client interactions and database operations;
 */;

import type { SupabaseClient } from '@supabase/supabase-js';
import { createClient } from '@supabase/supabase-js';
import { LogContext, logger } from '../utils/enhanced-logger';
export class SupabaseService {;
  private static instance: SupabaseService;
  public client: SupabaseClient;
  private constructor() {;
    const supabaseUrl = processenvSUPABASE_URL || '';
    const supabaseAnonKey = processenvSUPABASE_ANON_KEY || '';
    if (!supabaseUrl || !supabaseAnonKey) {;
      loggerwarn('Supabase credentials not found in environment variables');
    };

    thisclient = createClient(supabaseUrl, supabaseAnonKey, {;
      auth: {;
        persistSession: false;
      ;
};
    });
    loggerinfo('üóÑÔ∏è Supabase service initialized');
  };

  /**;
   * Get singleton instance;
   */;
  public static getInstance(): SupabaseService {;
    if (!SupabaseServiceinstance) {;
      SupabaseServiceinstance = new SupabaseService();
    };
    return SupabaseServiceinstance;
  };

  /**;
   * Save context to Supabase;
   */;
  public async saveContext(userId: string, context: any): Promise<void> {;
    try {;
      const { error instanceof Error ? errormessage : String(error)  = await thisclientfrom('contexts')insert({;
        user_id: userId;
        context;
        created_at: new Date()toISOString();
      });
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      loggerinfo(`Context saved for user ${userId}`);
    } catch (error) {;
      loggererror('Failed to save context:', LogContextDATABASE, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Retrieve context from Supabase;
   */;
  public async getContext(userId: string, limit = 10): Promise<any[]> {;
    try {;
      const { data, error } = await thisclient;
        from('contexts');
        select('*');
        eq('user_id', userId);
        order('created_at', { ascending: false });
        limit(limit);
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      return data || [];
    } catch (error) {;
      loggererror('Failed to retrieve context:', LogContextDATABASE, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Save memory to Supabase;
   */;
  public async saveMemory(memory: {;
    type: string;
    contentstring;
    metadata?: any;
    embedding?: number[];
  }): Promise<void> {;
    try {;
      const { error instanceof Error ? errormessage : String(error)  = await thisclientfrom('memories')insert({;
        ..memory;
        created_at: new Date()toISOString();
      });
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      loggerinfo(`Memory saved: ${memorytype}`);
    } catch (error) {;
      loggererror('Failed to save memory:', LogContextDATABASE, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Search memories by similarity;
   */;
  public async searchMemories(embedding: number[], limit = 10, threshold = 0.7): Promise<any[]> {;
    try {;
      // Real vector similarity search using pgvector;
      // First, try to use the vector similarity function;
      const { data, error } = await thisclientrpc('search_memories_by_embedding', {;
        query_embedding: embedding;
        similarity_threshold: threshold;
        match_count: limit;
      });
      if (error instanceof Error ? errormessage : String(error){;
        // If RPC function doesn't exist, fall back to manual similarity search;
        loggerwarn('RPC function not found, using manual vector search:', error instanceof Error ? errormessage : String(error);
        return await thisfallbackVectorSearch(embedding, limit, threshold);
      };

      return data || [];
    } catch (error) {;
      loggererror('Failed to search memories:', LogContextDATABASE, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      // Final fallback to simple search;
      return await thisfallbackVectorSearch(embedding, limit, threshold);
    };
  };

  /**;
   * Fallback vector search when RPC is not available;
   */;
  private async fallbackVectorSearch(;
    embedding: number[];
    limit: number;
    threshold: number;
  ): Promise<any[]> {;
    try {;
      // Get all memories with embeddings;
      const { data: memories, error instanceof Error ? errormessage : String(error)  = await thisclient;
        from('memories');
        select('*');
        not('embedding', 'is', null);
        order('created_at', { ascending: false });
        limit(limit * 3); // Get more to filter by similarity;
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      if (!memories || memorieslength === 0) {;
        return [];
      };

      // Calculate cosine similarity for each memory;
      const results = memories;
        map((memory) => {;
          if (!memoryembedding || !ArrayisArray(memoryembedding)) {;
            return null;
          };

          const similarity = thiscosineSimilarity(embedding, memoryembedding);
          return {;
            ..memory;
            similarity;
          };
        });
        filter((result) => result !== null && resultsimilarity >= threshold);
        sort((a, b) => bsimilarity - asimilarity);
        slice(0, limit);
      loggerdebug(`Vector search found ${resultslength} similar memories`);
      return results;
    } catch (error) {;
      loggererror('Fallback vector search failed:', error instanceof Error ? errormessage : String(error);
      // Last resort: return recent memories;
      const { data, error instanceof Error ? errormessage : String(error) simpleError } = await thisclient;
        from('memories');
        select('*');
        order('created_at', { ascending: false });
        limit(limit);
      if (simpleError) {;
        throw simpleError;
      };

      return data || [];
    };
  };

  /**;
   * Calculate cosine similarity between two vectors;
   */;
  private cosineSimilarity(a: number[], b: number[]): number {;
    if (alength !== blength) {;
      return 0;
    };

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < alength; i++) {;
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    };

    const magnitude = Mathsqrt(normA) * Mathsqrt(normB);
    if (magnitude === 0) {;
      return 0;
    };

    return dotProduct / magnitude;
  };

  /**;
   * Generic query method;
   */;
  public async query(table: string, filters?: any): Promise<any[]> {;
    try {;
      let query = thisclientfrom(table)select('*');
      if (filters) {;
        Objectentries(filters)forEach(([key, value]) => {;
          query = queryeq(key, value);
        });
      };

      const { data, error } = await query;
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      return data || [];
    } catch (error) {;
      loggererror`Failed to query ${table}:`, LogContextDATABASE, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Generic insert method;
   */;
  public async insert(table: string, data: any): Promise<unknown> {;
    try {;
      const { data: insertedData, error instanceof Error ? errormessage : String(error)  = await thisclient;
        from(table);
        insert(data);
        select();
        single();
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      return insertedData;
    } catch (error) {;
      loggererror`Failed to insert into ${table}:`, LogContextDATABASE, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Generic update method;
   */;
  public async update(table: string, id: string, data: any): Promise<unknown> {;
    try {;
      const { data: updatedData, error instanceof Error ? errormessage : String(error)  = await thisclient;
        from(table);
        update(data);
        eq('id', id);
        select();
        single();
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      return updatedData;
    } catch (error) {;
      loggererror`Failed to update ${table}:`, LogContextDATABASE, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Generic delete method;
   */;
  public async delete(table: string, id: string): Promise<void> {;
    try {;
      const { error instanceof Error ? errormessage : String(error)  = await thisclientfrom(table)delete()eq('id', id);
      if (error instanceof Error ? errormessage : String(error){;
        throw error instanceof Error ? errormessage : String(error);
      };

      loggerinfo(`Deleted record ${id} from ${table}`);
    } catch (error) {;
      loggererror`Failed to delete from ${table}:`, LogContextDATABASE, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };
};

// Export singleton instance for easy access;
export const supabase = SupabaseServicegetInstance()client;
// Export service instance;
export const supabaseService = SupabaseServicegetInstance();
// Export client factory function;
export function createSupabaseClient() {;
  return SupabaseServicegetInstance()client;
};
