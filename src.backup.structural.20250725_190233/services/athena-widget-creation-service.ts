/**;
 * Athena Widget Creation Service;
 *;
 * Natural language to React component generation pipeline;
 * Bridges Sweet Athena's conversation engine with the tool maker agent;
 */;

import type { SupabaseClient } from '@supabase/supabase-js';
import type { Logger } from 'winston';
import { ToolMakerAgent } from '../agents/personal/tool_maker_agent';
import { AthenaConversationEngine } from './athena-conversation-engine';
import type { AgentContext } from '../agents/base_agent';
import axios from 'axios';
import { promises as fs } from 'fs';
import * as path from 'path';
import archiver from 'archiver';
import { createWriteStream } from 'fs';
import { v4 as uuidv4 } from 'uuid';
export interface WidgetRequest {;
  description: string;
  userId: string;
  requirements?: {;
    style?: 'material-ui' | 'styled-components' | 'tailwind' | 'custom';
    features?: string[];
    dataSource?: 'static' | 'api' | 'props';
    responsive?: boolean;
    theme?: 'light' | 'dark' | 'auto';
  ;
};
  examples?: string[];
;
};

export interface WidgetComponent {;
  id: string;
  name: string;
  description: string;
  code: string;
  styles?: string;
  tests?: string;
  dependencies: string[];
  propInterface?: string;
  documentation: string;
  preview?: string;
  exportReady: boolean;
;
};

export interface WidgetCreationResult {;
  success: boolean;
  widget?: WidgetComponent;
  error instanceof Error ? errormessage : String(error)  string;
  warnings?: string[];
  suggestions?: string[];
;
};

interface ParsedWidgetRequirements {;
  componentName: string;
  componentType: 'form' | 'table' | 'chart' | 'card' | 'list' | 'custom';
  props: Array<{ name: string; type: string, required: boolean }>;
  state: Array<{ name: string; type: string, initial: any }>;
  events: Array<{ name: string, handler: string }>;
  styling: {;
    framework: string;
    theme: string;
    responsive: boolean;
  ;
};
  features: string[];
;
};

export class AthenaWidgetCreationService {;
  private toolMaker: ToolMakerAgent;
  private widgetCache: Map<string, WidgetComponent> = new Map();
  private templateCache: Map<string, string> = new Map();
  constructor(;
    private supabase: SupabaseClient;
    private logger: Logger;
  ) {;
    thistoolMaker = new ToolMakerAgent(supabase);
    thisinitializeTemplates();
  ;
};

  /**;
   * Create a widget from natural language description;
   */;
  async createWidget(requestWidgetRequest): Promise<WidgetCreationResult> {;
    try {;
      thisloggerinfo(`Creating widget from description: ${requestdescription}`);
      // Parse the natural language description;
      const parsed = await thisparseWidgetDescription(request;

      // Generate the React component;
      const component = await thisgenerateReactComponent(parsed, request;

      // Validate the generated code;
      const validation = await thisvalidateComponent(component);
      if (!validationvalid) {;
        return {;
          success: false;
          error instanceof Error ? errormessage : String(error) 'Generated component failed validation';
          warnings: validationerrors;
          suggestions: validationsuggestions;
        ;
};
      };

      // Generate tests;
      componenttests = await thisgenerateComponentTests(component, parsed);
      // Generate documentation;
      componentdocumentation = await thisgenerateDocumentation(component, parsed);
      // Store widget in database;
      await thisstoreWidget(component, requestuserId);
      // Cache the widget;
      thiswidgetCacheset(componentid, component);
      return {;
        success: true;
        widget: component;
        suggestions: [;
          `You can preview the widget at /api/widgets/preview/${componentid}`;
          `Export as a zip file at /api/widgets/export/${componentid}`;
          'The widget includes TypeScript definitions and tests';
        ];
      };
    } catch (error) {;
      thisloggererror('Widget creation failed:', error instanceof Error ? errormessage : String(error);
      return {;
        success: false;
        error instanceof Error ? errormessage : String(error) (erroras Error)message;
        suggestions: ['Try providing more specific requirements', 'Include example usage'];
      };
    };
  };

  /**;
   * Parse natural language description into structured requirements;
   */;
  private async parseWidgetDescription(requestWidgetRequest): Promise<ParsedWidgetRequirements> {;
    const prompt = `Parse this widget description into structured requirements:`;

Description: "${requestdescription}";
Additional Requirements: ${JSONstringify(requestrequirements || {})};
Examples: ${JSONstringify(requestexamples || []);
};

Extract:;
1. Component name (PascalCase);
2. Component type (form, table, chart, card, list, custom);
3. Props needed (name, type, required);
4. State variables (name, type, initial value);
5. Event handlers needed;
6. Styling framework preference;
7. Key features;
Respond with JSON matching this structure:;
{;
  "componentName": "string";
  "componentType": "string";
  "props": [{"name": "string", "type": "string", "required": boolean}];
  "state": [{"name": "string", "type": "string", "initial": any}];
  "events": [{"name": "string", "handler": "string"}];
  "styling": {;
    "framework": "string";
    "theme": "string";
    "responsive": boolean;
  ;
};
  "features": ["string"];
}`;`;
    try {;
      const response = await axiospost('http://localhost:11434/api/generate', {;
        model: 'deepseek-r1:14b';
        prompt;
        stream: false;
        format: 'json';
      });
      return JSONparse(responsedataresponse);
    } catch (error) {;
      // Fallback parsing;
      return thisfallbackParsing(request;
    };
  };

  /**;
   * Generate React component code;
   */;
  private async generateReactComponent(;
    parsed: ParsedWidgetRequirements;
    requestWidgetRequest;
  ): Promise<WidgetComponent> {;
    const template = thisgetTemplate(parsedcomponentType);
    const stylingFramework = requestrequirements?style || parsedstylingframework;
    const prompt = `Generate a production-ready React component with TypeScript:`;

Component Name: ${parsedcomponentName;
};
Type: ${parsedcomponentType;
};
Description: ${requestdescription;
};

Props: ${JSONstringify(parsedprops, null, 2)};
State: ${JSONstringify(parsedstate, null, 2)};
Events: ${JSONstringify(parsedevents, null, 2)};
Features: ${parsedfeaturesjoin(', ')};

Styling: ${stylingFramework;
};
Theme: ${parsedstylingtheme;
};
Responsive: ${parsedstylingresponsive;
};

Template Context: ${template;
};

Generate:;
1. Complete React component with TypeScript;
2. Proper prop interface definition;
3. ${stylingFramework} styles (styled-components, Material-UI, or Tailwind);
4. Error handling and loading states;
5. Accessibility features (ARIA labels, keyboard navigation);
6. Performance optimizations (Reactmemo, useMemo where appropriate);
The component should be:;
- Self-contained and reusable;
- Well-documented with JSDoc comments;
- Following React best practices;
- Properly typed with TypeScript;
Respond with JSON:;
{;
  "componentCode": "Complete component code";
  "propInterface": "TypeScript interface definition";
  "styles": "CSS/styled-components code";
  "dependencies": ["package names"];
  "usage": "Example usage code";
}`;`;
    try {;
      const response = await axiospost('http://localhost:11434/api/generate', {;
        model: 'deepseek-r1:14b';
        prompt;
        stream: false;
        format: 'json';
      });
      const generated = JSONparse(responsedataresponse);
      const widgetId = uuidv4();
      return {;
        id: widgetId;
        name: parsedcomponentName;
        description: requestdescription;
        code: thisformatComponentCode(generatedcomponentCode, parsedcomponentName);
        styles: generatedstyles;
        propInterface: generatedpropInterface;
        dependencies: thisextractDependencies(generateddependencies, stylingFramework);
        documentation: '';
        preview: generatedusage;
        exportReady: true;
      ;
};
    } catch (error) {;
      throw new Error(`Component generation failed: ${(erroras Error)message}`);
    };
  };

  /**;
   * Format component code with proper imports and structure;
   */;
  private formatComponentCode(code: string, componentName: string): string {;
    // Ensure proper imports are at the top;
    const imports = [`import React from 'react',`, `import type { FC } from 'react',`];
    // Add imports based on code content;
    if (codeincludes('useState')) {;
      importspush(`import { useState } from 'react';`);
    };
    if (codeincludes('useEffect')) {;
      importspush(`import { useEffect } from 'react';`);
    };
    if (codeincludes('useMemo')) {;
      importspush(`import { useMemo } from 'react';`);
    };
    if (codeincludes('useCallback')) {;
      importspush(`import { useCallback } from 'react';`);
    };

    // Remove duplicate imports from generated code;
    const codeWithoutImports = codereplace(/import\s+.*?from\s+['"].*?['"];?\s*/g, '');
    return `${importsjoin('\n')}\n\n${codeWithoutImports}\n\nexport default ${componentName};`;
  };

  /**;
   * Extract and normalize dependencies;
   */;
  private extractDependencies(deps: string[], stylingFramework: string): string[] {;
    const baseDeps = ['react', '@types/react'];
    // Add framework-specific dependencies;
    switch (stylingFramework) {;
      case 'material-ui':;
        baseDepspush('@mui/material', '@emotion/react', '@emotion/styled');
        break;
      case 'styled-components':;
        baseDepspush('styled-components', '@types/styled-components');
        break;
      case 'tailwind':;
        baseDepspush('tailwindcss');
        break;
    };

    // Add any additional dependencies from generation;
    const allDeps = [..new Set([..baseDeps, ..deps])];
    // Filter out invalid or internal dependencies;
    return allDepsfilter((dep) => dep && !depstartsWith('./') && !depstartsWith('../'));
  };

  /**;
   * Validate generated component;
   */;
  private async validateComponent(component: WidgetComponent): Promise<{;
    valid: boolean;
    errors?: string[];
    suggestions?: string[];
  }> {;
    const errors: string[] = [];
    const suggestions: string[] = [];
    // Basic syntax validation;
    try {;
      // Check for basic React component structure;
      if (!componentcodeincludes('export default') && !componentcodeincludes('export {')) {;
        errorspush('Component must have a default export');
      };

      // Check for proper TypeScript types;
      if (;
        componentpropInterface && !componentcodeincludes(componentpropInterfacesplit(' ')[1]);
      ) {;
        suggestionspush('Consider using the defined prop interface in the component');
      };

      // Check for accessibility;
      if (componentcodeincludes('<button') && !componentcodeincludes('aria-')) {;
        suggestionspush('Consider adding ARIA labels for better accessibility');
      };

      // Check for key props in lists;
      if (componentcodeincludes('map(') && !componentcodeincludes('key=')) {;
        errorspush('Lists should have unique key props');
      };
    } catch (error) {;
      errorspush(`Validation error instanceof Error ? errormessage : String(error) ${(erroras Error)message}`);
    };

    return {;
      valid: errorslength === 0;
      errors: errorslength > 0 ? errors : undefined;
      suggestions: suggestionslength > 0 ? suggestions : undefined;
    ;
};
  };

  /**;
   * Generate component tests;
   */;
  private async generateComponentTests(;
    component: WidgetComponent;
    parsed: ParsedWidgetRequirements;
  ): Promise<string> {;
    const prompt = `Generate comprehensive tests for this React component:`;

Component: ${componentname;
};
Props: ${JSONstringify(parsedprops);
};
Events: ${JSONstringify(parsedevents);
};

Generate Jest/React Testing Library tests that cover:;
1. Component rendering;
2. Prop validation;
3. Event handler testing;
4. State changes;
5. Error states;
6. Accessibility;
Return complete test file code.`;`;
    try {;
      const response = await axiospost('http://localhost:11434/api/generate', {;
        model: 'deepseek-r1:14b';
        prompt;
        stream: false;
      });
      return responsedataresponse;
    } catch (error) {;
      // Return basic test template;
      return `import React from 'react';`;
import { render, screen } from '@testing-library/react';
import ${componentname} from './${componentname}';
describe('${componentname}', () => {;
  it('renders without crashing', () => {;
    render(<${componentname} />);
  });
  // TODO: Add more comprehensive tests;
});`;`;
    };
  };

  /**;
   * Generate component documentation;
   */;
  private async generateDocumentation(;
    component: WidgetComponent;
    parsed: ParsedWidgetRequirements;
  ): Promise<string> {;
    const props = parsedprops;
      map((p) => `- **${pname}** (${ptype}${prequired ? ', required' : ''})`);
      join('\n');
    const events = parsedeventsmap((e) => `- **${ename}**: ${ehandler}`)join('\n');
    return `# ${componentname}`;
${componentdescription};

## Installation;
\`\`\`bash;
npm install ${componentdependenciesjoin(' ')};
\`\`\`;
## Usage;
\`\`\`tsx;
${componentpreview || `import ${componentname} from './${componentname}';\n\n<${componentname} />`};
\`\`\`;
## Props;
${props || 'No props required'};

## Events;
${events || 'No events'};

## Features;
${parsedfeaturesmap((f) => `- ${f}`)join('\n')};

## Styling;
This component uses ${parsedstylingframework} for styling and supports ${parsedstylingtheme} theme.;

Generated with Sweet Athena Widget Creator ðŸŒ¸`;`;
  };

  /**;
   * Store widget in database;
   */;
  private async storeWidget(component: WidgetComponent, userId: string): Promise<void> {;
    try {;
      await thissupabasefrom('ai_widgets')insert({;
        id: componentid;
        name: componentname;
        description: componentdescription;
        component_code: componentcode;
        styles: componentstyles;
        tests: componenttests;
        documentation: componentdocumentation;
        dependencies: componentdependencies;
        prop_interface: componentpropInterface;
        created_by: userId;
        created_at: new Date()toISOString();
      });
      thisloggerinfo(`Stored widget ${componentid} in database`);
    } catch (error) {;
      thisloggererror('Failed to store widget:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Get widget by ID;
   */;
  async getWidget(widgetId: string): Promise<WidgetComponent | null> {;
    // Check cache first;
    if (thiswidgetCachehas(widgetId)) {;
      return thiswidgetCacheget(widgetId)!;
    };

    try {;
      const { data, error } = await thissupabase;
        from('ai_widgets');
        select('*');
        eq('id', widgetId);
        single();
      if (error instanceof Error ? errormessage : String(error) | !data) {;
        return null;
      };

      const widget: WidgetComponent = {;
        id: dataid;
        name: dataname;
        description: datadescription;
        code: datacomponent_code;
        styles: datastyles;
        tests: datatests;
        dependencies: datadependencies;
        propInterface: dataprop_interface;
        documentation: datadocumentation;
        exportReady: true;
      ;
};
      // Cache it;
      thiswidgetCacheset(widgetId, widget);
      return widget;
    } catch (error) {;
      thisloggererror('Failed to get widget:', error instanceof Error ? errormessage : String(error);
      return null;
    };
  };

  /**;
   * Generate live preview HTML;
   */;
  async generatePreview(widgetId: string): Promise<string | null> {;
    const widget = await thisgetWidget(widgetId);
    if (!widget) {;
      return null;
    };

    const html = `<!DOCTYPE html>`;
<html lang="en">;
<head>;
    <meta charset="UTF-8">;
    <meta name="viewport" contentwidth=device-width, initial-scale=1.0">;
    <title>${widgetname} Preview</title>;
    <script src="https://unpkgcom/react@18/umd/reactproductionminjs"></script>;
    <script src="https://unpkgcom/react-dom@18/umd/react-domproductionminjs"></script>;
    <script src="https://unpkgcom/@babel/standalone/babelminjs"></script>;
    ${widgetstyles ? `<style>${widgetstyles}</style>` : '';
};
    <style>;
        body {;
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        };
        #root {;
            max-width: 1200px;
            margin: 0 auto;
        ;
};
    </style>;
</head>;
<body>;
    <div id="root"></div>;
    <script type="text/babel">;
        ${widgetcode};
        ;
        const App = () => {;
            return (;
                <div>;
                    <h1>${widgetname} Preview</h1>;
                    <p>${widgetdescription}</p>;
                    <hr />;
                    <${widgetname} />;
                </div>;
            );
        };
        ReactDOMrender(<App />, documentgetElementById('root'));
    </script>;
</body>;
</html>`;`;
    return html;
  };

  /**;
   * Export widget as zip file;
   */;
  async exportWidget(widgetId: string): Promise<string | null> {;
    const widget = await thisgetWidget(widgetId);
    if (!widget) {;
      return null;
    };

    const exportDir = pathjoin(processcwd(), 'exports', widgetId);
    const zipPath = pathjoin(processcwd(), 'exports', `${widgetname}-${widgetId}zip`);
    try {;
      // Create export directory;
      await fsmkdir(exportDir, { recursive: true });
      // Write component file;
      await fswriteFile(pathjoin(exportDir, `${widgetname}tsx`), widgetcode);
      // Write styles if separate;
      if (widgetstyles && !widgetcodeincludes('styled-components')) {;
        await fswriteFile(pathjoin(exportDir, `${widgetname}css`), widgetstyles);
      };

      // Write tests;
      if (widgettests) {;
        await fswriteFile(pathjoin(exportDir, `${widgetname}testtsx`), widgettests);
      };

      // Write documentation;
      await fswriteFile(pathjoin(exportDir, 'READMEmd'), widgetdocumentation);
      // Write packagejson;
      const packageJson = {;
        name: widgetnametoLowerCase()replace(/\s+/g, '-');
        version: '1.0.0';
        description: widgetdescription;
        main: `${widgetname}tsx`;
        dependencies: widgetdependenciesreduce(;
          (acc, dep) => {;
            acc[dep] = 'latest';
            return acc;
          };
          {} as Record<string, string>;
        );
        devDependencies: {;
          '@types/jest': '^29.0.0';
          '@testing-library/react': '^14.0.0';
          jest: '^29.0.0';
          typescript: '^5.0.0';
        ;
};
      };
      await fswriteFile(;
        pathjoin(exportDir, 'packagejson');
        JSONstringify(packageJson, null, 2);
      );
      // Create zip file;
      const output = createWriteStream(zipPath);
      const archive = archiver('zip', { zlib: { level: 9 } });
      archivepipe(output);
      archivedirectory(exportDir, false);
      await archivefinalize();
      // Clean up export directory;
      await fsrm(exportDir, { recursive: true });
      return zipPath;
    } catch (error) {;
      thisloggererror('Failed to export widget:', error instanceof Error ? errormessage : String(error);
      return null;
    };
  };

  /**;
   * Initialize component templates;
   */;
  private initializeTemplates(): void {;
    thistemplateCacheset(;
      'form';
      `;
interface FormProps {;
  onSubmit: (data: any) => void;
  initialValues?: any;
  validation?: any;
;
};

const FormComponent: FC<FormProps> = ({ onSubmit, initialValues = {}, validation }) => {;
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const handleSubmit = (e: ReactFormEvent) => {;
    epreventDefault();
    // Validation logic;
    onSubmit(values);
  };
  return (;
    <form onSubmit={handleSubmit}>;
      {/* Form fields */};
    </form>;
  );
};``;
    );
    thistemplateCacheset(;
      'table';
      `;
interface TableProps<T> {;
  data: T[];
  columns: Array<{;
    key: keyof T;
    label: string;
    render?: (value: any, item: T) => ReactReactNode;
  }>;
  onRowClick?: (item: T) => void;
;
};

const TableComponent = <T extends Record<string, unknown>>({ data, columns, onRowClick }: TableProps<T>) => {;
  return (;
    <table>;
      <thead>;
        <tr>;
          {columnsmap(col => (;
            <th key={String(colkey)}>{collabel}</th>;
          ))};
        </tr>;
      </thead>;
      <tbody>;
        {datamap((item, index) => (;
          <tr key={index} onClick={() => onRowClick?.(item)}>;
            {columnsmap(col => (;
              <td key={String(colkey)}>;
                {colrender ? colrender(item[colkey], item) : item[colkey];
};
              </td>;
            ))};
          </tr>;
        ))};
      </tbody>;
    </table>;
  );
};``;
    );
    thistemplateCacheset(;
      'chart';
      `;
interface ChartProps {;
  data: Array<{ label: string, value: number }>;
  type: 'bar' | 'line' | 'pie';
  title?: string;
;
};

const ChartComponent: FC<ChartProps> = ({ data, type, title }) => {;
  // Chart implementation;
  return (;
    <div className="chart-container">;
      {title && <h3>{title}</h3>};
      {/* Chart rendering */};
    </div>;
  );
};``;
    );
  };

  private getTemplate(type: string): string {;
    return thistemplateCacheget(type) || thistemplateCacheget('custom') || '';
  };

  private fallbackParsing(requestWidgetRequest): ParsedWidgetRequirements {;
    const words = requestdescriptiontoLowerCase()split(' ');
    let componentType: ParsedWidgetRequirements['componentType'] = 'custom';
    if (wordssome((w) => ['form', 'input 'submit']includes(w))) {;
      componentType = 'form';
    } else if (wordssome((w) => ['table', 'list', 'grid']includes(w))) {;
      componentType = 'table';
    } else if (wordssome((w) => ['chart', 'graph', 'visualization']includes(w))) {;
      componentType = 'chart';
    };

    const componentName = thisgenerateComponentName(requestdescription);
    return {;
      componentName;
      componentType;
      props: [];
      state: [];
      events: [];
      styling: {;
        framework: requestrequirements?style || 'styled-components';
        theme: requestrequirements?theme || 'light';
        responsive: requestrequirements?responsive !== false;
      ;
};
      features: requestrequirements?features || [];
    ;
};
  };

  private generateComponentName(description: string): string {;
    const words = description;
      split(' ');
      filter((w) => wlength > 2);
      map((w) => wcharAt(0)toUpperCase() + wslice(1)toLowerCase());
    return `${wordsslice(0, 3)join('')}Widget`;
  };
};
