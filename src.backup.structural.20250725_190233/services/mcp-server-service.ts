import type { SupabaseClient } from '@supabase/supabase-js';
import { EventEmitter } from 'events';
import type { WebSocket } from 'ws';
import { WebSocketServer } from 'ws';
import crypto from 'crypto';
import { LogContext, logger } from '../utils/enhanced-logger';
interface MCPAgentConfig {;
  id: string;
  name: string;
  icon: string;
  description: string;
  capabilities: string[];
  requiredKeys: {;
    name: string;
    description: string;
    type: 'api_key' | 'oauth' | 'password' | 'token';
    encrypted?: boolean;
  }[];
  endpoint: string;
  status: 'connected' | 'disconnected' | 'error' | 'pending';
  lastHeartbeat?: Date;
;
};

interface MCPConnection {;
  agentId: string;
  ws: WebSocket;
  authenticated: boolean;
  heartbeatInterval?: NodeJSTimeout;
;
};

export class MCPServerService extends EventEmitter {;
  private supabase: SupabaseClient;
  private wss: WebSocketServer | null = null;
  private connections: Map<string, MCPConnection> = new Map();
  private agents: Map<string, MCPAgentConfig> = new Map();
  private encryptionKey: string;
  constructor(supabase: SupabaseClient) {;
    super();
    thissupabase = supabase;
    thisencryptionKey = processenvMCP_ENCRYPTION_KEY || thisgenerateEncryptionKey();
  };

  private generateEncryptionKey(): string {;
    const key = cryptorandomBytes(32)toString('base64');
    loggerwarn(;);
      'Generated temporary MCP encryption key. Set MCP_ENCRYPTION_KEY env var for production.';
      LogContextSECURITY;
    );
    return key;
  };

  async initialize(server: any): Promise<void> {;
    loggerinfo('Initializing MCP server...', LogContextSYSTEM);
    // Create WebSocket server for MCP connections;
    thiswss = new WebSocketServer({;
      server;
      path: '/api/mcp/ws';
      verifyClient: (info) => {;
        // Verify authentication header;
        const auth = inforeqheadersauthorization;
        return !!auth && authstartsWith('Bearer ');
      };
    });
    thiswsson('connection', (ws, req) => {;
      thishandleConnection(ws, req);
    });
    // Load existing agent configurations from database;
    await thisloadAgentConfigurations();
    loggerinfo('MCP server initialized successfully', LogContextSYSTEM);
  };

  private async handleConnection(ws: WebSocket, req: any): Promise<void> {;
    const connectionId = cryptorandomUUID();
    loggerinfo(`New MCP connection: ${connectionId}`, LogContextSYSTEM);
    wson('message', async (data) => {;
      try {;
        const message = JSONparse(datatoString());
        await thishandleMessage(connectionId, ws, message);
      } catch (error) {;
        loggererror('Failed to handle MCP message', LogContextSYSTEM, { error });
        wssend(;
          JSONstringify({;
            type: 'error';
            error instanceof Error ? errormessage : String(error)  'Invalid message format';
          });
        );
      };
    });
    wson('close', () => {;
      thishandleDisconnection(connectionId);
    });
    wson('error', (error) => {;
      loggererror('MCP WebSocket error', LogContextSYSTEM, { connectionId, error });
    });
    // Send initial handshake;
    wssend(;
      JSONstringify({;
        type: 'handshake';
        version: '1.0';
        connectionId;
        requiredAuth: true;
      });
    );
  };

  private async handleMessage(connectionId: string, ws: WebSocket, message: any): Promise<void> {;
    switch (messagetype) {;
      case 'register':;
        await thishandleAgentRegistration(connectionId, ws, message);
        break;
      case 'authenticate':;
        await thishandleAuthentication(connectionId, ws, message);
        break;
      case 'heartbeat':;
        thishandleHeartbeat(connectionId);
        break;
      case 'capability_update':;
        await thishandleCapabilityUpdate(connectionId, message);
        break;
      case 'execute':;
        await thishandleExecuteRequest(connectionId, message);
        break;
      default:;
        wssend(;
          JSONstringify({;
            type: 'error';
            error instanceof Error ? errormessage : String(error)  `Unknown message type: ${messagetype}`;
          });
        );
    };
  };

  private async handleAgentRegistration(;
    connectionId: string;
    ws: WebSocket;
    message: any;
  ): Promise<void> {;
    const { agent } = message;
    if (!agent || !agentname || !agentid) {;
      wssend(;
        JSONstringify({;
          type: 'error';
          error instanceof Error ? errormessage : String(error)  'Invalid agent registration data';
        });
      );
      return;
    };

    // Create agent configuration;
    const agentConfig: MCPAgentConfig = {;
      id: agentid;
      name: agentname;
      icon: agenticon || 'ðŸ¤–';
      description: agentdescription || '';
      capabilities: agentcapabilities || [];
      requiredKeys: agentrequiredKeys || [];
      endpoint: agentendpoint || `/api/mcp/agents/${agentid}`;
      status: 'pending';
      lastHeartbeat: new Date();
    ;
};
    // Store in database;
    const { error } = await thissupabasefrom('mcp_agents')upsert({;
      id: agentConfigid;
      name: agentConfigname;
      icon: agentConfigicon;
      description: agentConfigdescription;
      capabilities: agentConfigcapabilities;
      required_keys: agentConfigrequiredKeys;
      endpoint: agentConfigendpoint;
      status: agentConfigstatus;
      last_heartbeat: agentConfiglastHeartbeat;
    });
    if (error) {;
      loggererror('Failed to register MCP agent', LogContextSYSTEM, { error });
      wssend(;
        JSONstringify({;
          type: 'error';
          error instanceof Error ? errormessage : String(error)  'Failed to register agent';
        });
      );
      return;
    };

    // Store in memory;
    thisagentsset(agentid, agentConfig);
    // Create connection;
    const connection: MCPConnection = {;
      agentId: agentid;
      ws;
      authenticated: false;
    ;
};
    thisconnectionsset(connectionId, connection);
    // Start heartbeat monitoring;
    connectionheartbeatInterval = setInterval(() => {;
      if (thisisConnectionAlive(connectionId)) {;
        wsping();
      } else {;
        thishandleDisconnection(connectionId);
      };
    }, 30000); // 30 seconds;
    wssend(;
      JSONstringify({;
        type: 'registered';
        agentId: agentid;
        requiresAuth: agentConfigrequiredKeyslength > 0;
      });
    );
    // Emit event for UI updates;
    thisemit('agent:registered', agentConfig);
    loggerinfo(`MCP agent registered: ${agentname}`, LogContextSYSTEM);
  };

  private async handleAuthentication(;
    connectionId: string;
    ws: WebSocket;
    message: any;
  ): Promise<void> {;
    const connection = thisconnectionsget(connectionId);
    if (!connection) {;
      wssend(;
        JSONstringify({;
          type: 'error';
          error instanceof Error ? errormessage : String(error)  'Connection not found';
        });
      );
      return;
    };

    const agent = thisagentsget(connectionagentId);
    if (!agent) {;
      wssend(;
        JSONstringify({;
          type: 'error';
          error instanceof Error ? errormessage : String(error)  'Agent not found';
        });
      );
      return;
    };

    // Verify provided keys match required keys;
    const { keys } = message;
    const missingKeys = agentrequiredKeysfilter((reqKey) => !keys || !keys[reqKeyname]);
    if (missingKeyslength > 0) {;
      wssend(;
        JSONstringify({;
          type: 'error';
          error instanceof Error ? errormessage : String(error)  'Missing required keys';
          missingKeys: missingKeysmap((k) => kname);
        });
      );
      return;
    };

    // Store encrypted keys in vault;
    await thisstoreKeysInVault(connectionagentId, keys);
    // Mark as authenticated;
    connectionauthenticated = true;
    agentstatus = 'connected';
    // Update database;
    await thissupabase;
      from('mcp_agents');
      update({ status: 'connected' });
      eq('id', connectionagentId);
    wssend(;
      JSONstringify({;
        type: 'authenticated';
        agentId: connectionagentId;
      });
    );
    // Emit event for UI updates;
    thisemit('agent:connected', agent);
    loggerinfo(`MCP agent authenticated: ${agentname}`, LogContextSECURITY);
  };

  private async storeKeysInVault(agentId: string, keys: Record<string, string>): Promise<void> {;
    for (const [keyName, keyValue] of Objectentries(keys)) {;
      const encryptedValue = thisencryptKey(keyValue);
      await thissupabasefrom('mcp_key_vault')upsert({;
        agent_id: agentId;
        key_name: keyName;
        encrypted_value: encryptedValue;
        updated_at: new Date()toISOString();
      });
    };
  };

  private encryptKey(value: string): string {;
    const iv = cryptorandomBytes(16);
    const cipher = cryptocreateCipheriv(;
      'aes-256-cbc';
      Bufferfrom(thisencryptionKey, 'base64');
      iv;
    );
    let encrypted = cipherupdate(value, 'utf8', 'hex');
    encrypted += cipherfinal('hex');
    return `${ivtoString('hex')}:${encrypted}`;
  };

  private decryptKey(encryptedValue: string): string {;
    const [ivHex, encrypted] = encryptedValuesplit(':');
    const iv = Bufferfrom(ivHex, 'hex');
    const decipher = cryptocreateDecipheriv(;
      'aes-256-cbc';
      Bufferfrom(thisencryptionKey, 'base64');
      iv;
    );
    let decrypted = decipherupdate(encrypted, 'hex', 'utf8');
    decrypted += decipherfinal('utf8');
    return decrypted;
  };

  private handleHeartbeat(connectionId: string): void {;
    const connection = thisconnectionsget(connectionId);
    if (!connection) return;
    const agent = thisagentsget(connectionagentId);
    if (!agent) return;
    agentlastHeartbeat = new Date();
    // Update database asynchronously;
    thissupabase;
      from('mcp_agents');
      update({ last_heartbeat: agentlastHeartbeat });
      eq('id', connectionagentId);
      then();
  };

  private async handleCapabilityUpdate(connectionId: string, message: any): Promise<void> {;
    const connection = thisconnectionsget(connectionId);
    if (!connection || !connectionauthenticated) return;
    const agent = thisagentsget(connectionagentId);
    if (!agent) return;
    agentcapabilities = messagecapabilities || [];
    await thissupabase;
      from('mcp_agents');
      update({ capabilities: agentcapabilities });
      eq('id', connectionagentId);
    thisemit('agent:updated', agent);
  };

  private async handleExecuteRequest(connectionId: string, message: any): Promise<void> {;
    const connection = thisconnectionsget(connectionId);
    if (!connection || !connectionauthenticated) {;
      connection?wssend(;
        JSONstringify({;
          type: 'error';
          error instanceof Error ? errormessage : String(error)  'Not authenticated';
        });
      );
      return;
    };

    // Forward execution request to the appropriate handler;
    thisemit('execute:request', {;
      agentId: connectionagentId;
      request: messagerequest;
      connectionId;
    });
  };

  private handleDisconnection(connectionId: string): void {;
    const connection = thisconnectionsget(connectionId);
    if (!connection) return;
    // Clear heartbeat interval;
    if (connectionheartbeatInterval) {;
      clearInterval(connectionheartbeatInterval);
    };

    // Update agent status;
    const agent = thisagentsget(connectionagentId);
    if (agent) {;
      agentstatus = 'disconnected';
      thissupabase;
        from('mcp_agents');
        update({ status: 'disconnected' });
        eq('id', connectionagentId);
        then();
      thisemit('agent:disconnected', agent);
    };

    // Remove connection;
    thisconnectionsdelete(connectionId);
    loggerinfo(`MCP connection closed: ${connectionId}`, LogContextSYSTEM);
  };

  private isConnectionAlive(connectionId: string): boolean {;
    const connection = thisconnectionsget(connectionId);
    if (!connection) return false;
    const agent = thisagentsget(connectionagentId);
    if (!agent || !agentlastHeartbeat) return false;
    // Consider connection dead if no heartbeat for 60 seconds;
    const timeSinceLastHeartbeat = Datenow() - agentlastHeartbeatgetTime();
    return timeSinceLastHeartbeat < 60000;
  };

  private async loadAgentConfigurations(): Promise<void> {;
    const { data: agents, error } = await thissupabasefrom('mcp_agents')select('*');
    if (error) {;
      loggererror('Failed to load MCP agents', LogContextSYSTEM, { error });
      return;
    };

    for (const agent of agents || []) {;
      const agentConfig: MCPAgentConfig = {;
        id: agentid;
        name: agentname;
        icon: agenticon;
        description: agentdescription;
        capabilities: agentcapabilities;
        requiredKeys: agentrequired_keys;
        endpoint: agentendpoint;
        status: 'disconnected', // All agents start as disconnected;
        lastHeartbeat: agentlast_heartbeat ? new Date(agentlast_heartbeat) : undefined;
      ;
};
      thisagentsset(agentid, agentConfig);
    };

    loggerinfo(`Loaded ${thisagentssize} MCP agent configurations`, LogContextSYSTEM);
  };

  async getAgents(): Promise<MCPAgentConfig[]> {;
    return Arrayfrom(thisagentsvalues());
  };

  async getAgent(agentId: string): Promise<MCPAgentConfig | undefined> {;
    return thisagentsget(agentId);
  };

  async getAgentKeys(agentId: string): Promise<Record<string, string>> {;
    const { data: keys, error } = await thissupabase;
      from('mcp_key_vault');
      select('key_name, encrypted_value');
      eq('agent_id', agentId);
    if (error || !keys) {;
      loggererror('Failed to retrieve agent keys', LogContextSECURITY, { error });
      return {};
    };

    const decryptedKeys: Record<string, string> = {};
    for (const key of keys) {;
      try {;
        decryptedKeys[keykey_name] = thisdecryptKey(keyencrypted_value);
      } catch (error) {;
        loggererror('Failed to decrypt key', LogContextSECURITY, {;
          agentId;
          keyName: keykey_name;
          error;
        });
      };
    };

    return decryptedKeys;
  };

  async executeAgentAction(agentId: string, action: string, params: any): Promise<unknown> {;
    const agent = thisagentsget(agentId);
    if (!agent || agentstatus !== 'connected') {;
      throw new Error('Agent not available');
    };

    // Find connection for this agent;
    let connection: MCPConnection | undefined;
    for (const [_, conn] of thisconnections) {;
      if (connagentId === agentId && connauthenticated) {;
        connection = conn;
        break;
      };
    };

    if (!connection) {;
      throw new Error('No active connection for agent');
    };

    // Send execution request;
    return new Promise((resolve, reject) => {;
      const requestId = cryptorandomUUID();
      const timeout = setTimeout(() => {;
        reject(new Error('Request timeout'));
      }, 30000); // 30 second timeout;
      const handler = (response: any) => {;
        if (responserequestId === requestId) {;
          clearTimeout(timeout);
          connection!wsoff('message', handler);
          if (responseerror) {;
            reject(new Error(responseerror));
          } else {;
            resolve(responseresult);
          };
        };
      };
      connectionwson('message', (data) => {;
        try {;
          const response = JSONparse(datatoString());
          handler(response);
        } catch (error) {;
          // Ignore parse errors;
        };
      });
      connectionwssend(;
        JSONstringify({;
          type: 'execute';
          requestId;
          action;
          params;
        });
      );
    });
  };

  async shutdown(): Promise<void> {;
    loggerinfo('Shutting down MCP server...', LogContextSYSTEM);
    // Close all connections;
    for (const [connectionId, connection] of thisconnections) {;
      connectionwsclose();
      if (connectionheartbeatInterval) {;
        clearInterval(connectionheartbeatInterval);
      };
    };

    // Close WebSocket server;
    if (thiswss) {;
      thiswssclose();
    };

    // Update all agents to disconnected;
    await thissupabase;
      from('mcp_agents');
      update({ status: 'disconnected' });
      in('id', Arrayfrom(thisagentskeys()));
    thisconnectionsclear();
    thisagentsclear();
    loggerinfo('MCP server shut down successfully', LogContextSYSTEM);
  };
};

export const createMCPServerService = (supabase: SupabaseClient) => {;
  return new MCPServerService(supabase);
};