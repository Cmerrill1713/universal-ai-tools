import { EventEmitter } from 'events';
import * as v8 from 'v8';
import { performance } from 'perf_hooks';
import { LogContext, logger } from '../utils/enhanced-logger';
import type { MemoryConfig } from '../config/resources';
import { getResourceConfig } from '../config/resources';
import { promises as fs } from 'fs';
import * as path from 'path';
export interface MemorySnapshot {;
  timestamp: Date;
  heapUsed: number;
  heapTotal: number;
  external: number;
  arrayBuffers: number;
  rss: number;
  heapUsedPercent: number;
  heapSizeLimit: number;
};

export interface MemoryLeak {;
  id: string;
  type: string;
  size: number;
  growthRate: number;
  firstDetected: Date;
  lastChecked: Date;
  samples: number[];
};

export interface CacheEntry {;
  key: string;
  size: number;
  lastAccessed: Date;
  hits: number;
  priority: number;
};

export class MemoryManager extends EventEmitter {;
  private static instance: MemoryManager;
  private config: MemoryConfig;
  private snapshots: MemorySnapshot[] = [];
  private leaks: Map<string, MemoryLeak> = new Map();
  private caches: Map<string, Map<string, CacheEntry>> = new Map();
  private gcForced = 0;
  private monitoringInterval?: NodeJSTimeout;
  private leakDetectionInterval?: NodeJSTimeout;
  private heapSnapshotInterval?: NodeJSTimeout;
  private lastGC: Date = new Date();
  private memoryPressureCallbacks: Array<() => void> = [];
  private constructor() {;
    super();
    thisconfig = getResourceConfig()memory;
    thisinitialize()};

  public static getInstance(): MemoryManager {;
    if (!MemoryManagerinstance) {;
      MemoryManagerinstance = new MemoryManager()};
    return MemoryManagerinstance;
  };

  private initialize() {;
    // Start memory monitoring;
    thisstartMonitoring();
    // Set up heap snapshot collection;
    if (thisconfigenableMemoryProfiling) {;
      thisstartHeapSnapshotCollection()};

    // Set up leak detection;
    if (thisconfigenableLeakDetection) {;
      thisstartLeakDetection()};

    // Handle process signals;
    processon('SIGUSR2', () => thistakeHeapSnapshot());
  };

  private startMonitoring() {;
    thismonitoringInterval = setInterval(() => {;
      thiscollectMemoryMetrics()}, thisconfigmemoryCheckInterval);
    // Monitor for memory pressure;
    thison('memory-pressure', (level: 'warning' | 'critical') => {;
      loggerwarn(`Memory pressure detected: ${level}`, LogContextPERFORMANCE);
      thishandleMemoryPressure(level);
    });
  };

  private collectMemoryMetrics() {;
    const memUsage = processmemoryUsage();
    const heapStats = v8getHeapStatistics();
    const heapUsedPercent = (memUsageheapUsed / heapStatsheap_size_limit) * 100,;

    const snapshot: MemorySnapshot = {;
      timestamp: new Date();
      heapUsed: memUsageheapUsed;
      heapTotal: memUsageheapTotal;
      external: memUsageexternal;
      arrayBuffers: memUsagearrayBuffers || 0;
      rss: memUsagerss;
      heapUsedPercent;
      heapSizeLimit: heapStatsheap_size_limit;
};
    thissnapshotspush(snapshot);
    // Keep only last 100 snapshots;
    if (thissnapshotslength > 100) {;
      thissnapshotsshift()};

    // Check thresholds;
    if (heapUsedPercent >= thisconfigcriticalThresholdPercent) {;
      thisemit('memory-pressure', 'critical')} else if (heapUsedPercent >= thisconfigwarningThresholdPercent) {;
      thisemit('memory-pressure', 'warning')};

    // Emit metrics;
    thisemit('memory-metrics', snapshot);
    // Log if verbose;
    if (processenvLOG_LEVEL === 'debug') {;
      loggerdebug('Memory metrics', LogContextPERFORMANCE, {;
        heapUsed: `${(snapshotheapUsed / 1024 / 1024)toFixed(2)} MB`;
        heapTotal: `${(snapshotheapTotal / 1024 / 1024)toFixed(2)} MB`;
        rss: `${(snapshotrss / 1024 / 1024)toFixed(2)} MB`;
        heapUsedPercent: `${snapshotheapUsedPercenttoFixed(1)}%`});
    };
  };

  private handleMemoryPressure(level: 'warning' | 'critical') {;
    if (level === 'critical') {;
      // Force garbage collection;
      thisforceGC();
      // Clear caches;
      thisclearAllCaches();
      // Execute registered callbacks;
      thismemoryPressureCallbacksforEach((callback) => {;
        try {;
          callback()} catch (error) {;
          loggererror('Error in memory pressure callback', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error) );
};
      });
    } else if (level === 'warning') {;
      // Clear old cache entries;
      thisevictOldCacheEntries();
      // Suggest GC;
      if (Datenow() - thislastGCgetTime() > thisconfiggcInterval) {;
        thisforceGC()};
    };
  };

  public forceGC() {;
    if (globalgc) {;
      const before = processmemoryUsage()heapUsed;
      const startTime = performancenow();
      globalgc();
      thisgcForced++;
      thislastGC = new Date();
      const after = processmemoryUsage()heapUsed;
      const duration = performancenow() - startTime;
      const freed = before - after;
      loggerinfo(;
        `Forced GC completed in ${durationtoFixed(2)}ms, freed ${(freed / 1024 / 1024)toFixed(2)} MB`;
        LogContextPERFORMANCE;
      );
      thisemit('gc-completed', {;
        duration;
        freedMemory: freed;
        heapBefore: before;
        heapAfter: after});
    } else {;
      loggerwarn(;
        'Garbage collection not exposed. Run with --expose-gc flag';
        LogContextPERFORMANCE;
      )};
  };

  // Leak detection;
  private startLeakDetection() {;
    const samples: Map<string, number[]> = new Map();
    thisleakDetectionInterval = setInterval(() => {;
      const heapStats = v8getHeapStatistics();
      const spaces = v8getHeapSpaceStatistics();
      spacesforEach((space) => {;
        const key = spacespace_name;
        const size = spacespace_used_size;
        if (!sampleshas(key)) {;
          samplesset(key, [])};

        const spaceSamples = samplesget(key)!;
        spaceSamplespush(size);
        // Keep last 10 samples;
        if (spaceSampleslength > 10) {;
          spaceSamplesshift()};

        // Detect potential leak;
        if (spaceSampleslength >= 5) {;
          const growthRate = thiscalculateGrowthRate(spaceSamples),;

          if (growthRate > 0.1) {;
            // 10% growth rate threshold;
            const leak = thisleaksget(key) || {;
              id: key;
              type: 'heap-space';
              size;
              growthRate;
              firstDetected: new Date();
              lastChecked: new Date();
              samples: spaceSamples;
};
            leaksize = size;
            leakgrowthRate = growthRate;
            leaklastChecked = new Date();
            leaksamples = spaceSamples;
            thisleaksset(key, leak);
            loggerwarn(;
              `Potential memory leak detected in ${key}: ${(growthRate * 100)toFixed(1)}% growth rate`;
              LogContextPERFORMANCE;
            );
            thisemit('leak-detected', leak);
          } else {;
            // Remove from leaks if growth stopped;
            thisleaksdelete(key)};
        };
      });
    }, thisconfigleakDetectionInterval);
  };

  private calculateGrowthRate(samples: number[]): number {;
    if (sampleslength < 2) return 0;
    const firstHalf = samplesslice(0, Mathfloor(sampleslength / 2));
    const secondHalf = samplesslice(Mathfloor(sampleslength / 2));
    const avgFirst = firstHalfreduce((a, b) => a + b, 0) / firstHalflength;
    const avgSecond = secondHalfreduce((a, b) => a + b, 0) / secondHalflength;
    return (avgSecond - avgFirst) / avgFirst};

  // Cache management;
  public registerCache(name: string) {;
    if (!thiscacheshas(name)) {;
      thiscachesset(name, new Map());
      loggerinfo(`Registered cache: ${name}`, LogContextPERFORMANCE);
    };
  };

  public addCacheEntry(cacheName: string, key: string, size: number, priority = 1) {;
    const cache = thiscachesget(cacheName),;
    if (!cache) {;
      loggerwarn(`Cache ${cacheName} not registered`, LogContextPERFORMANCE);
      return;
    };

    cacheset(key, {;
      key;
      size;
      lastAccessed: new Date();
      hits: 0;
      priority});
    // Check if eviction needed;
    const totalSize = thisgetCacheSize(cacheName);
    const heapUsedPercent =;
      (processmemoryUsage()heapUsed / v8getHeapStatistics()heap_size_limit) * 100;
    if (heapUsedPercent > thisconfigcacheEvictionThreshold) {;
      thisevictCacheEntries(cacheName, totalSize * 0.2); // Evict 20%};
  };

  public getCacheEntry(cacheName: string, key: string): CacheEntry | undefined {;
    const cache = thiscachesget(cacheName);
    if (!cache) return undefined;
    const entry = cacheget(key);
    if (entry) {;
      entrylastAccessed = new Date();
      entryhits++};
    return entry;
  };

  public removeCacheEntry(cacheName: string, key: string) {;
    const cache = thiscachesget(cacheName);
    if (cache) {;
      cachedelete(key)};
  };

  private getCacheSize(cacheName: string): number {;
    const cache = thiscachesget(cacheName);
    if (!cache) return 0;
    let totalSize = 0;
    cacheforEach((entry) => {;
      totalSize += entrysize});
    return totalSize;
  };

  private evictCacheEntries(cacheName: string, targetSize: number) {;
    const cache = thiscachesget(cacheName);
    if (!cache) return;
    // Sort by priority and last accessed time;
    const entries = Arrayfrom(cachevalues())sort((a, b) => {;
      if (apriority !== bpriority) {;
        return apriority - bpriority; // Lower priority first};
      return alastAccessedgetTime() - blastAccessedgetTime(); // Older first;
    });
    let evicted = 0;
    for (const entry of entries) {;
      if (evicted >= targetSize) break;
      cachedelete(entrykey);
      evicted += entrysize;
      loggerdebug(;
        `Evicted cache entry: ${entrykey} (${entrysize} bytes)`;
        LogContextPERFORMANCE;
      );
    };

    loggerinfo(`Evicted ${evicted} bytes from cache ${cacheName}`, LogContextPERFORMANCE);
    thisemit('cache-evicted', { cacheName, evictedSize: evicted });
  };

  private evictOldCacheEntries() {;
    const now = Datenow();
    const maxAge = 3600000; // 1 hour;

    thiscachesforEach((cache, cacheName) => {;
      const toEvict: string[] = [];
      cacheforEach((entry, key) => {;
        if (now - entrylastAccessedgetTime() > maxAge) {;
          toEvictpush(key)};
      });
      toEvictforEach((key) => {;
        cachedelete(key)});
      if (toEvictlength > 0) {;
        loggerinfo(;
          `Evicted ${toEvictlength} old entries from cache ${cacheName}`;
          LogContextPERFORMANCE;
        );
      };
    });
  };

  private clearAllCaches() {;
    let totalCleared = 0,;

    thiscachesforEach((cache, cacheName) => {;
      const { size } = cache;
      cacheclear();
      totalCleared += size;
      loggerinfo(`Cleared cache ${cacheName}: ${size} entries`, LogContextPERFORMANCE);
    });
    thisemit('caches-cleared', { totalCleared });
  };

  // Heap snapshots;
  private startHeapSnapshotCollection() {;
    thisheapSnapshotInterval = setInterval(() => {;
      thistakeHeapSnapshot()}, thisconfigheapSnapshotInterval);
  };

  public async takeHeapSnapshot(): Promise<string> {;
    const timestamp = new Date()toISOString()replace(/[:.]/g, '-'),;
    const filename = `heap-${timestamp}heapsnapshot`;
    const filepath = pathjoin(processcwd(), 'heap-snapshots', filename);
    try {;
      await fsmkdir(pathdirname(filepath), { recursive: true });
      const stream = v8getHeapSnapshot();
      const chunks: Buffer[] = [];
      for await (const chunk of stream) {;
        chunkspush(chunk)};

      await fswriteFile(filepath, Bufferconcat(chunks));
      loggerinfo(`Heap snapshot saved to ${filepath}`, LogContextPERFORMANCE);
      thisemit('heap-snapshot', { filepath });
      return filepath;
    } catch (error) {;
      loggererror('Failed to take heap snapshot', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error));
      throw error instanceof Error ? errormessage : String(error)};
  };

  // Memory profiling;
  public getMemoryProfile(): any {;
    const current = processmemoryUsage();
    const heapStats = v8getHeapStatistics();
    const spaces = v8getHeapSpaceStatistics(),;

    return {;
      current: {;
        heapUsed: currentheapUsed;
        heapTotal: currentheapTotal;
        external: currentexternal;
        arrayBuffers: currentarrayBuffers || 0;
        rss: currentrss};
      heap: {;
        totalHeapSize: heapStatstotal_heap_size;
        totalHeapSizeExecutable: heapStatstotal_heap_size_executable;
        totalPhysicalSize: heapStatstotal_physical_size;
        totalAvailableSize: heapStatstotal_available_size;
        usedHeapSize: heapStatsused_heap_size;
        heapSizeLimit: heapStatsheap_size_limit;
        mallocedMemory: heapStatsmalloced_memory;
        peakMallocedMemory: heapStatspeak_malloced_memory;
        doesZapGarbage: heapStatsdoes_zap_garbage};
      spaces: spacesmap((space) => ({;
        spaceName: spacespace_name;
        spaceSize: spacespace_size;
        spaceUsedSize: spacespace_used_size;
        spaceAvailableSize: spacespace_available_size;
        physicalSpaceSize: spacephysical_space_size}));
      caches: Arrayfrom(thiscachesentries())map(([name, cache]) => ({;
        name;
        entries: cachesize;
        totalSize: thisgetCacheSize(name)}));
      leaks: Arrayfrom(thisleaksvalues());
      gcForced: thisgcForced;
      lastGC: thislastGC;
};
  };

  // Alerts and callbacks;
  public onMemoryPressure(callback: () => void) {;
    thismemoryPressureCallbackspush(callback);
};

  public removeMemoryPressureCallback(callback: () => void) {;
    const index = thismemoryPressureCallbacksindexOf(callback);
    if (index > -1) {;
      thismemoryPressureCallbackssplice(index, 1)};
  };

  // Memory usage alerts;
  public checkMemoryUsage(): { status: 'ok' | 'warning' | 'critical', details: any } {;
    const current = processmemoryUsage();
    const heapStats = v8getHeapStatistics();
    const heapUsedPercent = (currentheapUsed / heapStatsheap_size_limit) * 100;
    let status: 'ok' | 'warning' | 'critical' = 'ok';
    if (heapUsedPercent >= thisconfigcriticalThresholdPercent) {;
      status = 'critical'} else if (heapUsedPercent >= thisconfigwarningThresholdPercent) {;
      status = 'warning'};

    return {;
      status;
      details: {;
        heapUsedPercent: heapUsedPercenttoFixed(1);
        heapUsed: `${(currentheapUsed / 1024 / 1024)toFixed(2)} MB`;
        heapLimit: `${(heapStatsheap_size_limit / 1024 / 1024)toFixed(2)} MB`;
        rss: `${(currentrss / 1024 / 1024)toFixed(2)} MB`;
        external: `${(currentexternal / 1024 / 1024)toFixed(2)} MB`}};
  };

  // AI Assistant Memory Integration;
  public async storeAIMemory(context: string, response: any, metadata: any = {}): Promise<void> {;
    try {;
      const memoryItem = {;
        context;
        response;
        metadata: {;
          ..metadata;
          timestamp: new Date()toISOString();
          memoryPressure: thisgetCurrentMemoryPressure();
          cacheHits: thisgetTotalCacheHits()}};
      // Add to specialized AI memory cache;
      thisaddCacheEntry(;
        'ai_memories';
        thisgenerateMemoryKey(context);
        JSONstringify(memoryItem)length;
        5 // High priority for AI memories;
      );
      loggerdebug('AI memory stored', LogContextPERFORMANCE, {;
        contextLength: contextlength;
        memoryPressure: thisgetCurrentMemoryPressure()});
    } catch (error) {;
      loggererror('Failed to store AI memory', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error) );
};
  };

  public retrieveAIMemory(context: string): any | null {;
    try {;
      const key = thisgenerateMemoryKey(context);
      const entry = thisgetCacheEntry('ai_memories', key);
      if (entry) {;
        return JSONparse(key), // Simplified for demo;
      };
      return null;
    } catch (error) {;
      loggererror('Failed to retrieve AI memory', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error));
      return null};
  };

  private generateMemoryKey(context: string): string {;
    // Simple hash function for memory keys;
    return Bufferfrom(context)toString('base64')substring(0, 32)};

  private getCurrentMemoryPressure(): number {;
    const latest = thissnapshots[thissnapshotslength - 1];
    return latest ? latestheapUsedPercent : 0};

  private getTotalCacheHits(): number {;
    let totalHits = 0;
    thiscachesforEach((cache) => {;
      cacheforEach((entry) => {;
        totalHits += entryhits});
    });
    return totalHits;
  };

  // Enhanced memory optimization for AI workloads;
  public optimizeForAI(): void {;
    loggerinfo('Optimizing memory manager for AI workloads...', LogContextPERFORMANCE);
    // Register AI-specific caches;
    thisregisterCache('ai_memories');
    thisregisterCache('agentcontexts');
    thisregisterCache('orchestration_results');
    thisregisterCache('dspy_outputs');
    // Add AI-specific memory pressure callback;
    thisonMemoryPressure(() => {;
      // Clear less critical caches first;
      thisevictCacheEntries(;
        'orchestration_results';
        thisgetCacheSize('orchestration_results') * 0.3;
      );
      thisevictCacheEntries('dspy_outputs', thisgetCacheSize('dspy_outputs') * 0.2)});
    loggerinfo('Memory manager optimized for AI workloads', LogContextPERFORMANCE);
  };

  // Get AI-specific memory metrics;
  public getAIMemoryMetrics(): any {;
    const aiCaches = ['ai_memories', 'agentcontexts', 'orchestration_results', 'dspy_outputs'],;
    const metrics: any = {;
      aiCacheStats: {};
      totalAIMemoryUsage: 0;
      memoryEfficiency: 0;
};
    aiCachesforEach((cacheName) => {;
      const cache = thiscachesget(cacheName);
      if (cache) {;
        const size = thisgetCacheSize(cacheName);
        const hitRate = thiscalculateCacheHitRate(cacheName),;

        metricsaiCacheStats[cacheName] = {;
          entries: cachesize;
          sizeBytes: size;
          hitRate};
        metricstotalAIMemoryUsage += size;
      };
    });
    // Calculate overall efficiency;
    const totalHits = thisgetTotalCacheHits();
    const totalRequests = thissnapshotslength;
    metricsmemoryEfficiency = totalRequests > 0 ? totalHits / totalRequests : 0;
    return metrics;
  };

  private calculateCacheHitRate(cacheName: string): number {;
    const cache = thiscachesget(cacheName);
    if (!cache) return 0;
    let totalHits = 0;
    let totalEntries = 0;
    cacheforEach((entry) => {;
      totalHits += entryhits;
      totalEntries++});
    return totalEntries > 0 ? totalHits / totalEntries : 0;
  };

  // Shutdown;
  public shutdown() {;
    loggerinfo('Shutting down memory manager...', LogContextPERFORMANCE);
    if (thismonitoringInterval) {;
      clearInterval(thismonitoringInterval)};
    if (thisleakDetectionInterval) {;
      clearInterval(thisleakDetectionInterval)};
    if (thisheapSnapshotInterval) {;
      clearInterval(thisheapSnapshotInterval)};

    thisclearAllCaches();
    thisremoveAllListeners();
    loggerinfo('Memory manager shutdown complete', LogContextPERFORMANCE);
  };
};

// Export singleton instance;
export const memoryManager = MemoryManagergetInstance();