import { promises as fs } from 'fs';
import * as path from 'path';
import { exec, execSync } from 'child_process';
import { promisify } from 'util';
import { logger } from '../utils/enhanced-logger';
import { agentCollaborationWS } from './agent-collaboration-websocket';
import { EventEmitter } from 'events';
import { SearXNGClient } from '../core/knowledge/searxng-client';
import axios from 'axios';
import * as cheerio from 'cheerio';
const execAsync = promisify(exec);
export interface ToolDefinition {;
  name: string;
  description: string;
  inputSchema: Record<string, any>;
  category: 'file' | 'code' | 'system' | 'analysis' | 'web';
  permissions?: string[];
;
};

export interface ToolExecutionRequest {;
  tool: string;
  parameters: Record<string, any>;
  agentId?: string;
  requestId?: string;
;
};

export interface ToolExecutionResult {;
  success: boolean;
  output?: any;
  error?: string;
  executionTime: number;
  toolUsed: string;
;
};

export class ToolExecutionService extends EventEmitter {;
  private tools: Map<string, ToolDefinition> = new Map();
  private executionHistory: ToolExecutionResult[] = [];
  private workingDirectory: string;
  private searxngClient: SearXNGClient;
  constructor(workingDirectory: string = processcwd()) {;
    super();
    thisworkingDirectory = workingDirectory;
    thissearxngClient = new SearXNGClient(processenvSEARXNG_URL || 'http: //localhost:8888');
    thisregisterSystemTools();
  ;
};

  private registerSystemTools(): void {;
    // File operation tools;
    thisregisterTool({;
      name: 'READ_FILE';
      description: 'Read contents of a file';
      inputSchema: {;
        path: { type: 'string', required: true ;
};
        encoding: { type: 'string', default: 'utf8' ;
};
      };
      category: 'file';
    });
    thisregisterTool({;
      name: 'WRITE_FILE';
      description: 'Write content to a file';
      inputSchema: {;
        path: { type: 'string', required: true ;
};
        content: { type: 'string', required: true ;
};
        encoding: { type: 'string', default: 'utf8' ;
};
      };
      category: 'file';
    });
    thisregisterTool({;
      name: 'LIST_FILES';
      description: 'List files in a directory';
      inputSchema: {;
        path: { type: 'string', required: true ;
};
        recursive: { type: 'boolean', default: false ;
};
      };
      category: 'file';
    });
    thisregisterTool({;
      name: 'CREATE_FILE';
      description: 'Create a new file with content';
      inputSchema: {;
        path: { type: 'string', required: true ;
};
        content: { type: 'string', required: true ;
};
      };
      category: 'file';
    });
    thisregisterTool({;
      name: 'DELETE_FILE';
      description: 'Delete a file';
      inputSchema: {;
        path: { type: 'string', required: true ;
};
      };
      category: 'file';
    });
    thisregisterTool({;
      name: 'CREATE_DIRECTORY';
      description: 'Create a new directory';
      inputSchema: {;
        path: { type: 'string', required: true ;
};
        recursive: { type: 'boolean', default: true ;
};
      };
      category: 'file';
    });
    // Code execution tools;
    thisregisterTool({;
      name: 'EXECUTE_CODE';
      description: 'Execute code in various languages';
      inputSchema: {;
        language: { type: 'string', required: true ;
};
        code: { type: 'string', required: true ;
};
        timeout: { type: 'number', default: 30000 ;
};
      };
      category: 'code';
    });
    thisregisterTool({;
      name: 'EXECUTE_COMMAND';
      description: 'Execute a shell command';
      inputSchema: {;
        command: { type: 'string', required: true ;
};
        cwd: { type: 'string', default: processcwd() ;
};
        timeout: { type: 'number', default: 30000 ;
};
      };
      category: 'system';
    });
    // Analysis tools;
    thisregisterTool({;
      name: 'ANALYZE_CODE';
      description: 'Analyze code structure and quality';
      inputSchema: {;
        path: { type: 'string', required: true ;
};
        language: { type: 'string' ;
};
      };
      category: 'analysis';
    });
    thisregisterTool({;
      name: 'SEARCH_FILES';
      description: 'Search for patterns in files';
      inputSchema: {;
        pattern: { type: 'string', required: true ;
};
        path: { type: 'string', default: '.' ;
};
        fileTypes: { type: 'array', default: [] ;
};
      };
      category: 'analysis';
    });
    // Web scraping and search tools;
    thisregisterTool({;
      name: 'WEB_SEARCH';
      description: 'Search the web using SearXNG';
      inputSchema: {;
        query: { type: 'string', required: true ;
};
        engines: { type: 'string', default: 'duckduckgo,google' };
        category: { type: 'string', default: 'general' ;
};
        limit: { type: 'number', default: 10 ;
};
      };
      category: 'web';
    });
    thisregisterTool({;
      name: 'SCRAPE_WEBPAGE';
      description: 'Scrape content from a webpage';
      inputSchema: {;
        url: { type: 'string', required: true ;
};
        selector: { type: 'string' ;
};
        extractType: { type: 'string', default: 'text' ;
};
      };
      category: 'web';
    });
    thisregisterTool({;
      name: 'DISCOVER_TOOLS';
      description: 'Search for and discover new tools from the web';
      inputSchema: {;
        query: { type: 'string', required: true ;
};
        technology: { type: 'string' ;
};
        toolType: { type: 'string' ;
};
      };
      category: 'web';
    });
    thisregisterTool({;
      name: 'EXTRACT_STRUCTURED_DATA';
      description: 'Extract structured data from web content';
      inputSchema: {;
        url: { type: 'string', required: true ;
};
        schema: { type: 'object' ;
};
      };
      category: 'web';
    });
    loggerinfo(`Registered ${thistoolssize} system tools`);
  };

  registerTool(tool: ToolDefinition): void {;
    thistoolsset(toolname, tool);
  };

  async executeTool(request: ToolExecutionRequest): Promise<ToolExecutionResult> {;
    const startTime = Datenow();
    const tool = thistoolsget(requesttool);
    if (!tool) {;
      return {;
        success: false;
        error instanceof Error ? errormessage : String(error) `Tool ${requesttool} not found`;
        executionTime: Datenow() - startTime;
        toolUsed: requesttool;
      ;
};
    };

    // Notify UI about tool execution;
    if (requestagentId) {;
      agentCollaborationWSupdateAgentProgress(;
        requestagentId;
        `Executing ${requesttool}`;
        30;
      );
    };

    try {;
      // Validate parameters;
      const validationError = thisvalidateParameters(tool, requestparameters);
      if (validationError) {;
        throw new Error(validationError);
      };

      // Execute the tool;
      const result = await thisexecuteToolInternal(requesttool, requestparameters);
      const executionResult: ToolExecutionResult = {;
        success: true;
        output: result;
        executionTime: Datenow() - startTime;
        toolUsed: requesttool;
      ;
};
      thisexecutionHistorypush(executionResult);
      thisemit('tool_executed', executionResult);
      return executionResult;
    } catch (error) {;
      const executionResult: ToolExecutionResult = {;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
        executionTime: Datenow() - startTime;
        toolUsed: requesttool;
      ;
};
      thisexecutionHistorypush(executionResult);
      thisemit('tool_failed', executionResult);
      return executionResult;
    };
  };

  private validateParameters(tool: ToolDefinition, parameters: Record<string, any>): string | null {;
    for (const [key, schema] of Objectentries(toolinputSchema)) {;
      if (schemarequired && !(key in parameters)) {;
        return `Required parameter '${key}' missing for tool ${toolname}`;
      };
    };
    return null;
  };

  private async executeToolInternal(toolName: string, params: Record<string, any>): Promise<any> {;
    switch (toolName) {;
      case 'READ_FILE':;
        return await thisreadFile(paramspath, paramsencoding);
      case 'WRITE_FILE':;
        return await thiswriteFile(paramspath, paramscontent: paramsencoding);
      case 'LIST_FILES':;
        return await thislistFiles(paramspath, paramsrecursive);
      case 'CREATE_FILE':;
        return await thiscreateFile(paramspath, paramscontent);
      case 'DELETE_FILE':;
        return await thisdeleteFile(paramspath);
      case 'CREATE_DIRECTORY':;
        return await thiscreateDirectory(paramspath, paramsrecursive);
      case 'EXECUTE_CODE':;
        return await thisexecuteCode(paramslanguage, paramscode, paramstimeout);
      case 'EXECUTE_COMMAND':;
        return await thisexecuteCommand(paramscommand, paramscwd, paramstimeout);
      case 'ANALYZE_CODE':;
        return await thisanalyzeCode(paramspath, paramslanguage);
      case 'SEARCH_FILES':;
        return await thissearchFiles(paramspattern, paramspath, paramsfileTypes);
      case 'WEB_SEARCH':;
        return await thiswebSearch(paramsquery, paramsengines, paramscategory, paramslimit);
      case 'SCRAPE_WEBPAGE':;
        return await thisscrapeWebpage(paramsurl, paramsselector, paramsextractType);
      case 'DISCOVER_TOOLS':;
        return await thisdiscoverTools(paramsquery, paramstechnology, paramstoolType);
      case 'EXTRACT_STRUCTURED_DATA':;
        return await thisextractStructuredData(paramsurl, paramsschema);
      default:;
        throw new Error(`Tool ${toolName} not implemented`);
    };
  };

  // File operations;
  private async readFile(filePath: string, encoding: string = 'utf8'): Promise<string> {;
    const absolutePath = pathresolve(thisworkingDirectory, filePath);
    thisvalidatePath(absolutePath);
    try {;
      const content = await fsreadFile(absolutePath, encoding);
      loggerinfo(`Read file: ${absolutePath}`);
      return content;
    } catch (error) {;
      if ((error as any)code === 'ENOENT') {;
        throw new Error(`File not found: ${filePath}`);
      };
      throw error;
    };
  };

  private async writeFile(filePath: string, content: string, encoding: string = 'utf8'): Promise<void> {;
    const absolutePath = pathresolve(thisworkingDirectory, filePath);
    thisvalidatePath(absolutePath);
    // Ensure directory exists;
    const dir = pathdirname(absolutePath);
    await fsmkdir(dir, { recursive: true });
    await fswriteFile(absolutePath, content: encoding);
    loggerinfo(`Wrote file: ${absolutePath}`);
  };

  private async listFiles(dirPath: string, recursive: boolean = false): Promise<string[]> {;
    const absolutePath = pathresolve(thisworkingDirectory, dirPath);
    thisvalidatePath(absolutePath);
    if (recursive) {;
      return await thislistFilesRecursive(absolutePath);
    } else {;
      const entries = await fsreaddir(absolutePath, { withFileTypes: true });
      return entriesmap(entry => pathjoin(dirPath, entryname));
    };
  };

  private async listFilesRecursive(dirPath: string): Promise<string[]> {;
    const files: string[] = [];
    const entries = await fsreaddir(dirPath, { withFileTypes: true });
    for (const entry of entries) {;
      const fullPath = pathjoin(dirPath, entryname);
      if (entryisDirectory()) {;
        filespush(..await thislistFilesRecursive(fullPath));
      } else {;
        filespush(pathrelative(thisworkingDirectory, fullPath));
      };
    };
    ;
    return files;
  };

  private async createFile(filePath: string, content: string): Promise<void> {;
    const absolutePath = pathresolve(thisworkingDirectory, filePath);
    thisvalidatePath(absolutePath);
    // Check if file already exists;
    try {;
      await fsaccess(absolutePath);
      throw new Error(`File already exists: ${filePath}`);
    } catch (error) {;
      if ((error as any)code !== 'ENOENT') {;
        throw error;
      };
    };
    ;
    await thiswriteFile(filePath, content);
  };

  private async deleteFile(filePath: string): Promise<void> {;
    const absolutePath = pathresolve(thisworkingDirectory, filePath);
    thisvalidatePath(absolutePath);
    await fsunlink(absolutePath);
    loggerinfo(`Deleted file: ${absolutePath}`);
  };

  private async createDirectory(dirPath: string, recursive: boolean = true): Promise<void> {;
    const absolutePath = pathresolve(thisworkingDirectory, dirPath);
    thisvalidatePath(absolutePath);
    await fsmkdir(absolutePath, { recursive });
    loggerinfo(`Created directory: ${absolutePath}`);
  };

  // Code execution;
  private async executeCode(language: string, code: string, timeout: number = 30000): Promise<string> {;
    const supportedLanguages: Record<string, { ext: string, cmd: string }> = {;
      javascript: { ext: 'js', cmd: 'node' ;
};
      typescript: { ext: 'ts', cmd: 'tsx' ;
};
      python: { ext: 'py', cmd: 'python3' ;
};
      bash: { ext: 'sh', cmd: 'bash' ;
};
      sh: { ext: 'sh', cmd: 'sh' ;
};
    };
    const langConfig = supportedLanguages[languagetoLowerCase()];
    if (!langConfig) {;
      throw new Error(`Unsupported language: ${language}`);
    };

    // Create temporary file;
    const tempFile = pathjoin(thisworkingDirectory, `temp_${Datenow()}.${langConfigext}`);
    try {;
      await fswriteFile(tempFile, code);
      const { stdout, stderr } = await execAsync(`${langConfigcmd} ${tempFile}`, {;
        timeout;
        cwd: thisworkingDirectory;
      });
      if (stderr) {;
        loggerwarn(`Code execution stderr: ${stderr}`);
      };
      ;
      return stdout || stderr;
    } finally {;
      // Clean up temp file;
      try {;
        await fsunlink(tempFile);
      } catch (error) {;
        loggerwarn(`Failed to clean up temp file: ${tempFile}`);
      };
    };
  };

  private async executeCommand(command: string, cwd: string = processcwd(), timeout: number = 30000): Promise<string> {;
    // Security check - prevent dangerous commands;
    const dangerousCommands = ['rm -rf', 'format', 'del /f', 'sudo rm'];
    if (dangerousCommandssome(cmd => commandincludes(cmd))) {;
      throw new Error('Dangerous command blocked for security reasons');
    };

    const { stdout, stderr } = await execAsync(command, {;
      timeout;
      cwd: pathresolve(thisworkingDirectory, cwd);
    });
    return stdout || stderr;
  };

  // Analysis tools;
  private async analyzeCode(filePath: string, language?: string): Promise<any> {;
    const content = await thisreadFile(filePath);
    const lines = contentsplit('\n');
    const ext = pathextname(filePath)slice(1);
    const detectedLanguage = language || ext;
    return {;
      file: filePath;
      language: detectedLanguage;
      lines: lineslength;
      size: contentlength;
      hasTests: contentincludes('test(') || contentincludes('describe(');
      imports: thisextractImports(content: detectedLanguage);
      functions: thisextractFunctions(content: detectedLanguage);
      complexity: thisestimateComplexity(content);
    ;
};
  };

  private async searchFiles(pattern: string, searchPath: string = '.', fileTypes: string[] = []): Promise<any[]> {;
    const results: any[] = [];
    const files = await thislistFilesRecursive(pathresolve(thisworkingDirectory, searchPath));
    for (const file of files) {;
      // Filter by file type if specified;
      if (fileTypeslength > 0) {;
        const ext = pathextname(file)slice(1);
        if (!fileTypesincludes(ext)) continue;
      };

      try {;
        const content = await thisreadFile(file);
        const lines = contentsplit('\n');
        linesforEach((line, index) => {;
          if (lineincludes(pattern)) {;
            resultspush({;
              file;
              line: index + 1;
              content: linetrim();
              match: pattern;
            });
          };
        });
      } catch (error) {;
        // Skip files that can't be read;
      };
    };

    return results;
  };

  // Self-healing capabilities;
  async selfHeal(error instanceof Error ? errormessage : String(error) Error, context: ToolExecutionRequest): Promise<ToolExecutionResult | null> {;
    loggerinfo('Attempting self-healing for error instanceof Error ? errormessage : String(error)', errormessage);
    // Handle file not found errors;
    if (errormessageincludes('File not found') || errormessageincludes('ENOENT')) {;
      if (contexttool === 'READ_FILE' || contexttool === 'WRITE_FILE') {;
        const filePath = contextparameterspath;
        const dir = pathdirname(filePath);
        // Try creating the directory;
        try {;
          await thiscreateDirectory(dir, true);
          loggerinfo(`Created missing directory: ${dir}`);
          // If writing, retry the operation;
          if (contexttool === 'WRITE_FILE') {;
            return await thisexecuteTool(context);
          };
        } catch (healError) {;
          loggererror('Self-healing failed:', healError);
        };
      };
    };

    // Handle permission errors;
    if (errormessageincludes('EACCES') || errormessageincludes('Permission denied')) {;
      loggerwarn('Permission denied - cannot self-heal permission errors');
      return {;
        success: false;
        error instanceof Error ? errormessage : String(error) 'Permission denied. Please check file permissions.';
        executionTime: 0;
        toolUsed: contexttool;
      ;
};
    };

    return null;
  };

  // Helper methods;
  private validatePath(absolutePath: string): void {;
    // Ensure path is within working directory (prevent directory traversal);
    const relative = pathrelative(thisworkingDirectory, absolutePath);
    if (relativestartsWith('..')) {;
      throw new Error('Access denied: Path is outside working directory');
    };
  };

  private extractImports(content: string, language: string): string[] {;
    const imports: string[] = [];
    const lines = contentsplit('\n');
    for (const line of lines) {;
      if (language === 'javascript' || language === 'typescript') {;
        const importMatch = linematch(/import .* from ['"](.+)['"]/);
        if (importMatch) importspush(importMatch[1]);
      } else if (language === 'python') {;
        const importMatch = linematch(/(?:from (.+) import|import (.+))/);
        if (importMatch) importspush(importMatch[1] || importMatch[2]);
      };
    };
    ;
    return imports;
  };

  private extractFunctions(content: string, language: string): string[] {;
    const functions: string[] = [];
    const lines = contentsplit('\n');
    for (const line of lines) {;
      if (language === 'javascript' || language === 'typescript') {;
        const funcMatch = linematch(/(?:function|const|let|var)\s+(\w+)\s*(?:=\s*)?(?:\([^)]*\)|async)/);
        if (funcMatch) functionspush(funcMatch[1]);
      } else if (language === 'python') {;
        const funcMatch = linematch(/def\s+(\w+)\s*\(/);
        if (funcMatch) functionspush(funcMatch[1]);
      };
    };
    ;
    return functions;
  };

  private estimateComplexity(content: string): 'low' | 'medium' | 'high' {;
    const lines = contentsplit('\n')length;
    const conditions = (contentmatch(/if|else|switch|case|while|for/g) || [])length;
    const complexity = conditions / lines;
    if (complexity < 0.1) return 'low';
    if (complexity < 0.2) return 'medium';
    return 'high';
  };

  // Get available tools;
  getAvailableTools(): ToolDefinition[] {;
    return Arrayfrom(thistoolsvalues());
  };

  // Get execution history;
  getExecutionHistory(): ToolExecutionResult[] {;
    return thisexecutionHistory;
  };

  // Web scraping and search methods;
  private async webSearch(query: string, engines: string = 'duckduckgo,google', category: string = 'general', limit: number = 10): Promise<any> {;
    try {;
      const results = await thissearxngClientsearch({;
        q: query;
        engines;
        category;
        format: 'json';
      });
      // Return top results up to limit;
      return {;
        query;
        results: resultsresultsslice(0, limit)map(r => ({;
          title: rtitle;
          url: rurl;
          content: rcontent;
          engine: rengine;
        }));
        total: resultsnumber_of_results;
        suggestions: resultssuggestions;
      ;
};
    } catch (error) {;
      loggererror('Web search failed:', error);
      throw new Error(`Web search failed: ${error instanceof Error ? errormessage : 'Unknown error'}`);
    };
  };

  private async scrapeWebpage(url: string, selector?: string, extractType: string = 'text'): Promise<any> {;
    try {;
      // Fetch webpage content;
      const response = await axiosget(url, {;
        headers: {;
          'User-Agent': 'Mozilla/5.0 (compatible; UniversalAITools/1.0)';
        };
        timeout: 30000;
      });
      const html = responsedata;
      const $ = cheerioload(html);
      let content: any;
      switch (extractType) {;
        case 'text':;
          if (selector) {;
            content = $(selector)text()trim();
          } else {;
            // Remove script and style elements;
            $('script, style')remove();
            content = $('body')text()trim()replace(/\s+/g, ' ');
          };
          break;
        case 'html':;
          content = selector ? $(selector)html() : $html();
          break;
        case 'links':;
          const links: string[] = [];
          $(selector || 'a')each((_, elem) => {;
            const href = $(elem)attr('href');
            if (href) {;
              // Convert relative URLs to absolute;
              const absoluteUrl = new URL(href, url)toString();
              linkspush(absoluteUrl);
            };
          });
          content = [..new Set(links)]; // Remove duplicates;
          break;
        case 'structured':;
          // Extract common structured data;
          content = {;
            title: $('title')text();
            headings: {;
              h1: $('h1')map((_, el) => $(el)text())get();
              h2: $('h2')map((_, el) => $(el)text())get();
            };
            meta: {;
              description: $('meta[name="description"]')attr('content');
              keywords: $('meta[name="keywords"]')attr('content');
            ;
};
            images: $('img')map((_, el) => $(el)attr('src'))get();
          };
          break;
        default:;
          content = html;
      };

      return {;
        url;
        content;
        extractType;
        timestamp: new Date()toISOString();
      ;
};
    } catch (error) {;
      loggererror('Webpage scraping failed:', error);
      throw new Error(`Failed to scrape webpage: ${error instanceof Error ? errormessage : 'Unknown error'}`);
    };
  };

  private async discoverTools(query: string, technology?: string, toolType?: string): Promise<any> {;
    try {;
      // Build search query for finding tools;
      let searchQuery = query;
      if (technology) searchQuery += ` ${technology}`;
      if (toolType) searchQuery += ` ${toolType}`;
      searchQuery += ' tool library package npm github';
      // Search for tools;
      const searchResults = await thiswebSearch(searchQuery, 'github,duckduckgo', 'general', 20);
      const discoveredTools: any[] = [];
      // Analyze each result for tool information;
      for (const result of searchResultsresults) {;
        if (resulturlincludes('githubcom') || resulturlincludes('npmjscom')) {;
          try {;
            // Scrape tool information;
            const pageData = await thisscrapeWebpage(resulturl, undefined, 'structured');
            discoveredToolspush({;
              name: resulttitle;
              url: resulturl;
              description: resultcontent;
              source: resulturlincludes('githubcom') ? 'github' : 'npm';
              metadata: pageDatacontent;
            });
          } catch (error) {;
            // Skip failed scrapes;
            loggerwarn(`Failed to scrape tool info from ${resulturl}`);
          };
        };
      };

      // Also search specific package registries;
      if (technology?toLowerCase()includes('javascript') || technology?toLowerCase()includes('node')) {;
        const npmResults = await thissearchNpmForTools(query);
        discoveredToolspush(..npmResults);
      };

      return {;
        query;
        technology;
        toolType;
        discoveredTools: discoveredToolsslice(0, 10), // Return top 10 tools;
        totalFound: discoveredToolslength;
      ;
};
    } catch (error) {;
      loggererror('Tool discovery failed:', error);
      throw new Error(`Failed to discover tools: ${error instanceof Error ? errormessage : 'Unknown error'}`);
    };
  };

  private async extractStructuredData(url: string, schema?: any): Promise<any> {;
    try {;
      // First scrape the webpage;
      const scraped = await thisscrapeWebpage(url, undefined, 'structured');
      const html = await thisscrapeWebpage(url, undefined, 'html');
      // Extract based on schema if provided;
      if (schema) {;
        const $ = cheerioload(htmlcontent);
        const extracted: any = {};
        for (const [key, selector] of Objectentries(schema)) {;
          if (typeof selector === 'string') {;
            extracted[key] = $(selector)text()trim();
          } else if (typeof selector === 'object' && selectorselector) {;
            const elements = $(selectorselector);
            if (selectormultiple) {;
              extracted[key] = elementsmap((_, el) => $(el)text()trim())get();
            } else {;
              extracted[key] = elementsfirst()text()trim();
            };
          };
        };
        ;
        return {;
          url;
          structured: scrapedcontent;
          extracted;
          timestamp: new Date()toISOString();
        ;
};
      };
      ;
      return scraped;
    } catch (error) {;
      loggererror('Structured data extraction failed:', error);
      throw new Error(`Failed to extract structured data: ${error instanceof Error ? errormessage : 'Unknown error'}`);
    };
  };

  private async searchNpmForTools(query: string): Promise<any[]> {;
    try {;
      // Search npm registry;
      const response = await axiosget(`https://registrynpmjsorg/-/v1/search`, {;
        params: {;
          text: query;
          size: 10;
        ;
};
        timeout: 10000;
      });
      return responsedataobjectsmap((pkg: any) => ({;
        name: pkgpackagename;
        url: `https://wwwnpmjscom/package/${pkgpackagename}`;
        description: pkgpackagedescription;
        source: 'npm';
        metadata: {;
          version: pkgpackageversion;
          keywords: pkgpackagekeywords;
          links: pkgpackagelinks;
        ;
};
      }));
    } catch (error) {;
      loggerwarn('NPM search failed:', error);
      return [];
    };
  };
};

// Export singleton instance;
export const toolExecutionService = new ToolExecutionService();