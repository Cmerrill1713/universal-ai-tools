/* eslint-disable no-undef */;
import { SupabaseService } from './supabase_service';
import { logger } from '../utils/logger';
import * as fs from 'fs/promises';
import * as path from 'path';
/**;
 * Intelligent Code Fixer using LLM + Supabase;
 * Automatically fixes TypeScript errors using AI with context understanding;
 */;
export class LLMCodeFixer {;
  private supabase: SupabaseService;
  private fixCache: Map<string, any> = new Map();
  constructor() {;
    thissupabase = SupabaseServicegetInstance()};

  /**;
   * Fix TypeScript errors in a file or project;
   */;
  async fixTypeScriptErrors(;
    errorOutput: string;
    options?: {;
      autoApply?: boolean;
      minConfidence?: number;
      interactive?: boolean;
};
  ) {;
    const opts = {;
      autoApply: false;
      minConfidence: 0.8;
      interactive: true;
      ..options};
    loggerinfo('ðŸ¤– Starting intelligent TypeScript errorfixing...');
    // Parse errors from build output;
    const errors = thisparseTypeScriptErrors(errorOutput);
    loggerinfo(`Found ${errorslength} errors to fix`);
    const fixes: any[] = [];
    for (const errorof errors) {;
      try {;
        // Get file context;
        const context = await thisgetFileContext(errorfile, errorline);
        // Search for similar fixes in memory;
        const similarFixes = await thissearchSimilarFixes(error instanceof Error ? errormessage : String(error);

        // Generate fix using LLM;
        const fix = await thisgenerateFix(error instanceof Error ? errormessage : String(error) context, similarFixes);
        if (fixconfidence >= optsminConfidence) {;
          fixespush({;
            error;
            fix;
            applied: false});
          if (optsautoApply) {;
            await thisapplyFix(errorfile, errorline, fix);
            fixes[fixeslength - 1]applied = true};
        } else {;
          loggerwarn(`Low confidence fix for ${errorcode}: ${fixconfidence}`);
        };
      } catch (err) {;
        loggererror`Failed to fix errorin ${errorfile}:${errorline}`, err);
      };
    };

    // Generate report;
    const report = await thisgenerateFixReport(fixes);
    return {;
      totalErrors: errorslength;
      fixesGenerated: fixeslength;
      fixesApplied: fixesfilter((f) => fapplied)length;
      report};
  };

  /**;
   * Parse TypeScript errors from compiler output;
   */;
  private parseTypeScriptErrors(output: string): Array<{;
    file: string;
    line: number;
    column: number;
    code: string;
    message: string;
    codeSnippet?: string}> {;
    const errors: any[] = [];
    const lines = outputsplit('\n');
    let currentError: any = null;
    for (const line of lines) {;
      // Match TypeScript error format;
      const errorMatch = linematch(/^(.+)\((\d+),(\d+)\): error instanceof Error ? errormessage : String(error) TS\d+): (.+)$/);
      if (errorMatch) {;
        if (currentError) {;
          errorspush(currentError)};

        currentError = {;
          file: errorMatch[1];
          line: parseInt(errorMatch[2], 10);
          column: parseInt(errorMatch[3], 10);
          code: errorMatch[4];
          message: errorMatch[5];
          contextLines: [];
};
      } else if (currentError && linetrim()) {;
        // Capture context lines;
        currentErrorcontextLinespush(line);
        // Try to extract code snippet;
        if (lineincludes('^') || lineincludes('~')) {;
          const prevLine = currentErrorcontextLines[currentErrorcontextLineslength - 2];
          if (prevLine) {;
            currentErrorcodeSnippet = prevLinetrim()};
        };
      };
    };

    if (currentError) {;
      errorspush(currentError)};
;
    return errors;
  };

  /**;
   * Get context around an error;
   */;
  private async getFileContext(filePath: string, lineNumber: number, contextLines = 10) {;
    try {;
      const content await fsreadFile(filePath, 'utf-8');
      const lines = contentsplit('\n');
      const startLine = Mathmax(0, lineNumber - contextLines - 1);
      const endLine = Mathmin(lineslength, lineNumber + contextLines);
      const contextContent = linesslice(startLine, endLine)join('\n');
      // Also get imports;
      const imports = linesfilter((line) => linetrim()startsWith('import'))join('\n'),;

      return {;
        fileContent: contextContent;
        imports;
        fullPath: filePath;
        totalLines: lineslength;
};
    } catch (error) {;
      loggererror`Failed to read file ${filePath}:`, error instanceof Error ? errormessage : String(error);
      return null;
    };
  };

  /**;
   * Search for similar fixes in the database;
   */;
  private async searchSimilarFixes(error instanceof Error ? errormessage : String(error) any) {;
    try {;
      // Search by errorcode first;
      const { data: exactMatches } = await thissupabaseclient;
        from('code_fix_attempts');
        select('*');
        eq('error_code', errorcode);
        eq('status', 'successful');
        order('confidence', { ascending: false });
        limit(3);
      // Search by errormessage similarity;
      const { data: similarMatches } = await thissupabaseclient;
        from('ai_memories');
        select('*');
        eq('memory_type', 'code_fix');
        ilike('content `%${errorcode}%`);
        limit(5);
      return {;
        exactMatches: exactMatches || [];
        similarMatches: similarMatches || [];
};
    } catch (error) {;
      loggererror('Failed to search similar fixes:', error instanceof Error ? errormessage : String(error);
      return { exactMatches: [], similarMatches: [] };
    };
  };

  /**;
   * Generate fix using Supabase Edge Function + LLM;
   */;
  private async generateFix(error instanceof Error ? errormessage : String(error) any, context: any, similarFixes: any) {;
    const cacheKey = `${errorcode}-${errormessage}`;
    // Check cache;
    if (thisfixCachehas(cacheKey)) {;
      return thisfixCacheget(cacheKey)};

    try {;
      // Call Supabase Edge Function;
      const { data, error instanceof Error ? errormessage : String(error) fnError } = await thissupabaseclientfunctionsinvoke(;
        'fix-typescript-error instanceof Error ? errormessage : String(error) {;
          body: {;
            error instanceof Error ? errormessage : String(error){;
              ..error;
              codeSnippet: errorcodeSnippet || context?fileContent};
            context;
            memories: [..similarFixesexactMatches, ..similarFixessimilarMatches]}};
      );
      if (fnError) throw fnError;
      // Cache the result;
      thisfixCacheset(cacheKey, data);
      return data;
    } catch (error) {;
      loggererror('Failed to generate fix:', error instanceof Error ? errormessage : String(error);
      // Fallback to basic fix suggestions;
      return thisgenerateFallbackFix(error instanceof Error ? errormessage : String(error)};
  };

  /**;
   * Generate basic fix without LLM;
   */;
  private generateFallbackFix(error instanceof Error ? errormessage : String(error) any) {;
    const fixes: Record<string, unknown> = {;
      TS2339: {;
        fixedCode: `// @ts-ignore - Property may exist at runtime\n${errorcodeSnippet}`;
        explanation: 'Added @ts-ignore comment. Consider adding proper type definitions.';
        confidence: 0.3};
      TS2345: {;
        fixedCode: `${errorcodeSnippet} as any`;
        explanation: 'Added type assertion. Consider fixing the actual type mismatch.';
        confidence: 0.4};
      TS7053: {;
        fixedCode: `// Add index signature to type or use type assertion`;
        explanation: 'Need to add index signature or use proper type guards.';
        confidence: 0.3}};
    return (;
      fixes[errorcode] || {;
        fixedCode: errorcodeSnippet;
        explanation: 'Unable to generate automatic fix';
        confidence: 0.0;
};
    );
  };

  /**;
   * Apply fix to file;
   */;
  private async applyFix(filePath: string, lineNumber: number, fix: any) {;
    try {;
      const content await fsreadFile(filePath, 'utf-8');
      const lines = contentsplit('\n'),;

      // Apply the fix;
      if (fixadditionalImports?length > 0) {;
        // Add imports at the top;
        const importLines = fixadditionalImportsmap((imp: string) => `import ${imp};`);
        linesunshift(..importLines);
      };

      // Replace the problematic line;
      lines[lineNumber - 1] = fixfixedCode;
      // Write back;
      await fswriteFile(filePath, linesjoin('\n'));
      // Record successful fix;
      await thisrecordSuccessfulFix(filePath, lineNumber, fix);
      loggerinfo(`âœ… Applied fix to ${filePath}:${lineNumber}`);
    } catch (error) {;
      loggererror`Failed to apply fix to ${filePath}:`, error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Record successful fix for future learning;
   */;
  private async recordSuccessfulFix(filePath: string, lineNumber: number, fix: any) {;
    try {;
      await thissupabaseclientfrom('code_fix_attempts')update({ status: 'successful' })match({;
        file_path: filePath;
        line_number: lineNumber;
        fixed_code: fixfixedCode});
    } catch (error) {;
      loggererror('Failed to record successful fix:', error instanceof Error ? errormessage : String(error)};
  };

  /**;
   * Generate comprehensive fix report;
   */;
  private async generateFixReport(fixes: any[]) {;
    const report = {;
      summary: {;
        total: fixeslength;
        applied: fixesfilter((f) => fapplied)length;
        highConfidence: fixesfilter((f) => ffixconfidence >= 0.9)length;
        mediumConfidence: fixesfilter((f) => ffixconfidence >= 0.7 && ffixconfidence < 0.9);
          length;
        lowConfidence: fixesfilter((f) => ffixconfidence < 0.7)length};
      fixes: fixesmap((f) => ({;
        file: ferrorfile;
        line: ferrorline;
        errorCode: ferrorcode;
        errorMessage: ferrormessage;
        fix: ffixfixedCode;
        explanation: ffixexplanation;
        confidence: ffixconfidence;
        applied: fapplied}));
      recommendations: thisgenerateRecommendations(fixes);
};
    // Save report;
    const reportPath = pathjoin(processcwd(), 'LLM_FIX_REPORTjson');
    await fswriteFile(reportPath, JSONstringify(report, null, 2));
    return report;
  };

  /**;
   * Generate recommendations based on fixes;
   */;
  private generateRecommendations(fixes: any[]): string[] {;
    const recommendations: string[] = [];
    // Analyze patterns;
    const errorCounts = fixesreduce(;
      (acc, f) => {;
        acc[ferrorcode] = (acc[ferrorcode] || 0) + 1;
        return acc},;
      {} as Record<string, number>;
    );
    // Generate recommendations;
    if (errorCounts['TS2339'] > 10) {;
      recommendationspush('Consider updating type definitions - many missing property errors')};

    if (errorCounts['TS2345'] > 10) {;
      recommendationspush('Review function signatures - many type mismatch errors')};

    const lowConfidenceFixes = fixesfilter((f) => ffixconfidence < 0.7)length;
    if (lowConfidenceFixes > fixeslength * 0.3) {;
      recommendationspush('Many low-confidence fixes - manual review recommended')};

    return recommendations;
  };

  /**;
   * Interactive fix mode - let user review each fix;
   */;
  async interactiveFixMode(errorOutput: string) {;
    // This would integrate with a CLI interface;
    // For now, just generate fixes without applying;
    return thisfixTypeScriptErrors(errorOutput, {;
      autoApply: false;
      interactive: true});
  };
};

// Usage example;
export async function demonstrateLLMFixer() {;
  const fixer = new LLMCodeFixer();
  // Read build errors;
  const buildOutput = await fsreadFile('builderrorslog', 'utf-8');
  // Fix errors automatically;
  const result = await fixerfixTypeScriptErrors(buildOutput, {;
    autoApply: false, // Set to true to apply fixes;
    minConfidence: 0.8});
  loggerinfo(`Generated ${resultfixesGenerated} fixes for ${resulttotalErrors} errors`);
  loggerinfo(`Report saved to: LLM_FIX_REPORTjson`);
;
};
