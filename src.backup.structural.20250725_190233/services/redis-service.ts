/**;
 * Redis Service - Production-ready Redis connection management;
 * Provides connection pooling, health monitoring, error handling;
 * circuit breaker pattern and in-memory fallback cache;
 */;

import Redis, { Cluster, type RedisOptions } from 'ioredis';
import { LogContext, logger } from '../utils/enhanced-logger';
import config from '../config';
import { circuitBreaker } from './circuit-breaker';
import { LRUCache } from 'lru-cache';
export interface RedisConfig {;
  url: string;
  maxRetriesPerRequest?: number;
  retryDelayOnFailover?: number;
  enableAutoPipelining?: boolean;
  maxReconnectTimes?: number;
  connectTimeout?: number;
  commandTimeout?: number;
  enableReadReplicas?: boolean;
  clusterMode?: boolean;
  poolSize?: number;
;
};

interface CacheEntry {;
  value: any;
  ttl?: number;
  createdAt: number;
;
};

export class RedisService {;
  private static instance: RedisService | null = null;
  private client: Redis | null = null;
  private clusterClient: Cluster | null = null;
  private readReplicas: Redis[] = [];
  private isConnected = false;
  private connectionAttempts = 0;
  private readonly maxConnectionAttempts = 5;
  // In-memory fallback cache using LRU;
  private fallbackCache: LRUCache<string, CacheEntry>;
  private readonly fallbackCacheOptions = {;
    max: 10000, // Maximum number of items;
    maxSize: 100 * 1024 * 1024, // 100MB max size;
    sizeCalculation: (entry: CacheEntry) => {;
      const str = JSONstringify(entryvalue);
      return strlength;
    };
    ttl: 1000 * 60 * 5, // 5 minutes default TTL;
    updateAgeOnGet: true;
    updateAgeOnHas: true;
  ;
};
  // Connection pool management;
  private connectionPool: Redis[] = [];
  private poolIndex = 0;
  constructor(private config: RedisConfig) {;
    // Initialize fallback cache;
    thisfallbackCache = new LRUCache<string, CacheEntry>(thisfallbackCacheOptions);
  };

  static getInstance(redisConfig?: RedisConfig): RedisService {;
    if (!RedisServiceinstance) {;
      const defaultConfig: RedisConfig = {;
        url: configcache?redisUrl || 'redis://localhost:6379';
        maxRetriesPerRequest: 3;
        retryDelayOnFailover: 100;
        enableAutoPipelining: true;
        maxReconnectTimes: 5;
        connectTimeout: 10000;
        commandTimeout: 5000;
        enableReadReplicas: processenvREDIS_READ_REPLICAS === 'true';
        clusterMode: processenvREDIS_CLUSTER_MODE === 'true';
        poolSize: parseInt(processenvREDIS_POOL_SIZE || '5', 10);
      };
      RedisServiceinstance = new RedisService(redisConfig || defaultConfig);
    };
    return RedisServiceinstance;
  };

  async connect(): Promise<void> {;
    if (thisisConnected && (thisclient || thisclusterClient)) {;
      return;
    };

    try {;
      thisconnectionAttempts++;
      loggerinfo('üîó Connecting to Redis...', LogContextCACHE, {;
        clusterMode: thisconfigclusterMode;
        poolSize: thisconfigpoolSize;
      });
      const redisOptions: RedisOptions = {;
        maxRetriesPerRequest: thisconfigmaxRetriesPerRequest;
        enableAutoPipelining: thisconfigenableAutoPipelining;
        connectTimeout: thisconfigconnectTimeout;
        commandTimeout: thisconfigcommandTimeout;
        lazyConnect: true;
        keepAlive: 30000;
        family: 4;
        retryStrategy: (times) => {;
          if (times > thismaxConnectionAttempts) {;
            return null, // Stop retrying;
          };
          return Mathmin(times * 100, 3000);
        };
      };
      if (thisconfigclusterMode) {;
        // Initialize Redis Cluster;
        const clusterNodes = thisparseClusterNodes(thisconfigurl);
        thisclusterClient = new Cluster(clusterNodes, {;
          redisOptions;
          enableReadyCheck: true;
          maxRedirections: 16;
          retryDelayOnFailover: thisconfigretryDelayOnFailover;
          retryDelayOnClusterDown: 300;
          slotsRefreshTimeout: 2000;
          clusterRetryStrategy: (times) => {;
            if (times > thismaxConnectionAttempts) {;
              return null;
            };
            return Mathmin(times * 100, 3000);
          };
        });
        // Set up cluster event listeners;
        thissetupClusterEventListeners();
        await thisclusterClientconnect();
      } else {;
        // Initialize single Redis instance or connection pool;
        if (thisconfigpoolSize && thisconfigpoolSize > 1) {;
          // Create connection pool;
          for (let i = 0; i < thisconfigpoolSize, i++) {;
            const poolClient = new Redis(thisconfigurl, {;
              ..redisOptions;
              connectionName: `pool-${i}`;
            });
            thissetupEventListeners(poolClient);
            await poolClientconnect();
            thisconnectionPoolpush(poolClient);
          };

          // Use first connection as primary client;
          thisclient = thisconnectionPool[0];
        } else {;
          // Single connection;
          thisclient = new Redis(thisconfigurl, redisOptions);
          thissetupEventListeners(thisclient);
          await thisclientconnect();
        };

        // Initialize read replicas if enabled;
        if (thisconfigenableReadReplicas) {;
          await thisinitializeReadReplicas();
        };
      };

      thisisConnected = true;
      thisconnectionAttempts = 0;
      loggerinfo('‚úÖ Redis connected successfully', LogContextCACHE, {;
        url: thismaskUrl(thisconfigurl);
        attempts: thisconnectionAttempts;
        mode: thisconfigclusterMode ? 'cluster' : 'standalone';
        poolSize: thisconnectionPoollength || 1;
      });
    } catch (error) {;
      thisisConnected = false;
      const errorMessage = error instanceof Error ? errormessage : String(error);
      loggererror('‚ùå Redis connection failed', LogContextCACHE, {;
        error instanceof Error ? errormessage : String(error) errorMessage;
        attempts: thisconnectionAttempts;
        maxAttempts: thismaxConnectionAttempts;
      });
      if (thisconnectionAttempts >= thismaxConnectionAttempts) {;
        loggerwarn('üîÑ Falling back to in-memory cache', LogContextCACHE);
        // Don't throw - allow fallback to in-memory cache;
        return;
      };

      // Exponential backoff retry;
      const delay = Mathmin(1000 * Mathpow(2, thisconnectionAttempts), 10000);
      await new Promise((resolve) => setTimeout(resolve, delay));
      return thisconnect();
    };
  };

  private parseClusterNodes(url: string): Array<{ host: string, port: number }> {;
    // Parse cluster nodes from URL or environment variable;
    const clusterUrls = processenvREDIS_CLUSTER_NODES?split(',') || [url];
    return clusterUrlsmap((nodeUrl) => {;
      const urlObj = new URL(nodeUrl);
      return {;
        host: urlObjhostname;
        port: parseInt(urlObjport || '6379', 10);
      };
    });
  };

  private async initializeReadReplicas(): Promise<void> {;
    const replicaUrls = processenvREDIS_READ_REPLICA_URLS?split(',') || [];
    for (const replicaUrl of replicaUrls) {;
      try {;
        const replica = new Redis(replicaUrl, {;
          enableOfflineQueue: false;
          connectTimeout: 5000;
          lazyConnect: true;
        });
        await replicaconnect();
        thisreadReplicaspush(replica);
        loggerinfo('‚úÖ Read replica connected', LogContextCACHE, {;
          url: thismaskUrl(replicaUrl);
        });
      } catch (error) {;
        loggerwarn('‚ö†Ô∏è Read replica connection failed', LogContextCACHE, {;
          url: thismaskUrl(replicaUrl);
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
        });
      };
    };
  };

  private setupEventListeners(client?: Redis): void {;
    const targetClient = client || thisclient;
    if (!targetClient) return;
    targetClienton('connect', () => {;
      loggerinfo('üîó Redis connection established', LogContextCACHE);
    });
    targetClienton('ready', () => {;
      if (!client || client === thisclient) {;
        thisisConnected = true;
      };
      loggerinfo('‚úÖ Redis ready for commands', LogContextCACHE);
    });
    targetClienton('error', (error) => {;
      if (!client || client === thisclient) {;
        thisisConnected = false;
      };
      loggererror('‚ùå Redis error', LogContextCACHE, {;
        error instanceof Error ? errormessage : String(error) errormessage;
        stack: errorstack;
      });
    });
    targetClienton('close', () => {;
      if (!client || client === thisclient) {;
        thisisConnected = false;
      };
      loggerwarn('‚ö†Ô∏è Redis connection closed', LogContextCACHE);
    });
    targetClienton('reconnecting', (delay: number) => {;
      loggerinfo('üîÑ Redis reconnecting...', LogContextCACHE, { delay });
    });
    targetClienton('end', () => {;
      if (!client || client === thisclient) {;
        thisisConnected = false;
      };
      loggerinfo('üì™ Redis connection ended', LogContextCACHE);
    });
  };

  private setupClusterEventListeners(): void {;
    if (!thisclusterClient) return;
    thisclusterClienton('connect', () => {;
      loggerinfo('üîó Redis cluster connection established', LogContextCACHE);
    });
    thisclusterClienton('ready', () => {;
      thisisConnected = true;
      loggerinfo('‚úÖ Redis cluster ready for commands', LogContextCACHE);
    });
    thisclusterClienton('error', (error) => {;
      thisisConnected = false;
      loggererror('‚ùå Redis cluster error', LogContextCACHE, {;
        error instanceof Error ? errormessage : String(error) errormessage;
      });
    });
    thisclusterClienton('close', () => {;
      thisisConnected = false;
      loggerwarn('‚ö†Ô∏è Redis cluster connection closed', LogContextCACHE);
    });
    thisclusterClienton('node error', (error instanceof Error ? errormessage : String(error) address) => {;
      loggererror('‚ùå Redis cluster node error', LogContextCACHE, {;
        error instanceof Error ? errormessage : String(error) errormessage;
        address;
      });
    });
  };

  async disconnect(): Promise<void> {;
    try {;
      // Disconnect connection pool;
      for (const poolClient of thisconnectionPool) {;
        try {;
          await poolClientquit();
        } catch (error) {;
          loggererror('‚ùå Error disconnecting pool client', LogContextCACHE, {;
            error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
          });
        };
      };
      thisconnectionPool = [];
      // Disconnect read replicas;
      for (const replica of thisreadReplicas) {;
        try {;
          await replicaquit();
        } catch (error) {;
          loggererror('‚ùå Error disconnecting read replica', LogContextCACHE, {;
            error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
          });
        };
      };
      thisreadReplicas = [];
      // Disconnect main client;
      if (thisclient) {;
        await thisclientquit();
      };

      // Disconnect cluster client;
      if (thisclusterClient) {;
        await thisclusterClientquit();
      };

      loggerinfo('üëã Redis disconnected gracefully', LogContextCACHE);
    } catch (error) {;
      loggererror('‚ùå Error during Redis disconnect', LogContextCACHE, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
    } finally {;
      thisclient = null;
      thisclusterClient = null;
      thisisConnected = false;
      thispoolIndex = 0;
    };
  };

  getClient(): Redis | Cluster {;
    if (thisclusterClient) {;
      return thisclusterClient;
    };

    if (!thisclient || !thisisConnected) {;
      throw new Error('Redis client not connected. Call connect() first.');
    };

    // Return a connection from the pool using round-robin;
    if (thisconnectionPoollength > 1) {;
      const client = thisconnectionPool[thispoolIndex];
      thispoolIndex = (thispoolIndex + 1) % thisconnectionPoollength;
      return client;
    };

    return thisclient;
  };

  private getReadClient(): Redis | Cluster {;
    // If we have read replicas, use them for read operations;
    if (thisreadReplicaslength > 0) {;
      const replicaIndex = Mathfloor(Mathrandom() * thisreadReplicaslength);
      return thisreadReplicas[replicaIndex];
    };

    // Otherwise use the main client;
    return thisgetClient();
  };

  isHealthy(): boolean {;
    return thisisConnected && thisclient !== null;
  };

  async healthCheck(): Promise<{ healthy: boolean; latency?: number, error?: string }> {;
    if (!thisclient || !thisisConnected) {;
      return { healthy: false, error instanceof Error ? errormessage : String(error) 'Not connected' };
    };

    try {;
      const start = Datenow();
      await thisclientping();
      const latency = Datenow() - start;
      return { healthy: true, latency };
    } catch (error) {;
      return {;
        healthy: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      ;
};
    };
  };

  async getStats(): Promise<{;
    connected: boolean;
    connectionAttempts: number;
    memoryUsage?: string;
    connectedClients?: number;
    uptime?: number;
  }> {;
    const stats = {;
      connected: thisisConnected;
      connectionAttempts: thisconnectionAttempts;
    };
    if (thisclient && thisisConnected) {;
      try {;
        const info = await thisclientinfo('memory');
        const memoryMatch = infomatch(/used_memory_human:(\S+)/);
        if (memoryMatch) {;
          (stats as any)memoryUsage = memoryMatch[1];
        };

        const serverInfo = await thisclientinfo('server');
        const uptimeMatch = serverInfomatch(/uptime_in_seconds:(\d+)/);
        if (uptimeMatch) {;
          (stats as any)uptime = parseInt(uptimeMatch[1], 10);
        };

        const clientsInfo = await thisclientinfo('clients');
        const clientsMatch = clientsInfomatch(/connected_clients:(\d+)/);
        if (clientsMatch) {;
          (stats as any)connectedClients = parseInt(clientsMatch[1], 10);
        };
      } catch (error) {;
        loggerwarn('‚ö†Ô∏è Could not fetch Redis stats', LogContextCACHE, {;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
        });
      };
    };

    return stats;
  };

  private maskUrl(url: string): string {;
    try {;
      const urlObj = new URL(url);
      if (urlObjpassword) {;
        urlObjpassword = '***';
      };
      return urlObjtoString();
    } catch {;
      return urlreplace(/:([^@]+)@/, ':***@');
    };
  };

  // Cache operations with circuit breaker and fallback;

  async get(key: string): Promise<string | null> {;
    return circuitBreakerredisOperation(;
      'get';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetReadClient();
        return await clientget(key);
      };
      {;
        fallback: () => {;
          // Fallback to in-memory cache;
          const cached = thisfallbackCacheget(key);
          if (cached && thisisEntryValid(cached)) {;
            loggerdebug('üì¶ Serving from fallback cache', LogContextCACHE, { key });
            return cachedvalue;
          };
          return null;
        };
      };
    );
  };

  async set(key: string, value: string, ttl?: number): Promise<'OK' | null> {;
    return circuitBreakerredisOperation(;
      'set';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetClient();
        let result: 'OK' | null;
        if (ttl) {;
          result = await clientsetex(key, ttl, value);
        } else {;
          result = await clientset(key, value);
        };

        // Also store in fallback cache;
        thisfallbackCacheset(key, {;
          value;
          ttl;
          createdAt: Datenow();
        });
        return result;
      };
      {;
        fallback: () => {;
          // Store only in fallback cache when Redis is down;
          thisfallbackCacheset(key, {;
            value;
            ttl;
            createdAt: Datenow();
          });
          loggerwarn('‚ö†Ô∏è Stored in fallback cache only', LogContextCACHE, { key });
          return 'OK';
        };
      };
    );
  };

  async del(key: string | string[]): Promise<number> {;
    const keys = ArrayisArray(key) ? key : [key];
    return circuitBreakerredisOperation(;
      'del';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetClient();
        const result = await clientdel(..keys);
        // Also remove from fallback cache;
        keysforEach((k) => thisfallbackCachedelete(k));
        return result;
      };
      {;
        fallback: () => {;
          // Remove only from fallback cache when Redis is down;
          let count = 0;
          keysforEach((k) => {;
            if (thisfallbackCachedelete(k)) {;
              count++;
            };
          });
          return count;
        };
      };
    );
  };

  async mget(keys: string[]): Promise<(string | null)[]> {;
    return circuitBreakerredisOperation(;
      'mget';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetReadClient();
        return await clientmget(..keys);
      };
      {;
        fallback: () => {;
          // Get from fallback cache;
          return keysmap((key) => {;
            const cached = thisfallbackCacheget(key);
            if (cached && thisisEntryValid(cached)) {;
              return cachedvalue;
            };
            return null;
          });
        };
      };
    );
  };

  async mset(keyValues: Record<string, string>): Promise<'OK'> {;
    return circuitBreakerredisOperation(;
      'mset';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetClient();
        const args: string[] = [];
        Objectentries(keyValues)forEach(([key, value]) => {;
          argspush(key, value);
          // Also store in fallback cache;
          thisfallbackCacheset(key, {;
            value;
            createdAt: Datenow();
          });
        });
        return await clientmset(..args);
      };
      {;
        fallback: () => {;
          // Store only in fallback cache when Redis is down;
          Objectentries(keyValues)forEach(([key, value]) => {;
            thisfallbackCacheset(key, {;
              value;
              createdAt: Datenow();
            });
          });
          return 'OK';
        };
      };
    );
  };

  async exists(key: string | string[]): Promise<number> {;
    const keys = ArrayisArray(key) ? key : [key];
    return circuitBreakerredisOperation(;
      'exists';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetReadClient();
        return await clientexists(..keys);
      };
      {;
        fallback: () => {;
          // Check in fallback cache;
          let count = 0;
          keysforEach((k) => {;
            if (thisfallbackCachehas(k)) {;
              const entry = thisfallbackCacheget(k);
              if (entry && thisisEntryValid(entry)) {;
                count++;
              };
            };
          });
          return count;
        };
      };
    );
  };

  async expire(key: string, ttl: number): Promise<number> {;
    return circuitBreakerredisOperation(;
      'expire';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetClient();
        const result = await clientexpire(key, ttl);
        // Update TTL in fallback cache;
        const cached = thisfallbackCacheget(key);
        if (cached) {;
          cachedttl = ttl;
          thisfallbackCacheset(key, cached);
        };
;
        return result;
      };
      {;
        fallback: () => {;
          // Update TTL only in fallback cache;
          const cached = thisfallbackCacheget(key);
          if (cached) {;
            cachedttl = ttl;
            thisfallbackCacheset(key, cached);
            return 1;
          };
          return 0;
        };
      };
    );
  };

  async ttl(key: string): Promise<number> {;
    return circuitBreakerredisOperation(;
      'ttl';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetReadClient();
        return await clientttl(key);
      };
      {;
        fallback: () => {;
          // Calculate TTL from fallback cache;
          const cached = thisfallbackCacheget(key);
          if (cached && cachedttl) {;
            const elapsed = (Datenow() - cachedcreatedAt) / 1000;
            const remainingTtl = Mathmax(0, cachedttl - elapsed);
            return Mathfloor(remainingTtl);
          };
          return -2; // Key does not exist;
        };
      };
    );
  };

  // Hash operations;
  async hget(key: string, field: string): Promise<string | null> {;
    return circuitBreakerredisOperation(;
      'hget';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetReadClient();
        return await clienthget(key, field);
      };
      {;
        fallback: () => {;
          const hashKey = `hash:${key}:${field}`;
          const cached = thisfallbackCacheget(hashKey);
          if (cached && thisisEntryValid(cached)) {;
            return cachedvalue;
          };
          return null;
        };
      };
    );
  };

  async hset(key: string, field: string, value: string): Promise<number> {;
    return circuitBreakerredisOperation(;
      'hset';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetClient();
        const result = await clienthset(key, field, value);
        // Store in fallback cache;
        const hashKey = `hash:${key}:${field}`;
        thisfallbackCacheset(hashKey, {;
          value;
          createdAt: Datenow();
        });
        return result;
      };
      {;
        fallback: () => {;
          const hashKey = `hash:${key}:${field}`;
          thisfallbackCacheset(hashKey, {;
            value;
            createdAt: Datenow();
          });
          return 1;
        };
      };
    );
  };

  // List operations;
  async lpush(key: string, ..values: string[]): Promise<number> {;
    return circuitBreakerredisOperation(;
      'lpush';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetClient();
        return await clientlpush(key, ..values);
      };
      {;
        fallback: () => {;
          loggerwarn('‚ö†Ô∏è List operations not supported in fallback cache', LogContextCACHE, {;
            key;
          });
          return 0;
        };
      };
    );
  };

  async lrange(key: string, start: number, stop: number): Promise<string[]> {;
    return circuitBreakerredisOperation(;
      'lrange';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetReadClient();
        return await clientlrange(key, start, stop);
      };
      {;
        fallback: () => {;
          loggerwarn('‚ö†Ô∏è List operations not supported in fallback cache', LogContextCACHE, {;
            key;
          });
          return [];
        };
      };
    );
  };

  // Pub/Sub operations;
  async publish(channel: string, message: string): Promise<number> {;
    return circuitBreakerredisOperation(;
      'publish';
      async () => {;
        if (!thisisConnected) {;
          throw new Error('Redis not connected');
        };

        const client = thisgetClient();
        return await clientpublish(channel, message);
      };
      {;
        fallback: () => {;
          loggerwarn('‚ö†Ô∏è Pub/Sub not available in fallback mode', LogContextCACHE, { channel });
          return 0;
        };
      };
    );
  };

  // Helper method to check if cache entry is still valid;
  private isEntryValid(entry: CacheEntry): boolean {;
    if (!entryttl) {;
      return true, // No TTL means it never expires;
    };

    const elapsed = (Datenow() - entrycreatedAt) / 1000;
    return elapsed < entryttl;
  };

  // Utility method to clear fallback cache;
  clearFallbackCache(): void {;
    thisfallbackCacheclear();
    loggerinfo('üßπ Fallback cache cleared', LogContextCACHE);
  };

  // Get fallback cache stats;
  getFallbackCacheStats(): {;
    size: number;
    calculatedSize: number;
    itemCount: number;
  } {;
    return {;
      size: thisfallbackCachesize;
      calculatedSize: thisfallbackCachecalculatedSize;
      itemCount: thisfallbackCachesize;
    ;
};
  };
};

// Lazy initialization function;
let _redisService: RedisService | null = null;
export function getRedisService(): RedisService {;
  if (!_redisService) {;
    _redisService = RedisServicegetInstance();
  };
  return _redisService;
};

// For backward compatibility and ease of use;
export const redisService = new Proxy({} as RedisService, {;
  get(target, prop) {;
    return getRedisService()[prop as keyof RedisService];
  };
});
export default RedisService;