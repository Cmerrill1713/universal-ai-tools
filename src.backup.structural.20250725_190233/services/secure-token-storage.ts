 ;
/**;
 * Secure Token Storage Service;
 * Provides recommendations and utilities for secure client-side token storage;
 */;

export interface TokenStorageOptions {;
  accessToken: string;
  refreshToken?: string;
  expiresIn: number;
  environment: 'development' | 'production';
;
};

export interface StorageRecommendations {;
  accessToken: {;
    storage: 'memory' | 'sessionStorage';
    reasoning: string;
    implementation: string;
  ;
};
  refreshToken: {;
    storage: 'httpOnlyCookie' | 'secureLocalStorage' | 'memory';
    reasoning: string;
    implementation: string;
  ;
};
  security: {;
    csrfProtection: boolean;
    secureContext: boolean;
    sameSite: 'strict' | 'lax' | 'none';
  ;
};
  rotation: {;
    enabled: boolean;
    interval: number;
    beforeExpiry: number;
  ;
};
};

export class SecureTokenStorageService {;
  /**;
   * Get storage recommendations based on environment and security requirements;
   */;
  public static getStorageRecommendations(;
    environment: 'development' | 'production';
    securityLevel: 'standard' | 'high' | 'maximum' = 'high';
  ): StorageRecommendations {;
    const isProduction = environment === 'production';
    const isHighSecurity = securityLevel === 'high' || securityLevel === 'maximum';
    return {;
      accessToken: {;
        storage: 'memory';
        reasoning:;
          'Access tokens should never be stored persistently. Memory storage (JavaScript variables) provides the best security as tokens are lost on page refresh/close.';
        implementation: ``;
// Store in memory (recommended);
class TokenManager {;
  private accessToken: string | null = null;
  setAccessToken(token: string) {;
    thisaccessToken = token;
  ;
};
  ;
  getAccessToken(): string | null {;
    return thisaccessToken;
  };
  ;
  clearTokens() {;
    thisaccessToken = null;
  };
};

// Alternative: sessionStorage (less secure but survives page refresh);
sessionStoragesetItem('accessToken', token);
`,`;
      };
      refreshToken: {;
        storage: isProduction && isHighSecurity ? 'httpOnlyCookie' : 'secureLocalStorage';
        reasoning:;
          isProduction && isHighSecurity;
            ? 'HttpOnly cookies provide maximum security - not accessible via JavaScript, automatically sent with requests, and protected from XSS attacks.';
            : 'Encrypted localStorage provides good security while maintaining flexibility for client-side management.';
        implementation:;
          isProduction && isHighSecurity;
            ? `;
// Server sets HttpOnly cookie (recommended for production);
rescookie('refreshToken', refreshToken, {;
  httpOnly: true;
  secure: true;
  sameSite: 'strict';
  maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days;
  path: '/api/auth';
});
// Client-side: Cookie is automatically sent, no manual handling needed;
fetch('/api/auth/refresh', {;
  method: 'POST';
  credentials: 'include' // Important: includes cookies;
});
``;
            : `;
// Encrypted localStorage (development/standard security);
import CryptoJS from 'crypto-js';
const SECRET_KEY = processenvTOKEN_ENCRYPTION_KEY || '';
function setSecureItem(key: string, value: string) {;
  const encrypted = CryptoJSAESencrypt(value, SECRET_KEY)toString();
  localStoragesetItem(key, encrypted);
};

function getSecureItem(key: string): string | null {;
  const encrypted = localStoragegetItem(key);
  if (!encrypted) return null;
  try {;
    const decrypted = CryptoJSAESdecrypt(encrypted, SECRET_KEY);
    return decryptedtoString(CryptoJSencUtf8);
  } catch {;
    return null;
  };
};

setSecureItem('refreshToken', refreshToken);
`,`;
      };
      security: {;
        csrfProtection: isProduction;
        secureContext: isProduction;
        sameSite: isProduction ? 'strict' : 'lax';
      ;
};
      rotation: {;
        enabled: true;
        interval: 14 * 60 * 1000, // Refresh 1 minute before expiry (15min - 1min);
        beforeExpiry: 60 * 1000, // 1 minute;
      };
    };
  };

  /**;
   * Generate client-side token management implementation;
   */;
  public static generateClientImplementation(recommendations: StorageRecommendations): string {;
    return `;
/**;
 * Client-side JWT Token Manager;
 * Generated implementation based on security recommendations;
 */;

interface TokenData {;
  accessToken: string;
  refreshToken?: string;
  expiresIn: number;
  expiresAt: number;
;
};

class JWTTokenManager {;
  private tokenData: TokenData | null = null;
  private refreshTimer: NodeJSTimeout | null = null;
  private readonly API_BASE = '${processenvREACT_APP_API_URL || '/api'}';
  constructor() {;
    // Load existing refresh token on initialization;
    thisloadRefreshToken();
  };

  /**;
   * Store new token pair;
   */;
  setTokens(data: { accessToken: string; refreshToken?: string, expiresIn: number }) {;
    const expiresAt = Datenow() + (dataexpiresIn * 1000);
    thistokenData = {;
      ..data;
      expiresAt;
    };
    // Store refresh token persistently;
    ${;
      recommendationsrefreshTokenstorage === 'httpOnlyCookie';
        ? '// Refresh token stored in HttpOnly cookie by server';
        : `thisstoreRefreshToken(datarefreshToken);`;
    };

    // Setup automatic refresh;
    thissetupTokenRefresh();
  };

  /**;
   * Get current access token;
   */;
  getAccessToken(): string | null {;
    if (!thistokenData) return null;
    // Check if token is expired;
    if (Datenow() >= thistokenDataexpiresAt) {;
      thisrefreshTokens();
      return null;
    };
    ;
    return thistokenDataaccessToken;
  };

  /**;
   * Store refresh token securely;
   */;
  private storeRefreshToken(refreshToken?: string) {;
    if (!refreshToken) return;
    ${;
      recommendationsrefreshTokenstorage === 'secureLocalStorage';
        ? `;
    // Encrypted localStorage storage;
    try {;
      const encrypted = btoa(JSONstringify({ token: refreshToken, timestamp: Datenow() }));
      localStoragesetItem('_rt', encrypted);
    } catch (error) {;
      consoleerror instanceof Error ? errormessage : String(error) Failed to store refresh token:', error instanceof Error ? errormessage : String(error)  ;
};
    ``;
        : `;
    // Memory storage only (high security);
    // Refresh token managed by server-side HttpOnly cookies;
    ``;
    ;
};
  };

  /**;
   * Load refresh token from storage;
   */;
  private loadRefreshToken(): string | null {;
    ${;
      recommendationsrefreshTokenstorage === 'secureLocalStorage';
        ? `;
    try {;
      const stored = localStoragegetItem('_rt');
      if (!stored) return null;
      const data = JSONparse(atob(stored));
      // Check if token is not too old (7 days);
      if (Datenow() - datatimestamp > 7 * 24 * 60 * 60 * 1000) {;
        localStorageremoveItem('_rt');
        return null;
      };
      ;
      return datatoken;
    } catch {;
      localStorageremoveItem('_rt');
      return null;
    };
    ``;
        : `;
    // Refresh token managed by HttpOnly cookies;
    return null;
    ``;
    };
  };

  /**;
   * Setup automatic token refresh;
   */;
  private setupTokenRefresh() {;
    if (thisrefreshTimer) {;
      clearTimeout(thisrefreshTimer);
    };

    if (!thistokenData) return;
    const timeUntilRefresh = thistokenDataexpiresAt - Datenow() - ${recommendationsrotationbeforeExpiry};
    if (timeUntilRefresh > 0) {;
      thisrefreshTimer = setTimeout(() => {;
        thisrefreshTokens();
      }, timeUntilRefresh);
    };
  };

  /**;
   * Refresh access token;
   */;
  async refreshTokens(): Promise<boolean> {;
    try {;
      ${;
        recommendationsrefreshTokenstorage === 'httpOnlyCookie';
          ? `;
      const response = await fetch('${thisAPI_BASE}/auth/refresh', {;
        method: 'POST';
        credentials: 'include';
        headers: {;
          'Content-Type': 'application/json';
        ;
};
      });
      ``;
          : `;
      const refreshToken = thisloadRefreshToken();
      if (!refreshToken) {;
        thisclearTokens();
        return false;
      };

      const response = await fetch('${thisAPI_BASE}/auth/refresh', {;
        method: 'POST';
        headers: {;
          'Content-Type': 'application/json';
        ;
};
        body: JSONstringify({ refreshToken });
      });
      ``;
      };

      if (!responseok) {;
        thisclearTokens();
        return false;
      };

      const data = await responsejson();
      thissetTokens(data);
      return true;
    } catch (error) {;
      consoleerror instanceof Error ? errormessage : String(error) Token refresh failed:', error instanceof Error ? errormessage : String(error);
      thisclearTokens();
      return false;
    };
  };

  /**;
   * Clear all tokens and logout;
   */;
  clearTokens() {;
    thistokenData = null;
    if (thisrefreshTimer) {;
      clearTimeout(thisrefreshTimer);
      thisrefreshTimer = null;
    };

    ${;
      recommendationsrefreshTokenstorage === 'secureLocalStorage';
        ? `;
    localStorageremoveItem('_rt');
    ``;
        : '// HttpOnly cookies cleared by server';
    ;
};
  };

  /**;
   * Get authorization header for API requests;
   */;
  getAuthHeader(): Record<string, string> | null {;
    const token = thisgetAccessToken();
    return token ? { 'Authorization': \`Bearer \${token}\` } : null;
  };

  /**;
   * Make authenticated API request;
   */;
  async authenticatedFetch(url: string, options: RequestInit = {}): Promise<Response> {;
    const authHeader = thisgetAuthHeader();
    const response = await fetch(url, {;
      ..options;
      headers: {;
        ..optionsheaders;
        ..authHeader;
      ;
};
      ${recommendationsrefreshTokenstorage === 'httpOnlyCookie' ? 'credentials: "include",' : '';
};
    });
    // Try to refresh token if unauthorized;
    if (responsestatus === 401 && authHeader) {;
      const refreshed = await thisrefreshTokens();
      if (refreshed) {;
        const newAuthHeader = thisgetAuthHeader();
        return fetch(url, {;
          ..options;
          headers: {;
            ..optionsheaders;
            ..newAuthHeader;
          ;
};
          ${recommendationsrefreshTokenstorage === 'httpOnlyCookie' ? 'credentials: "include",' : '';
};
        });
      };
    };

    return response;
  };
};

// Export singleton instance;
export const tokenManager = new JWTTokenManager();
// Usage examples:;
// ;
// // After login;
// tokenManagersetTokens({ accessToken, refreshToken, expiresIn });
// ;
// // Making authenticated requests;
// const response = await tokenManagerauthenticatedFetch('/api/v1/tools');
// ;
// // Or manually get token;
// const token = tokenManagergetAccessToken();
// if (token) {;
//   fetch('/api/v1/tools', {;
//     headers: { 'Authorization': \`Bearer \${token}\` };
//   });
// };
`;`;
  };

  /**;
   * Generate security best practices documentation;
   */;
  public static generateSecurityGuide(): string {;
    return `;
# JWT Token Security Best Practices;
## Token Storage Recommendations;
### Access Tokens (Short-lived: 15 minutes);
- **NEVER** store in localStorage or sessionStorage in production;
- **RECOMMENDED**: Store in memory (JavaScript variables);
- **ALTERNATIVE**: sessionStorage for development only;
- **REASONING**: Minimizes exposure window if compromised;

### Refresh Tokens (Long-lived: 7 days);
- **PRODUCTION**: HttpOnly cookies (most secure);
- **DEVELOPMENT**: Encrypted localStorage;
- **NEVER**: Plain text storage;
- **ROTATION**: Always rotate on refresh;
## Implementation Security Checklist;
### Client-Side Security;
- [ ] Access tokens stored in memory only;
- [ ] Refresh tokens in HttpOnly cookies (production);
- [ ] Automatic token refresh before expiry;
- [ ] Clear tokens on logout/error;
- [ ] HTTPS enforced in production;
- [ ] CSRF protection enabled;
- [ ] SameSite cookie attribute set to 'strict';
### Server-Side Security;
- [ ] Short access token expiry (15 minutes);
- [ ] Refresh token rotation enabled;
- [ ] Token blacklist/revocation system;
- [ ] Rate limiting on auth endpoints;
- [ ] Secure token generation (cryptorandomUUID);
- [ ] Encrypted refresh token storage in database;
- [ ] Session management across devices;
- [ ] Failed attempt tracking and account lockout;
### Network Security;
- [ ] HTTPS only (production);
- [ ] Secure cookie flags;
- [ ] CORS properly configured;
- [ ] Content Security Policy headers;
- [ ] No tokens in URL parameters;
- [ ] No tokens in logs;
## Common Security Pitfalls to Avoid;
1. **Storing JWT in localStorage**: Vulnerable to XSS attacks;
2. **Long-lived access tokens**: Increases security window;
3. **No token rotation**: Compromised tokens remain valid;
4. **Client-side token validation**: Always validate on server;
5. **Tokens in URLs**: Can be logged or cached;
6. **Missing HTTPS**: Tokens can be intercepted;
7. **No rate limiting**: Vulnerable to brute force attacks;
8. **Weak secrets**: Use cryptographically secure random keys;
## Emergency Procedures;
### If Tokens Are Compromised;
1. Immediately revoke all user sessions;
2. Force password reset for affected users;
3. Rotate JWT signing secrets;
4. Audit access logs for suspicious activity;
5. Notify affected users;
6. Review and strengthen security measures;
### Monitoring and Alerting;
- Monitor failed authentication attempts;
- Alert on unusual login patterns;
- Track token refresh frequency;
- Log security events for audit;
- Set up automated security scanning;
`;`;
  };
};

export default SecureTokenStorageService;