/**;
 * Application Performance Monitoring (APM) Service;
 *;
 * Comprehensive APM service for Universal AI Tools with:;
 * - Real-time performance monitoring;
 * - Application insights and analytics;
 * - Transaction tracing;
 * - Error rate monitoring;
 * - Resource utilization tracking;
 * - Sweet Athena performance metrics;
 * - Automatic anomaly detection;
 * - Performance alerting;
 */;

import { EventEmitter } from 'events';
import { PerformanceObserver, performance } from 'perf_hooks';
import { telemetryService } from './telemetry-service';
import { performanceMonitor } from '../utils/performance-monitor';
import { LogContext, logger } from '../utils/enhanced-logger';
import type { SupabaseClient } from '@supabase/supabase-js';
import { createClient } from '@supabase/supabase-js';
export interface APMConfig {;
  enabled: boolean;
  samplingRate: number;
  maxTransactions: number;
  maxSpans: number;
  flushInterval: number; // ms;
  enableRealUserMonitoring: boolean;
  enableSyntheticMonitoring: boolean;
  enableResourceMonitoring: boolean;
  enableMemoryLeakDetection: boolean;
  enablePerformanceBaseline: boolean;
  alertThresholds: {;
    responseTime: number; // ms;
    errorRate: number; // percentage;
    memoryUsage: number; // MB;
    cpuUsage: number; // percentage;
  };
};

export interface Transaction {;
  id: string;
  name: string;
  type: 'request| 'task' | 'background' | 'athena';
  startTime: number;
  endTime?: number;
  duration?: number;
  result: 'success' | 'error instanceof Error ? errormessage : String(error) | 'timeout' | 'cancelled';
  spans: Span[];
  tags: Record<string, unknown>;
  user?: {;
    id: string;
    sessionId: string;
  ;
};
  context: {;
    traceId?: string;
    url?: string;
    method?: string;
    statusCode?: number;
    userAgent?: string;
    ip?: string;
  ;
};
  metrics: {;
    memoryUsed: number;
    cpuTime: number;
    dbQueries: number;
    apiCalls: number;
  ;
};
};

export interface Span {;
  id: string;
  transactionId: string;
  name: string;
  type: 'db' | 'http' | 'ai' | 'cache' | 'custom';
  startTime: number;
  endTime?: number;
  duration?: number;
  tags: Record<string, unknown>;
  stackTrace?: string[];
;
};

export interface PerformanceMetric {;
  timestamp: Date;
  transactionType: string;
  name: string;
  value: number;
  unit: string;
  tags: Record<string, unknown>;
};

export interface ErrorEvent {;
  id: string;
  timestamp: Date;
  transactionId?: string;
  spanId?: string;
  message: string;
  type: string;
  stackTrace: string;
  handled: boolean;
  tags: Record<string, unknown>;
  context: Record<string, unknown>;
  fingerprint: string;
;
};

export interface APMReport {;
  timeRange: {;
    start: Date;
    end: Date;
  ;
};
  overview: {;
    totalTransactions: number;
    totalErrors: number;
    averageResponseTime: number;
    errorRate: number;
    throughput: number; // transactions per minute;
  };
  topTransactions: Array<{;
    name: string;
    count: number;
    averageTime: number;
    errorRate: number;
  }>;
  topErrors: Array<{;
    fingerprint: string;
    message: string;
    count: number;
    lastSeen: Date;
  }>;
  performance: {;
    responseTimePercentiles: {;
      p50: number;
      p95: number;
      p99: number;
    ;
};
    memoryUsage: {;
      average: number;
      peak: number;
    ;
};
    cpuUsage: {;
      average: number;
      peak: number;
    ;
};
  };
  athenaMetrics?: {;
    totalInteractions: number;
    averageResponseTime: number;
    satisfactionScore: number;
    topMoods: Array<{;
      mood: string;
      count: number;
      averageTime: number;
    }>;
  };
};

export class APMService extends EventEmitter {;
  private config: APMConfig;
  private supabase: SupabaseClient;
  private isStarted = false;
  private transactions = new Map<string, Transaction>();
  private spans = new Map<string, Span>();
  private errors: ErrorEvent[] = [];
  private metrics: PerformanceMetric[] = [];
  private performanceObserver?: PerformanceObserver;
  private flushInterval?: NodeJSTimeout;
  private memoryBaseline?: NodeJSMemoryUsage;
  private lastGCTime = Datenow();
  private transactionCount = 0;
  constructor(supabaseUrl: string, supabaseKey: string, config: Partial<APMConfig> = {}) {;
    super();
    thissupabase = createClient(supabaseUrl, supabaseKey);
    thisconfig = {;
      enabled: true;
      samplingRate: 1.0;
      maxTransactions: 1000;
      maxSpans: 10000;
      flushInterval: 30000, // 30 seconds;
      enableRealUserMonitoring: true;
      enableSyntheticMonitoring: false;
      enableResourceMonitoring: true;
      enableMemoryLeakDetection: true;
      enablePerformanceBaseline: true;
      alertThresholds: {;
        responseTime: 2000, // 2 seconds;
        errorRate: 5, // 5%;
        memoryUsage: 1024, // 1GB;
        cpuUsage: 80, // 80%;
      };
      ..config;
    };
    thissetupErrorHandling();
  };

  /**;
   * Start APM monitoring;
   */;
  async start(): Promise<void> {;
    if (thisisStarted) {;
      loggerwarn('APM service already started', LogContextPERFORMANCE);
      return;
    };

    if (!thisconfigenabled) {;
      loggerinfo('APM service disabled', LogContextPERFORMANCE);
      return;
    };

    try {;
      loggerinfo('Starting APM service', LogContextPERFORMANCE, { config: thisconfig });
      // Initialize baseline metrics;
      if (thisconfigenablePerformanceBaseline) {;
        thismemoryBaseline = processmemoryUsage();
      };

      // Setup performance monitoring;
      thissetupPerformanceMonitoring();
      // Setup resource monitoring;
      if (thisconfigenableResourceMonitoring) {;
        thissetupResourceMonitoring();
      };

      // Setup memory leak detection;
      if (thisconfigenableMemoryLeakDetection) {;
        thissetupMemoryLeakDetection();
      };

      // Start flush interval;
      thisflushInterval = setInterval(() => {;
        thisflushMetrics();
      }, thisconfigflushInterval);
      thisisStarted = true;
      thisemit('started', { config: thisconfig });
      loggerinfo('APM service started successfully', LogContextPERFORMANCE);
    } catch (error) {;
      loggererror('Failed to start APM service', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error));
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Stop APM monitoring;
   */;
  async stop(): Promise<void> {;
    if (!thisisStarted) {;
      loggerwarn('APM service not started', LogContextPERFORMANCE);
      return;
    };

    try {;
      loggerinfo('Stopping APM service', LogContextPERFORMANCE);
      // Clear intervals;
      if (thisflushInterval) {;
        clearInterval(thisflushInterval);
        thisflushInterval = undefined;
      };

      // Disconnect performance observer;
      if (thisperformanceObserver) {;
        thisperformanceObserverdisconnect();
        thisperformanceObserver = undefined;
      };

      // Final flush;
      await thisflushMetrics();
      thisisStarted = false;
      thisemit('stopped');
      loggerinfo('APM service stopped successfully', LogContextPERFORMANCE);
    } catch (error) {;
      loggererror('Error stopping APM service', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error));
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Start a new transaction;
   */;
  startTransaction(;
    name: string;
    type: Transaction['type'] = 'request;
    context: Partial<Transaction['context']> = {;
};
  ): string {;
    const transactionId = thisgenerateId();
    const startTime = performancenow();
    const transaction: Transaction = {;
      id: transactionId;
      name;
      type;
      startTime;
      result: 'success';
      spans: [];
      tags: {;
};
      context: {;
        traceId: telemetryServicegetCurrentTraceId();
        ..context;
      ;
};
      metrics: {;
        memoryUsed: processmemoryUsage()heapUsed;
        cpuTime: processcpuUsage()user + processcpuUsage()system;
        dbQueries: 0;
        apiCalls: 0;
      ;
};
    };
    thistransactionsset(transactionId, transaction);
    thistransactionCount++;
    // Cleanup old transactions if we exceed limit;
    if (thistransactionssize > thisconfigmaxTransactions) {;
      thiscleanupOldTransactions();
    };

    loggerdebug('Started transaction', LogContextPERFORMANCE, {;
      transaction_id: transactionId;
      name;
      type;
      trace_id: transactioncontexttraceId;
    });
    thisemit('transactionStarted', transaction);
    return transactionId;
  };

  /**;
   * End a transaction;
   */;
  endTransaction(;
    transactionId: string;
    result: Transaction['result'] = 'success';
    tags: Record<string, unknown> = {};
  ): void {;
    const transaction = thistransactionsget(transactionId);
    if (!transaction) {;
      loggerwarn('Transaction not found', LogContextPERFORMANCE, {;
        transaction_id: transactionId;
      });
      return;
    };

    const endTime = performancenow();
    transactionendTime = endTime;
    transactionduration = endTime - transactionstartTime;
    transactionresult = result;
    transactiontags = { ..transactiontags, ..tags };
    // Update final metrics;
    const finalMemory = processmemoryUsage();
    const finalCpu = processcpuUsage();
    transactionmetrics = {;
      ..transactionmetrics;
      memoryUsed: finalMemoryheapUsed - transactionmetricsmemoryUsed;
      cpuTime: finalCpuuser + finalCpusystem - transactionmetricscpuTime;
    ;
};
    loggerdebug('Ended transaction', LogContextPERFORMANCE, {;
      transaction_id: transactionId;
      duration_ms: transactionduration;
      result;
      memory_used: transactionmetricsmemoryUsed;
      cpu_time: transactionmetricscpuTime;
    });
    // Check for performance alerts;
    thischeckPerformanceAlerts(transaction);
    thisemit('transactionEnded', transaction);
    // Record performance metric;
    thisrecordMetric('transaction_duration', transactionduration, 'ms', {;
      transaction_name: transactionname;
      transaction_type: transactiontype;
      result: transactionresult;
    });
  };

  /**;
   * Start a span within a transaction;
   */;
  startSpan(;
    transactionId: string;
    name: string;
    type: Span['type'] = 'custom';
    tags: Record<string, unknown> = {};
  ): string {;
    const spanId = thisgenerateId();
    const startTime = performancenow();
    const span: Span = {;
      id: spanId;
      transactionId;
      name;
      type;
      startTime;
      tags;
    ;
};
    thisspansset(spanId, span);
    // Add to transaction;
    const transaction = thistransactionsget(transactionId);
    if (transaction) {;
      transactionspanspush(span);
    };

    // Cleanup old spans if we exceed limit;
    if (thisspanssize > thisconfigmaxSpans) {;
      thiscleanupOldSpans();
    };

    loggerdebug('Started span', LogContextPERFORMANCE, {;
      span_id: spanId;
      transaction_id: transactionId;
      name;
      type;
    });
    thisemit('spanStarted', span);
    return spanId;
  };

  /**;
   * End a span;
   */;
  endSpan(spanId: string, tags: Record<string, unknown> = {}): void {;
    const span = thisspansget(spanId);
    if (!span) {;
      loggerwarn('Span not found', LogContextPERFORMANCE, { span_id: spanId });
      return;
    };

    const endTime = performancenow();
    spanendTime = endTime;
    spanduration = endTime - spanstartTime;
    spantags = { ..spantags, ..tags };
    // Update transaction metrics based on span type;
    const transaction = thistransactionsget(spantransactionId);
    if (transaction) {;
      switch (spantype) {;
        case 'db':;
          transactionmetricsdbQueries++;
          break;
        case 'http':;
          transactionmetricsapiCalls++;
          break;
      };
    };

    loggerdebug('Ended span', LogContextPERFORMANCE, {;
      span_id: spanId;
      transaction_id: spantransactionId;
      duration_ms: spanduration;
      type: spantype;
    });
    thisemit('spanEnded', span);
    // Record span metric;
    thisrecordMetric('span_duration', spanduration, 'ms', {;
      span_name: spanname;
      span_type: spantype;
      transaction_id: spantransactionId;
    });
  };

  /**;
   * Record an error;
   */;
  recordError(;
    error instanceof Error ? errormessage : String(error) Error;
    context: Record<string, unknown> = {};
    transactionId?: string;
    spanId?: string;
  ): string {;
    const errorId = thisgenerateId();
    const fingerprint = thisgenerateErrorFingerprint(error instanceof Error ? errormessage : String(error);

    const errorEvent: ErrorEvent = {;
      id: errorId;
      timestamp: new Date();
      transactionId;
      spanId;
      message: errormessage;
      type: errorname;
      stackTrace: errorstack || '';
      handled: true;
      tags: {;
};
      context;
      fingerprint;
    };
    thiserrorspush(errorEvent);
    // Update transaction result if associated;
    if (transactionId) {;
      const transaction = thistransactionsget(transactionId);
      if (transaction) {;
        transactionresult = 'error instanceof Error ? errormessage : String(error)  ;
};
    };

    // Keep only recent errors (last 1000);
    if (thiserrorslength > 1000) {;
      thiserrors = thiserrorsslice(-1000);
    };

    loggererror('APM errorrecorded', LogContextPERFORMANCE, {;
      error_id: errorId;
      transaction_id: transactionId;
      span_id: spanId;
      fingerprint;
      message: errormessage;
    });
    thisemit('errorRecorded', errorEvent);
    // Record errormetric;
    thisrecordMetric('error_count', 1, 'count', {;
      error_type: errorname;
      fingerprint;
      transaction_id: transactionId;
    });
    return errorId;
  };

  /**;
   * Record Sweet Athena interaction;
   */;
  recordAthenaInteraction(;
    interactionType: string;
    personalityMood: string;
    responseTime: number;
    satisfactionScore?: number;
    sessionId?: string;
  ): void {;
    const transactionId = thisstartTransaction(`athena.${interactionType}`, 'athena', {;
      url: `/athena/${interactionType}`;
    });
    // Add Athena-specific tags;
    const transaction = thistransactionsget(transactionId);
    if (transaction) {;
      transactiontags = {;
        'athenainteraction_type': interactionType;
        'athenapersonality_mood': personalityMood;
        'athenasession_id': sessionId || 'unknown';
        'athenasatisfaction_score': satisfactionScore;
      ;
};
      if (sessionId) {;
        transactionuser = {;
          id: 'athena_user';
          sessionId;
        ;
};
      };
    };

    // Simulate transaction completion;
    setTimeout(() => {;
      thisendTransaction(transactionId, 'success', {;
        'athenaresponse_time': responseTime;
        'athenasatisfaction_score': satisfactionScore;
      });
    }, responseTime);
    // Record specific Athena metrics;
    thisrecordMetric('athena_interaction_duration', responseTime, 'ms', {;
      interaction_type: interactionType;
      personality_mood: personalityMood;
      session_id: sessionId || 'unknown';
    });
    if (satisfactionScore !== undefined) {;
      thisrecordMetric('athena_satisfaction_score', satisfactionScore, 'score', {;
        interaction_type: interactionType;
        personality_mood: personalityMood;
        session_id: sessionId || 'unknown';
      });
    };
  };

  /**;
   * Generate comprehensive APM report;
   */;
  generateReport(durationMinutes = 60): APMReport {;
    const endTime = new Date();
    const startTime = new Date(endTimegetTime() - durationMinutes * 60 * 1000);
    const recentTransactions = Arrayfrom(thistransactionsvalues())filter(;
      (t) => tendTime && new Date(tstartTime) > startTime;
    );
    const recentErrors = thiserrorsfilter((e) => etimestamp > startTime);
    const recentMetrics = thismetricsfilter((m) => mtimestamp > startTime);
    // Calculate overview metrics;
    const totalTransactions = recentTransactionslength;
    const totalErrors = recentErrorslength;
    const completedTransactions = recentTransactionsfilter((t) => tduration !== undefined);
    const averageResponseTime =;
      completedTransactionslength > 0;
        ? completedTransactionsreduce((sum, t) => sum + (tduration || 0), 0) /;
          completedTransactionslength;
        : 0;
    const errorRate = totalTransactions > 0 ? (totalErrors / totalTransactions) * 100 : 0;
    const throughput = totalTransactions / durationMinutes;
    // Calculate top transactions;
    const transactionGroups = new Map<string, Transaction[]>();
    recentTransactionsforEach((t) => {;
      const key = `${ttype}:${tname}`;
      if (!transactionGroupshas(key)) {;
        transactionGroupsset(key, []);
      };
      transactionGroupsget(key)!push(t);
    });
    const topTransactions = Arrayfrom(transactionGroupsentries());
      map(([name, transactions]) => {;
        const completed = transactionsfilter((t) => tduration !== undefined);
        const errors = transactionsfilter((t) => tresult === 'error instanceof Error ? errormessage : String(error) length;
        return {;
          name;
          count: transactionslength;
          averageTime:;
            completedlength > 0;
              ? completedreduce((sum, t) => sum + (tduration || 0), 0) / completedlength;
              : 0;
          errorRate: transactionslength > 0 ? (errors / transactionslength) * 100 : 0;
        ;
};
      });
      sort((a, b) => bcount - acount);
      slice(0, 10);
    // Calculate top errors;
    const errorGroups = new Map<string, ErrorEvent[]>();
    recentErrorsforEach((e) => {;
      if (!errorGroupshas(efingerprint)) {;
        errorGroupsset(efingerprint, []);
      };
      errorGroupsget(efingerprint)!push(e);
    });
    const topErrors = Arrayfrom(errorGroupsentries());
      map(([fingerprint, errors]) => ({;
        fingerprint;
        message: errors[0]message;
        count: errorslength;
        lastSeen: new Date(Mathmax(..errorsmap((e) => etimestampgetTime())));
      }));
      sort((a, b) => bcount - acount);
      slice(0, 10);
    // Calculate response time percentiles;
    const durations = completedTransactionsmap((t) => tduration!)sort((a, b) => a - b);
    const responseTimePercentiles = {;
      p50: thiscalculatePercentile(durations, 50);
      p95: thiscalculatePercentile(durations, 95);
      p99: thiscalculatePercentile(durations, 99);
    };
    // Calculate resource usage;
    const memoryMetrics = recentMetricsfilter((m) => mname === 'memory_usage');
    const cpuMetrics = recentMetricsfilter((m) => mname === 'cpu_usage');
    const performance = {;
      responseTimePercentiles;
      memoryUsage: {;
        average:;
          memoryMetricslength > 0;
            ? memoryMetricsreduce((sum, m) => sum + mvalue, 0) / memoryMetricslength;
            : 0;
        peak: memoryMetricslength > 0 ? Mathmax(..memoryMetricsmap((m) => mvalue)) : 0;
      };
      cpuUsage: {;
        average:;
          cpuMetricslength > 0;
            ? cpuMetricsreduce((sum, m) => sum + mvalue, 0) / cpuMetricslength;
            : 0;
        peak: cpuMetricslength > 0 ? Mathmax(..cpuMetricsmap((m) => mvalue)) : 0;
      ;
};
    };
    // Calculate Athena metrics;
    const athenaTransactions = recentTransactionsfilter((t) => ttype === 'athena');
    const athenaMetrics =;
      athenaTransactionslength > 0;
        ? {;
            totalInteractions: athenaTransactionslength;
            averageResponseTime:;
              athenaTransactionsreduce((sum, t) => sum + (tduration || 0), 0) /;
              athenaTransactionslength;
            satisfactionScore: thiscalculateAverageSatisfactionScore(athenaTransactions);
            topMoods: thiscalculateTopMoods(athenaTransactions);
          ;
};
        : undefined;
    return {;
      timeRange: { start: startTime, end: endTime ;
};
      overview: {;
        totalTransactions;
        totalErrors;
        averageResponseTime: Mathround(averageResponseTime);
        errorRate: Mathround(errorRate * 100) / 100;
        throughput: Mathround(throughput * 100) / 100;
      ;
};
      topTransactions;
      topErrors;
      performance;
      athenaMetrics;
    };
  };

  /**;
   * Get current metrics;
   */;
  getCurrentMetrics(): {;
    activeTransactions: number;
    activeSpans: number;
    errorCount: number;
    memoryUsage: NodeJSMemoryUsage;
    uptime: number;
  } {;
    return {;
      activeTransactions: Arrayfrom(thistransactionsvalues())filter((t) => !tendTime)length;
      activeSpans: Arrayfrom(thisspansvalues())filter((s) => !sendTime)length;
      errorCount: thiserrorslength;
      memoryUsage: processmemoryUsage();
      uptime: processuptime();
    ;
};
  };

  // Private methods;

  private setupErrorHandling(): void {;
    // Global errorhandling;
    processon('uncaughtException', (error instanceof Error ? errormessage : String(error)=> {;
      thisrecordError(error instanceof Error ? errormessage : String(error) { source: 'uncaughtException' });
    });
    processon('unhandledRejection', (reason) => {;
      const error instanceof Error ? errormessage : String(error)  reason instanceof Error ? reason : new Error(String(reason));
      thisrecordError(error instanceof Error ? errormessage : String(error) { source: 'unhandledRejection' });
    });
  };

  private setupPerformanceMonitoring(): void {;
    thisperformanceObserver = new PerformanceObserver((list) => {;
      const entries = listgetEntries();
      entriesforEach((entry) => {;
        thisrecordMetric('performance_entry', entryduration, 'ms', {;
          entry_type: entryentryType;
          name: entryname;
        });
      });
    });
    thisperformanceObserverobserve({ entryTypes: ['measure', 'navigation', 'resource'] });
  };

  private setupResourceMonitoring(): void {;
    setInterval(() => {;
      const memUsage = processmemoryUsage();
      const cpuUsage = processcpuUsage();
      thisrecordMetric('memory_usage', memUsageheapUsed / 1024 / 1024, 'MB', {;
        type: 'heap_used';
      });
      thisrecordMetric('memory_usage', memUsagerss / 1024 / 1024, 'MB', {;
        type: 'rss';
      });
      thisrecordMetric('cpu_usage', (cpuUsageuser + cpuUsagesystem) / 1000, 'ms', {;
        type: 'total';
      });
    }, 15000); // Every 15 seconds;
  };

  private setupMemoryLeakDetection(): void {;
    setInterval(() => {;
      if (!thismemoryBaseline) return;
      const currentMemory = processmemoryUsage();
      const heapGrowth = currentMemoryheapUsed - thismemoryBaselineheapUsed;
      // Check for significant memory growth;
      if (heapGrowth > 50 * 1024 * 1024) {;
        // 50MB;
        loggerwarn('Potential memory leak detected', LogContextPERFORMANCE, {;
          heap_growth_mb: Mathround(heapGrowth / 1024 / 1024);
          current_heap_mb: Mathround(currentMemoryheapUsed / 1024 / 1024);
          baseline_heap_mb: Mathround(thismemoryBaselineheapUsed / 1024 / 1024);
        });
        thisemit('memoryLeakDetected', {;
          heapGrowth;
          currentMemory;
          baseline: thismemoryBaseline;
        });
      };

      // Update baseline periodically;
      if (Datenow() - thislastGCTime > 300000) {;
        // 5 minutes;
        if (globalgc) {;
          globalgc();
          thismemoryBaseline = processmemoryUsage();
          thislastGCTime = Datenow();
        };
      };
    }, 60000); // Every minute;
  };

  private recordMetric(;
    name: string;
    value: number;
    unit: string;
    tags: Record<string, unknown> = {};
  ): void {;
    const metric: PerformanceMetric = {;
      timestamp: new Date();
      transactionType: 'system';
      name;
      value;
      unit;
      tags;
    ;
};
    thismetricspush(metric);
    // Keep only recent metrics (last 10000);
    if (thismetricslength > 10000) {;
      thismetrics = thismetricsslice(-10000);
    };

    thisemit('metricRecorded', metric);
  };

  private checkPerformanceAlerts(transaction: Transaction): void {;
    const { alertThresholds } = thisconfig;
    // Check response time;
    if (transactionduration && transactionduration > alertThresholdsresponseTime) {;
      thisemit('performanceAlert', {;
        type: 'high_response_time';
        transaction;
        threshold: alertThresholdsresponseTime;
        value: transactionduration;
      });
    };

    // Check memory usage;
    const memoryMB = transactionmetricsmemoryUsed / 1024 / 1024;
    if (memoryMB > alertThresholdsmemoryUsage) {;
      thisemit('performanceAlert', {;
        type: 'high_memory_usage';
        transaction;
        threshold: alertThresholdsmemoryUsage;
        value: memoryMB;
      });
    };
  };

  private async flushMetrics(): Promise<void> {;
    try {;
      // Persist recent transactions to database;
      const recentTransactions = Arrayfrom(thistransactionsvalues());
        filter((t) => tendTime);
        slice(-100); // Last 100 completed transactions;
      if (recentTransactionslength > 0) {;
        await thissupabasefrom('apm_transactions')upsert(;
          recentTransactionsmap((t) => ({;
            id: tid;
            name: tname;
            type: ttype;
            start_time: new Date(tstartTime);
            end_time: tendTime ? new Date(tendTime) : null;
            duration: tduration;
            result: tresult;
            tags: ttags;
            context: tcontext;
            metrics: tmetrics;
          }));
        );
      };

      // Persist recent errors;
      const recentErrors = thiserrorsslice(-50); // Last 50 errors;
      if (recentErrorslength > 0) {;
        await thissupabasefrom('apmerrors')upsert(;
          recentErrorsmap((e) => ({;
            id: eid;
            timestamp: etimestamp;
            transaction_id: etransactionId;
            span_id: espanId;
            message: emessage;
            type: etype;
            stack_trace: estackTrace;
            handled: ehandled;
            tags: etags;
            context: econtext;
            fingerprint: efingerprint;
          }));
        );
      };

      loggerdebug('APM metrics flushed', LogContextPERFORMANCE, {;
        transactions: recentTransactionslength;
        errors: recentErrorslength;
      });
    } catch (error) {;
      loggererror('Failed to flush APM metrics', LogContextPERFORMANCE, { error instanceof Error ? errormessage : String(error) );
    ;
};
  };

  private cleanupOldTransactions(): void {;
    const transactions = Arrayfrom(thistransactionsentries());
    const cutoff = performancenow() - 300000; // 5 minutes ago;

    const toDelete = transactions;
      filter(([_, t]) => tstartTime < cutoff && tendTime);
      slice(0, Mathfloor(thisconfigmaxTransactions * 0.1)); // Delete 10%;
    toDeleteforEach(([id, _]) => thistransactionsdelete(id));
  };

  private cleanupOldSpans(): void {;
    const spans = Arrayfrom(thisspansentries());
    const cutoff = performancenow() - 300000; // 5 minutes ago;

    const toDelete = spans;
      filter(([_, s]) => sstartTime < cutoff && sendTime);
      slice(0, Mathfloor(thisconfigmaxSpans * 0.1)); // Delete 10%;
    toDeleteforEach(([id, _]) => thisspansdelete(id));
  };

  private generateId(): string {;
    return (;
      Mathrandom()toString(36)substring(2, 15) + Mathrandom()toString(36)substring(2, 15);
    );
  };

  private generateErrorFingerprint(error instanceof Error ? errormessage : String(error) Error): string {;
    // Create a fingerprint based on errortype and stack trace;
    const stack = errorstack || '';
    const lines = stacksplit('\n')slice(0, 3), // First 3 lines;
    return Bufferfrom(`${errorname}:${linesjoin('')}`);
      toString('base64');
      substring(0, 16);
  };

  private calculatePercentile(values: number[], percentile: number): number {;
    if (valueslength === 0) return 0;
    const index = Mathceil((percentile / 100) * valueslength) - 1;
    return values[Mathmax(0, index)] || 0;
  };

  private calculateAverageSatisfactionScore(transactions: Transaction[]): number {;
    const scores = transactions;
      map((t) => ttags['athenasatisfaction_score']);
      filter((score) => typeof score === 'number');
    return scoreslength > 0 ? scoresreduce((sum, score) => sum + score, 0) / scoreslength : 0;
  };

  private calculateTopMoods(transactions: Transaction[]): Array<{;
    mood: string;
    count: number;
    averageTime: number;
  }> {;
    const moodGroups = new Map<string, Transaction[]>();
    transactionsforEach((t) => {;
      const mood = ttags['athenapersonality_mood'];
      if (mood) {;
        if (!moodGroupshas(mood)) {;
          moodGroupsset(mood, []);
        };
        moodGroupsget(mood)!push(t);
      };
    });
    return Arrayfrom(moodGroupsentries());
      map(([mood, moods]) => ({;
        mood;
        count: moodslength;
        averageTime: moodsreduce((sum, t) => sum + (tduration || 0), 0) / moodslength;
      }));
      sort((a, b) => bcount - acount);
      slice(0, 5);
  };
};

// Create singleton instance;
let apmService: APMService | null = null;
export function getAPMService(;
  supabaseUrl?: string;
  supabaseKey?: string;
  config?: Partial<APMConfig>;
): APMService {;
  if (!apmService) {;
    if (!supabaseUrl || !supabaseKey) {;
      throw new Error('Supabase URL and key required to initialize APM service');
    };
    apmService = new APMService(supabaseUrl, supabaseKey, config);
  };
  return apmService;
};

export default APMService;