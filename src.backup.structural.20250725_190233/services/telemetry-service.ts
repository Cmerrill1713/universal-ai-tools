/**;
 * Enhanced OpenTelemetry Distributed Tracing Service;
 *;
 * Comprehensive telemetry service for Universal AI Tools with:;
 * - Distributed tracing across all services;
 * - Metrics collection and export;
 * - Custom span instrumentation;
 * - Performance monitoring;
 * - Error tracking and correlation;
 * - Service mesh visibility;
 * - Sweet Athena specific tracing;
 */;

import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { ConsoleMetricExporter, PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics';
import { PrometheusExporter } from '@opentelemetry/exporter-prometheus';
import type { SpanProcessor } from '@opentelemetry/sdk-trace-base';
import {;
  BatchSpanProcessor;
  ConsoleSpanExporter;
  SimpleSpanProcessor;
} from '@opentelemetry/sdk-trace-base';
import { JaegerExporter } from '@opentelemetry/exporter-jaeger';
import { ZipkinExporter } from '@opentelemetry/exporter-zipkin';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';
import type { Context, Span, Tracer } from '@opentelemetry/api';
import { SpanKind, SpanStatusCode, context, metrics, propagation, trace } from '@opentelemetry/api';
import { W3CTraceContextPropagator } from '@opentelemetry/core';
import { W3CBaggagePropagator } from '@opentelemetry/core';
import { CompositePropagator } from '@opentelemetry/core';
import {;
  AlwaysOnSampler;
  ParentBasedSampler;
  TraceIdRatioBasedSampler;
} from '@opentelemetry/sdk-trace-base';
import { DiagConsoleLogger, DiagLogLevel, diag } from '@opentelemetry/api';
import { EventEmitter } from 'events';
import { LogContext, logger } from '../utils/enhanced-logger';
import { getTelemetryConfig } from '../config/telemetry';
export interface TelemetryServiceOptions {;
  serviceName?: string;
  serviceVersion?: string;
  environment?: string;
  enableConsoleExporter?: boolean;
  enableJaeger?: boolean;
  enableZipkin?: boolean;
  enableOTLP?: boolean;
  enablePrometheus?: boolean;
  prometheusPort?: number;
  samplingRate?: number;
  debug?: boolean;
  metricsInterval?: number;
;
};

export interface CustomSpanData {;
  name: string;
  attributes?: Record<string, unknown>;
  spanKind?: SpanKind;
  parentSpan?: Span;
;
};

export interface TraceMetadata {;
  traceId: string;
  spanId: string;
  parentSpanId?: string;
  operation: string;
  duration: number;
  status: 'success' | 'error instanceof Error ? errormessage : String(error) | 'timeout';
  attributes: Record<string, unknown>;
  timestamp: Date;
;
};

export interface PerformanceTrace {;
  operation: string;
  component: string;
  duration: number;
  success: boolean;
  metadata: Record<string, unknown>;
  traceId: string;
  timestamp: Date;
;
};

export class TelemetryService extends EventEmitter {;
  private sdk: NodeSDK | null = null;
  private tracer: Tracer | null = null;
  private meter: any = null;
  private isInitialized = false;
  private activeSpans: Map<string, Span> = new Map();
  private performanceTraces: PerformanceTrace[] = [];
  private spanProcessors: SpanProcessor[] = [];
  private metricReaders: any[] = [];
  constructor() {;
    super();
    // Setup errorhandling;
    thison('error instanceof Error ? errormessage : String(error)  (error instanceof Error ? errormessage : String(error)=> {;
      loggererror('Telemetry service error instanceof Error ? errormessage : String(error)  LogContextTELEMETRY, { error instanceof Error ? errormessage : String(error));
    });
  };

  async initialize(options: TelemetryServiceOptions = {}): Promise<void> {;
    if (thisisInitialized) {;
      loggerwarn('Telemetry service already initialized', LogContextSYSTEM);
      return;
    };

    const config = getTelemetryConfig();
    const mergedOptions = { ..config, ..options };
    // Enable debug logging if requested;
    if (mergedOptionsdebug) {;
      diagsetLogger(new DiagConsoleLogger(), DiagLogLevelDEBUG);
    };

    try {;
      // Create resource with service information;
      const resource = Resourcedefault()merge(;
        new Resource({;
          [SemanticResourceAttributesSERVICE_NAME]:;
            mergedOptionsserviceName || 'universal-ai-tools';
          [SemanticResourceAttributesSERVICE_VERSION]:;
            mergedOptionsserviceVersion || processenvnpm_package_version || '1.0.0';
          [SemanticResourceAttributesDEPLOYMENT_ENVIRONMENT]:;
            mergedOptionsenvironment || processenvNODE_ENV || 'development';
          'serviceinstanceid': processenvINSTANCE_ID || `instance-${Datenow()}`;
          'servicenamespace': 'ai-tools';
        });
      );
      // Configure span processors;
      const spanProcessors: SpanProcessor[] = [];
      if (mergedOptionsenableConsoleExporter) {;
        spanProcessorspush(new SimpleSpanProcessor(new ConsoleSpanExporter()));
      };

      if (mergedOptionsenableJaeger) {;
        const jaegerExporter = new JaegerExporter({;
          endpoint: processenvJAEGER_ENDPOINT || 'http://localhost:14268/api/traces';
        });
        spanProcessorspush(new BatchSpanProcessor(jaegerExporter));
      };

      if (mergedOptionsenableZipkin) {;
        const zipkinExporter = new ZipkinExporter({;
          url: processenvZIPKIN_ENDPOINT || 'http://localhost:9411/api/v2/spans';
        });
        spanProcessorspush(new BatchSpanProcessor(zipkinExporter));
      };

      if (mergedOptionsenableOTLP) {;
        const otlpExporter = new OTLPTraceExporter({;
          url: processenvOTEL_EXPORTER_OTLP_TRACES_ENDPOINT || 'http://localhost:4318/v1/traces';
          headers: processenvOTEL_EXPORTER_OTLP_HEADERS;
            ? JSONparse(processenvOTEL_EXPORTER_OTLP_HEADERS);
            : {;
};
        });
        spanProcessorspush(new BatchSpanProcessor(otlpExporter));
      };

      // Configure metrics;
      thismetricReaders = [];
      if (mergedOptionsenablePrometheus) {;
        const prometheusExporter = new PrometheusExporter({;
          port: mergedOptionsprometheusPort || 9464;
          endpoint: '/metrics';
        });
        thismetricReaderspush(;
          new PeriodicExportingMetricReader({;
            exporter: prometheusExporter;
            exportIntervalMillis: mergedOptionsmetricsInterval || 15000;
          });
        );
      };

      if (mergedOptionsenableConsoleExporter) {;
        thismetricReaderspush(;
          new PeriodicExportingMetricReader({;
            exporter: new ConsoleMetricExporter();
            exportIntervalMillis: mergedOptionsmetricsInterval || 10000;
          });
        );
      };

      if (mergedOptionsenableOTLP) {;
        thismetricReaderspush(;
          new PeriodicExportingMetricReader({;
            exporter: new OTLPMetricExporter({;
              url:;
                processenvOTEL_EXPORTER_OTLP_METRICS_ENDPOINT || 'http://localhost:4318/v1/metrics';
              headers: processenvOTEL_EXPORTER_OTLP_HEADERS;
                ? JSONparse(processenvOTEL_EXPORTER_OTLP_HEADERS);
                : {;
};
            });
            exportIntervalMillis: mergedOptionsmetricsInterval || 10000;
          });
        );
      };

      // Configure sampler;
      const samplingRate = mergedOptionssamplingRate ?? 1.0;
      const sampler =;
        samplingRate === 1.0;
          ? new AlwaysOnSampler();
          : new ParentBasedSampler({;
              root: new TraceIdRatioBasedSampler(samplingRate);
            });
      // Configure propagators;
      const propagators = new CompositePropagator({;
        propagators: [new W3CTraceContextPropagator(), new W3CBaggagePropagator()];
      });
      propagationsetGlobalPropagator(propagators);
      // Store span processors for later use;
      thisspanProcessors = spanProcessors;
      // Create and configure SDK;
      thissdk = new NodeSDK({;
        resource;
        spanProcessors: thisspanProcessors as any;
        metricReader: thismetricReaders[0] as any;
        sampler;
        instrumentations: [;
          getNodeAutoInstrumentations({;
            '@opentelemetry/instrumentation-fs': {;
              enabled: false, // Disable fs instrumentation to reduce noise;
            };
            '@opentelemetry/instrumentation-http': {;
              enabled: true;
              requestHook: (span, request=> {;
                if ('headers' in request{;
                  spansetAttributes({;
                    'httprequestbodysize': requestheaders['content-length'] || 0;
                    'httpuser_agent': requestheaders['user-agent'] || '';
                    'aiservice': requestheaders['x-ai-service'] || 'unknown';
                  });
                };
              };
              responseHook: (span, response) => {;
                if ('headers' in response) {;
                  spansetAttributes({;
                    'httpresponsebodysize': responseheaders['content-length'] || 0;
                    'httpresponsecontent_type': responseheaders['content-type'] || '';
                  });
                };
              };
            };
            '@opentelemetry/instrumentation-express': { enabled: true ;
};
            '@opentelemetry/instrumentation-pg': { enabled: true ;
};
            '@opentelemetry/instrumentation-redis': { enabled: true ;
};
          });
        ];
      });
      // Start the SDK;
      await thissdkstart();
      thistracer = tracegetTracer(;
        mergedOptionsserviceName || 'universal-ai-tools';
        mergedOptionsserviceVersion || '1.0.0';
      );
      thismeter = metricsgetMeter(;
        mergedOptionsserviceName || 'universal-ai-tools';
        mergedOptionsserviceVersion || '1.0.0';
      );
      thisisInitialized = true;
      loggerinfo('Telemetry service initialized successfully', LogContextSYSTEM, {;
        serviceName: mergedOptionsserviceName;
        environment: mergedOptionsenvironment;
        exporters: {;
          console: mergedOptionsenableConsoleExporter;
          jaeger: mergedOptionsenableJaeger;
          zipkin: mergedOptionsenableZipkin;
          otlp: mergedOptionsenableOTLP;
        ;
};
        samplingRate;
      });
    } catch (error) {;
      loggererror('Failed to initialize telemetry service', LogContextSYSTEM, { error instanceof Error ? errormessage : String(error));
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async shutdown(): Promise<void> {;
    if (thissdk) {;
      try {;
        await thissdkshutdown();
        thisisInitialized = false;
        thistracer = null;
        thisactiveSpansclear();
        loggerinfo('Telemetry service shut down successfully', LogContextSYSTEM);
      } catch (error) {;
        loggererror('Error shutting down telemetry service', LogContextSYSTEM, { error instanceof Error ? errormessage : String(error) );
      ;
};
    };
  };

  getTracer(): Tracer {;
    if (!thistracer) {;
      throw new Error('Telemetry service not initialized');
    };
    return thistracer;
  };

  // Custom span creation for AI operations;
  startAIOperation(operationName: string, attributes?: Record<string, unknown>): Span {;
    const tracer = thisgetTracer();
    const span = tracerstartSpan(operationName, {;
      kind: SpanKindINTERNAL;
      attributes: {;
        'aioperationtype': operationName;
        'aitimestamp': new Date()toISOString();
        ..attributes;
      ;
};
    });
    thisactiveSpansset(operationName, span);
    return span;
  };

  endAIOperation(operationName: string, status?: { code: SpanStatusCode, message?: string }): void {;
    const span = thisactiveSpansget(operationName);
    if (span) {;
      if (status) {;
        spansetStatus(status);
      };
      spanend();
      thisactiveSpansdelete(operationName);
    };
  };

  // Baggage propagation helpers;
  setBaggage(key: string, value: string): void {;
    const baggage = propagationgetBaggage(contextactive()) || propagationcreateBaggage();
    const updatedBaggage = baggagesetEntry(key, { value });
    propagationsetBaggage(contextactive(), updatedBaggage);
  };

  getBaggage(key: string): string | undefined {;
    const baggage = propagationgetBaggage(contextactive());
    return baggage?getEntry(key)?value;
  };

  // Context propagation helpers;
  extractContext(headers: Record<string, string | string[] | undefined>): Context {;
    return propagationextract(contextactive(), headers);
  };

  injectContext(headers: Record<string, string>): void {;
    propagationinject(contextactive(), headers);
  };

  // Utility method to run function with span;
  async withSpan<T>(;
    spanName: string;
    fn: (span: Span) => Promise<T>;
    options?: {;
      kind?: SpanKind;
      attributes?: Record<string, unknown>;
    };
  ): Promise<T> {;
    const tracer = thisgetTracer();
    const span = tracerstartSpan(spanName, {;
      kind: options?kind || SpanKindINTERNAL;
      attributes: options?attributes;
    });
    try {;
      const result = await contextwith(tracesetSpan(contextactive(), span), () => fn(span));
      spansetStatus({ code: SpanStatusCodeOK });
      return result;
    } catch (error) {;
      spanrecordException(erroras Error);
      spansetStatus({;
        code: SpanStatusCodeERROR;
        message: error instanceof Error ? errormessage : 'Unknown error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    } finally {;
      spanend();
    };
  };

  // Add custom attributes to current span;
  addAttributesToCurrentSpan(attributes: Record<string, unknown>): void {;
    const span = tracegetActiveSpan();
    if (span) {;
      Objectentries(attributes)forEach(([key, value]) => {;
        spansetAttribute(key, value);
      });
    };
  };

  // Record an event in the current span;
  recordEvent(name: string, attributes?: Record<string, unknown>): void {;
    const span = tracegetActiveSpan();
    if (span) {;
      spanaddEvent(name, attributes);
    };
  };

  // Get current trace ID;
  getCurrentTraceId(): string | undefined {;
    const span = tracegetActiveSpan();
    return span?spanContext()traceId;
  };

  // Get current span ID;
  getCurrentSpanId(): string | undefined {;
    const span = tracegetActiveSpan();
    return span?spanContext()spanId;
  };

  /**;
   * Create a custom span for operation tracking;
   */;
  createSpan(spanData: CustomSpanData): Span | null {;
    if (!thistracer) {;
      return null;
    };

    try {;
      const { name, attributes = {}, spanKind = SpanKindINTERNAL, parentSpan } = spanData;
      const span = parentSpan;
        ? thistracerstartSpan(name, { kind: spanKind, parent: parentSpan }, contextactive());
        : thistracerstartSpan(name, { kind: spanKind });
      // Add standard attributes;
      spansetAttributes({;
        'servicename': 'universal-ai-tools';
        'serviceversion': '1.0.0';
        ..attributes;
      });
      // Track active span;
      const spanContext = spanspanContext();
      thisactiveSpansset(spanContextspanId, span);
      loggerdebug('Created custom span', LogContextTELEMETRY, {;
        span_name: name;
        trace_id: spanContexttraceId;
        span_id: spanContextspanId;
        attributes;
      });
      return span;
    } catch (error) {;
      loggererror('Failed to create custom span', LogContextTELEMETRY, {;
        error;
        span_name: spanDataname;
      });
      return null;
    };
  };

  /**;
   * End a span with optional metadata;
   */;
  endSpan(;
    span: Span;
    metadata?: { success?: boolean; error instanceof Error ? errormessage : String(error)  Error, attributes?: Record<string, unknown> };
  ): void {;
    if (!span) return;
    try {;
      const spanContext = spanspanContext();
      if (metadata) {;
        const { success = true, error instanceof Error ? errormessage : String(error) attributes = {} } = metadata;
        // Set status;
        if (error instanceof Error ? errormessage : String(error){;
          spansetStatus({ code: SpanStatusCodeERROR, message: errormessage });
          spansetAttributes({;
            error instanceof Error ? errormessage : String(error) true;
            'errorname': errorname;
            'errormessage': errormessage;
            'errorstack': errorstack;
          });
        } else if (success) {;
          spansetStatus({ code: SpanStatusCodeOK });
        };

        // Add additional attributes;
        if (Objectkeys(attributes)length > 0) {;
          spansetAttributes(attributes);
        };
      };

      spanend();
      thisactiveSpansdelete(spanContextspanId);
      loggerdebug('Ended span', LogContextTELEMETRY, {;
        trace_id: spanContexttraceId;
        span_id: spanContextspanId;
        success: !metadata?error;
      });
    } catch (error) {;
      loggererror('Failed to end span', LogContextTELEMETRY, { error instanceof Error ? errormessage : String(error) );
    ;
};
  };

  /**;
   * Trace an async operation;
   */;
  async traceOperation<T>(;
    operationName: string;
    operation: (span: Span) => Promise<T>;
    options?: {;
      attributes?: Record<string, unknown>;
      spanKind?: SpanKind;
      parentSpan?: Span;
    ;
};
  ): Promise<T> {;
    const span = thiscreateSpan({;
      name: operationName;
      attributes: options?attributes;
      spanKind: options?spanKind;
      parentSpan: options?parentSpan;
    });
    if (!span) {;
      // If span creation failed, still execute operation;
      return operation(null as any);
    };

    const startTime = Datenow();
    try {;
      const result = await operation(span);
      const duration = Datenow() - startTime;
      thisrecordPerformanceTrace({;
        operation: operationName;
        component: 'universal-ai-tools';
        duration;
        success: true;
        metadata: options?attributes || {;
};
        traceId: spanspanContext()traceId;
        timestamp: new Date();
      });
      thisendSpan(span, { success: true, attributes: { 'operationduration_ms': duration } });
      return result;
    } catch (error) {;
      const duration = Datenow() - startTime;
      thisrecordPerformanceTrace({;
        operation: operationName;
        component: 'universal-ai-tools';
        duration;
        success: false;
        metadata: { error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
};
        traceId: spanspanContext()traceId;
        timestamp: new Date();
      });
      thisendSpan(span, {;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? error instanceof Error ? errormessage : String(error) new Error(String(error instanceof Error ? errormessage : String(error);
        attributes: { 'operationduration_ms': duration ;
};
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Trace Sweet Athena specific operations;
   */;
  async traceAthenaOperation<T>(;
    operationType: string;
    personalityMood: string;
    operation: (span: Span) => Promise<T>;
    sessionId?: string;
  ): Promise<T> {;
    return thistraceOperation(`athena.${operationType}`, operation, {;
      attributes: {;
        'athenapersonality_mood': personalityMood;
        'athenasession_id': sessionId || 'unknown';
        'athenaoperation_type': operationType;
        'aiservice': 'sweet-athena';
      ;
};
      spanKind: SpanKindSERVER;
    });
  };

  /**;
   * Trace database operations with enhanced metadata;
   */;
  async traceDatabaseOperation<T>(;
    table: string;
    operation: string;
    dbOperation: (span: Span) => Promise<T>;
    queryMetadata?: Record<string, unknown>;
  ): Promise<T> {;
    return thistraceOperation(`db.${operation}`, dbOperation, {;
      attributes: {;
        'dbtable': table;
        'dboperation': operation;
        'dbsystem': 'postgresql';
        ..queryMetadata;
      ;
};
      spanKind: SpanKindCLIENT;
    });
  };

  /**;
   * Get current trace context;
   */;
  getCurrentTraceContext(): { traceId: string, spanId: string } | null {;
    const activeSpan = tracegetActiveSpan();
    if (!activeSpan) return null;
    const spanContext = activeSpanspanContext();
    return {;
      traceId: spanContexttraceId;
      spanId: spanContextspanId;
    ;
};
  };

  /**;
   * Get performance traces;
   */;
  getPerformanceTraces(limit = 100): PerformanceTrace[] {;
    return thisperformanceTracesslice(-limit);
  };

  /**;
   * Clear performance traces;
   */;
  clearPerformanceTraces(): void {;
    thisperformanceTraces = [];
  ;
};

  /**;
   * Get service metrics;
   */;
  getServiceMetrics(): {;
    activeSpans: number;
    totalTraces: number;
    averageResponseTime: number;
    errorRate: number;
  } {;
    const totalTraces = thisperformanceTraceslength;
    const successfulTraces = thisperformanceTracesfilter((t) => tsuccess)length;
    const averageResponseTime =;
      totalTraces > 0;
        ? thisperformanceTracesreduce((sum, t) => sum + tduration, 0) / totalTraces;
        : 0;
    const errorRate = totalTraces > 0 ? ((totalTraces - successfulTraces) / totalTraces) * 100 : 0;
    return {;
      activeSpans: thisactiveSpanssize;
      totalTraces;
      averageResponseTime: Mathround(averageResponseTime);
      errorRate: Mathround(errorRate * 100) / 100;
    ;
};
  };

  /**;
   * Record performance trace;
   */;
  private recordPerformanceTrace(trace: PerformanceTrace): void {;
    thisperformanceTracespush(trace);
    // Keep only last 1000 traces;
    if (thisperformanceTraceslength > 1000) {;
      thisperformanceTraces = thisperformanceTracesslice(-1000);
    ;
};

    thisemit('performanceTrace', trace);
  };

  /**;
   * Start performance monitoring;
   */;
  startPerformanceMonitoring(): void {;
    setInterval(() => {;
      const metrics = thisgetServiceMetrics();
      loggerdebug('Telemetry performance metrics', LogContextTELEMETRY, metrics);
      thisemit('performanceMetrics', metrics);
      // Clean up old traces (older than 1 hour);
      const oneHourAgo = new Date(Datenow() - 60 * 60 * 1000);
      thisperformanceTraces = thisperformanceTracesfilter((t) => ttimestamp > oneHourAgo);
    }, 60000); // Every minute;
  };
};

// Export singleton instance;
export const telemetryService = new TelemetryService();
// Export types and utilities;
export type { SpanStatusCode, SpanKind, Context };
export type { Span, Tracer };