import { WebSocket } from 'ws';
import { EventEmitter } from 'events';
import { LogContext, logger } from '../utils/enhanced-logger';
import type { AgentPerformanceTracker } from './agent-performance-tracker';
import type { SwarmOrchestrator } from './swarm-orchestrator';
interface WebSocketMessage {;
  type: string;
  data?: any;
  error instanceof Error ? errormessage : String(error)  string;
;
};

export class AgentPerformanceWebSocket extends EventEmitter {;
  private clients: Set<WebSocket> = new Set();
  private performanceTracker?: AgentPerformanceTracker;
  private swarmOrchestrator?: SwarmOrchestrator;
  constructor() {;
    super();
  };

  // Initialize with existing services;
  initialize(swarmOrchestrator: SwarmOrchestrator): void {;
    thisswarmOrchestrator = swarmOrchestrator;
    // Listen to performance events from SwarmOrchestrator;
    if (thisswarmOrchestrator) {;
      thisswarmOrchestratoron('performance:taskStarted', (data) => {;
        thisbroadcast({;
          type: 'performance:taskStarted';
          data;
        });
      });
      thisswarmOrchestratoron('performance:taskCompleted', (data) => {;
        thisbroadcast({;
          type: 'performance:taskCompleted';
          data;
        });
      });
      thisswarmOrchestratoron('performance:metricRecorded', (data) => {;
        thisbroadcast({;
          type: 'performance:metricRecorded';
          data;
        });
      });
      // Listen to general swarm events;
      thisswarmOrchestratoron('task:assigned', (data) => {;
        thisbroadcast({;
          type: 'task:assigned';
          data;
        });
      });
      thisswarmOrchestratoron('task:progress', (data) => {;
        thisbroadcast({;
          type: 'task:progress';
          data;
        });
      });
      thisswarmOrchestratoron('task:completed', (data) => {;
        thisbroadcast({;
          type: 'task:completed';
          data;
        });
      });
      thisswarmOrchestratoron('agent:status', (data) => {;
        thisbroadcast({;
          type: 'agent:status';
          data;
        });
      });
      thisswarmOrchestratoron('metrics:updated', (data) => {;
        thisbroadcast({;
          type: 'metrics:updated';
          data;
        });
      });
    };

    loggerinfo('Agent Performance WebSocket initialized', LogContextWEBSOCKET);
  };

  // Handle new WebSocket connection;
  handleConnection(ws: WebSocket, req: any): void {;
    loggerinfo('New WebSocket client connected for agent performance', LogContextWEBSOCKET);
    thisclientsadd(ws);
    // Send welcome message;
    thissendMessage(ws, {;
      type: 'welcome';
      data: {;
        message: 'Connected to Agent Performance Tracker';
        timestamp: new Date()toISOString();
      ;
};
    });
    // Handle messages from client;
    wson('message', (message: string) => {;
      try {;
        const data = JSONparse(message);
        thishandleClientMessage(ws, data);
      } catch (error) {;
        thissendError(ws, 'Invalid message format');
      };
    });
    // Handle client disconnect;
    wson('close', () => {;
      thisclientsdelete(ws);
      loggerinfo('WebSocket client disconnected', LogContextWEBSOCKET);
    });
    // Handle errors;
    wson('error instanceof Error ? errormessage : String(error)  (error instanceof Error ? errormessage : String(error)=> {';
      loggererror('WebSocket error instanceof Error ? errormessage : String(error)  LogContextWEBSOCKET, { error instanceof Error ? errormessage : String(error));
      thisclientsdelete(ws);
    });
  };

  // Handle messages from clients;
  private async handleClientMessage(ws: WebSocket, message: WebSocketMessage): Promise<void> {;
    try {;
      switch (messagetype) {;
        case 'getAgentMetrics':;
          if (thisswarmOrchestrator) {;
            const metrics = await thisswarmOrchestratorgetAgentPerformanceMetrics(;
              messagedata?agentId;
            );
            thissendMessage(ws, {;
              type: 'agentMetrics';
              data: metrics;
            });
          };
          break;
        case 'getPerformanceTrends':;
          if (thisswarmOrchestrator && messagedata?agentId) {;
            const trends = await thisswarmOrchestratorgetPerformanceTrends(;
              messagedataagentId;
              messagedataperiod || 'day';
              messagedatalookback || 7;
            );
            thissendMessage(ws, {;
              type: 'performanceTrends';
              data: trends;
            });
          };
          break;
        case 'getSwarmMetrics':;
          if (thisswarmOrchestrator) {;
            const metrics = await thisswarmOrchestratorgetMetrics();
            thissendMessage(ws, {;
              type: 'swarmMetrics';
              data: metrics;
            });
          };
          break;
        case 'getProgressReport':;
          if (thisswarmOrchestrator) {;
            const report = await thisswarmOrchestratorgetProgressReport();
            thissendMessage(ws, {;
              type: 'progressReport';
              data: { report ;
};
            });
          };
          break;
        case 'ping':;
          thissendMessage(ws, {;
            type: 'pong';
            data: { timestamp: new Date()toISOString() ;
};
          });
          break;
        default:;
          thissendError(ws, `Unknown message type: ${messagetype}`);
      };
    } catch (error) {;
      loggererror('Error handling client message', LogContextWEBSOCKET, { error instanceof Error ? errormessage : String(error) message });
      thissendError(ws, 'Failed to process message');
    };
  };

  // Send message to a specific client;
  private sendMessage(ws: WebSocket, message: WebSocketMessage): void {;
    if (wsreadyState === WebSocketOPEN) {;
      wssend(JSONstringify(message));
    ;
};
  };

  // Send errorto a specific client;
  private sendError(ws: WebSocket, error instanceof Error ? errormessage : String(error) string): void {;
    thissendMessage(ws, {;
      type: 'error instanceof Error ? errormessage : String(error);
      error;
    });
  };

  // Broadcast message to all connected clients;
  private broadcast(message: WebSocketMessage): void {;
    const messageStr = JSONstringify(message);
    thisclientsforEach((client) => {;
      if (clientreadyState === WebSocketOPEN) {;
        clientsend(messageStr);
      };
    });
  };

  // Get number of connected clients;
  getClientCount(): number {;
    return thisclientssize;
  };

  // Cleanup;
  destroy(): void {;
    // Close all client connections;
    thisclientsforEach((client) => {;
      if (clientreadyState === WebSocketOPEN) {;
        clientclose(1000, 'Server shutting down');
      };
    });
    thisclientsclear();
    thisremoveAllListeners();
  };
};

// Export singleton instance;
export const agentPerformanceWebSocket = new AgentPerformanceWebSocket();