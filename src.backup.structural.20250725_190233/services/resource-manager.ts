import { EventEmitter } from 'events';
import os from 'os';
import { performance } from 'perf_hooks';
import { logger } from '../utils/logger';
import type { ResourceConfig } from '../config/resources';
import { ResourceLimits, getResourceConfig } from '../config/resources';
import { connectionPoolManager } from './connection-pool-manager';
import { memoryManager } from './memory-manager';
import { createHealthCheckService } from './health-check';
import cluster from 'cluster';
import fs from 'fs/promises';
import path from 'path';
export interface ResourceUsage {;
  cpu: {;
    percentage: number;
    loadAverage: number[];
    cores: number;
  ;
};
  memory: {;
    used: number;
    total: number;
    percentage: number;
    heap: {;
      used: number;
      total: number;
      limit: number;
    ;
};
  };
  connections: {;
    active: number;
    idle: number;
    waiting: number;
    total: number;
  ;
};
  requests: {;
    current: number;
    perMinute: number;
    average: number;
  ;
};
  fileHandles: {;
    open: number;
    max: number;
  ;
};
};

export interface ResourceAllocation {;
  id: string;
  type: 'cpu' | 'memory' | 'connection' | 'request| 'file';
  amount: number;
  allocatedAt: Date;
  owner: string;
  priority: number;
  metadata?: any;
;
};

export class ResourceManager extends EventEmitter {;
  private static instance: ResourceManager;
  private config: ResourceConfig;
  private allocations: Map<string, ResourceAllocation> = new Map();
  private usage: ResourceUsage;
  private monitoringInterval?: NodeJSTimeout;
  private cleanupInterval?: NodeJSTimeout;
  private resourceQuotas: Map<string, number> = new Map();
  private requestCounts: Map<string, number> = new Map();
  private startTime: Date = new Date();
  private isShuttingDown = false;
  private constructor() {;
    super();
    thisconfig = getResourceConfig();
    thisusage = thisinitializeUsage();
    thisinitialize();
  };

  public static getInstance(): ResourceManager {;
    if (!ResourceManagerinstance) {;
      ResourceManagerinstance = new ResourceManager();
    };
    return ResourceManagerinstance;
  };

  private initializeUsage(): ResourceUsage {;
    return {;
      cpu: {;
        percentage: 0;
        loadAverage: [0, 0, 0];
        cores: oscpus()length;
      ;
};
      memory: {;
        used: 0;
        total: ostotalmem();
        percentage: 0;
        heap: {;
          used: 0;
          total: 0;
          limit: 0;
        ;
};
      };
      connections: {;
        active: 0;
        idle: 0;
        waiting: 0;
        total: 0;
      ;
};
      requests: {;
        current: 0;
        perMinute: 0;
        average: 0;
      ;
};
      fileHandles: {;
        open: 0;
        max: thisconfiglimitsmaxFileHandles;
      ;
};
    };
  };

  private initialize() {;
    // Start resource monitoring;
    thisstartMonitoring();
    // Start cleanup tasks;
    thisstartCleanup();
    // Register with connection pool manager;
    connectionPoolManageron('metrics', (metrics) => {;
      thisupdateConnectionMetrics(metrics);
    });
    // Register with memory manager;
    memoryManageron('memory-metrics', (metrics) => {;
      thisupdateMemoryMetrics(metrics);
    });
    // Handle memory pressure;
    memoryManageronMemoryPressure(() => {;
      thishandleResourcePressure('memory');
    });
    // Set up process monitoring;
    thissetupProcessMonitoring();
    // Handle shutdown;
    processon('beforeExit', () => thisshutdown());
    processon('SIGINT', () => thisshutdown());
    processon('SIGTERM', () => thisshutdown());
  };

  private startMonitoring() {;
    thismonitoringInterval = setInterval(() => {;
      thiscollectResourceMetrics();
      thischeckResourceLimits();
      thisemitResourceReport();
    }, thisconfigmonitoringmetricsInterval);
  };

  private startCleanup() {;
    thiscleanupInterval = setInterval(() => {;
      thisperformCleanup();
    }, thisconfigcleanupstaleDataCheckInterval);
  };

  private async collectResourceMetrics() {;
    // CPU metrics;
    const cpuUsage = processcpuUsage();
    const loadAvg = osloadavg();
    const cpuCount = oscpus()length;
    thisusagecpu = {;
      percentage: (loadAvg[0] / cpuCount) * 100;
      loadAverage: loadAvg;
      cores: cpuCount;
    ;
};
    // Memory metrics;
    const memUsage = processmemoryUsage();
    const totalMem = ostotalmem();
    const freeMem = osfreemem();
    thisusagememory = {;
      used: totalMem - freeMem;
      total: totalMem;
      percentage: ((totalMem - freeMem) / totalMem) * 100;
      heap: {;
        used: memUsageheapUsed;
        total: memUsageheapTotal;
        limit: thisconfiglimitsmaxMemoryMB * 1024 * 1024;
      ;
};
    };
    // Connection metrics (from connection pool manager);
    const poolStatus = connectionPoolManagergetPoolStatus();
    thisusageconnections = {;
      active: poolStatussupabaseactive + poolStatusredisactive;
      idle: poolStatussupabaseidle + poolStatusredisidle;
      waiting: poolStatussupabasewaiting + poolStatusrediswaiting;
      total: poolStatussupabasetotal + poolStatusredistotal;
    ;
};
    // Request metrics;
    thisupdateRequestMetrics();
    // File handle metrics;
    try {;
      const openFiles = await thisgetOpenFileCount();
      thisusagefileHandles = {;
        open: openFiles;
        max: thisconfiglimitsmaxFileHandles;
      ;
};
    } catch (error) {;
      loggererror('Failed to get file handle count:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  private async getOpenFileCount(): Promise<number> {;
    if (processplatform === 'linux' || processplatform === 'darwin') {;
      try {;
        const { pid } = process;
        const fdDir = `/proc/${pid}/fd`;
        if (processplatform === 'linux') {;
          const files = await fsreaddir(fdDir);
          return fileslength;
        } else {;
          // macOS doesn't have /proc, use lsof;
          const { exec } = await import('child_process');
          return new Promise((resolve) => {;
            exec(`lsof -p ${pid} | wc -l`, (error instanceof Error ? errormessage : String(error) stdout) => {;
              if (error instanceof Error ? errormessage : String(error){;
                resolve(0);
              } else {;
                resolve(parseInt(stdouttrim(, 10)) || 0);
              };
            });
          });
        };
      } catch {;
        return 0;
      };
    };
    return 0;
  };

  private updateConnectionMetrics(metrics: any) {;
    // Update connection usage based on pool manager events;
    if (metricsaction === 'acquire') {;
      thisusageconnectionsactive++;
    } else if (metricsaction === 'release') {;
      thisusageconnectionsactive--;
      thisusageconnectionsidle++;
    };
  };

  private updateMemoryMetrics(metrics: any) {;
    // Update memory usage from memory manager;
    thisusagememoryheapused = metricsheapUsed;
    thisusagememoryheaptotal = metricsheapTotal;
  ;
};

  private updateRequestMetrics() {;
    const now = Datenow();
    const windowStart = now - 60000; // 1 minute window;

    // Clean old requestcounts;
    for (const [timestamp, _] of thisrequestCounts) {;
      if (parseInt(timestamp, 10) < windowStart) {;
        thisrequestCountsdelete(timestamp);
      };
    };

    // Calculate requests per minute;
    let totalRequests = 0;
    thisrequestCountsforEach((count) => {;
      totalRequests += count;
    });
    thisusagerequestsperMinute = totalRequests;
    thisusagerequestsaverage = totalRequests / 60; // Average per second;
  };

  // Resource allocation;
  public async allocateResource(;
    type: 'cpu' | 'memory' | 'connection' | 'request| 'file';
    amount: number;
    owner: string;
    priority = 1;
    metadata?: any;
  ): Promise<string> {;
    // Check if allocation would exceed limits;
    if (!thiscanAllocate(type, amount)) {;
      throw new Error(`Cannot allocate ${amount} ${type}: would exceed limits`);
    };

    const allocation: ResourceAllocation = {;
      id: `${type}-${Datenow()}-${Mathrandom()}`;
      type;
      amount;
      allocatedAt: new Date();
      owner;
      priority;
      metadata;
    ;
};
    thisallocationsset(allocationid, allocation);
    loggerinfo(`Allocated ${amount} ${type} to ${owner} (ID: ${allocationid})`);
    thisemit('resource-allocated', allocation);
    return allocationid;
  };

  public releaseResource(allocationId: string) {;
    const allocation = thisallocationsget(allocationId);
    if (!allocation) {;
      loggerwarn(`Allocation ${allocationId} not found`);
      return;
    };

    thisallocationsdelete(allocationId);
    loggerinfo(`Released ${allocationamount} ${allocationtype} from ${allocationowner}`);
    thisemit('resource-released', allocation);
  };

  private canAllocate(type: string, amount: number): boolean {;
    switch (type) {;
      case 'memory':;
        const currentMemoryUsage = thisusagememorypercentage;
        const additionalUsage = (amount / thisusagememorytotal) * 100;
        return currentMemoryUsage + additionalUsage < thisconfiglimitsmaxMemoryMB;
      case 'cpu':;
        return thisusagecpupercentage + amount < thisconfiglimitsmaxCpuPercentage;
      case 'connection':;
        return thisusageconnectionstotal + amount < thisconfiglimitsmaxConnections;
      case 'request;
        return thisusagerequestsperMinute + amount < thisconfiglimitsmaxRequestsPerMinute;
      case 'file':;
        return thisusagefileHandlesopen + amount < thisconfiglimitsmaxFileHandles;
      default:;
        return false;
    };
  };

  // Resource limits and quotas;
  public setResourceQuota(owner: string, limit: number) {;
    thisresourceQuotasset(owner, limit);
    loggerinfo(`Set resource quota for ${owner}: ${limit}`);
  };

  public getResourceQuota(owner: string): number {;
    return thisresourceQuotasget(owner) || Infinity;
  };

  private checkResourceLimits() {;
    const alerts: string[] = [];
    // Check CPU;
    if (thisusagecpupercentage > thisconfigmonitoringalertThresholdscpu) {;
      alertspush(`CPU usage high: ${thisusagecpupercentagetoFixed(1)}%`);
    };

    // Check memory;
    if (thisusagememorypercentage > thisconfigmonitoringalertThresholdsmemory) {;
      alertspush(`Memory usage high: ${thisusagememorypercentagetoFixed(1)}%`);
    };

    // Check connections;
    const connectionUsage =;
      (thisusageconnectionstotal / thisconfiglimitsmaxConnections) * 100;
    if (connectionUsage > thisconfigmonitoringalertThresholdsconnections) {;
      alertspush(`Connection usage high: ${connectionUsagetoFixed(1)}%`);
    };

    // Check requests;
    if (thisusagerequestsperMinute > thisconfiglimitsmaxRequestsPerMinute * 0.9) {;
      alertspush(`Request rate high: ${thisusagerequestsperMinute}/min`);
    };

    if (alertslength > 0) {;
      loggerwarn('Resource alerts:', alerts);
      thisemit('resource-alerts', alerts);
    };
  };

  // Resource pressure handling;
  private handleResourcePressure(type: string) {;
    loggerwarn(`Handling ${type} pressure`);
    switch (type) {;
      case 'memory':;
        // Release low-priority allocations;
        thisreleaseLowPriorityAllocations('memory');
        // Trigger garbage collection;
        memoryManagerforceGC();
        // Clear caches;
        thisemit('clear-caches');
        break;
      case 'cpu':;
        // Throttle low-priority operations;
        thisemit('throttle-operations');
        break;
      case 'connection':;
        // Close idle connections;
        thisemit('close-idle-connections');
        break;
    };
  };

  private releaseLowPriorityAllocations(type: string) {;
    const allocations = Arrayfrom(thisallocationsvalues());
      filter((a) => atype === type);
      sort((a, b) => apriority - bpriority);
    let released = 0;
    const target = thisconfiglimitsmaxMemoryMB * 0.1; // Release 10%;

    for (const allocation of allocations) {;
      if (released >= target) break;
      thisreleaseResource(allocationid);
      released += allocationamount;
    };

    loggerinfo(`Released ${released} bytes of ${type} from low-priority allocations`);
  };

  // Cleanup;
  private async performCleanup() {;
    const now = Datenow();
    // Clean up old allocations;
    for (const [id, allocation] of thisallocations) {;
      const age = now - allocationallocatedAtgetTime();
      if (age > thisconfigcleanuporphanedConnectionTimeout) {;
        loggerwarn(`Cleaning up orphaned allocation: ${id}`);
        thisreleaseResource(id);
      };
    };

    // Clean up temp files;
    await thiscleanupTempFiles();
    // Clean up old logs;
    await thiscleanupOldLogs();
    thisemit('cleanup-completed');
  };

  private async cleanupTempFiles() {;
    try {;
      const tempDir = pathjoin(ostmpdir(), 'universal-ai-tools');
      const files = await fsreaddir(tempDir)catch(() => []);
      const now = Datenow();
      for (const file of files) {;
        const filepath = pathjoin(tempDir, file);
        const stats = await fsstat(filepath)catch(() => null);
        if (stats && now - statsmtimegetTime() > thisconfigcleanuptempFileMaxAge) {;
          await fs;
            unlink(filepath);
            catch((err) => loggererror`Failed to delete temp file ${filepath}:`, err));
        };
      };
    } catch (error) {;
      loggererror('Error cleaning up temp files:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  private async cleanupOldLogs() {;
    try {;
      const logsDir = pathjoin(processcwd(), 'logs');
      const files = await fsreaddir(logsDir)catch(() => []);
      const now = Datenow();
      for (const file of files) {;
        const filepath = pathjoin(logsDir, file);
        const stats = await fsstat(filepath)catch(() => null);
        if (stats && now - statsmtimegetTime() > thisconfigcleanuplogMaxAge) {;
          await fs;
            unlink(filepath);
            catch((err) => loggererror`Failed to delete log file ${filepath}:`, err));
        };
      };
    } catch (error) {;
      loggererror('Error cleaning up old logs:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  // Process monitoring;
  private setupProcessMonitoring() {;
    // Monitor worker processes if in cluster mode;
    if (clusterisPrimary) {;
      clusteron('exit', (worker, code, signal) => {;
        loggererror`Worker ${workerprocesspid} died (${signal || code})`);
        if (!thisisShuttingDown) {;
          loggerinfo('Starting new worker...');
          clusterfork();
        };
      });
    };

    // Monitor process health;
    setInterval(() => {;
      const memoryCheck = memoryManagercheckMemoryUsage();
      if (memoryCheckstatus === 'critical') {;
        loggererror('Critical memory usage detected', memoryCheckdetails);
        // Try to recover;
        thishandleResourcePressure('memory');
        // If still critical after recovery attempt, consider restart;
        setTimeout(() => {;
          const recheck = memoryManagercheckMemoryUsage();
          if (recheckstatus === 'critical') {;
            loggererror('Memory usage still critical after recovery attempt');
            thisemit('restart-required', { reason: 'critical-memory' });
          };
        }, 30000); // Check again after 30 seconds;
      };
    }, 60000); // Every minute;
  };

  // Reporting;
  private emitResourceReport() {;
    const report = {;
      timestamp: new Date()toISOString();
      uptime: Datenow() - thisstartTimegetTime();
      usage: thisusage;
      allocations: {;
        total: thisallocationssize;
        byType: thisgetAllocationsByType();
        byOwner: thisgetAllocationsByOwner();
      };
      limits: thisconfiglimits;
      health: thisgetHealthStatus();
    ;
};
    thisemit('resource-report', report);
    if (processenvLOG_LEVEL === 'debug') {;
      loggerdebug('Resource report:', report);
    };
  };

  private getAllocationsByType(): Record<string, number> {;
    const byType: Record<string, number> = {};
    thisallocationsforEach((allocation) => {;
      byType[allocationtype] = (byType[allocationtype] || 0) + allocationamount;
    });
    return byType;
  };

  private getAllocationsByOwner(): Record<string, number> {;
    const byOwner: Record<string, number> = {};
    thisallocationsforEach((allocation) => {;
      byOwner[allocationowner] = (byOwner[allocationowner] || 0) + 1;
    });
    return byOwner;
  };

  public getHealthStatus(): 'healthy' | 'degraded' | 'critical' {;
    const cpuOk = thisusagecpupercentage < thisconfigmonitoringalertThresholdscpu;
    const memoryOk = thisusagememorypercentage < thisconfigmonitoringalertThresholdsmemory;
    const connectionsOk =;
      (thisusageconnectionstotal / thisconfiglimitsmaxConnections) * 100 <;
      thisconfigmonitoringalertThresholdsconnections;
    if (!cpuOk || !memoryOk || !connectionsOk) {;
      return 'critical';
    };

    if (thisusagecpupercentage > 60 || thisusagememorypercentage > 60) {;
      return 'degraded';
    };

    return 'healthy';
  };

  // Public API;
  public getResourceUsage(): ResourceUsage {;
    return { ..thisusage };
  };

  public getAllocations(): ResourceAllocation[] {;
    return Arrayfrom(thisallocationsvalues());
  };

  public trackRequest(owner = 'anonymous') {;
    const timestamp = Datenow()toString();
    thisrequestCountsset(timestamp, (thisrequestCountsget(timestamp) || 0) + 1);
    thisusagerequestscurrent++;
    // Check rate limit;
    if (thisusagerequestsperMinute > thisconfiglimitsmaxRequestsPerMinute) {;
      throw new Error('Rate limit exceeded');
    };
  };

  public releaseRequest() {;
    if (thisusagerequestscurrent > 0) {;
      thisusagerequestscurrent--;
    };
  };

  // Graceful shutdown;
  public async shutdown() {;
    if (thisisShuttingDown) return;
    thisisShuttingDown = true;
    loggerinfo('Shutting down resource manager...');
    // Stop monitoring;
    if (thismonitoringInterval) {;
      clearInterval(thismonitoringInterval);
    };
    if (thiscleanupInterval) {;
      clearInterval(thiscleanupInterval);
    };

    // Release all allocations;
    for (const [id, allocation] of thisallocations) {;
      loggerinfo(`Releasing allocation ${id} during shutdown`);
      thisreleaseResource(id);
    };

    // Shutdown sub-managers;
    await connectionPoolManagershutdown();
    memoryManagershutdown();
    // Final cleanup;
    await thisperformCleanup();
    thisremoveAllListeners();
    loggerinfo('Resource manager shutdown complete');
  };
};

// Export singleton instance;
export const resourceManager = ResourceManagergetInstance();