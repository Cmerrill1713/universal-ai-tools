import { type DSPyBridge, dspyBridge } from './dspy-orchestrator/bridge';
import { LogContext, logger } from '../utils/enhanced-logger';
import { v4 as uuidv4 } from 'uuid';
import { TIME_1000MS } from "../utils/common-constants";
import type { SupabaseClient } from '@supabase/supabase-js';
import { EnhancedMemorySystem } from '../memory/enhanced_memory_system';
import { agentCollaborationWS } from './agent-collaboration-websocket';
export interface DSPyOrchestrationRequest {;
  requestId: string;
  userRequest: string;
  userId: string;
  orchestrationMode?: 'simple' | 'standard' | 'cognitive' | 'adaptive';
  context?: Record<string, unknown>;
  timestamp: Date;
};

export interface DSPyOrchestrationResponse {;
  requestId: string;
  success: boolean;
  mode: string;
  result: any;
  complexity?: number;
  confidence?: number;
  reasoning?: string;
  participatingAgents?: string[];
  executionTime: number;
  error?: string;
};

export class DSPyService {;
  private bridge: DSPyBridge;
  private isInitialized = false;
  private memorySystem: EnhancedMemorySystem | null = null;
  constructor(supabase?: SupabaseClient) {;
    thisbridge = dspyBridge;
    // Initialize memory system if supabase is provided;
    if (supabase) {;
      thismemorySystem = new EnhancedMemorySystem(supabase, logger)};
    ;
    // Don't block on initialization - let it happen in the background;
    thisinitialize()catch((error) => {;
      loggererror('DSPy service initialization failed:', LogContextDSPY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
    });
  };

  private async initialize(): Promise<void> {;
    try {;
      loggerinfo('ðŸš€ Initializing DSPy service...');
      // Wait for bridge to connect (with short timeout to not block server startup);
      if (processenvENABLE_DSPY_MOCK === 'true') {;
        await thiswaitForConnection(5000)} else {;
        loggerinfo('DSPy mock disabled - skipping connection wait')};

      thisisInitialized = true;
      loggerinfo('âœ… DSPy service initialized successfully');
    } catch (error) {;
      loggerwarn(;
        'DSPy service initialization failed (will retry on first use)';
        LogContextSYSTEM;
        { error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error) ;
};
      );
      // Don't throw - let server continue without DSPy;
      thisisInitialized = false;
    };
  };

  private async waitForConnection(timeout = 30000): Promise<void> {;
    const startTime = Datenow();
    while (!thisbridgegetStatus()connected) {;
      if (Datenow() - startTime > timeout) {;
        throw new Error('DSPy connection timeout')};
      await new Promise((resolve) => setTimeout(resolve, TIME_1000MS));
    };
  };

  /**;
   * Main orchestration method that replaces the old enhanced orchestrator;
   */;
  async orchestrate(request: DSPyOrchestrationRequest): Promise<DSPyOrchestrationResponse> {;
    const startTime = Datenow();
    try {;
      if (!thisisInitialized) {;
        await thiswaitForConnection()};

      loggerinfo(`ðŸŽ¯ DSPy orchestration for request ${requestrequestId}`);
      // Notify UI about orchestration start;
      agentCollaborationWSupdateAgentStatus({;
        agentId: 'orchestrator';
        agentName: 'Orchestrator';
        status: 'thinking';
        currentTask: 'Analyzing user request';
        timestamp: new Date();
        metadata: {;
          participatingIn: requestrequestId}});
      // Call DSPy orchestrator;
      const result = await thisbridgeorchestrate(requestuserRequest, {;
        userId: requestuserId;
        mode: requestorchestrationMode;
        ..requestcontext});
      const executionTime = Datenow() - startTime;
      // Extract relevant information from DSPy result;
      const response: DSPyOrchestrationResponse = {;
        requestId: requestrequestId;
        success: true;
        mode: resultorchestration_mode || 'standard';
        result: resultconsensus || result;
        complexity: resultcomplexity;
        confidence: resultconfidence;
        reasoning: resultcoordination_plan || resultreasoning;
        participatingAgents: resultselected_agents;
          ? resultselected_agentssplit(',')map((a: string) => atrim());
          : [];
        executionTime};
      loggerinfo(`âœ… DSPy orchestration completed in ${executionTime}ms`);
      // Update orchestrator status and notify about participating agents;
      if (responseparticipatingAgents && responseparticipatingAgentslength > 0) {;
        agentCollaborationWSstartCollaboration(requestrequestId, responseparticipatingAgents);
        ;
        // Update orchestrator to working status;
        agentCollaborationWSupdateAgentStatus({;
          agentId: 'orchestrator';
          agentName: 'Orchestrator';
          status: 'working';
          currentTask: 'Coordinating agents';
          progress: 50;
          timestamp: new Date();
          metadata: {;
            participatingIn: requestrequestId;
            confidence: responseconfidence}});
      };
      ;
      // Store orchestration details in memory if available;
      if (thismemorySystem && responsesuccess) {;
        try {;
          await thismemorySystemstoreMemory(;
            'dspy-orchestrator';
            'orchestration';
            `Orchestration: ${requestuserRequest} -> ${JSONstringify(responseresult)}`;
            {;
              requestId: requestrequestId;
              userId: requestuserId;
              orchestrationMode: responsemode;
              confidence: responseconfidence;
              participatingAgents: responseparticipatingAgents;
              complexity: responsecomplexity;
              executionTime: responseexecutionTime;
              timestamp: requesttimestamp};
            [] // Keywords extracted automatically;
          );
          loggerdebug('DSPy orchestration stored in memory system');
        } catch (memoryError) {;
          // Don't fail orchestration if memory storage fails;
          loggerwarn('Failed to store DSPy orchestration in memory:', memoryError)};
      };
      ;
      // Complete orchestration and notify UI;
      agentCollaborationWScompleteAgentTask('orchestrator', responseresult);
      agentCollaborationWSendCollaboration(requestrequestId, responseresult);
      return response;
    } catch (error) {;
      const executionTime = Datenow() - startTime,;
      loggererror('DSPy orchestration failed:', LogContextDSPY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      return {;
        requestId: requestrequestId;
        success: false;
        mode: 'fallback';
        result: null;
        executionTime;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      ;
};
    };
  };

  /**;
   * Coordinate multiple agents for a specific task;
   */;
  async coordinateAgents(;
    task: string;
    availableAgents: string[];
    context: Record<string, unknown> = {};
  ): Promise<unknown> {;
    try {;
      const result = await thisbridgecoordinateAgents(task, availableAgents, context),;

      return {;
        success: true;
        selectedAgents: resultselected_agents;
        coordinationPlan: resultcoordination_plan;
        assignments: resultagent_assignments || [];
};
    } catch (error) {;
      loggererror('Agent coordination failed:', LogContextDSPY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      throw error;
    };
  };

  /**;
   * Generic request method for DSPy operations;
   */;
  async request(operation: string, params: any = {}): Promise<unknown> {;
    try {;
      switch (operation) {;
        case 'manage_knowledge':;
        case 'optimize_knowledge_modules':;
        case 'get_optimization_metrics':;
          return await thismanageKnowledge(operation, params),;

        case 'orchestrate':;
          return await thisorchestrate({;
            requestId: paramsrequestId || uuidv4();
            userRequest: paramsuserRequest || '';
            userId: paramsuserId || 'system';
            orchestrationMode: paramsmode;
            context: params;
            timestamp: new Date()});
        case 'coordinate_agents':;
          return await thiscoordinateAgents(;
            paramstask || '';
            paramsavailableAgents || [];
            paramscontext || {};
          );
        default:;
          // For unknown operations, try to pass through to DSPy bridge;
          if (thisbridge && typeof (thisbridge as any)[operation] === 'function') {;
            return await (thisbridge as any)[operation](params)};
          throw new Error(`Unknown DSPy operation: ${operation}`);
      };
    } catch (error) {;
      loggererror(`DSPy request failed for operation ${operation}:`, LogContextDSPY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      return {;
        success: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      ;
};
    };
  };

  /**;
   * Manage knowledge operations through DSPy;
   */;
  async manageKnowledge(operation: string, data: any): Promise<unknown> {;
    try {;
      const result = await thisbridgemanageKnowledge(operation, data),;

      return {;
        success: true;
        operation;
        result};
    } catch (error) {;
      loggererror('Knowledge management failed:', LogContextDSPY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      throw error;
    };
  };

  /**;
   * Search knowledge using DSPy's optimized search;
   */;
  async searchKnowledge(query: string, options: any = {}): Promise<unknown> {;
    return thismanageKnowledge('search', { query, ..options });
  };

  /**;
   * Extract structured knowledge from content;
   */;
  async extractKnowledge(content: string, context: any = {}): Promise<unknown> {;
    return thismanageKnowledge('extract', { content: context });
  };

  /**;
   * Evolve existing knowledge with new information;
   */;
  async evolveKnowledge(existingKnowledge: string, newInfo: string): Promise<unknown> {;
    return thismanageKnowledge('evolve', {;
      existing_knowledge: existingKnowledge;
      new_information: newInfo});
  };

  /**;
   * Optimize prompts for better performance;
   */;
  async optimizePrompts(examples: any[]): Promise<unknown> {;
    try {;
      const result = await thisbridgeoptimizePrompts(examples),;

      return {;
        success: true;
        optimized: resultoptimized;
        improvements: resultimprovements;
        performanceGain: resultperformance_gain;
};
    } catch (error) {;
      loggererror('Prompt optimization failed:', LogContextDSPY, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
      throw error;
    };
  };

  /**;
   * Get service status;
   */;
  getStatus(): { initialized: boolean; connected: boolean, queueSize: number } {;
    const bridgeStatus = thisbridgegetStatus(),;

    return {;
      initialized: thisisInitialized;
      connected: bridgeStatusconnected;
      queueSize: bridgeStatusqueueSize;
};
  };

  /**;
   * Shutdown the service gracefully;
   */;
  async shutdown(): Promise<void> {;
    loggerinfo('Shutting down DSPy service...');
    await thisbridgeshutdown();
    thisisInitialized = false;
};
};

// Lazy initialization to prevent blocking during import;
let _dspyService: DSPyService | null = null;
export function getDSPyService(): DSPyService {;
  if (!_dspyService) {;
    _dspyService = new DSPyService()};
  return _dspyService;
};

// For backward compatibility (but prefer using getDSPyService());
export const dspyService = {;
  orchestrate: async (request: DSPyOrchestrationRequest) => getDSPyService()orchestrate(request);
  coordinateAgents: async (;
    task: string;
    availableAgents: string[];
    context: Record<string, unknown> = {};
  ) => getDSPyService()coordinateAgents(task, availableAgents, context);
  searchKnowledge: async (query: string, options: any = {}) =>;
    getDSPyService()searchKnowledge(query, options);
  extractKnowledge: async (content: string, context: any = {}) =>;
    getDSPyService()extractKnowledge(content: context);
  evolveKnowledge: async (existingKnowledge: string, newInfo: string) =>;
    getDSPyService()evolveKnowledge(existingKnowledge, newInfo);
  optimizePrompts: async (examples: any[]) => getDSPyService()optimizePrompts(examples);
  request: async (operation: string, params: any = {}) =>;
    getDSPyService()request(operation, params);
  manageKnowledge: async (operation: string, data: any) =>;
    getDSPyService()manageKnowledge(operation, data);
  getStatus: () => getDSPyService()getStatus();
  shutdown: async () => getDSPyService()shutdown();
};
// Types are already exported above;
