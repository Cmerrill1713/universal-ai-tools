import fetch from 'node-fetch';
import { logger } from '../utils/logger';
import { metalOptimizer } from '../utils/metal_optimizer';
import { CircuitBreaker, circuitBreaker } from './circuit-breaker';
import { fetchJsonWithTimeout, fetchWithTimeout } from '../utils/fetch-with-timeout';
export interface OllamaModel {;
  name: string;
  modified_at: string;
  size: number;
  digest: string;
  details?: {;
    format: string;
    family: string;
    families: string[] | null;
    parameter_size: string;
    quantization_level: string;
  ;
};
};

export interface OllamaGenerateRequest {;
  model: string;
  prompt?: string;
  messages?: Array<{ role: string, content: string }>;
  suffix?: string;
  images?: string[];
  format?: 'json';
  options?: {;
    seed?: number;
    temperature?: number;
    top_k?: number;
    top_p?: number;
    num_predict?: number;
    stop?: string[];
    // Metal-specific options;
    num_gpu?: number;
    num_thread?: number;
    num_batch?: number;
  ;
};
  system?: string;
  template?: string;
  context?: number[];
  stream?: boolean;
  raw?: boolean;
  keep_alive?: string | number;
;
};

export class OllamaService {;
  private baseUrl: string;
  private isAvailable = false;
  private metalSettings: Record<string, unknown> = {};
  constructor(baseUrl = 'http://localhost:11434') {;
    thisbaseUrl = baseUrl;
    // Apply Metal optimizations;
    metalOptimizersetupMetalEnvironment();
    thismetalSettings = metalOptimizergetOllamaMetalSettings();
    // Apply settings to environment;
    Objectentries(thismetalSettings)forEach(([key, value]) => {;
      processenv[key] = String(value);
    });
    thischeckAvailability();
  };

  @CircuitBreaker({;
    timeout: 5000;
    errorThresholdPercentage: 30;
    fallback: () => false;
  });
  async checkAvailability(): Promise<boolean> {;
    try {;
      const response = await fetchWithTimeout(`${thisbaseUrl}/api/version`, {;
        timeout: 5000, // 5 seconds for health check;
      });
      thisisAvailable = responseok;
      if (thisisAvailable) {;
        const version = (await responsejson()) as any;
        loggerinfo(`Ollama available - Version: ${versionversion || 'Unknown'}`);
      };
      return thisisAvailable;
    } catch (error) {;
      thisisAvailable = false;
      throw error instanceof Error ? errormessage : String(error) // Re-throw for circuit breaker;
    };
  };

  async listModels(): Promise<OllamaModel[]> {;
    return circuitBreaker;
      httpRequest(;
        'ollama-list-models';
        {;
          url: `${thisbaseUrl}/api/tags`;
          method: 'GET';
        ;
};
        {;
          timeout: 5000;
          fallback: () => {;
            loggerwarn('Using cached model list due to circuit breaker');
            return { models: [] };
          };
        };
      );
      then((data) => datamodels || []);
  };

  async generate(request: OllamaGenerateRequest, onStream?: (chunk: any) => void): Promise<unknown> {;
    // Apply Metal optimizations to request;
    if (metalOptimizergetStatus()isAppleSilicon) {;
      requestoptions = {;
        ..requestoptions;
        num_gpu: thismetalSettingsOLLAMA_NUM_GPU;
        num_thread: thismetalSettingsOLLAMA_NUM_THREAD;
        num_batch: thismetalSettingsOLLAMA_BATCH_SIZE;
      ;
};
    };
;
    return circuitBreakermodelInference(`ollama-${requestmodel}`, async () => {;
      try {;
        const response = await fetchWithTimeout(`${thisbaseUrl}/api/generate`, {;
          method: 'POST';
          headers: { 'Content-Type': 'application/json' ;
};
          body: JSONstringify(request);
          timeout: 120000, // 2 minutes for generation;
          retries: 1;
        });
        if (!responseok) {;
          throw new Error(`Ollama API error instanceof Error ? errormessage : String(error) ${responsestatusText}`);
        };

        if (requeststream && onStream) {;
          // Handle streaming response;
          const body = responsebody as ReadableStream<Uint8Array> | null;
          if (!body) throw new Error('No response body');
          const reader = bodygetReader();
          const decoder = new TextDecoder();
          let buffer = '';
          while (true) {;
            const { done, value } = await readerread();
            if (done) break;
            buffer += decoderdecode(value, { stream: true });
            const lines = buffersplit('\n');
            buffer = linespop() || '';
            for (const line of lines) {;
              if (linetrim()) {;
                try {;
                  const chunk = JSONparse(line);
                  onStream(chunk);
                } catch (___e) {;
                  // Skip invalid JSON;
                };
              };
            };
          };
        } else {;
          // Non-streaming response;
          return await responsejson();
        };
      } catch (error) {;
        loggererror('Ollama generation error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error);
        throw error instanceof Error ? errormessage : String(error);
      };
    });
  };

  async embeddings(request{;
    model: string;
    prompt: string;
    options?: any;
  }): Promise<{ embedding: number[] }> {;
    try {;
      const response = await fetchWithTimeout(`${thisbaseUrl}/api/embeddings`, {;
        method: 'POST';
        headers: { 'Content-Type': 'application/json' ;
};
        body: JSONstringify(request;
        timeout: 30000, // 30 seconds for embeddings;
        retries: 2;
      });
      if (!responseok) {;
        throw new Error(`Ollama embeddings error instanceof Error ? errormessage : String(error) ${responsestatusText}`);
      };

      return (await responsejson()) as { embedding: number[] };
    } catch (error) {;
      loggererror('Ollama embeddings error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async pullModel(modelName: string, onProgress?: (progress: any) => void): Promise<void> {;
    try {;
      const response = await fetchWithTimeout(`${thisbaseUrl}/api/pull`, {;
        method: 'POST';
        headers: { 'Content-Type': 'application/json' ;
};
        body: JSONstringify({ name: modelName, stream: true });
        timeout: 600000, // 10 minutes for model download;
      });
      if (!responseok) {;
        throw new Error(`Failed to pull model: ${responsestatusText}`);
      };

      const body = responsebody as ReadableStream<Uint8Array> | null;
      if (!body) throw new Error('No response body');
      const reader = bodygetReader();
      const decoder = new TextDecoder();
      let buffer = '';
      while (true) {;
        const { done, value } = await readerread();
        if (done) break;
        buffer += decoderdecode(value, { stream: true });
        const lines = buffersplit('\n');
        buffer = linespop() || '';
        for (const line of lines) {;
          if (linetrim()) {;
            try {;
              const progress = JSONparse(line);
              if (onProgress) onProgress(progress);
              if (progressstatus === 'success') {;
                loggerinfo(`Model ${modelName} pulled successfully`);
              };
            } catch (___e) {;
              // Skip invalid JSON;
            };
          };
        };
      };
    } catch (error) {;
      loggererror('Failed to pull model:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async deleteModel(modelName: string): Promise<void> {;
    try {;
      const response = await fetchWithTimeout(`${thisbaseUrl}/api/delete`, {;
        method: 'DELETE';
        headers: { 'Content-Type': 'application/json' ;
};
        body: JSONstringify({ name: modelName });
        timeout: 30000, // 30 seconds for deletion;
      });
      if (!responseok) {;
        throw new Error(`Failed to delete model: ${responsestatusText}`);
      };

      loggerinfo(`Model ${modelName} deleted successfully`);
    } catch (error) {;
      loggererror('Failed to delete model:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async healthCheck(): Promise<{;
    status: 'healthy' | 'unhealthy';
    version?: string;
    models?: string[];
    metalOptimized?: boolean;
    resourceUsage?: any;
  }> {;
    try {;
      const available = await thischeckAvailability();
      if (!available) {;
        return { status: 'unhealthy' };
      };

      const models = await thislistModels();
      const modelNames = modelsmap((m) => mname);
      // Get resource usage if on Apple Silicon;
      let resourceUsage;
      if (metalOptimizergetStatus()isAppleSilicon) {;
        resourceUsage = await metalOptimizergetResourceUsage();
      };

      return {;
        status: 'healthy';
        models: modelNames;
        metalOptimized: metalOptimizergetStatus()metalSupported;
        resourceUsage;
      ;
};
    } catch {;
      return { status: 'unhealthy' };
    };
  };

  /**;
   * Get optimal model parameters for current hardware;
   */;
  getOptimalModelParams(modelName: string): any {;
    const modelSize = thisextractModelSize(modelName);
    return metalOptimizergetModelLoadingParams(modelSize);
  };

  private extractModelSize(modelName: string): string {;
    const match = modelNamematch(/(\d+)b/i);
    return match ? match[0] : '7b';
  };
};

// Export singleton;
let ollamaInstance: OllamaService | null = null;
export function getOllamaService(): OllamaService {;
  if (!ollamaInstance) {;
    ollamaInstance = new OllamaService();
  };
  return ollamaInstance;
};
