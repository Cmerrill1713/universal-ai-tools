/**;
 * Human-in-the-Loop Feedback Service;
 * Collects, stores, and processes human feedback for DSPy training;
 */;

import type { SupabaseClient } from '@supabase/supabase-js';
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
export interface FeedbackRequest {;
  id: string;
  agentId: string;
  requestId: string;
  userRequest: string;
  agentResponse: any;
  timestamp: Date;
  feedbackType: 'rating' | 'correction' | 'preference' | 'label';
  metadata?: Record<string, any>;
};

export interface UserFeedback {;
  feedbackId: string;
  requestId: string;
  feedbackType: 'rating' | 'correction' | 'preference' | 'label';
  rating?: number; // 1-5 stars;
  correctedResponse?: string;
  preferredResponse?: string;
  labels?: string[];
  comments?: string;
  timestamp: Date;
  userId?: string;
;
};

export interface FeedbackMetrics {;
  totalFeedback: number;
  averageRating: number;
  ratingDistribution: Record<number, number>;
  commonLabels: string[];
  improvementTrend: number;
  agentPerformance: Record<string, number>;
};

export interface TrainingDataset {;
  datasetId: string;
  name: string;
  description: string;
  examples: TrainingExample[];
  metadata: {;
    created: Date;
    lastUpdated: Date;
    exampleCount: number;
    avgQuality: number;
  ;
};
};

export interface TrainingExample {;
  input: string;
  expectedOutput: string;
  actualOutput?: string;
  feedback: UserFeedback;
  quality: number; // 0-1 quality score;
  isGoldStandard: boolean;
;
};

export class HumanFeedbackService extends EventEmitter {;
  private supabase: SupabaseClient;
  private pendingFeedback: Map<string, FeedbackRequest> = new Map();
  private feedbackHistory: UserFeedback[] = [];
  private trainingDatasets: Map<string, TrainingDataset> = new Map();
  private wsConnections: Set<any> = new Set();
  constructor(supabase: SupabaseClient) {;
    super();
    thissupabase = supabase;
    thisinitialize();
  };

  private async initialize(): Promise<void> {;
    await thisloadFeedbackHistory();
    await thisloadTrainingDatasets();
    loggerinfo('âœ… Human Feedback Service initialized');
  ;
};

  /**;
   * Request feedback for an agent response;
   */;
  async requestFeedback(;
    agentId: string;
    requestId: string;
    userRequest: string;
    agentResponse: any;
    feedbackType: FeedbackRequest['feedbackType'] = 'rating';
  ): Promise<FeedbackRequest> {;
    const feedbackRequest: FeedbackRequest = {;
      id: `feedback_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
      agentId;
      requestId;
      userRequest;
      agentResponse;
      timestamp: new Date();
      feedbackType;
    ;
};
    thispendingFeedbackset(feedbackRequestid, feedbackRequest);
    // Store in database;
    await thisstoreFeedbackRequest(feedbackRequest);
    // Notify UI clients;
    thisbroadcastFeedbackRequest(feedbackRequest);
    thisemit('feedbackrequested', feedbackRequest);
    return feedbackRequest;
  };

  /**;
   * Submit user feedback;
   */;
  async submitFeedback(feedback: UserFeedback): Promise<void> {;
    // Validate feedback;
    thisvalidateFeedback(feedback);
    // Store feedback;
    await thisstoreFeedback(feedback);
    thisfeedbackHistorypush(feedback);
    // Update pending request;
    const request = Arrayfrom(thispendingFeedbackvalues())find(;
      r => rrequestId === feedbackrequestId;
    );
    if (request) {;
      thispendingFeedbackdelete(requestid);
    };

    // Process feedback for training;
    await thisprocessFeedbackForTraining(feedback, request);
    // Update metrics;
    await thisupdateFeedbackMetrics(feedback);
    // Notify listeners;
    thisemit('feedback_received', feedback);
    thisbroadcastFeedbackUpdate(feedback);
  };

  /**;
   * Get feedback metrics;
   */;
  async getFeedbackMetrics(agentId?: string, timeframe = '7d'): Promise<FeedbackMetrics> {;
    const cutoffDate = thisgetCutoffDate(timeframe);
    let relevantFeedback = thisfeedbackHistoryfilter(;
      f => ftimestamp > cutoffDate;
    );
    if (agentId) {;
      const agentRequests = Arrayfrom(thispendingFeedbackvalues());
        filter(r => ragentId === agentId);
        map(r => rrequestId);
      relevantFeedback = relevantFeedbackfilter(;
        f => agentRequestsincludes(frequestId);
      );
    };

    const ratings = relevantFeedback;
      filter(f => frating !== undefined);
      map(f => frating!);
    const ratingDistribution: Record<number, number> = {};
    for (let i = 1; i <= 5; i++) {;
      ratingDistribution[i] = ratingsfilter(r => r === i)length;
    };

    const labels = relevantFeedback;
      flatMap(f => flabels || []);
      reduce((acc, label) => {;
        acc[label] = (acc[label] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);
    const commonLabels = Objectentries(labels);
      sort((a, b) => b[1] - a[1]);
      slice(0, 10);
      map(([label]) => label);
    return {;
      totalFeedback: relevantFeedbacklength;
      averageRating: ratingslength > 0 ;
        ? ratingsreduce((a, b) => a + b, 0) / ratingslength ;
        : 0;
      ratingDistribution;
      commonLabels;
      improvementTrend: await thiscalculateImprovementTrend(agentId, timeframe);
      agentPerformance: await thiscalculateAgentPerformance();
    ;
};
  };

  /**;
   * Create training dataset from feedback;
   */;
  async createTrainingDataset(;
    name: string;
    description: string;
    filters?: {;
      agentId?: string;
      minRating?: number;
      labels?: string[];
      timeframe?: string;
    ;
};
  ): Promise<TrainingDataset> {;
    const examples = await thiscollectTrainingExamples(filters);
    const dataset: TrainingDataset = {;
      datasetId: `dataset_${Datenow()}`;
      name;
      description;
      examples;
      metadata: {;
        created: new Date();
        lastUpdated: new Date();
        exampleCount: exampleslength;
        avgQuality: examplesreduce((sum, ex) => sum + exquality, 0) / exampleslength;
      };
    };
    thistrainingDatasetsset(datasetdatasetId, dataset);
    await thisstoreTrainingDataset(dataset);
    thisemit('dataset_created', dataset);
    return dataset;
  };

  /**;
   * Export training data for DSPy;
   */;
  async exportForDSPy(datasetId: string): Promise<any> {;
    const dataset = thistrainingDatasetsget(datasetId);
    if (!dataset) {;
      throw new Error(`Dataset ${datasetId} not found`);
    };

    // Format for DSPy training;
    const dspyExamples = datasetexamplesmap(ex => ({;
      question: exinput;
      answer: exexpectedOutput;
      metadata: {;
        quality: exquality;
        feedback: exfeedback;
        isGoldStandard: exisGoldStandard;
      ;
};
    }));
    return {;
      dataset_name: datasetname;
      examples: dspyExamples;
      metadata: datasetmetadata;
    ;
};
  };

  /**;
   * Get active feedback requests;
   */;
  getActiveFeedbackRequests(): FeedbackRequest[] {;
    return Arrayfrom(thispendingFeedbackvalues());
      sort((a, b) => btimestampgetTime() - atimestampgetTime());
  };

  /**;
   * Rate limit feedback requests;
   */;
  async shouldRequestFeedback(agentId: string, userId?: string): Promise<boolean> {;
    // Check recent feedback count;
    const recentCount = await thisgetRecentFeedbackCount(agentId, userId);
    // Limit to 5 feedback requests per hour per agent;
    if (recentCount >= 5) {;
      return false;
    };

    // Check if user has pending feedback;
    if (userId) {;
      const hasPending = Arrayfrom(thispendingFeedbackvalues())some(;
        r => rmetadata?userId === userId;
      );
      if (hasPending) {;
        return false;
      };
    };

    return true;
  };

  /**;
   * WebSocket connection for real-time feedback UI;
   */;
  addWebSocketConnection(ws: any): void {;
    thiswsConnectionsadd(ws);
    // Send current pending feedback;
    wssend(JSONstringify({;
      type: 'pending_feedback';
      data: thisgetActiveFeedbackRequests();
    }));
  };

  removeWebSocketConnection(ws: any): void {;
    thiswsConnectionsdelete(ws);
  ;
};

  // Private methods;

  private validateFeedback(feedback: UserFeedback): void {;
    if (!feedbackfeedbackId || !feedbackrequestId) {;
      throw new Error('Invalid feedback: missing required fields');
    };

    if (feedbackfeedbackType === 'rating' && !feedbackrating) {;
      throw new Error('Rating feedback must include a rating');
    };

    if (feedbackfeedbackType === 'correction' && !feedbackcorrectedResponse) {;
      throw new Error('Correction feedback must include corrected response');
    };
  };

  private async storeFeedbackRequest(request: FeedbackRequest): Promise<void> {;
    try {;
      await thissupabasefrom('feedbackrequests')insert({;
        id: requestid;
        agent_id: requestagentId;
        request_id: requestrequestId;
        userrequest: requestuserRequest;
        agent_response: requestagentResponse;
        feedback_type: requestfeedbackType;
        metadata: requestmetadata;
        created_at: requesttimestamp;
      });
    } catch (error) {;
      loggererror('Failed to store feedback request:', error);
    };
  };

  private async storeFeedback(feedback: UserFeedback): Promise<void> {;
    try {;
      await thissupabasefrom('user_feedback')insert({;
        feedback_id: feedbackfeedbackId;
        request_id: feedbackrequestId;
        feedback_type: feedbackfeedbackType;
        rating: feedbackrating;
        corrected_response: feedbackcorrectedResponse;
        preferred_response: feedbackpreferredResponse;
        labels: feedbacklabels;
        comments: feedbackcomments;
        user_id: feedbackuserId;
        created_at: feedbacktimestamp;
      });
    } catch (error) {;
      loggererror('Failed to store feedback:', error);
    };
  };

  private async processFeedbackForTraining(;
    feedback: UserFeedback;
    request?: FeedbackRequest;
  ): Promise<void> {;
    if (!request) return;
    // Create training example;
    const example: TrainingExample = {;
      input: requestuserRequest;
      expectedOutput: thisdetermineExpectedOutput(feedback, request);
      actualOutput: JSONstringify(requestagentResponse);
      feedback;
      quality: thiscalculateQuality(feedback);
      isGoldStandard: feedbackrating === 5 || feedbackfeedbackType === 'correction';
    ;
};
    // Add to active training set;
    const activeDataset = await thisgetOrCreateActiveDataset(requestagentId);
    activeDatasetexamplespush(example);
    activeDatasetmetadatalastUpdated = new Date();
    activeDatasetmetadataexampleCount++;
    // Update quality metrics;
    activeDatasetmetadataavgQuality = ;
      (activeDatasetmetadataavgQuality * (activeDatasetmetadataexampleCount - 1) + examplequality) /;
      activeDatasetmetadataexampleCount;
    await thisstoreTrainingDataset(activeDataset);
  };

  private determineExpectedOutput(feedback: UserFeedback, request: FeedbackRequest): string {;
    if (feedbackcorrectedResponse) {;
      return feedbackcorrectedResponse;
    };
    ;
    if (feedbackpreferredResponse) {;
      return feedbackpreferredResponse;
    };

    // For high ratings, use the original response as expected;
    if (feedbackrating && feedbackrating >= 4) {;
      return JSONstringify(requestagentResponse);
    };

    return '';
  };

  private calculateQuality(feedback: UserFeedback): number {;
    if (feedbackfeedbackType === 'correction') {;
      return 1.0; // Corrections are highest quality;
    };

    if (feedbackrating) {;
      return feedbackrating / 5.0;
    };

    if (feedbacklabels && feedbacklabelsincludes('accurate')) {;
      return 0.9;
    };

    return 0.5; // Default moderate quality;
  };

  private async getOrCreateActiveDataset(agentId: string): Promise<TrainingDataset> {;
    const datasetName = `${agentId}_active_training`;
    let dataset = Arrayfrom(thistrainingDatasetsvalues())find(;
      d => dname === datasetName;
    );
    if (!dataset) {;
      dataset = await thiscreateTrainingDataset(;
        datasetName;
        `Active training dataset for ${agentId}`;
        { agentId };
      );
    };

    return dataset;
  };

  private async collectTrainingExamples(filters?: any): Promise<TrainingExample[]> {;
    const examples: TrainingExample[] = [];
    // Collect from feedback history;
    for (const feedback of thisfeedbackHistory) {;
      // Apply filters;
      if (filters?minRating && feedbackrating && feedbackrating < filtersminRating) {;
        continue;
      };

      if (filters?labels && feedbacklabels) {;
        const hasLabel = filterslabelssome(l => feedbacklabels?includes(l));
        if (!hasLabel) continue;
      };

      // Find corresponding request;
      const request = await thisgetFeedbackRequest(feedbackrequestId);
      if (!request) continue;
      if (filters?agentId && requestagentId !== filtersagentId) {;
        continue;
      };

      const example: TrainingExample = {;
        input: requestuserRequest;
        expectedOutput: thisdetermineExpectedOutput(feedback, request);
        actualOutput: JSONstringify(requestagentResponse);
        feedback;
        quality: thiscalculateQuality(feedback);
        isGoldStandard: feedbackrating === 5;
      ;
};
      examplespush(example);
    };

    return examples;
  };

  private async getFeedbackRequest(requestId: string): Promise<FeedbackRequest | null> {;
    // Check memory first;
    const memoryRequest = Arrayfrom(thispendingFeedbackvalues())find(;
      r => rrequestId === requestId;
    );
    if (memoryRequest) return memoryRequest;
    // Check database;
    try {;
      const { data } = await thissupabase;
        from('feedbackrequests');
        select('*');
        eq('request_id', requestId);
        single();
      if (data) {;
        return {;
          id: dataid;
          agentId: dataagent_id;
          requestId: datarequest_id;
          userRequest: datauserrequest;
          agentResponse: dataagent_response;
          timestamp: new Date(datacreated_at);
          feedbackType: datafeedback_type;
          metadata: datametadata;
        ;
};
      };
    } catch (error) {;
      loggererror('Failed to fetch feedback request:', error);
    };

    return null;
  };

  private getCutoffDate(timeframe: string): Date {;
    const date = new Date();
    const match = timeframematch(/(\d+)([dhm])/);
    if (match) {;
      const [ amount, unit] = match;
      const value = parseInt(amount);
      switch (unit) {;
        case 'd':;
          datesetDate(dategetDate() - value);
          break;
        case 'h':;
          datesetHours(dategetHours() - value);
          break;
        case 'm':;
          datesetMinutes(dategetMinutes() - value);
          break;
      };
    };
    ;
    return date;
  };

  private async calculateImprovementTrend(agentId?: string, timeframe: string): Promise<number> {;
    // Calculate trend in ratings over time;
    const cutoff = thisgetCutoffDate(timeframe);
    const midpoint = new Date((cutoffgetTime() + new Date()getTime()) / 2);
    const firstHalf = thisfeedbackHistoryfilter(;
      f => ftimestamp > cutoff && ftimestamp <= midpoint && frating;
    );
    const secondHalf = thisfeedbackHistoryfilter(;
      f => ftimestamp > midpoint && frating;
    );
    if (firstHalflength === 0 || secondHalflength === 0) return 0;
    const firstAvg = firstHalfreduce((sum, f) => sum + frating!, 0) / firstHalflength;
    const secondAvg = secondHalfreduce((sum, f) => sum + frating!, 0) / secondHalflength;
    return (secondAvg - firstAvg) / firstAvg;
  };

  private async calculateAgentPerformance(): Promise<Record<string, number>> {;
    const performance: Record<string, number> = {};
    // Group feedback by agent;
    const agentFeedback = new Map<string, UserFeedback[]>();
    for (const feedback of thisfeedbackHistory) {;
      const request = await thisgetFeedbackRequest(feedbackrequestId);
      if (!request) continue;
      if (!agentFeedbackhas(requestagentId)) {;
        agentFeedbackset(requestagentId, []);
      };
      agentFeedbackget(requestagentId)!push(feedback);
    };

    // Calculate average rating per agent;
    for (const [agentId, feedbacks] of agentFeedback) {;
      const ratings = feedbacksfilter(f => frating)map(f => frating!);
      if (ratingslength > 0) {;
        performance[agentId] = ratingsreduce((a, b) => a + b, 0) / ratingslength;
      };
    };

    return performance;
  };

  private async getRecentFeedbackCount(agentId: string, userId?: string): Promise<number> {;
    const oneHourAgo = new Date(Datenow() - 60 * 60 * 1000);
    return Arrayfrom(thispendingFeedbackvalues())filter(r => ;
      ragentId === agentId && rtimestamp > oneHourAgo && (!userId || rmetadata?userId === userId);
    )length;
  };

  private async loadFeedbackHistory(): Promise<void> {;
    try {;
      const { data } = await thissupabase;
        from('user_feedback');
        select('*');
        order('created_at', { ascending: false });
        limit(1000);
      if (data) {;
        thisfeedbackHistory = datamap(f => ({;
          feedbackId: ffeedback_id;
          requestId: frequest_id;
          feedbackType: ffeedback_type;
          rating: frating;
          correctedResponse: fcorrected_response;
          preferredResponse: fpreferred_response;
          labels: flabels;
          comments: fcomments;
          userId: fuser_id;
          timestamp: new Date(fcreated_at);
        }));
      };
    } catch (error) {;
      loggererror('Failed to load feedback history:', error);
    };
  };

  private async loadTrainingDatasets(): Promise<void> {;
    try {;
      const { data } = await thissupabase;
        from('training_datasets');
        select('*');
      if (data) {;
        for (const dataset of data) {;
          thistrainingDatasetsset(datasetdataset_id, {;
            datasetId: datasetdataset_id;
            name: datasetname;
            description: datasetdescription;
            examples: datasetexamples || [];
            metadata: datasetmetadata;
          });
        };
      };
    } catch (error) {;
      loggererror('Failed to load training datasets:', error);
    };
  };

  private async storeTrainingDataset(dataset: TrainingDataset): Promise<void> {;
    try {;
      await thissupabasefrom('training_datasets')upsert({;
        dataset_id: datasetdatasetId;
        name: datasetname;
        description: datasetdescription;
        examples: datasetexamples;
        metadata: datasetmetadata;
      });
    } catch (error) {;
      loggererror('Failed to store training dataset:', error);
    };
  };

  private async updateFeedbackMetrics(feedback: UserFeedback): Promise<void> {;
    // Update real-time metrics;
    const metrics = await thisgetFeedbackMetrics();
    thisemit('metrics_updated', metrics);
  };

  private broadcastFeedbackRequest(request: FeedbackRequest): void {;
    const message = JSONstringify({;
      type: 'new_feedbackrequest';
      data: request;
    });
    thiswsConnectionsforEach(ws => {;
      try {;
        wssend(message);
      } catch (error) {;
        loggererror('Failed to broadcast feedback request:', error);
      };
    });
  };

  private broadcastFeedbackUpdate(feedback: UserFeedback): void {;
    const message = JSONstringify({;
      type: 'feedback_submitted';
      data: feedback;
    });
    thiswsConnectionsforEach(ws => {;
      try {;
        wssend(message);
      } catch (error) {;
        loggererror('Failed to broadcast feedback update:', error);
      };
    });
  };
};

// Export singleton instance;
export const humanFeedbackService = (supabase: SupabaseClient) => new HumanFeedbackService(supabase);