/**;
 * Autofix Memory Service - Tracks and learns from code fixes using Supabase;
 */;

import type { SupabaseClient } from '@supabase/supabase-js';
import { logger } from '../utils/logger';
export interface AutofixMemory {;
  id?: string;
  file_path: string;
  fix_type: string;
  original_code: string;
  fixed_code: string;
  reasoning: string;
  linterror instanceof Error ? errormessage : String(error)  string;
  confidence: number;
  success: boolean;
  created_at?: string;
  session_id: string;
  metadata?: {;
    line_numbers?: number[];
    imports_changed?: boolean;
    types_improved?: boolean;
    magic_numbers_extracted?: boolean;
    unused_vars_fixed?: boolean;
  ;
};
};

export interface FixPattern {;
  pattern_type: string;
  description: string;
  success_rate: number;
  usage_count: number;
  example_before: string;
  example_after: string;
;
};

export class AutofixMemoryService {;
  private supabase: SupabaseClient;
  private sessionId: string;
  constructor(supabase: SupabaseClient) {;
    thissupabase = supabase;
    thissessionId = `autofix_${Datenow()}`;
  };

  /**;
   * Store a fix in memory for learning;
   */;
  async storeFix(fix: Omit<AutofixMemory, 'session_id'>): Promise<void> {;
    try {;
      const fixWithSession = {;
        ..fix;
        session_id: thissessionId;
      };
      // Generate embedding for the fix contentfor similarity search;
      const content `${fixfix_type}: ${fixreasoning} | ${fixoriginal_code} -> ${fixfixed_code}`;
      const { data: embedding } = await thissupabaserpc('ai_generate_embedding', {;
        content;
      });
      // Store in memories table with autofix-specific metadata;
      const { error instanceof Error ? errormessage : String(error) memoryError } = await thissupabasefrom('memories')insert({;
        content;
        metadata: {;
          ..fixWithSession;
          memory_type: 'autofix';
          tags: [;
            'autofix';
            fixfix_type;
            fixfile_pathsplit('/')pop()?split('.')[1] || 'unknown';
          ];
        ;
};
        embedding;
        user_id: 'claude-autofix';
      });
      if (memoryError) {;
        loggerwarn('Failed to store autofix memory:', memoryError);
      };

      // Also store in dedicated autofix table if it exists;
      await thisstoreAutofixRecord(fixWithSession);
      loggerinfo(`ðŸ“š Stored autofix memory: ${fixfix_type} in ${fixfile_path}`);
    } catch (error) {;
      loggererror('Error storing autofix memory:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Retrieve similar fixes for learning;
   */;
  async getSimilarFixes(currentFix: string, filePath: string, limit = 5): Promise<AutofixMemory[]> {;
    try {;
      // Generate embedding for current fix;
      const { data: embedding } = await thissupabaserpc('ai_generate_embedding', {;
        contentcurrentFix;
      });
      // Search for similar fixes;
      const { data: memories } = await thissupabaserpc('search_memories', {;
        query_embedding: embedding;
        match_threshold: 0.6;
        match_count: limit;
        filter: { memory_type: 'autofix' ;
};
      });
      if (!memories) return [];
      return memories;
        map((memory: any) => memorymetadata);
        filter((fix: AutofixMemory) => fixfile_pathendsWith(filePathsplit('.')pop() || ''));
        filter((fix: AutofixMemory) => fixsuccess);
    } catch (error) {;
      loggererror('Error retrieving similar fixes:', error instanceof Error ? errormessage : String(error);
      return [];
    };
  };

  /**;
   * Get fix patterns for a specific file type;
   */;
  async getFixPatternsForFileType(fileExtension: string): Promise<FixPattern[]> {;
    try {;
      const { data } = await thissupabase;
        from('memories');
        select('*');
        like('metadata->>tags', `%${fileExtension}%`);
        eq('metadata->>memory_type', 'autofix');
        eq('metadata->>success', 'true');
        order('created_at', { ascending: false });
        limit(20);
      if (!data) return [];
      // Group by fix type and calculate success patterns;
      const patterns = new Map<string, FixPattern>();
      dataforEach((memory: any) => {;
        const fix = memorymetadata as AutofixMemory;
        const existing = patternsget(fixfix_type);
        if (existing) {;
          existingusage_count++;
          existingsuccess_rate = (existingsuccess_rate + (fixconfidence || 0.8)) / 2;
        } else {;
          patternsset(fixfix_type, {;
            pattern_type: fixfix_type;
            description: fixreasoning;
            success_rate: fixconfidence || 0.8;
            usage_count: 1;
            example_before: fixoriginal_codesubstring(0, 100);
            example_after: fixfixed_codesubstring(0, 100);
          });
        };
      });
      return Arrayfrom(patternsvalues())sort((a, b) => bsuccess_rate - asuccess_rate);
    } catch (error) {;
      loggererror('Error getting fix patterns:', error instanceof Error ? errormessage : String(error);
      return [];
    };
  };

  /**;
   * Store session summary;
   */;
  async storeSessionSummary(summary: {;
    total_fixes: number;
    files_modified: string[];
    fix_types: string[];
    success_rate: number;
    duration_ms: number;
  }): Promise<void> {;
    try {;
      const content `Autofix session completed: ${summarytotal_fixes} fixes across ${summaryfiles_modifiedlength} files`;
      const { data: embedding } = await thissupabaserpc('ai_generate_embedding', {;
        content;
      });
      await thissupabasefrom('memories')insert({;
        content;
        metadata: {;
          ..summary;
          memory_type: 'autofix_session';
          session_id: thissessionId;
          tags: ['autofix', 'session_summary'];
        };
        embedding;
        user_id: 'claude-autofix';
      });
      loggerinfo(`ðŸ“Š Stored autofix session summary: ${summarytotal_fixes} fixes`);
    } catch (error) {;
      loggererror('Error storing session summary:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Get autofix insights and recommendations;
   */;
  async getAutofixInsights(): Promise<{;
    most_common_fixes: string[];
    highest_success_patterns: FixPattern[];
    recent_learnings: string[];
    recommendations: string[];
  }> {;
    try {;
      const { data: recentFixes } = await thissupabase;
        from('memories');
        select('*');
        eq('metadata->>memory_type', 'autofix');
        order('created_at', { ascending: false });
        limit(50);
      if (!recentFixes) {;
        return {;
          most_common_fixes: [];
          highest_success_patterns: [];
          recent_learnings: [];
          recommendations: [];
        ;
};
      };

      // Analyze fix types;
      const fixTypeCounts = new Map<string, number>();
      const learnings: string[] = [];
      recentFixesforEach((memory: any) => {;
        const fix = memorymetadata as AutofixMemory;
        fixTypeCountsset(fixfix_type, (fixTypeCountsget(fixfix_type) || 0) + 1);
        if (fixsuccess && fixconfidence > 0.8) {;
          learningspush(`${fixfix_type}: ${fixreasoning}`);
        };
      });
      const mostCommonFixes = Arrayfrom(fixTypeCountsentries());
        sort((a, b) => b[1] - a[1]);
        slice(0, 5);
        map(([type]) => type);
      return {;
        most_common_fixes: mostCommonFixes;
        highest_success_patterns: await thisgetFixPatternsForFileType('ts');
        recent_learnings: learningsslice(0, 10);
        recommendations: [;
          'Continue using type inference patterns for better TypeScript compliance';
          'Focus on removing unused imports and variables';
          'Extract magic numbers to named constants for better maintainability';
          'Prefer explicit return types over any for better type safety';
        ];
      ;
};
    } catch (error) {;
      loggererror('Error getting autofix insights:', error instanceof Error ? errormessage : String(error);
      return {;
        most_common_fixes: [];
        highest_success_patterns: [];
        recent_learnings: [];
        recommendations: [];
      ;
};
    };
  };

  private async storeAutofixRecord(fix: AutofixMemory): Promise<void> {;
    try {;
      // Try to store in dedicated autofix table if it exists;
      const { error instanceof Error ? errormessage : String(error)  = await thissupabasefrom('autofix_history')insert(fix);
      if (error instanceof Error ? errormessage : String(error) & !errormessageincludes('does not exist')) {;
        loggerwarn('Failed to store in autofix_history table:', error instanceof Error ? errormessage : String(error)  ;
};
    } catch (error) {;
      // Table might not exist, that's okay - we're storing in memories table anyway;
      loggerdebug('Autofix history table not available, using memories only');
    };
  };
};
