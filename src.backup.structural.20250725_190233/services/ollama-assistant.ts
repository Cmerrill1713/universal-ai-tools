import axios from 'axios';
import { logger } from '../utils/logger';
import type { SupabaseClient } from '@supabase/supabase-js';
interface Memory {;
  id: string;
  contentstring;
  [key: string]: any;
};

interface Knowledge {;
  id: string;
  title: string;
  contentstring;
  [key: string]: any;
};

interface Context {;
  memories: Memory[] | null;
  knowledge: Knowledge[] | null;
};

interface Tool {;
  tool_name: string;
  description: string;
  [key: string]: any;
};

type ToolDescriptionKey =;
  | 'trading_data_provider';
  | 'database_connector';
  | 'memory_store';
  | 'context_store';
  | 'web_scraper';
  | 'api_integrator';
  | 'file_processor';
  | 'notification_system';
  | 'ai_model_connector';
  | 'workflow_orchestrator';
  | 'security_scanner';
  | 'performance_monitor';
  | 'backup_manager';
  | 'deployment_manager';
export class OllamaAssistant {;
  private ollamaUrl: string;
  private model: string | null = null;
  private availableModels: string[] = [];
  private supabase: SupabaseClient;
  private preferredModels = [;
    'llama3.2:3b';
    'gemma: 2b';
    'phi: 2.7b-chat-v2-q4_0';
    'qwen2.5: 7b';
    'deepseek-r1: 14b';
    'nous-hermes: 13b-llama2-q4_K_M'];
  constructor(supabase: SupabaseClient) {;
    thisollamaUrl = processenvOLLAMA_HOST || 'http://localhost:11434';
    thissupabase = supabase;
    // Don't initialize model in constructor - fully lazy initialization;
    loggerinfo('OllamaAssistant initialized - models will be loaded on first use');
};

  private async initializeModel() {;
    try {;
      loggerinfo('Initializing Ollama models...');
      // Get list of available models with short timeout;
      const response = await axiosget(`${thisollamaUrl}/api/tags`, {;
        timeout: 3000, // 3 second timeout;
        headers: {;
          'Content-Type': 'application/json'}});
      thisavailableModels = responsedatamodelsmap((m: any) => mname);
      loggerinfo(`Found ${thisavailableModelslength} Ollama models`);
      // Select the first available preferred model;
      for (const preferred of thispreferredModels) {;
        if (thisavailableModelssome((model) => modelstartsWith(preferred))) {;
          thismodel = thisavailableModelsfind((model) => modelstartsWith(preferred)) || null;
          loggerinfo(`Selected Ollama model: ${thismodel}`);
          break;
        };
      };

      // If no preferred model found, use the first available;
      if (!thismodel && thisavailableModelslength > 0) {;
        thismodel = thisavailableModels[0];
        loggerinfo(`Using first available model: ${thismodel}`);
      };

      if (!thismodel) {;
        loggerwarn('No Ollama models available, will use fallback');
        thismodel = processenvOLLAMA_MODEL || 'llama3.2:3b'; // Default fallback};
    } catch (error) {;
      loggererror('Failed to initialize Ollama model:', error instanceof Error ? errormessage : String(error) // Fallback to environment variable or default;
      thismodel = processenvOLLAMA_MODEL || 'llama3.2:3b';
      loggerinfo(`Using fallback model: ${thismodel}`);
    };
  };

  private async ensureModel(): Promise<string> {;
    if (!thismodel) {;
      await thisinitializeModel();
      if (!thismodel) {;
        throw new Error('No Ollama models available')};
    };
    return thismodel;
  };

  /**;
   * Analyze a requestand suggest appropriate tools;
   */;
  async suggestTools(userRequest: string, availableTools: Tool[]): Promise<unknown> {;
    try {;
      // First, analyze the request to understand intent;
      const requestAnalysis = await thisanalyzeRequestIntent(userRequest);
      // Get relevant context from memory and knowledge base;
      const context = await thisgetRelevantContext(userRequest);
      // Build comprehensive available tools list;
      const toolsList = await thisbuildToolsList(availableTools),;

      const prompt = `You are an expert AI assistant specializing in tool selection and system integration. Analyze the user's requestand provide intelligent tool recommendations.`;

USER REQUEST: "${userRequest}";
REQUEST ANALYSIS: - Intent: ${requestAnalysisintent;
};
- Domain: ${requestAnalysisdomain;
};
- Complexity: ${requestAnalysiscomplexity;
};
- Action Type: ${requestAnalysisactionType;
};

AVAILABLE TOOLS: ${toolsList;
};

RELEVANT CONTEXT:;
${;
  contextmemories;
    ? `Previous Experience: ${contextmemories`;
        slice(0, 3);
        map((m: Memory) => mcontent;
        join(', ')}`;
    : 'No previous experience found';
;
};
${;
  contextknowledge;
    ? `Knowledge Base: ${contextknowledge`;
        slice(0, 2);
        map((k: Knowledge) => `${ktitle}: ${kcontentsubstring(0, 100)}`);
        join('; ')}`;
    : 'No relevant knowledge found';
;
};

INTELLIGENT ANALYSIS:;
Based on the requestanalysis determine:;
1. What specific problem the user is trying to solve;
2. Which tools best match their needs (not just generic memory storage);
3. What additional setup or configuration might be needed;
4. Any potential challenges or considerations;
Respond with a JSON object containing:;
{;
  "suggested_tools": ["specific_tool1", "specific_tool2"];
  "reasoning": "Detailed explanation of why these tools are recommended";
  "setup_steps": ["Step 1", "Step 2", "Step 3"];
  "parameters": {;
    "tool_name": { "param1": "suggested_value", "param2": "suggested_value" ;
};
  };
  "additional_recommendations": "Any extra suggestions or considerations";
  "estimated_complexity": "low|medium|high";
}`;`;
      const model = await thisensureModel();
      const response = await axiospost(`${thisollamaUrl}/api/generate`, {;
        model;
        prompt;
        stream: false;
        format: 'json'});
      const result = JSONparse(responsedataresponse);
      // Store this interaction for future learning;
      await thisstoreInteraction(userRequest, result);
      return result;
    } catch (error) {;
      loggererror('Ollama tool suggestion failed:', error instanceof Error ? errormessage : String(error);
      // Fallback to basic _analysisif Ollama fails;
      return await thisfallbackToolSuggestion(userRequest, availableTools)};
  };

  /**;
   * Analyze requestintent and characteristics;
   */;
  private async analyzeRequestIntent(requeststring): Promise<unknown> {;
    try {;
      const model = await thisensureModel();
      const prompt = `Analyze this requestand categorize it:`;

Request: "${request;
Determine:;
1. Intent (setup, create, analyze, integrate, troubleshoot, learn, etc.);
2. Domain (trading, development, ai, database, web, mobile, etc.);
3. Complexity (low, medium, high);
4. Action Type (configuration, development, deployment, monitoring, etc.);

Respond with JSON: {"intent": "...", "domain": "...", "complexity": "...", "actionType": "..."}`;
      const response = await axiospost(`${thisollamaUrl}/api/generate`, {;
        model;
        prompt;
        stream: false;
        format: 'json'});
      return JSONparse(responsedataresponse);
    } catch (error) {;
      loggererror('Request _analysisfailed:', error instanceof Error ? errormessage : String(error);
      return {;
        intent: 'unknown';
        domain: 'general';
        complexity: 'medium';
        actionType: 'configuration';
};
    };
  };

  /**;
   * Get relevant context from memory and knowledge base;
   */;
  private async getRelevantContext(requeststring): Promise<Context> {;
    try {;
      // Get relevant memories;
      const { data: memories } = await thissupabase;
        from('ai_memories');
        select('*');
        textSearch('content request;
        limit(5);
      // Get relevant knowledge;
      const { data: knowledge } = await thissupabase;
        from('ai_knowledge_base');
        select('*');
        textSearch('content request;
        limit(3);
      return { memories, knowledge };
    } catch (error) {;
      loggererror('Context retrieval failed:', error instanceof Error ? errormessage : String(error);
      return { memories: null, knowledge: null };
    };
  };

  /**;
   * Build comprehensive tools list with detailed descriptions;
   */;
  private async buildToolsList(availableTools: Tool[]): Promise<string> {;
    // Enhanced tool descriptions based on common use cases;
    const toolDescriptions: Record<ToolDescriptionKey, string> = {;
      trading_data_provider: 'Real-time market data, price feeds, and trading signals';
      database_connector: 'Universal database connections (PostgreSQL, MySQL, MongoDB, etc.)';
      memory_store: 'Persistent memory storage for AI agents and user context';
      context_store: 'Session and conversation context management';
      web_scraper: 'Web contentextraction and monitoring';
      api_integrator: 'REST and GraphQL API integration tools';
      file_processor: 'File parsing, conversion, and processing utilities';
      notification_system: 'Multi-channel notifications (email, SMS, Slack, etc.)';
      ai_model_connector: 'Connect to various AI models (OpenAI, Anthropic, local models)';
      workflow_orchestrator: 'Automated task sequences and scheduling';
      security_scanner: 'Security validation and compliance checking';
      performance_monitor: 'System performance tracking and optimization';
      backup_manager: 'Automated backup and disaster recovery';
      deployment_manager: 'Application deployment and CI/CD integration';
};
    return (;
      `${availableTools`;
        map((tool) => {;
          const enhanced =;
            toolDescriptions[tooltool_name as ToolDescriptionKey] || tooldescription;
          return `- ${tooltool_name}: ${enhanced}`;
        });
        join('\n')}\n\n` +`;
      `Additional Available Tools: \n${Objectentries(toolDescriptions)`;
        map(([name, desc]) => `- ${name}: ${desc}`);
        join('\n')}`;
    );
  };

  /**;
   * Store interaction for future learning;
   */;
  private async storeInteraction(requeststring, response: any): Promise<void> {;
    try {;
      await thissupabasefrom('ai_interactions')insert({;
        request_text: request;
        response_data: response;
        interaction_type: 'tool_suggestion';
        timestamp: new Date()toISOString()});
    } catch (error) {;
      loggererror('Failed to store interaction:', error instanceof Error ? errormessage : String(error)};
  };

  /**;
   * Fallback tool suggestion when Ollama fails;
   */;
  private async fallbackToolSuggestion(requeststring, availableTools: any[]): Promise<unknown> {;
    const requestLower = request toLowerCase();
    // Basic keyword matching;
    const suggestions = [];
    if (;
      requestLowerincludes('trading') || requestLowerincludes('bot') || requestLowerincludes('market');
    ) {;
      suggestionspush('trading_data_provider', 'memory_store', 'notification_system')};

    if (requestLowerincludes('database') || requestLowerincludes('data')) {;
      suggestionspush('database_connector', 'memory_store')};

    if (;
      requestLowerincludes('web') || requestLowerincludes('scraping') || requestLowerincludes('api');
    ) {;
      suggestionspush('web_scraper', 'api_integrator')};

    if (;
      requestLowerincludes('ai') || requestLowerincludes('model') || requestLowerincludes('llm');
    ) {;
      suggestionspush('ai_model_connector', 'memory_store', 'context_store')};

    if (requestLowerincludes('deploy') || requestLowerincludes('production')) {;
      suggestionspush('deployment_manager', 'security_scanner', 'performance_monitor')};

    // Default suggestions if nothing matches;
    if (suggestionslength === 0) {;
      suggestionspush('memory_store', 'context_store', 'api_integrator')};

    return {;
      suggested_tools: suggestionsslice(0, 3);
      reasoning:;
        'Basic _analysisbased on keywords in your requestFor more detailed suggestions, please ensure Ollama is running.';
      setup_steps: [;
        'Review the suggested tools';
        'Check tool documentation';
        'Configure required parameters';
        'Test the integration'];
      parameters: {};
      additional_recommendations: 'Consider using multiple tools together for complex workflows';
      estimated_complexity: 'medium';
};
  };

  /**;
   * Generate code to connect a new program to the Universal AI Tools;
   */;
  async generateConnectionCode(;
    language: string;
    framework: string;
    purpose: string;
  ): Promise<string> {;
    const prompt = `Generate ${language} code to connect to the Universal AI Tools API.`;

Framework: ${framework;
};
Purpose: ${purpose;
};
API Base URL: http://localhost:9999/api;
Authentication: X-API-Key and X-AI-Service headers;
The code should:;
1. Register the service;
2. Store the API key;
3. Implement basic tool execution;
4. Handle errors properly;
Provide clean, production-ready code with comments.`;`;
    try {;
      const model = await thisensureModel(),;
      const response = await axiospost(`${thisollamaUrl}/api/generate`, {;
        model;
        prompt;
        stream: false});
      return responsedataresponse;
    } catch (error) {;
      loggererror('Ollama code generation failed:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error)};
  };

  /**;
   * Analyze a codebase and suggest integration points;
   */;
  async analyzeIntegrationPoints(codeStructure: any): Promise<unknown> {;
    const prompt = `Analyze this code structure and suggest where to integrate Universal AI Tools:`;

Structure:;
${JSONstringify(codeStructure, null, 2)};

Suggest:;
1. Where to add AI memory storage;
2. Where to implement context saving;
3. Which existing functions could benefit from AI assistance;
4. How to structure the integration;
Respond with specific file paths and code locations.`;`;
    try {;
      const response = await axiospost(`${thisollamaUrl}/api/generate`, {;
        model: thismodel;
        prompt;
        stream: false});
      return responsedataresponse;
    } catch (error) {;
      loggererror('Ollama _analysisfailed:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error)};
  };

  /**;
   * Create a custom tool implementation;
   */;
  async createToolImplementation(;
    toolName: string;
    description: string;
    requirements: string;
  ): Promise<unknown> {;
    const prompt = `Create a tool implementation for the Universal AI Tools system.`;

Tool Name: ${toolName;
};
Description: ${description;
};
Requirements: ${requirements;
};

Generate:;
1. Input schema (JSON Schema format);
2. Implementation code (JavaScript function);
3. Output schema;
4. Usage example;
The implementation should be self-contained and handle errors.`;`;
    try {;
      const response = await axiospost(`${thisollamaUrl}/api/generate`, {;
        model: thismodel;
        prompt;
        stream: false});
      const toolCode = responsedataresponse;
      // Parse and structure the response;
      // This is a simplified version - you'd want more robust parsing;
      return {;
        tool_name: toolName;
        description;
        input_schema: { type: 'object', properties: {} };
        implementation_type: 'function';
        implementation: toolCode;
        generated_by: 'ollama-assistant';
};
    } catch (error) {;
      loggererror('Tool creation failed:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error)};
  };

  /**;
   * Generate API documentation for a specific use case;
   */;
  async generateDocumentation(useCase: string, language: string): Promise<string> {;
    const prompt = `Generate API documentation for using Universal AI Tools.`;

Use Case: ${useCase;
};
Programming Language: ${language;
};

Include:;
1. Setup instructions;
2. Authentication example;
3. Common operations;
4. Error handling;
5. Best practices;
Format as markdown with code examples.`;`;
    try {;
      const response = await axiospost(`${thisollamaUrl}/api/generate`, {;
        model: thismodel;
        prompt;
        stream: false});
      return responsedataresponse;
    } catch (error) {;
      loggererror('Documentation generation failed:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error)};
  };

  /**;
   * Intelligently route requests to appropriate tools;
   */;
  async routeRequest(requeststring, context?: any): Promise<unknown> {;
    // First, check if we have relevant memory;
    const { data: memories } = await thissupabase;
      from('ai_memories');
      select('*');
      textSearch('content request;
      limit(5);
    // Then check knowledge base;
    const { data: knowledge } = await thissupabase;
      from('ai_knowledge_base');
      select('*');
      textSearch('content request;
      limit(5);
    const prompt = `Route this request to the appropriate tool or action:`;

Request: "${request;
Relevant Context:;
${context ? JSONstringify(context, null, 2) : 'None';
};

Related Memories: ${memories?map((m) => mcontentjoin('\n') || 'None';
};

Related Knowledge:;
${knowledge?map((k) => `${ktitle}: ${kcontent)join('\n') || 'None'}`;
Determine:;
1. What type of operation this is (store, retrieve, execute, etc.);
2. Which specific tool to use;
3. What parameters to pass;
Respond with a JSON object containing the routing decision.`;`;
    try {;
      const model = await thisensureModel(),;
      const response = await axiospost(`${thisollamaUrl}/api/generate`, {;
        model;
        prompt;
        stream: false;
        format: 'json'});
      return JSONparse(responsedataresponse);
    } catch (error) {;
      loggererror('Request routing failed:', error instanceof Error ? errormessage : String(error);
      return null};
  };
};

// Singleton instance;
let ollamaAssistant: OllamaAssistant | null = null;
export function getOllamaAssistant(supabase: SupabaseClient): OllamaAssistant {;
  if (!ollamaAssistant) {;
    ollamaAssistant = new OllamaAssistant(supabase)};
  return ollamaAssistant;
};
