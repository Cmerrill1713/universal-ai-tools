import { EventEmitter } from 'events';
import type { SupabaseClient } from '@supabase/supabase-js';
import { LogContext, logger } from '../utils/enhanced-logger';
import { z } from 'zod';
import { randomUUID } from 'crypto';
import type { ResourceUsage } from './agent-performance-tracker';
import { AgentPerformanceTracker } from './agent-performance-tracker';
// Pydantic-style schemas for type safety;
const TaskSchema = zobject({;
  id: zstring();
  name: zstring();
  description: zstring();
  priority: zenum(['high', 'medium', 'low']);
  status: zenum(['pending', 'assigned', 'in_progress', 'completed', 'failed', 'validated']);
  assignedAgent: zstring()optional();
  dependencies: zarray(zstring())default([]);
  result: zany()optional();
  error instanceof Error ? errormessage : String(error) zstring()optional();
  startedAt: zdate()optional();
  completedAt: zdate()optional();
  validatedAt: zdate()optional();
  attempts: znumber()default(0);
  maxAttempts: znumber()default(3);
  estimatedDuration: znumber()optional(), // in milliseconds;
  actualDuration: znumber()optional();
  validationScore: znumber()min(0)max(100)optional();
});
const AgentSchema = zobject({;
  id: zstring();
  name: zstring();
  type: zstring();
  capabilities: zarray(zstring());
  status: zenum(['idle', 'busy', 'error instanceof Error ? errormessage : String(error)  'offline']);
  currentTask: zstring()optional();
  tasksCompleted: znumber()default(0);
  tasksFailed: znumber()default(0);
  averageCompletionTime: znumber()default(0);
  reliability: znumber()min(0)max(100)default(100), // percentage;
  lastActive: zdate();
});
const SwarmMetricsSchema = zobject({;
  totalTasks: znumber();
  completedTasks: znumber();
  failedTasks: znumber();
  validatedTasks: znumber();
  pendingTasks: znumber();
  inProgressTasks: znumber();
  completionPercentage: znumber();
  validationPercentage: znumber();
  averageTaskDuration: znumber();
  estimatedTimeRemaining: znumber();
  agentUtilization: znumber(), // percentage;
  swarmEfficiency: znumber(), // percentage;
});
type Task = zinfer<typeof TaskSchema>;
type Agent = zinfer<typeof AgentSchema>;
type SwarmMetrics = zinfer<typeof SwarmMetricsSchema>;
export interface SwarmConfig {;
  maxConcurrentTasks: number;
  taskTimeout: number; // milliseconds;
  validationRequired: boolean;
  autoRetry: boolean;
  priorityWeights: {;
    high: number;
    medium: number;
    low: number;
  ;
};
};

export class SwarmOrchestrator extends EventEmitter {;
  private supabase: SupabaseClient;
  private agents: Map<string, Agent> = new Map();
  private tasks: Map<string, Task> = new Map();
  private taskQueue: string[] = [];
  private config: SwarmConfig;
  private isRunning = false;
  private orchestrationInterval?: NodeJSTimeout;
  private metricsInterval?: NodeJSTimeout;
  private performanceTracker: AgentPerformanceTracker;
  constructor(supabase: SupabaseClient, config?: Partial<SwarmConfig>) {;
    super();
    thissupabase = supabase;
    thisconfig = {;
      maxConcurrentTasks: 10;
      taskTimeout: 300000, // 5 minutes;
      validationRequired: true;
      autoRetry: true;
      priorityWeights: {;
        high: 3;
        medium: 2;
        low: 1;
      ;
};
      ..config;
    };
    // Initialize performance tracker;
    thisperformanceTracker = new AgentPerformanceTracker({;
      supabase: thissupabase;
      realTimeUpdates: true;
      aggregationIntervals: ['hour', 'day', 'week'];
    });
    // Forward performance events;
    thisperformanceTrackeron('taskStarted', (data) => {;
      thisemit('performance:taskStarted', data);
    });
    thisperformanceTrackeron('taskCompleted', (data) => {;
      thisemit('performance:taskCompleted', data);
    });
    thisperformanceTrackeron('metricRecorded', (data) => {;
      thisemit('performance:metricRecorded', data);
    });
    loggerinfo('SwarmOrchestrator initialized', LogContextSYSTEM, thisconfig);
  };

  // Agent Management;
  async registerAgent(agent: Omit<Agent, 'lastActive'>): Promise<void> {;
    const fullAgent: Agent = {;
      ..agent;
      lastActive: new Date();
    ;
};
    thisagentsset(agentid, fullAgent);
    // Store in Supabase;
    await thissupabasefrom('swarm_agents')upsert({;
      id: fullAgentid;
      name: fullAgentname;
      type: fullAgenttype;
      capabilities: fullAgentcapabilities;
      status: fullAgentstatus;
      reliability: fullAgentreliability;
      last_active: fullAgentlastActive;
    });
    thisemit('agent:registered', fullAgent);
    loggerinfo('Agent registered', LogContextSYSTEM, { agentId: agentid, name: agentname });
  };

  async updateAgentStatus(;
    agentId: string;
    status: Agent['status'];
    currentTask?: string;
  ): Promise<void> {;
    const agent = thisagentsget(agentId);
    if (!agent) return;
    agentstatus = status;
    agentcurrentTask = currentTask;
    agentlastActive = new Date();
    await thissupabase;
      from('swarm_agents');
      update({;
        status;
        current_task: currentTask;
        last_active: agentlastActive;
      });
      eq('id', agentId);
    thisemit('agent:status', { agentId, status, currentTask });
  };

  // Task Management;
  async addTask(task: Omit<Task, 'id' | 'attempts'>): Promise<string> {;
    const taskId = randomUUID();
    const fullTask: Task = {;
      ..task;
      id: taskId;
      attempts: 0;
    ;
};
    thistasksset(taskId, fullTask);
    thistaskQueuepush(taskId);
    // Store in Supabase;
    await thissupabasefrom('swarm_tasks')insert({;
      id: taskId;
      name: fullTaskname;
      description: fullTaskdescription;
      priority: fullTaskpriority;
      status: fullTaskstatus;
      dependencies: fullTaskdependencies;
      estimated_duration: fullTaskestimatedDuration;
    });
    thisemit('task:added', fullTask);
    loggerinfo('Task added to swarm', LogContextSYSTEM, { taskId, name: taskname });
    return taskId;
  };

  async addBulkTasks(tasks: Omit<Task, 'id' | 'attempts'>[]): Promise<string[]> {;
    const taskIds: string[] = [];
    for (const task of tasks) {;
      const taskId = await thisaddTask(task);
      taskIdspush(taskId);
    };

    return taskIds;
  };

  // Swarm Orchestration;
  async start(): Promise<void> {;
    if (thisisRunning) return;
    thisisRunning = true;
    loggerinfo('Starting swarm orchestration', LogContextSYSTEM);
    // Start orchestration loop;
    thisorchestrationInterval = setInterval(() => {;
      thisorchestrate();
    }, 1000); // Run every second;
    // Start metrics collection;
    thismetricsInterval = setInterval(() => {;
      thiscollectMetrics();
    }, 5000); // Every 5 seconds;
    thisemit('swarm: started');
  ;
};

  async stop(): Promise<void> {;
    thisisRunning = false;
    if (thisorchestrationInterval) {;
      clearInterval(thisorchestrationInterval);
    };

    if (thismetricsInterval) {;
      clearInterval(thismetricsInterval);
    };

    // Cleanup performance tracker;
    thisperformanceTrackerdestroy();
    loggerinfo('Stopping swarm orchestration', LogContextSYSTEM);
    thisemit('swarm: stopped');
  ;
};

  private async orchestrate(): Promise<void> {;
    // Get available agents;
    const availableAgents = Arrayfrom(thisagentsvalues())filter(;
      (agent) => agentstatus === 'idle' && agentreliability > 50;
    );
    if (availableAgentslength === 0) return;
    // Get assignable tasks;
    const assignableTasks = thisgetAssignableTasks();
    // Assign tasks to agents;
    for (const agent of availableAgents) {;
      const task = thisselectTaskForAgent(agent, assignableTasks);
      if (task) {;
        await thisassignTaskToAgent(task, agent);
        assignableTaskssplice(assignableTasksindexOf(task), 1);
      };

      if (assignableTaskslength === 0) break;
    };
  };

  private getAssignableTasks(): Task[] {;
    return Arrayfrom(thistasksvalues());
      filter((task) => {;
        // Check if task is ready;
        if (taskstatus !== 'pending') return false;
        // Check dependencies;
        for (const depId of taskdependencies) {;
          const depTask = thistasksget(depId);
          if (!depTask || depTaskstatus !== 'validated') {;
            return false;
          };
        };

        return true;
      });
      sort((a, b) => {;
        // Sort by priority;
        const priorityA = thisconfigpriorityWeights[apriority];
        const priorityB = thisconfigpriorityWeights[bpriority];
        return priorityB - priorityA;
      });
  };

  private selectTaskForAgent(agent: Agent, tasks: Task[]): Task | null {;
    // Simple matching for now - can be enhanced with capability matching;
    return tasks[0] || null;
  };

  private async assignTaskToAgent(task: Task, agent: Agent): Promise<void> {;
    taskstatus = 'assigned';
    taskassignedAgent = agentid;
    taskstartedAt = new Date();
    taskattempts++;
    agentstatus = 'busy';
    agentcurrentTask = taskid;
    // Update in Supabase;
    await Promiseall([;
      thissupabase;
        from('swarm_tasks');
        update({;
          status: taskstatus;
          assigned_agent: taskassignedAgent;
          started_at: taskstartedAt;
          attempts: taskattempts;
        });
        eq('id', taskid);
      thisupdateAgentStatus(agentid, 'busy', taskid);
    ]);
    // Track performance - task started;
    await thisperformanceTrackerstartTaskExecution(;
      agentid;
      agentname;
      agenttype;
      taskid;
      taskname;
      thiscalculateTaskComplexity(task);
    );
    thisemit('task:assigned', { task, agent });
    loggerinfo('Task assigned to agent', LogContextSYSTEM, {;
      taskId: taskid;
      agentId: agentid;
      taskName: taskname;
      agentName: agentname;
    });
    // Set timeout for task;
    setTimeout(() => {;
      thishandleTaskTimeout(taskid);
    }, thisconfigtaskTimeout);
    // Simulate task execution (in real implementation, this would be handled by the agent);
    thissimulateTaskExecution(task, agent);
  };

  private async simulateTaskExecution(task: Task, agent: Agent): Promise<void> {;
    // Update task status to in_progress;
    taskstatus = 'in_progress';
    await thissupabasefrom('swarm_tasks')update({ status: 'in_progress' })eq('id', taskid);
    thisemit('task:progress', { taskId: taskid, progress: 50 });
    // Simulate work being done;
    const duration = taskestimatedDuration || Mathrandom() * 30000 + 10000; // 10-40 seconds;

    setTimeout(async () => {;
      // Simulate success/failure (90% success rate);
      const success = Mathrandom() > 0.1;
      if (success) {;
        await thiscompleteTask(taskid, {;
          success: true;
          result: `Task ${taskname} completed successfully`;
        });
      } else {;
        await thisfailTask(taskid, 'Simulated failure for demonstration');
      };
    }, duration);
  };

  async completeTask(;
    taskId: string;
    result: { success: boolean; result?: any, error instanceof Error ? errormessage : String(error) string ;
};
  ): Promise<void> {;
    const task = thistasksget(taskId);
    if (!task) return;
    const agent = thisagentsget(taskassignedAgent!);
    if (!agent) return;
    taskstatus = resultsuccess ? 'completed' : 'failed';
    taskresult = resultresult;
    taskerror instanceof Error ? errormessage : String(error)  resulterror;
    taskcompletedAt = new Date();
    taskactualDuration = taskcompletedAtgetTime() - taskstartedAt!getTime();
    // Simulate resource usage;
    const resourceUsage: ResourceUsage = {;
      cpu_percentage: Mathrandom() * 80 + 20, // 20-100%;
      memory_mb: Mathrandom() * 1536 + 512, // 512-2048 MB;
      network_kb: Mathrandom() * 1024;
      disk_io_kb: Mathrandom() * 512;
    ;
};
    // Track performance - task completed;
    await thisperformanceTrackerendTaskExecution(;
      agentid;
      agentname;
      agenttype;
      taskid;
      resultsuccess;
      resulterror;
      resourceUsage;
    );
    // Update agent stats;
    if (resultsuccess) {;
      agenttasksCompleted++;
    } else {;
      agenttasksFailed++;
    };

    // Update agent reliability;
    const totalTasks = agenttasksCompleted + agenttasksFailed;
    agentreliability = Mathround((agenttasksCompleted / totalTasks) * 100);
    // Calculate average completion time;
    if (resultsuccess && taskactualDuration) {;
      agentaverageCompletionTime = Mathround(;
        (agentaverageCompletionTime * (agenttasksCompleted - 1) + taskactualDuration) /;
          agenttasksCompleted;
      );
    };

    // Free up agent;
    agentstatus = 'idle';
    agentcurrentTask = undefined;
    // Update in Supabase;
    await Promiseall([;
      thissupabase;
        from('swarm_tasks');
        update({;
          status: taskstatus;
          result: taskresult;
          error instanceof Error ? errormessage : String(error) taskerror;
          completed_at: taskcompletedAt;
          actual_duration: taskactualDuration;
        });
        eq('id', taskId);
      thissupabase;
        from('swarm_agents');
        update({;
          tasks_completed: agenttasksCompleted;
          tasks_failed: agenttasksFailed;
          reliability: agentreliability;
          average_completion_time: agentaverageCompletionTime;
          status: 'idle';
          current_task: null;
        });
        eq('id', agentid);
    ]);
    thisemit('task:completed', task);
    loggerinfo('Task completed', LogContextSYSTEM, {;
      taskId;
      success: resultsuccess;
      duration: taskactualDuration;
    });
    // Trigger validation if required;
    if (thisconfigvalidationRequired && resultsuccess) {;
      await thisvalidateTask(taskId);
    };
  };

  async failTask(taskId: string, error instanceof Error ? errormessage : String(error) string): Promise<void> {;
    const task = thistasksget(taskId);
    if (!task) return;
    // Check if we should retry;
    if (thisconfigautoRetry && taskattempts < taskmaxAttempts) {;
      taskstatus = 'pending';
      taskassignedAgent = undefined;
      loggerinfo('Task failed, queuing for retry', LogContextSYSTEM, {;
        taskId;
        attempts: taskattempts;
        maxAttempts: taskmaxAttempts;
        error;
      });
      await thissupabase;
        from('swarm_tasks');
        update({;
          status: 'pending';
          assigned_agent: null;
        });
        eq('id', taskId);
      thisemit('task:retry', task);
    } else {;
      await thiscompleteTask(taskId, { success: false, error instanceof Error ? errormessage : String(error) );
    ;
};
  };

  private async handleTaskTimeout(taskId: string): Promise<void> {;
    const task = thistasksget(taskId);
    if (!task || taskstatus === 'completed' || taskstatus === 'failed') return;
    loggerwarn('Task timeout', LogContextSYSTEM, { taskId, taskName: taskname });
    await thisfailTask(taskId, 'Task timed out');
  };

  async validateTask(taskId: string): Promise<void> {;
    const task = thistasksget(taskId);
    if (!task || taskstatus !== 'completed') return;
    // Simulate validation (in real implementation, this would be done by a validator agent);
    const validationScore = Mathrandom() * 30 + 70; // 70-100%;

    taskstatus = 'validated';
    taskvalidatedAt = new Date();
    taskvalidationScore = Mathround(validationScore);
    await thissupabase;
      from('swarm_tasks');
      update({;
        status: 'validated';
        validated_at: taskvalidatedAt;
        validation_score: taskvalidationScore;
      });
      eq('id', taskId);
    thisemit('task:validated', task);
    loggerinfo('Task validated', LogContextSYSTEM, {;
      taskId;
      validationScore: taskvalidationScore;
    });
  };

  // Metrics and Monitoring;
  async getMetrics(): Promise<SwarmMetrics> {;
    const tasks = Arrayfrom(thistasksvalues());
    const agents = Arrayfrom(thisagentsvalues());
    const totalTasks = taskslength;
    const completedTasks = tasksfilter((t) => tstatus === 'completed')length;
    const failedTasks = tasksfilter((t) => tstatus === 'failed')length;
    const validatedTasks = tasksfilter((t) => tstatus === 'validated')length;
    const pendingTasks = tasksfilter((t) => tstatus === 'pending')length;
    const inProgressTasks = tasksfilter(;
      (t) => tstatus === 'assigned' || tstatus === 'in_progress';
    )length;
    const completionPercentage =;
      totalTasks > 0 ? Mathround((validatedTasks / totalTasks) * 100) : 0;
    const validationPercentage =;
      completedTasks > 0 ? Mathround((validatedTasks / completedTasks) * 100) : 0;
    const completedTasksWithDuration = tasksfilter((t) => tactualDuration);
    const averageTaskDuration =;
      completedTasksWithDurationlength > 0;
        ? Mathround(;
            completedTasksWithDurationreduce((sum, t) => sum + tactualDuration!, 0) /;
              completedTasksWithDurationlength;
          );
        : 0;
    const busyAgents = agentsfilter((a) => astatus === 'busy')length;
    const agentUtilization = agentslength > 0 ? Mathround((busyAgents / agentslength) * 100) : 0;
    // Calculate estimated time remaining;
    const remainingTasks = pendingTasks + inProgressTasks;
    const averageAgentTime =;
      agentslength > 0;
        ? agentsreduce((sum, a) => sum + aaverageCompletionTime, 0) / agentslength;
        : averageTaskDuration;
    const estimatedTimeRemaining =;
      remainingTasks > 0 && agentslength > 0;
        ? Mathround((remainingTasks * averageAgentTime) / Mathmax(1, agentslength - busyAgents));
        : 0;
    // Calculate swarm efficiency;
    const totalPossibleTasks = agentsreduce((sum, a) => sum + atasksCompleted + atasksFailed, 0);
    const successfulTasks = agentsreduce((sum, a) => sum + atasksCompleted, 0);
    const swarmEfficiency =;
      totalPossibleTasks > 0 ? Mathround((successfulTasks / totalPossibleTasks) * 100) : 100;
    const metrics: SwarmMetrics = {;
      totalTasks;
      completedTasks;
      failedTasks;
      validatedTasks;
      pendingTasks;
      inProgressTasks;
      completionPercentage;
      validationPercentage;
      averageTaskDuration;
      estimatedTimeRemaining;
      agentUtilization;
      swarmEfficiency;
    };
    return metrics;
  };

  private async collectMetrics(): Promise<void> {;
    const metrics = await thisgetMetrics();
    // Store metrics in Supabase;
    await thissupabasefrom('swarm_metrics')insert({;
      metrics;
      collected_at: new Date();
    });
    thisemit('metrics:updated', metrics);
    // Log progress;
    loggerinfo('Swarm metrics', LogContextSYSTEM, {;
      completion: `${metricscompletionPercentage}%`;
      validation: `${metricsvalidationPercentage}%`;
      efficiency: `${metricsswarmEfficiency}%`;
      remaining: `${Mathround(metricsestimatedTimeRemaining / 60000)}m`;
    });
    // Check if we're done;
    if (metricscompletionPercentage === 100) {;
      loggerinfo('🎉 All tasks completed and validated!', LogContextSYSTEM);
      thisemit('swarm: complete');
    ;
};
  };

  // Progress Reporting;
  async getProgressReport(): Promise<string> {;
    const metrics = await thisgetMetrics();
    const agents = Arrayfrom(thisagentsvalues());
    const tasks = Arrayfrom(thistasksvalues());
    let report = '# Swarm Progress Report\n\n';
    report += `## Overall Progress: ${metricscompletionPercentage}%\n\n`;
    report += `### Task Summary\n`;
    report += `- Total Tasks: ${metricstotalTasks}\n`;
    report += `- Validated: ${metricsvalidatedTasks} ✓\n`;
    report += `- Completed: ${metricscompletedTasks}\n`;
    report += `- In Progress: ${metricsinProgressTasks}\n`;
    report += `- Pending: ${metricspendingTasks}\n`;
    report += `- Failed: ${metricsfailedTasks}\n\n`;
    report += `### Performance Metrics\n`;
    report += `- Validation Rate: ${metricsvalidationPercentage}%\n`;
    report += `- Average Task Duration: ${Mathround(metricsaverageTaskDuration / 1000)}s\n`;
    report += `- Swarm Efficiency: ${metricsswarmEfficiency}%\n`;
    report += `- Agent Utilization: ${metricsagentUtilization}%\n`;
    report += `- ETA: ${Mathround(metricsestimatedTimeRemaining / 60000)} minutes\n\n`;
    report += `### Agent Performance\n`;
    for (const agent of agents) {;
      report += `#### ${agentname} (${agentid})\n`;
      report += `- Status: ${agentstatus}\n`;
      report += `- Completed: ${agenttasksCompleted}\n`;
      report += `- Failed: ${agenttasksFailed}\n`;
      report += `- Reliability: ${agentreliability}%\n`;
      report += `- Avg Time: ${Mathround(agentaverageCompletionTime / 1000)}s\n\n`;
    };

    report += `### Task Details\n`;
    for (const task of tasks) {;
      const status =;
        taskstatus === 'validated';
          ? '✓';
          : taskstatus === 'failed';
            ? '✗';
            : taskstatus === 'in_progress';
              ? '⟳';
              : taskstatus === 'pending';
                ? '○';
                : '◐';
      report += `- [${status}] ${taskname}`;
      if (taskvalidationScore) {;
        report += ` (${taskvalidationScore}%)`;
      };
      if (taskactualDuration) {;
        report += ` - ${Mathround(taskactualDuration / 1000)}s`;
      };
      report += '\n';
    };
;
    return report;
  };

  private calculateTaskComplexity(task: Task): number {;
    // Calculate complexity based on various factors;
    let complexity = 1; // Base complexity;

    // Factor in dependencies;
    if (taskdependencieslength > 0) {;
      complexity += taskdependencieslength * 0.5;
    };

    // Factor in priority;
    if (taskpriority === 'high') {;
      complexity += 1;
    } else if (taskpriority === 'medium') {;
      complexity += 0.5;
    };

    // Factor in retry attempts;
    if (taskattempts > 0) {;
      complexity += taskattempts * 0.3;
    };

    // Factor in estimated duration;
    if (taskestimatedDuration) {;
      if (taskestimatedDuration > 60000) {;
        // > 1 minute;
        complexity += 1;
      };
      if (taskestimatedDuration > 300000) {;
        // > 5 minutes;
        complexity += 1;
      };
    };

    // Cap at level 5;
    return Mathmin(Mathround(complexity), 5);
  };

  // Get performance metrics for agents;
  async getAgentPerformanceMetrics(agentId?: string): Promise<unknown> {;
    if (agentId) {;
      return thisperformanceTrackergetAgentPerformanceSummary(agentId);
    };

    // Get metrics for all agents;
    const agentIds = Arrayfrom(thisagentskeys());
    const comparisons = await thisperformanceTrackercompareAgents(agentIds);
    return ObjectfromEntries(comparisons);
  };

  // Get performance trends;
  async getPerformanceTrends(;
    agentId: string;
    period: 'hour' | 'day' | 'week' | 'month' = 'day';
    lookback = 7;
  ): Promise<any[]> {;
    return thisperformanceTrackergetPerformanceTrends(agentId, period, lookback);
  };
};

// Factory function;
export function createSwarmOrchestrator(;
  supabase: SupabaseClient;
  config?: Partial<SwarmConfig>;
): SwarmOrchestrator {;
  return new SwarmOrchestrator(supabase, config);
};
