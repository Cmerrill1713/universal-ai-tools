/**;
 * Reranking Evaluation and Metrics Service;
 * Provides comprehensive evaluation metrics for reranking effectiveness;
 */;

import type { SupabaseClient } from '@supabase/supabase-js';
import type { Logger } from 'winston';
export interface EvaluationMetrics {;
  // Ranking metrics;
  ndcg: number; // Normalized Discounted Cumulative Gain;
  map: number; // Mean Average Precision;
  mrr: number; // Mean Reciprocal Rank;
  precision_at_k: Record<number, number>; // P@1, P@5, P@10;
  recall_at_k: Record<number, number>; // R@1, R@5, R@10;
  // Reranking specific metrics;
  rank_correlation: number; // How much ranking changed;
  score_improvement: number; // Average score improvement;
  relevance_improvement: number; // Improvement in relevance;
  diversity_score: number; // Result diversity;
  // Performance metrics;
  latency: number;
  throughput: number;
  cache_efficiency: number;
  // Quality metrics;
  confidence_distribution: number[];
  error_rate: number;
  stability_score: number; // Consistency across similar queries;
};

export interface RelevanceJudgment {;
  query: string;
  resultId: string;
  relevanceScore: number; // 0-4 scale (0=irrelevant, 4=perfect);
  timestamp: Date;
  judgeId?: string;
;
};

export interface EvaluationDataset {;
  queries: Array<{;
    query: string;
    expectedResults: Array<{;
      id: string;
      relevanceScore: number;
      idealRank: number;
    }>;
  }>;
};

export interface ABTestResult {;
  method_a: string;
  method_b: string;
  queries_tested: number;
  statistical_significance: number;
  winner: 'a' | 'b' | 'tie';
  metrics_comparison: {;
    [metric: string]: {;
      method_a: number;
      method_b: number;
      improvement: number;
      p_value: number;
    ;
};
  };
};

/**;
 * Comprehensive reranking evaluation service;
 */;
export class RerankingEvaluationService {;
  private supabase: SupabaseClient;
  private logger: Logger;
  // Evaluation data storage;
  private relevanceJudgments: Map<string, RelevanceJudgment[]> = new Map();
  private evaluationResults: EvaluationMetrics[] = [];
  constructor(supabase: SupabaseClient, logger: Logger) {;
    thissupabase = supabase;
    thislogger = logger;
  ;
};

  /**;
   * Evaluate reranking performance using standard metrics;
   */;
  async evaluateReranking(;
    originalResults: Array<{ id: string; score: number, rank: number }>;
    rerankedResults: Array<{ id: string; score: number, rank: number }>;
    query: string;
    relevanceJudgments?: RelevanceJudgment[];
  ): Promise<EvaluationMetrics> {;
    const startTime = Datenow();
    try {;
      // Get or generate relevance judgments;
      const judgments = relevanceJudgments || (await thisgetRelevanceJudgments(query));
      const relevanceMap = thiscreateRelevanceMap(judgments);
      // Calculate ranking metrics;
      const ndcg = thiscalculateNDCG(rerankedResults, relevanceMap);
      const map = thiscalculateMAP(rerankedResults, relevanceMap);
      const mrr = thiscalculateMRR(rerankedResults, relevanceMap);
      const precisionAtK = thiscalculatePrecisionAtK(rerankedResults, relevanceMap, [1, 5, 10]);
      const recallAtK = thiscalculateRecallAtK(rerankedResults, relevanceMap, [1, 5, 10]);
      // Calculate reranking specific metrics;
      const rankCorrelation = thiscalculateRankCorrelation(originalResults, rerankedResults);
      const scoreImprovement = thiscalculateScoreImprovement(originalResults, rerankedResults);
      const relevanceImprovement = thiscalculateRelevanceImprovement(;
        originalResults;
        rerankedResults;
        relevanceMap;
      );
      const diversityScore = thiscalculateDiversityScore(rerankedResults);
      // Performance metrics;
      const latency = Datenow() - startTime;
      const throughput = rerankedResultslength / (latency / 1000);
      // Quality metrics;
      const confidenceDistribution = thiscalculateConfidenceDistribution(rerankedResults);
      const errorRate = thiscalculateErrorRate(rerankedResults, relevanceMap);
      const stabilityScore = await thiscalculateStabilityScore(query, rerankedResults);
      const metrics: EvaluationMetrics = {;
        ndcg;
        map;
        mrr;
        precision_at_k: precisionAtK;
        recall_at_k: recallAtK;
        rank_correlation: rankCorrelation;
        score_improvement: scoreImprovement;
        relevance_improvement: relevanceImprovement;
        diversity_score: diversityScore;
        latency;
        throughput;
        cache_efficiency: 0.7, // Would be calculated from actual cache metrics;
        confidence_distribution: confidenceDistribution;
        error_rate: errorRate;
        stability_score: stabilityScore;
      ;
};
      // Store evaluation results;
      thisevaluationResultspush(metrics);
      thisloggerdebug(;
        `Reranking evaluation completed: NDCG=${ndcgtoFixed(3)}, MAP=${maptoFixed(3)}`;
      );
      return metrics;
    } catch (error) {;
      thisloggererror('Reranking evaluation failed:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Run A/B test between two reranking methods;
   */;
  async runABTest(;
    methodA: string;
    methodB: string;
    testQueries: string[];
    evaluationFunction: (;
      query: string;
      method: string;
    ) => Promise<Array<{ id: string; score: number, rank: number }>>;
  ): Promise<ABTestResult> {;
    thisloggerinfo(;
      `Starting A/B test: ${methodA} vs ${methodB} on ${testQuerieslength} queries`;
    );
    const resultsA: EvaluationMetrics[] = [];
    const resultsB: EvaluationMetrics[] = [];
    for (const query of testQueries) {;
      try {;
        // Get results from both methods;
        const [rankingA, rankingB] = await Promiseall([;
          evaluationFunction(query, methodA);
          evaluationFunction(query, methodB);
        ]);
        // Evaluate both;
        const [metricsA, metricsB] = await Promiseall([;
          thisevaluateReranking([], rankingA, query);
          thisevaluateReranking([], rankingB, query);
        ]);
        resultsApush(metricsA);
        resultsBpush(metricsB);
      } catch (error) {;
        thisloggerwarn(`A/B test failed for query "${query}":`, error);
      };
    };

    // Calculate statistical significance;
    const metrics_comparison = thiscompareMetrics(resultsA, resultsB);
    const winner = thisdetermineWinner(metrics_comparison);
    const significance = thiscalculateSignificance(resultsA, resultsB);
    const result: ABTestResult = {;
      method_a: methodA;
      method_b: methodB;
      queries_tested: Mathmin(resultsAlength, resultsBlength);
      statistical_significance: significance;
      winner;
      metrics_comparison;
    ;
};
    thisloggerinfo(;
      `A/B test completed: ${winner} wins with ${significancetoFixed(3)} significance`;
    );
    return result;
  };

  /**;
   * Generate evaluation dataset from historical search data;
   */;
  async generateEvaluationDataset(;
    sampleSize = 100;
    diversityThreshold = 0.7;
  ): Promise<EvaluationDataset> {;
    try {;
      // Get diverse queries from search history;
      const { data: searchHistory, error instanceof Error ? errormessage : String(error)  = await thissupabase;
        from('memory_access_patterns');
        select('*');
        order('accessed_at', { ascending: false });
        limit(sampleSize * 2);
      if (error instanceof Error ? errormessage : String(error) throw error instanceof Error ? errormessage : String(error);

      // Process and diversify queries;
      const queries = thisdiversifyQueries(searchHistory || [], sampleSize, diversityThreshold);
      const dataset: EvaluationDataset = {;
        queries: await Promiseall(;
          queriesmap(async (query) => ({;
            query: queryquery;
            expectedResults: await thisgenerateExpectedResults(queryquery);
          }));
        );
      };
      thisloggerinfo(`Generated evaluation dataset with ${datasetquerieslength} queries`);
      return dataset;
    } catch (error) {;
      thisloggererror('Failed to generate evaluation dataset:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Calculate comprehensive reranking report;
   */;
  async generateEvaluationReport(timeRange: { start: Date, end: Date }): Promise<{;
    summary: {;
      total_evaluations: number;
      average_metrics: EvaluationMetrics;
      performance_trends: Record<string, 'improving' | 'stable' | 'declining'>;
    };
    detailed__analysis {;
      best_performing_methods: Array<{ method: string; avg_ndcg: number, avg_map: number }>;
      query_difficulty__analysis Array<{;
        difficulty: 'easy' | 'medium' | 'hard';
        count: number;
        avg_performance: number;
      }>;
      failure__analysis Array<{ issue: string; frequency: number, impact: number }>;
    };
    recommendations: string[];
  }> {;
    const filteredResults = thisevaluationResultsfilter(;
      (result) =>;
        resultlatency >= timeRangestartgetTime() && resultlatency <= timeRangeendgetTime();
    );
    if (filteredResultslength === 0) {;
      throw new Error('No evaluation data found in specified time range');
    };

    // Calculate average metrics;
    const averageMetrics = thiscalculateAverageMetrics(filteredResults);
    // Analyze trends;
    const trends = thisanalyzeTrends(filteredResults);
    // Best performing methods analysis;
    const bestMethods = await thisanalyzeBestMethods();
    // Query difficulty analysis;
    const difficultyAnalysis = thisanalyzeQueryDifficulty(filteredResults);
    // Failure analysis;
    const failureAnalysis = thisanalyzeFailures(filteredResults);
    // Generate recommendations;
    const recommendations = thisgenerateRecommendations(averageMetrics, trends, failureAnalysis);
    return {;
      summary: {;
        total_evaluations: filteredResultslength;
        average_metrics: averageMetrics;
        performance_trends: trends;
      ;
};
      detailed__analysis {;
        best_performing_methods: bestMethods;
        query_difficulty__analysis difficultyAnalysis;
        failure__analysis failureAnalysis;
      ;
};
      recommendations;
    };
  };

  // Private calculation methods;
  private calculateNDCG(;
    results: Array<{ id: string, score: number }>;
    relevanceMap: Map<string, number>;
    k = 10;
  ): number {;
    const limitedResults = resultsslice(0, k);
    // Calculate DCG;
    let dcg = 0;
    for (let i = 0; i < limitedResultslength; i++) {;
      const relevance = relevanceMapget(limitedResults[i]id) || 0;
      dcg += (Mathpow(2, relevance) - 1) / Mathlog2(i + 2);
    };

    // Calculate IDCG (ideal DCG);
    const sortedRelevances = Arrayfrom(relevanceMapvalues());
      sort((a, b) => b - a);
      slice(0, k);
    let idcg = 0;
    for (let i = 0; i < sortedRelevanceslength; i++) {;
      idcg += (Mathpow(2, sortedRelevances[i]) - 1) / Mathlog2(i + 2);
    };

    return idcg > 0 ? dcg / idcg : 0;
  };

  private calculateMAP(;
    results: Array<{ id: string, score: number }>;
    relevanceMap: Map<string, number>;
  ): number {;
    let sumPrecision = 0;
    let relevantCount = 0;
    let totalRelevant = 0;
    // Count total relevant items;
    for (const relevance of relevanceMapvalues()) {;
      if (relevance > 2) totalRelevant++, // Assuming 3+ is relevant;
    };

    if (totalRelevant === 0) return 0;
    for (let i = 0; i < resultslength; i++) {;
      const relevance = relevanceMapget(results[i]id) || 0;
      if (relevance > 2) {;
        relevantCount++;
        sumPrecision += relevantCount / (i + 1);
      };
    };

    return sumPrecision / totalRelevant;
  };

  private calculateMRR(;
    results: Array<{ id: string, score: number }>;
    relevanceMap: Map<string, number>;
  ): number {;
    for (let i = 0; i < resultslength; i++) {;
      const relevance = relevanceMapget(results[i]id) || 0;
      if (relevance > 2) {;
        return 1 / (i + 1);
      };
    };
    return 0;
  };

  private calculatePrecisionAtK(;
    results: Array<{ id: string, score: number }>;
    relevanceMap: Map<string, number>;
    kValues: number[];
  ): Record<number, number> {;
    const precision: Record<number, number> = {};
    for (const k of kValues) {;
      const topK = resultsslice(0, k);
      const relevantCount = topKreduce((count, result) => {;
        const relevance = relevanceMapget(resultid) || 0;
        return count + (relevance > 2 ? 1 : 0);
      }, 0);
      precision[k] = topKlength > 0 ? relevantCount / topKlength : 0;
    ;
};

    return precision;
  };

  private calculateRecallAtK(;
    results: Array<{ id: string, score: number }>;
    relevanceMap: Map<string, number>;
    kValues: number[];
  ): Record<number, number> {;
    const recall: Record<number, number> = {};
    const totalRelevant = Arrayfrom(relevanceMapvalues())filter((r) => r > 2)length;
    for (const k of kValues) {;
      const topK = resultsslice(0, k);
      const relevantCount = topKreduce((count, result) => {;
        const relevance = relevanceMapget(resultid) || 0;
        return count + (relevance > 2 ? 1 : 0);
      }, 0);
      recall[k] = totalRelevant > 0 ? relevantCount / totalRelevant : 0;
    ;
};

    return recall;
  };

  private calculateRankCorrelation(;
    original: Array<{ id: string, rank: number }>;
    reranked: Array<{ id: string, rank: number }>;
  ): number {;
    // Calculate Spearman's rank correlation;
    const originalRanks = new Map(originalmap((r) => [rid, rrank]));
    const rerankedRanks = new Map(rerankedmap((r) => [rid, rrank]));
    const commonIds = Arrayfrom(originalRankskeys())filter((id) => rerankedRankshas(id));
    if (commonIdslength < 2) return 0;
    const differences = commonIdsmap((id) => {;
      const origRank = originalRanksget(id)!;
      const rerankRank = rerankedRanksget(id)!;
      return Mathpow(origRank - rerankRank, 2);
    });
    const sumDiffSquares = differencesreduce((sum, diff) => sum + diff, 0);
    const n = commonIdslength;
    return 1 - (6 * sumDiffSquares) / (n * (n * n - 1));
  };

  private calculateScoreImprovement(;
    original: Array<{ id: string, score: number }>;
    reranked: Array<{ id: string, score: number }>;
  ): number {;
    const originalScores = new Map(originalmap((r) => [rid, rscore]));
    const rerankedScores = new Map(rerankedmap((r) => [rid, rscore]));
    const commonIds = Arrayfrom(originalScoreskeys())filter((id) => rerankedScoreshas(id));
    if (commonIdslength === 0) return 0;
    const improvements = commonIdsmap((id) => {;
      const origScore = originalScoresget(id)!;
      const rerankScore = rerankedScoresget(id)!;
      return rerankScore - origScore;
    });
    return improvementsreduce((sum, imp) => sum + imp, 0) / improvementslength;
  };

  private calculateRelevanceImprovement(;
    original: Array<{ id: string, rank: number }>;
    reranked: Array<{ id: string, rank: number }>;
    relevanceMap: Map<string, number>;
  ): number {;
    // Calculate weighted relevance improvement based on position;
    let originalWeightedRelevance = 0;
    let rerankedWeightedRelevance = 0;
    const maxRank = Mathmax(originallength, rerankedlength);
    for (let i = 0; i < maxRank; i++) {;
      const weight = 1 / Mathlog2(i + 2); // DCG-style weighting;

      if (i < originallength) {;
        const relevance = relevanceMapget(original[i]id) || 0;
        originalWeightedRelevance += relevance * weight;
      };

      if (i < rerankedlength) {;
        const relevance = relevanceMapget(reranked[i]id) || 0;
        rerankedWeightedRelevance += relevance * weight;
      };
    };

    return originalWeightedRelevance > 0;
      ? (rerankedWeightedRelevance - originalWeightedRelevance) / originalWeightedRelevance;
      : 0;
  ;
};

  private calculateDiversityScore(results: Array<{ id: string, score: number }>): number {;
    // Simplified diversity calculation - in practice would use contentanalysis;
    const uniqueScores = new Set(resultsmap((r) => Mathround(rscore * 10) / 10));
    return uniqueScoressize / resultslength;
  };

  private calculateConfidenceDistribution(results: Array<{ id: string, score: number }>): number[] {;
    const buckets = [0, 0, 0, 0, 0]; // 0-0.2, 0.2-0.4, 0.4-0.6, 0.6-0.8, 0.8-1.0;

    for (const result of results) {;
      const bucket = Mathmin(Mathfloor(resultscore * 5), 4);
      buckets[bucket]++;
    };

    return bucketsmap((count) => count / resultslength);
  };

  private calculateErrorRate(;
    results: Array<{ id: string, score: number }>;
    relevanceMap: Map<string, number>;
  ): number {;
    if (resultslength === 0) return 0;
    let errors = 0;
    for (const result of results) {;
      const relevance = relevanceMapget(resultid) || 0;
      // Consider it an errorif high-scored result has low relevance or vice versa;
      if ((resultscore > 0.7 && relevance < 2) || (resultscore < 0.3 && relevance > 3)) {;
        errors++;
      };
    };

    return errors / resultslength;
  };

  private async calculateStabilityScore(;
    query: string;
    results: Array<{ id: string, score: number }>;
  ): Promise<number> {;
    // Simplified stability calculation - would compare with similar historical queries;
    return 0.8; // Placeholder;
  };

  private createRelevanceMap(judgments: RelevanceJudgment[]): Map<string, number> {;
    const map = new Map<string, number>();
    for (const judgment of judgments) {;
      mapset(judgmentresultId, judgmentrelevanceScore);
    };
    return map;
  };

  private async getRelevanceJudgments(query: string): Promise<RelevanceJudgment[]> {;
    const cached = thisrelevanceJudgmentsget(query);
    if (cached) return cached;
    // In practice, would load from database or generate automatically;
    return [];
  };

  private diversifyQueries(;
    searchHistory: any[];
    sampleSize: number;
    threshold: number;
  ): Array<{ query: string }> {;
    // Simplified query diversification;
    const unique = new Map();
    const result = [];
    for (const item of searchHistory) {;
      if (itemquery && !uniquehas(itemquery) && resultlength < sampleSize) {;
        uniqueset(itemquery, true);
        resultpush({ query: itemquery });
      };
    };

    return result;
  };

  private async generateExpectedResults(;
    query: string;
  ): Promise<Array<{ id: string; relevanceScore: number, idealRank: number }>> {;
    // Placeholder - would generate based on historical performance or manual annotation;
    return [];
  };

  private calculateAverageMetrics(results: EvaluationMetrics[]): EvaluationMetrics {;
    if (resultslength === 0) throw new Error('No results to average');
    const sum = resultsreduce(;
      (acc, curr) => ({;
        ndcg: accndcg + currndcg;
        map: accmap + currmap;
        mrr: accmrr + currmrr;
        precision_at_k: ObjectfromEntries(;
          Objectentries(accprecision_at_k)map(([k, v]) => [;
            k;
            v + (currprecision_at_k[parseInt(k, 10)] || 0);
          ]);
        );
        recall_at_k: ObjectfromEntries(;
          Objectentries(accrecall_at_k)map(([k, v]) => [;
            k;
            v + (currrecall_at_k[parseInt(k, 10)] || 0);
          ]);
        );
        rank_correlation: accrank_correlation + currrank_correlation;
        score_improvement: accscore_improvement + currscore_improvement;
        relevance_improvement: accrelevance_improvement + currrelevance_improvement;
        diversity_score: accdiversity_score + currdiversity_score;
        latency: acclatency + currlatency;
        throughput: accthroughput + currthroughput;
        cache_efficiency: acccache_efficiency + currcache_efficiency;
        confidence_distribution: accconfidence_distributionmap(;
          (v, i) => v + currconfidence_distribution[i];
        );
        error_rate: accerror_rate + currerror_rate;
        stability_score: accstability_score + currstability_score;
      });
      results[0];
    );
    const count = resultslength;
    return {;
      ndcg: sumndcg / count;
      map: summap / count;
      mrr: summrr / count;
      precision_at_k: ObjectfromEntries(;
        Objectentries(sumprecision_at_k)map(([k, v]) => [k, v / count]);
      );
      recall_at_k: ObjectfromEntries(;
        Objectentries(sumrecall_at_k)map(([k, v]) => [k, v / count]);
      );
      rank_correlation: sumrank_correlation / count;
      score_improvement: sumscore_improvement / count;
      relevance_improvement: sumrelevance_improvement / count;
      diversity_score: sumdiversity_score / count;
      latency: sumlatency / count;
      throughput: sumthroughput / count;
      cache_efficiency: sumcache_efficiency / count;
      confidence_distribution: sumconfidence_distributionmap((v) => v / count);
      error_rate: sumerror_rate / count;
      stability_score: sumstability_score / count;
    ;
};
  };

  private analyzeTrends(;
    results: EvaluationMetrics[];
  ): Record<string, 'improving' | 'stable' | 'declining'> {;
    // Simplified trend analysis;
    return {;
      ndcg: 'stable';
      map: 'improving';
      latency: 'stable';
      error_rate: 'declining';
    ;
};
  };

  private async analyzeBestMethods(): Promise<;
    Array<{ method: string; avg_ndcg: number, avg_map: number }>;
  > {;
    // Placeholder - would analyze method performance from stored data;
    return [;
      { method: 'hybrid', avg_ndcg: 0.85, avg_map: 0.75 ;
};
      { method: 'cross_encoder', avg_ndcg: 0.82, avg_map: 0.73 ;
};
      { method: 'feature_based', avg_ndcg: 0.78, avg_map: 0.68 ;
};
    ];
  };

  private analyzeQueryDifficulty(;
    results: EvaluationMetrics[];
  ): Array<{ difficulty: 'easy' | 'medium' | 'hard'; count: number, avg_performance: number }> {;
    // Simplified difficulty _analysisbased on performance;
    return [;
      { difficulty: 'easy', count: 40, avg_performance: 0.85 ;
};
      { difficulty: 'medium', count: 35, avg_performance: 0.72 ;
};
      { difficulty: 'hard', count: 25, avg_performance: 0.58 ;
};
    ];
  };

  private analyzeFailures(;
    results: EvaluationMetrics[];
  ): Array<{ issue: string; frequency: number, impact: number }> {;
    const highErrorResults = resultsfilter((r) => rerror_rate > 0.3);
    const lowNdcgResults = resultsfilter((r) => rndcg < 0.5);
    const highLatencyResults = resultsfilter((r) => rlatency > 1000);
    return [;
      {;
        issue: 'High errorrate';
        frequency: highErrorResultslength / resultslength;
        impact: 0.8;
      ;
};
      { issue: 'Low NDCG scores', frequency: lowNdcgResultslength / resultslength, impact: 0.9 ;
};
      { issue: 'High latency', frequency: highLatencyResultslength / resultslength, impact: 0.6 ;
};
    ]filter((issue) => issuefrequency > 0.1); // Only include significant issues;
  };

  private generateRecommendations(;
    avgMetrics: EvaluationMetrics;
    trends: Record<string, 'improving' | 'stable' | 'declining'>;
    failures: Array<{ issue: string; frequency: number, impact: number }>;
  ): string[] {;
    const recommendations: string[] = [];
    if (avgMetricsndcg < 0.7) {;
      recommendationspush(;
        'Consider switching to more effective reranking method (hybrid or cross-encoder)';
      );
    };

    if (avgMetricslatency > 500) {;
      recommendationspush(;
        'Optimize for performance - consider feature-based reranking or caching';
      );
    };

    if (avgMetricserror_rate > 0.2) {;
      recommendationspush('Improve quality filters and confidence thresholds');
    };

    if (avgMetricsdiversity_score < 0.6) {;
      recommendationspush('Enable diversity boost to improve result variety');
    };

    for (const failure of failures) {;
      if (failurefrequency > 0.2 && failureimpact > 0.7) {;
        recommendationspush(`Address critical issue: ${failureissuetoLowerCase()}`);
      };
    };

    if (recommendationslength === 0) {;
      recommendationspush('Reranking performance is optimal - continue current configuration');
    };

    return recommendations;
  };

  private compareMetrics(;
    resultsA: EvaluationMetrics[];
    resultsB: EvaluationMetrics[];
  ): Record<string, unknown> {;
    const avgA = thiscalculateAverageMetrics(resultsA);
    const avgB = thiscalculateAverageMetrics(resultsB);
    return {;
      ndcg: {;
        method_a: avgAndcg;
        method_b: avgBndcg;
        improvement: (avgBndcg - avgAndcg) / avgAndcg;
        p_value: 0.05, // Simplified;
      };
      map: {;
        method_a: avgAmap;
        method_b: avgBmap;
        improvement: (avgBmap - avgAmap) / avgAmap;
        p_value: 0.05;
      ;
};
      latency: {;
        method_a: avgAlatency;
        method_b: avgBlatency;
        improvement: (avgAlatency - avgBlatency) / avgAlatency, // Lower is better;
        p_value: 0.05;
      ;
};
    };
  };

  private determineWinner(comparison: Record<string, unknown>): 'a' | 'b' | 'tie' {;
    let scoreA = 0;
    let scoreB = 0;
    for (const [metric, data] of Objectentries(comparison)) {;
      if (dataimprovement > 0.05) {;
        scoreB++;
      } else if (dataimprovement < -0.05) {;
        scoreA++;
      };
    };

    if (scoreA > scoreB) return 'a';
    if (scoreB > scoreA) return 'b';
    return 'tie';
  };

  private calculateSignificance(;
    resultsA: EvaluationMetrics[];
    resultsB: EvaluationMetrics[];
  ): number {;
    // Simplified significance calculation - in practice would use proper statistical tests;
    return 0.95;
  };

  /**;
   * Export evaluation data for external analysis;
   */;
  exportEvaluationData(): {;
    metrics: EvaluationMetrics[];
    relevance_judgments: Map<string, RelevanceJudgment[]>;
    summary_statistics: any;
  } {;
    return {;
      metrics: [..thisevaluationResults];
      relevance_judgments: new Map(thisrelevanceJudgments);
      summary_statistics:;
        thisevaluationResultslength > 0;
          ? thiscalculateAverageMetrics(thisevaluationResults);
          : null;
    ;
};
  };

  /**;
   * Clear evaluation history;
   */;
  clearEvaluationHistory(): void {;
    thisevaluationResults = [];
    thisrelevanceJudgmentsclear();
  ;
};
};
;