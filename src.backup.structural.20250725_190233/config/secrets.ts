import crypto from 'crypto';
import { config } from './environment';
// Encryption utilities;
export class SecretsManager {;
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyLength = 32;
  private readonly ivLength = 16;
  private readonly tagLength = 16;
  private encryptionKey: Buffer;
  constructor() {;
    thisencryptionKey = thisderiveKey(configsecurityencryptionKey);
  ;
};

  /**;
   * Derive encryption key from the base key;
   */;
  private deriveKey(baseKey: string): Buffer {;
    return cryptoscryptSync(baseKey, 'universal-ai-tools', thiskeyLength);
  };

  /**;
   * Encrypt sensitive data;
   */;
  encrypt(plaintext: string): string {;
    const iv = cryptorandomBytes(thisivLength);
    const cipher = cryptocreateCipheriv(thisalgorithm, thisencryptionKey, iv);
    ciphersetAAD(Bufferfrom('universal-ai-tools'));
    let encrypted = cipherupdate(plaintext, 'utf8', 'hex');
    encrypted += cipherfinal('hex');
    const tag = ciphergetAuthTag();
    // Combine IV + tag + encrypted data;
    const result = ivtoString('hex') + tagtoString('hex') + encrypted;
    return result;
  };

  /**;
   * Decrypt sensitive data;
   */;
  decrypt(encryptedData: string): string {;
    const ivHex = encryptedDataslice(0, thisivLength * 2);
    const tagHex = encryptedDataslice(thisivLength * 2, (thisivLength + thistagLength) * 2);
    const encrypted = encryptedDataslice((thisivLength + thistagLength) * 2);
    const iv = Bufferfrom(ivHex, 'hex');
    const tag = Bufferfrom(tagHex, 'hex');
    const decipher = cryptocreateDecipheriv(thisalgorithm, thisencryptionKey, iv);
    deciphersetAAD(Bufferfrom('universal-ai-tools'));
    deciphersetAuthTag(tag);
    let decrypted = decipherupdate(encrypted, 'hex', 'utf8');
    decrypted += decipherfinal('utf8');
    return decrypted;
  };

  /**;
   * Generate a secure random key;
   */;
  generateKey(length = 32): string {;
    return cryptorandomBytes(length)toString('hex');
  };

  /**;
   * Hash a password or sensitive string;
   */;
  hash(data: string, salt?: string): { hash: string; salt: string } {;
    const saltBuffer = salt ? Bufferfrom(salt, 'hex') : cryptorandomBytes(16);
    const hash = cryptoscryptSync(data, saltBuffer, 64);
    return {;
      hash: hashtoString('hex');
      salt: saltBuffertoString('hex');
    ;
};
  };

  /**;
   * Verify a hash;
   */;
  verifyHash(data: string, hash: string, salt: string): boolean {;
    const { hash: computedHash } = thishash(data, salt);
    return computedHash === hash;
  };
};

// Singleton instance;
export const secretsManager = new SecretsManager();
// API Key management;
export class APIKeyManager {;
  private keys: Map<string, { encrypted: string; permissions: string[] }> = new Map();
  /**;
   * Store an API key securely;
   */;
  storeAPIKey(keyName: string, apiKey: string, permissions: string[] = []): string {;
    const encrypted = secretsManagerencrypt(apiKey);
    const keyId = secretsManagergenerateKey(16);
    thiskeysset(keyId, {;
      encrypted;
      permissions;
    });
    return keyId;
  };

  /**;
   * Retrieve and decrypt an API key;
   */;
  getAPIKey(keyId: string): { apiKey: string; permissions: string[] } | null {;
    const keyData = thiskeysget(keyId);
    if (!keyData) return null;
    const apiKey = secretsManagerdecrypt(keyDataencrypted);
    return {;
      apiKey;
      permissions: keyDatapermissions;
    ;
};
  };

  /**;
   * Revoke an API key;
   */;
  revokeAPIKey(keyId: string): boolean {;
    return thiskeysdelete(keyId);
  };

  /**;
   * List all API key IDs (without revealing the keys);
   */;
  listKeys(): string[] {;
    return Arrayfrom(thiskeyskeys());
  };
};

// Singleton instance;
export const apiKeyManager = new APIKeyManager();
// Environment-specific secrets;
export interface SecretConfig {;
  name: string;
  value: string;
  encrypted?: boolean;
  environment?: string;
;
};

export class EnvironmentSecrets {;
  private secrets: Map<string, SecretConfig> = new Map();
  /**;
   * Set a secret value;
   */;
  setSecret(;
    name: string;
    value: string;
    options: {;
      encrypt?: boolean;
      environment?: string;
    } = {};
  ): void {;
    const { encrypt = true, environment = configserverenv } = options;
    const secret: SecretConfig = {;
      name;
      value: encrypt ? secretsManagerencrypt(value) : value;
      encrypted: encrypt;
      environment;
    ;
};
    thissecretsset(name, secret);
  };

  /**;
   * Get a secret value;
   */;
  getSecret(name: string): string | null {;
    const secret = thissecretsget(name);
    if (!secret) return null;
    // Check environment match;
    if (secretenvironment && secretenvironment !== configserverenv) {;
      return null;
    };

    return secretencrypted ? secretsManagerdecrypt(secretvalue) : secretvalue;
  };

  /**;
   * Delete a secret;
   */;
  deleteSecret(name: string): boolean {;
    return thissecretsdelete(name);
  };

  /**;
   * List all secret names for current environment;
   */;
  listSecrets(): string[] {;
    return Arrayfrom(thissecretsentries());
      filter(([_, secret]) => !secretenvironment || secretenvironment === configserverenv);
      map(([name]) => name);
  };
};

// Singleton instance;
export const environmentSecrets = new EnvironmentSecrets();
// Utility functions;
export function maskSecret(secret: string, visibleChars = 4): string {;
  if (secretlength <= visibleChars) {;
    return '*'repeat(secretlength);
  };

  const start = secretslice(0, visibleChars);
  const masked = '*'repeat(secretlength - visibleChars);
  return start + masked;
};

export function validateSecretStrength(secret: string): {;
  isStrong: boolean;
  score: number;
  feedback: string[];
} {;
  const feedback: string[] = [];
  let score = 0;
  // Length check;
  if (secretlength >= 12) score += 25;
  else feedbackpush('Secret should be at least 12 characters long');
  // Complexity checks;
  if (/[a-z]/test(secret)) score += 10;
  else feedbackpush('Secret should contain lowercase letters');
  if (/[A-Z]/test(secret)) score += 10;
  else feedbackpush('Secret should contain uppercase letters');
  if (/[0-9]/test(secret)) score += 10;
  else feedbackpush('Secret should contain numbers');
  if (/[^a-zA-Z0-9]/test(secret)) score += 15;
  else feedbackpush('Secret should contain special characters');
  // Entropy check;
  const entropy = calculateEntropy(secret);
  if (entropy >= 4) score += 20;
  else feedbackpush('Secret should have higher entropy (more randomness)');
  // Common patterns check;
  if (!/(.)\1{2}/test(secret)) score += 10;
  else feedbackpush('Secret should not contain repeated characters');
  return {;
    isStrong: score >= 70;
    score;
    feedback;
  ;
};
};

function calculateEntropy(str: string): number {;
  const freq: Record<string, number> = {};
  // Count character frequencies;
  for (const char of str) {;
    freq[char] = (freq[char] || 0) + 1;
  };

  // Calculate Shannon entropy;
  const len = strlength;
  let entropy = 0;
  for (const count of Objectvalues(freq)) {;
    const p = count / len;
    entropy -= p * Mathlog2(p);
  };

  return entropy;
};

// Classes are already exported above;
