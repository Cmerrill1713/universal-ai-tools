import { EventEmitter } from 'events';
import { Redis } from 'ioredis';
import { logger } from '../../utils/logger';
import { LRUCache } from './lru-cache';
interface WriteThroughOptions {;
  localCacheSize?: number;
  localCacheTTL?: number;
  remoteTTL?: number;
  namespace?: string;
  serializer?: (value: any) => string;
  deserializer?: (data: string) => any;
;
};

export class WriteThroughCache<T = any> extends EventEmitter {;
  private localCache: LRUCache<T>;
  private redis: Redis;
  private namespace: string;
  private remoteTTL: number;
  private serializer: (value: any) => string;
  private deserializer: (data: string) => any;
  private pendingWrites: Map<string, Promise<void>>;
  constructor(redisUrl: string, options: WriteThroughOptions = {}) {;
    super();
    thisredis = new Redis(redisUrl);
    thisnamespace = optionsnamespace || 'wt';
    thisremoteTTL = optionsremoteTTL || 3600;
    thisserializer = optionsserializer || JSONstringify;
    thisdeserializer = optionsdeserializer || JSONparse;
    thispendingWrites = new Map();
    // Initialize local cache;
    thislocalCache = new LRUCache<T>({;
      maxSize: optionslocalCacheSize || 50 * 1024 * 1024, // 50MB;
      ttl: optionslocalCacheTTL || 300, // 5 minutes;
      onEvict: (key: string) => {;
        thisemit('local:evict', key);
      };
    });
    thissetupLocalCacheListeners();
  };

  private setupLocalCacheListeners(): void {;
    thislocalCacheon('hit', (key: string) => {;
      thisemit('local:hit', key);
    });
    thislocalCacheon('miss', (key: string) => {;
      thisemit('local:miss', key);
    });
  };

  private getRedisKey(key: string): string {;
    return `${thisnamespace}:${key}`;
  };

  async get(key: string): Promise<T | undefined> {;
    // Check local cache first;
    const localValue = thislocalCacheget(key);
    if (localValue !== undefined) {;
      thisemit('hit', key, 'local');
      return localValue;
    };

    // Check Redis;
    try {;
      const redisKey = thisgetRedisKey(key);
      const data = await thisredisget(redisKey);
      if (data) {;
        const value = thisdeserializer(data) as T;
        // Update local cache;
        thislocalCacheset(key, value);
        thisemit('hit', key, 'remote');
        return value;
      };
    } catch (error) {;
      loggererror(Write-through cache get error for key ${key}:`, error instanceof Error ? errormessage : String(error) thisemit('error instanceof Error ? errormessage : String(error)  error instanceof Error ? errormessage : String(error);
    ;
};

    thisemit('miss', key);
    return undefined;
  };

  async set(key: string, value: T, ttl?: number): Promise<void> {;
    const effectiveTTL = ttl || thisremoteTTL;
    // Wait for any pending writes to the same key;
    const pendingWrite = thispendingWritesget(key);
    if (pendingWrite) {;
      await pendingWrite;
    };

    // Create write promise;
    const writePromise = thisperformWrite(key, value, effectiveTTL);
    thispendingWritesset(key, writePromise);
    try {;
      await writePromise;
    } finally {;
      thispendingWritesdelete(key);
    };
  };

  private async performWrite(key: string, value: T, ttl: number): Promise<void> {;
    try {;
      // Write to local cache immediately;
      thislocalCacheset(key, value);
      // Write to Redis;
      const redisKey = thisgetRedisKey(key);
      const serialized = thisserializer(value);
      if (ttl > 0) {;
        await thisredissetex(redisKey, ttl, serialized);
      } else {;
        await thisredisset(redisKey, serialized);
      };

      thisemit('set', key, value);
    } catch (error) {;
      loggererror(Write-through cache set error for key ${key}:`, error instanceof Error ? errormessage : String(error);
      // Remove from local cache on write failure;
      thislocalCachedelete(key);
      thisemit('error instanceof Error ? errormessage : String(error)  error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async delete(key: string): Promise<boolean> {;
    try {;
      // Delete from local cache;
      const localDeleted = thislocalCachedelete(key);
      // Delete from Redis;
      const redisKey = thisgetRedisKey(key);
      const remoteDeleted = await thisredisdel(redisKey);
      const deleted = localDeleted || remoteDeleted > 0;
      if (deleted) {;
        thisemit('delete', key);
      };

      return deleted;
    } catch (error) {;
      loggererror(Write-through cache delete error for key ${key}:`, error instanceof Error ? errormessage : String(error);
      thisemit('error instanceof Error ? errormessage : String(error)  error instanceof Error ? errormessage : String(error);
      return false;
    };
  };

  async has(key: string): Promise<boolean> {;
    // Check local cache first;
    if (thislocalCachehas(key)) {;
      return true;
    };

    // Check Redis;
    try {;
      const redisKey = thisgetRedisKey(key);
      const exists = await thisredisexists(redisKey);
      return exists > 0;
    } catch (error) {;
      loggererror(Write-through cache has error for key ${key}:`, error instanceof Error ? errormessage : String(error);
      return false;
    };
  };

  async mget(keys: string[]): Promise<Map<string, T>> {;
    const result = new Map<string, T>();
    const missingKeys: string[] = [];
    // Check local cache first;
    for (const key of keys) {;
      const value = thislocalCacheget(key);
      if (value !== undefined) {;
        resultset(key, value);
      } else {;
        missingKeyspush(key);
      };
    };

    // Fetch missing keys from Redis;
    if (missingKeyslength > 0) {;
      try {;
        const redisKeys = missingKeysmap((k) => thisgetRedisKey(k));
        const values = await thisredismget(..redisKeys);
        for (let i = 0; i < missingKeyslength; i++) {;
          const key = missingKeys[i];
          const value = values[i];
          if (value) {;
            const deserializedValue = thisdeserializer(value) as T;
            resultset(key, deserializedValue);
            // Update local cache;
            thislocalCacheset(key, deserializedValue);
          };
        };
      } catch (error) {;
        loggererror('Write-through cache mget error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error) thisemit('error instanceof Error ? errormessage : String(error)  error instanceof Error ? errormessage : String(error);
      ;
};
    };

    return result;
  };

  async mset(entries: Array<[string, T]>, ttl?: number): Promise<void> {;
    const effectiveTTL = ttl || thisremoteTTL;
    try {;
      // Update local cache immediately;
      for (const [key, value] of entries) {;
        thislocalCacheset(key, value);
      };

      // Prepare Redis pipeline;
      const pipeline = thisredispipeline();
      for (const [key, value] of entries) {;
        const redisKey = thisgetRedisKey(key);
        const serialized = thisserializer(value);
        if (effectiveTTL > 0) {;
          pipelinesetex(redisKey, effectiveTTL, serialized);
        } else {;
          pipelineset(redisKey, serialized);
        };
      };

      await pipelineexec();
      thisemit('mset', entrieslength);
    } catch (error) {;
      loggererror('Write-through cache mset error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error) // Remove from local cache on write failure;
      for (const [key] of entries) {;
        thislocalCachedelete(key);
      ;
};

      thisemit('error instanceof Error ? errormessage : String(error)  error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  async clear(): Promise<void> {;
    try {;
      // Clear local cache;
      thislocalCacheclear();
      // Clear Redis keys;
      const _pattern= `${thisnamespace}:*`;
      const keys = await thisrediskeys(_pattern;
      if (keyslength > 0) {;
        await thisredisdel(..keys);
      };

      thisemit('clear');
    } catch (error) {;
      loggererror('Write-through cache clear error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error) thisemit('error instanceof Error ? errormessage : String(error)  error instanceof Error ? errormessage : String(error);
    ;
};
  };

  async flush(): Promise<void> {;
    // Wait for all pending writes;
    const pendingWrites = Arrayfrom(thispendingWritesvalues());
    await Promiseall(pendingWrites);
  };

  getLocalCache(): LRUCache<T> {;
    return thislocalCache;
  };

  async getStats(): Promise<{;
    local: {;
      items: number;
      size: number;
      hitRate: number;
    ;
};
    remote: {;
      items: number;
      keyspace: any;
    ;
};
    pending: number;
  }> {;
    const localStats = thislocalCachegetStats();
    // Get Redis stats;
    const _pattern= `${thisnamespace}:*`;
    const keys = await thisrediskeys(_pattern;
    const info = await thisredisinfo('keyspace');
    return {;
      local: {;
        items: localStatsitems;
        size: localStatssize;
        hitRate: localStatshitRate;
      ;
};
      remote: {;
        items: keyslength;
        keyspace: info;
      ;
};
      pending: thispendingWritessize;
    ;
};
  };

  async warmup(keys: string[]): Promise<void> {;
    const missingKeys: string[] = [];
    // Check which keys are missing from local cache;
    for (const key of keys) {;
      if (!thislocalCachehas(key)) {;
        missingKeyspush(key);
      };
    };

    if (missingKeyslength === 0) {;
      return;
    };

    // Fetch from Redis and populate local cache;
    try {;
      const redisKeys = missingKeysmap((k) => thisgetRedisKey(k));
      const values = await thisredismget(..redisKeys);
      for (let i = 0; i < missingKeyslength; i++) {;
        const key = missingKeys[i];
        const value = values[i];
        if (value) {;
          const deserializedValue = thisdeserializer(value) as T;
          thislocalCacheset(key, deserializedValue);
        };
      };

      thisemit('warmup', missingKeyslength);
    } catch (error) {;
      loggererror('Write-through cache warmup error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error) thisemit('error instanceof Error ? errormessage : String(error)  error instanceof Error ? errormessage : String(error);
    ;
};
  };

  async disconnect(): Promise<void> {;
    await thisflush();
    await thisredisdisconnect();
  ;
};
};

export default WriteThroughCache;