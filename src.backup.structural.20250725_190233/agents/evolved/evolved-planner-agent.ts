/**;
 * Evolved Planner Agent;
 * Enhanced planning agent with self-improving strategies;
 */;

import { EnhancedPlannerAgent } from '../cognitive/enhanced_planner_agentjs';
import { EvolvedBaseAgent } from './evolved-base-agentjs';
import type { AgentContext, AgentResponse } from '../base_agentjs';
import type { SupabaseClient } from '@supabase/supabase-js';
export class EvolvedPlannerAgent extends EvolvedBaseAgent {;
  private plannerInstance: EnhancedPlannerAgent;
  constructor(supabase: SupabaseClient) {;
    super(;);
      {;
        name: 'planner';
        description: 'Evolved strategic task planning with adaptive strategies';
        priority: 1;
        capabilities: [;
          {;
            name: 'task_planning';
            description: 'Strategic task decomposition with evolution';
            inputSchema: {;
};
            outputSchema: {;
};
          };
          {;
            name: 'goal_decomposition';
            description: 'Break down complex goals adaptively';
            inputSchema: {;
};
            outputSchema: {;
};
          };
          {;
            name: 'strategy_design';
            description: 'Design execution strategies that improve over time';
            inputSchema: {;
};
            outputSchema: {;
};
          };
        ];
        maxLatencyMs: 2000;
        retryAttempts: 3;
        dependencies: [];
        memoryEnabled: true;
        evolutionEnabled: true;
        evolutionConfig: {;
          populationSize: 25;
          mutationRate: 0.18;
          crossoverRate: 0.8;
          adaptationThreshold: 0.7;
          learningRate: 0.03;
        ;
};
      };
      supabase;
    );
    // Create wrapped planner instance;
    thisplannerInstance = new EnhancedPlannerAgent({;
      name: 'planner_base';
      description: 'Base planner for evolution';
      priority: 1;
      capabilities: [];
      maxLatencyMs: 2000;
      retryAttempts: 3;
      dependencies: [];
      memoryEnabled: true;
    });
  };

  async onInitialize(): Promise<void> {;
    await thisplannerInstanceinitialize(thismemoryCoordinator);
  ;
};

  protected async process(context: AgentContext): Promise<any> {;
    // Extract evolved strategy parameters;
    const strategy = contextmetadata?strategyParams || {};
    // Apply evolved parameters to planning;
    const evolvedContext = thisapplyEvolvedStrategy(context, strategy);
    // Execute planning with evolved parameters;
    const planResult = await thisplannerInstanceexecute(evolvedContext);
    // Enhance plan with evolution insights;
    if (planResultsuccess && planResultdata) {;
      planResultdata = thisenhancePlanWithEvolution(planResultdata, strategy);
    };
;
    return {;
      success: planResultsuccess;
      data: planResultdata;
      reasoning: thisenhanceReasoning(planResultreasoning, strategy);
      confidence: thisadjustConfidence(planResultconfidence, strategy);
      error instanceof Error ? errormessage : String(error) planResulterror;
      nextActions: planResultnextActions;
      memoryUpdates: planResultmemoryUpdates;
      metadata: {;
        ..planResultmetadata;
        evolutionGeneration: contextmetadata?evolutionGeneration;
        strategyApplied: strategy;
      ;
};
    };
  };

  private applyEvolvedStrategy(context: AgentContext, strategy: any): AgentContext {;
    // Apply evolved parameters to context;
    const evolvedContext = { ..context };
    // Planning depth evolution;
    if (strategyplanningdepth) {;
      evolvedContextmetadata = {;
        ..evolvedContextmetadata;
        planningDepth: Mathround(strategyplanningdepth * 10), // Scale to 1-10;
      };
    };

    // Task decomposition strategy;
    if (strategytaskdecomposition) {;
      evolvedContextmetadata = {;
        ..evolvedContextmetadata;
        decompositionStrategy: thisgetDecompositionStrategy(strategytaskdecomposition);
      ;
};
    };

    // Priority weighting;
    if (strategypriorityweighting) {;
      evolvedContextmetadata = {;
        ..evolvedContextmetadata;
        priorityWeights: {;
          urgency: strategypriorityweighting;
          importance: 1 - strategypriorityweighting;
          complexity: strategycomplexityweight || 0.5;
        ;
};
      };
    };

    // Parallelization preference;
    if (strategyparallelization) {;
      evolvedContextmetadata = {;
        ..evolvedContextmetadata;
        preferParallel: strategyparallelization > 0.5;
        maxParallelTasks: Mathround(strategyparallelization * 5) + 1;
      ;
};
    };
;
    return evolvedContext;
  };

  private getDecompositionStrategy(value: number): string {;
    if (value < 0.33) return 'hierarchical';
    if (value < 0.67) return 'sequential';
    return 'adaptive';
  };

  private enhancePlanWithEvolution(plan: any, strategy: any): any {;
    if (!plantasks) return plan;
    // Apply evolved optimization to tasks;
    const optimizedTasks = plantasksmap((task: any) => {;
      // Adjust task priority based on evolution;
      if (strategypriorityweighting && taskpriority !== undefined) {;
        taskevolutionAdjustedPriority = thiscalculateEvolvedPriority(;
          task;
          strategypriorityweighting;
        );
      };

      // Add parallelization hints;
      if (strategyparallelization && strategyparallelization > 0.5) {;
        taskcanParallelize = !taskdependencies || taskdependencieslength === 0;
      };

      // Add complexity estimates;
      if (strategycomplexityweight) {;
        taskcomplexityScore = thisestimateComplexity(task, strategycomplexityweight);
      };
;
      return task;
    });
    // Reorder tasks based on evolved strategy;
    if (strategyexecutionorder) {;
      optimizedTaskssort((a: any, b: any) => {;
        const scoreA = thiscalculateTaskScore(a, strategy);
        const scoreB = thiscalculateTaskScore(b, strategy);
        return scoreB - scoreA;
      });
    };

    return {;
      ..plan;
      tasks: optimizedTasks;
      evolutionOptimized: true;
      strategySignature: thisgenerateStrategySignature(strategy);
    ;
};
  };

  private calculateEvolvedPriority(task: any, weight: number): number {;
    const basePriority = taskpriority || 0.5;
    const urgency = taskurgent ? 1 : 0;
    const importance = taskimportant ? 1 : 0;
    return (;
      basePriority * (1 - weight) +;
      urgency * weight * 0.6 +;
      importance * weight * 0.4;
    );
  };

  private estimateComplexity(task: any, weight: number): number {;
    let complexity = 0.5; // Base complexity;
    ;
    // Adjust based on task characteristics;
    if (tasksubtasks && tasksubtaskslength > 0) {;
      complexity += 0.1 * Mathmin(tasksubtaskslength, 5);
    };
    ;
    if (taskdependencies && taskdependencieslength > 0) {;
      complexity += 0.1 * Mathmin(taskdependencieslength, 3);
    };
    ;
    if (taskestimatedDuration && taskestimatedDuration > 3600) {;
      complexity += 0.2;
    };
    ;
    return Mathmin(1, complexity * weight);
  };

  private calculateTaskScore(task: any, strategy: any): number {;
    let score = 0;
    if (taskevolutionAdjustedPriority) {;
      score += taskevolutionAdjustedPriority * 0.4;
    };
    ;
    if (taskcomplexityScore) {;
      // Prefer simpler tasks if strategy suggests it;
      score += (1 - taskcomplexityScore) * 0.3;
    };
    ;
    if (taskcanParallelize && strategyparallelization > 0.5) {;
      score += 0.3;
    };
    ;
    return score;
  };

  private enhanceReasoning(reasoning: string, strategy: any): string {;
    const insights = [];
    if (strategyplanningdepth) {;
      insightspush(`Using evolved planning depth: ${Mathround(strategyplanningdepth * 10)}/10`);
    };
    ;
    if (strategytaskdecomposition) {;
      insightspush(`Decomposition strategy: ${thisgetDecompositionStrategy(strategytaskdecomposition)}`);
    };
    ;
    if (insightslength > 0) {;
      return `${reasoning}\n\nEvolution insights: ${insightsjoin(', ')}`;
    };
    ;
    return reasoning;
  };

  private adjustConfidence(baseConfidence: number, strategy: any): number {;
    // Adjust confidence based on strategy fitness;
    if (strategy._fitness) {;
      return baseConfidence * 0.7 + strategy._fitness * 0.3;
    };
    return baseConfidence;
  };

  private generateStrategySignature(strategy: any): string {;
    const keys = Objectkeys(strategy)sort();
    const values = keysmap(k => `${k}:${Mathround(strategy[k] * 100) / 100}`);
    return valuesjoin('|');
  };

  protected identifyOperationType(context: AgentContext): string {;
    const request = contextuserRequesttoLowerCase();
    if (requestincludes('plan') || requestincludes('strategy')) {;
      return 'strategic_planning';
    };
    if (requestincludes('break') || requestincludes('decompose')) {;
      return 'task_decomposition';
    };
    if (requestincludes('prioriti') || requestincludes('order')) {;
      return 'prioritization';
    };
    if (requestincludes('optimize') || requestincludes('improve')) {;
      return 'optimization';
    };
    ;
    return 'general_planning';
  };

  /**;
   * Get planner-specific evolution status;
   */;
  async getPlannerEvolutionStatus(): Promise<any> {;
    const baseStatus = await thisgetEvolutionStatus();
    // Add planner-specific metrics;
    const plannerMetrics = {;
      averagePlanComplexity: thiscalculateAveragePlanComplexity();
      successfulPlanRate: thiscalculateSuccessfulPlanRate();
      evolutionImprovements: thisgetEvolutionImprovements();
    };
    return {;
      ..baseStatus;
      plannerSpecific: plannerMetrics;
    ;
};
  };

  private calculateAveragePlanComplexity(): number {;
    const complexities = Arrayfrom(thisperformanceHistoryget('strategic_planning') || []);
    if (complexitieslength === 0) return 0;
    return complexitiesreduce((a, b) => a + b, 0) / complexitieslength;
  };

  private calculateSuccessfulPlanRate(): number {;
    let total = 0;
    let successful = 0;
    for (const [_, history] of thisperformanceHistory) {;
      total += historylength;
      successful += historyfilter(score => score > 0.7)length;
    };
    ;
    return total > 0 ? successful / total : 0;
  };

  private getEvolutionImprovements(): any[] {;
    const improvements = [];
    for (const [operation, history] of thisperformanceHistory) {;
      if (historylength >= 10) {;
        const early = historyslice(0, 5)reduce((a, b) => a + b, 0) / 5;
        const recent = historyslice(-5)reduce((a, b) => a + b, 0) / 5;
        const improvement = ((recent - early) / early) * 100;
        if (improvement > 0) {;
          improvementspush({;
            operation;
            improvement: Mathround(improvement);
            trend: improvement > 10 ? 'significant' : 'moderate';
          });
        };
      };
    };
    ;
    return improvements;
  };

  async shutdown(): Promise<void> {;
    await supershutdown();
    if (thisplannerInstanceshutdown) {;
      await thisplannerInstanceshutdown();
    ;
};
  };
};

export default EvolvedPlannerAgent;