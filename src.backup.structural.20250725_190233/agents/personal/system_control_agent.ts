/**;
 * SystemControlAgent - macOS system integration and control;
 * Provides system automation, application management, network monitoring, and resource optimization;
 */;

import type { AgentConfig, AgentContext, AgentResponse } from '../base_agent';
import { BaseAgent } from '../base_agent';
import type { SupabaseClient } from '@supabase/supabase-js';
import { execSync, spawn } from 'child_process';
import { promises as fs } from 'fs';
import * as path from 'path';
import * as os from 'os';
import axios from 'axios';
import { TIME_500MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_10000MS, ZERO_POINT_FIVE, ZERO_POINT_EIGHT, ZERO_POINT_NINE, BATCH_SIZE_10, MAX_ITEMS_100, PERCENT_10, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, PERCENT_100, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500 } from "../utils/common-constants";
interface SystemMetrics {;
  cpu: {;
    usage: number;
    temperature?: number;
    cores: number;
    model: string;
  ;
};
  memory: {;
    total: number;
    used: number;
    available: number;
    pressure: 'normal' | 'warning' | 'critical';
  ;
};
  disk: {;
    total: number;
    used: number;
    available: number;
    health: 'good' | 'warning' | 'critical';
  ;
};
  network: {;
    download: number;
    upload: number;
    latency: number;
    connected: boolean;
  ;
};
  battery?: {;
    level: number;
    isCharging: boolean;
    timeRemaining?: number;
    health: 'normal' | 'replace_soon' | 'replace_now';
  ;
};
};

interface ApplicationInfo {;
  name: string;
  bundleId: string;
  version: string;
  isRunning: boolean;
  pid?: number;
  cpuUsage?: number;
  memoryUsage?: number;
  windowCount?: number;
;
};

interface NetworkConnection {;
  ssid?: string;
  signalStrength?: number;
  security: string;
  ipAddress: string;
  gateway: string;
  dns: string[];
  isActive: boolean;
;
};

interface SystemPreferences {;
  appearance: 'light' | 'dark' | 'auto';
  doNotDisturb: boolean;
  volume: number;
  brightness: number;
  energySaver: boolean;
  bluetooth: boolean;
  wifi: boolean;
;
};

export class SystemControlAgent extends BaseAgent {;
  private supabase: SupabaseClient;
  private systemMonitoringInterval?: NodeJSTimeout;
  private lastMetrics?: SystemMetrics;
  private runningApplications: Map<string, ApplicationInfo> = new Map();
  constructor(supabase: SupabaseClient) {;
    const config: AgentConfig = {;
      name: 'system_control';
      description: 'macOS system integration and intelligent automation';
      priority: 7;
      capabilities: [;
        {;
          name: 'system_status';
          description: 'Get comprehensive system status and metrics';
          inputSchema: {;
            type: 'object';
            properties: {;
              detailed: { type: 'boolean' ;
};
              includeApps: { type: 'boolean' ;
};
              includeNetwork: { type: 'boolean' ;
};
            };
          };
          outputSchema: {;
            type: 'object';
            properties: {;
              metrics: { type: 'object' ;
};
              applications: { type: 'array' ;
};
              network: { type: 'object' ;
};
              recommendations: { type: 'array' ;
};
            };
          };
        };
        {;
          name: 'app_control';
          description: 'Launch, quit, and manage applications';
          inputSchema: {;
            type: 'object';
            properties: {;
              action: { type: 'string', enum: ['launch', 'quit', 'restart', 'focus', 'hide'] };
              application: { type: 'string' ;
};
              arguments: { type: 'array' ;
};
            };
            required: ['action', 'application'];
          };
          outputSchema: {;
            type: 'object';
            properties: {;
              success: { type: 'boolean' ;
};
              pid: { type: 'number' ;
};
              message: { type: 'string' ;
};
            };
          };
        };
        {;
          name: 'system_preferences';
          description: 'Get and set system preferences';
          inputSchema: {;
            type: 'object';
            properties: {;
              action: { type: 'string', enum: ['get', 'set'] };
              preference: { type: 'string' ;
};
              value: { type: 'string' ;
};
            };
            required: ['action'];
          ;
};
          outputSchema: {;
            type: 'object';
            properties: {;
              preferences: { type: 'object' ;
};
              changed: { type: 'boolean' ;
};
            };
          };
        };
        {;
          name: 'automation';
          description: 'Create and execute system automation workflows';
          inputSchema: {;
            type: 'object';
            properties: {;
              workflow: { type: 'string' ;
};
              trigger: { type: 'string' ;
};
              actions: { type: 'array' ;
};
            };
            required: ['workflow'];
          ;
};
          outputSchema: {;
            type: 'object';
            properties: {;
              executed: { type: 'boolean' ;
};
              results: { type: 'array' ;
};
            };
          };
        };
      ];
      maxLatencyMs: 5000;
      retryAttempts: 2;
      dependencies: ['ollama_assistant'];
      memoryEnabled: true;
    ;
};
    super(config);
    thissupabase = supabase;
  };

  protected async onInitialize(): Promise<void> {;
    // Check macOS version and capabilities;
    await thischeckSystemCapabilities();
    // Initialize system monitoring;
    await thisstartSystemMonitoring();
    // Load automation rules;
    await thisloadAutomationRules();
    thisloggerinfo('âœ… SystemControlAgent initialized with macOS integration');
  ;
};

  protected async process(_context: AgentContext & { memoryContext?: any }): Promise<AgentResponse> {;
    const { userRequest } = context;
    const startTime = Datenow();
    try {;
      // Parse the user request to determine system operation;
      const intent = await thisparseSystemIntent(userRequest);
      let result: any;
      switch (intentaction) {;
        case 'status':;
          result = await thisgetSystemStatus(intent);
          break;
        case 'launch':;
        case 'quit':;
        case 'focus':;
          result = await thiscontrolApplication(intent);
          break;
        case 'preferences':;
          result = await thismanageSystemPreferences(intent);
          break;
        case 'optimize':;
          result = await thisoptimizeSystem(intent);
          break;
        case 'monitor':;
          result = await thismonitorResource(intent);
          break;
        case 'network':;
          result = await thismanageNetwork(intent);
          break;
        case 'automate':;
          result = await thisexecuteAutomation(intent);
          break;
        case 'backup':;
          result = await thismanageBackup(intent);
          break;
        default:;
          result = await thishandleGeneralSystemQuery(userRequest);
      };

      const confidence = thiscalculateSystemConfidence(intent, result);
      return {;
        success: true;
        data: result;
        reasoning: thisbuildSystemReasoning(intent, result);
        confidence;
        latencyMs: Datenow() - startTime;
        agentId: thisconfigname;
        nextActions: thissuggestSystemActions(intent, result);
      };
    } catch (error) {;
      thisloggererror('SystemControlAgent processing error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error)';
      return {;
        success: false;
        data: null;
        reasoning: `System operation failed: ${(erroras Error)message}`;
        confidence: 0.1;
        latencyMs: Datenow() - startTime;
        agentId: thisconfigname;
        error instanceof Error ? errormessage : String(error) (erroras Error)message;
      ;
};
    };
  };

  protected async onShutdown(): Promise<void> {;
    // Stop system monitoring;
    if (thissystemMonitoringInterval) {;
      clearInterval(thissystemMonitoringInterval);
    };

    thisloggerinfo('SystemControlAgent shutting down');
  };

  /**;
   * Parse system control intent from natural language;
   */;
  private async parseSystemIntent(requeststring): Promise<unknown> {;
    const prompt = `Parse this macOS system control request`;

Request: "${request;
Determine:;
1. Action (status, launch, quit, preferences, optimize, monitor, network, automate, backup);
2. Target (application name, preference name, resource type);
3. Parameters (specific values, options);
4. Context (user preference, system state);
Respond with JSON: {;
  "action": "...";
  "target": "...";
  "parameters": {...;
};
  "context": "...";
}`;`;
    try {;
      const response = await axiospost('http://localhost:11434/api/generate', {;
        model: 'llama3.2:3b';
        prompt;
        stream: false;
        format: 'json';
      });
      return JSONparse(responsedataresponse);
    } catch (error) {;
      return thisfallbackSystemIntentParsing(request;
    };
  };

  /**;
   * Get comprehensive system status;
   */;
  private async getSystemStatus(intent: any): Promise<unknown> {;
    const detailed = intentparameters?detailed || false;
    const includeApps = intentparameters?includeApps || false;
    const includeNetwork = intentparameters?includeNetwork || false;
    // Collect system metrics;
    const metrics = await thiscollectSystemMetrics();
    let applications: ApplicationInfo[] = [];
    if (includeApps) {;
      applications = await thisgetRunningApplications();
    };

    let network: NetworkConnection | null = null;
    if (includeNetwork) {;
      network = await thisgetNetworkStatus();
    };

    // Generate recommendations based on metrics;
    const recommendations = await thisgenerateSystemRecommendations(metrics);
    // Store metrics for historical analysis;
    await thisstoreSystemMetrics(metrics);
    return {;
      metrics;
      applications;
      network;
      recommendations;
      timestamp: new Date()toISOString();
      detailed;
    ;
};
  };

  /**;
   * Control applications (launch, quit, focus, etc.);
   */;
  private async controlApplication(intent: any): Promise<unknown> {;
    const { action } = intent;
    const appName = intenttarget;
    const args = intentparameters?arguments || [];
    let success = false;
    let pid: number | undefined;
    let message = '';
    try {;
      switch (action) {;
        case 'launch':;
          const result = await thislaunchApplication(appName, args);
          success = resultsuccess;
          pid = resultpid;
          message = resultmessage;
          break;
        case 'quit':;
          success = await thisquitApplication(appName);
          message = success ? `Successfully quit ${appName}` : `Failed to quit ${appName}`;
          break;
        case 'focus':;
          success = await thisfocusApplication(appName);
          message = success ? `Brought ${appName} to front` : `Failed to focus ${appName}`;
          break;
        case 'hide':;
          success = await thishideApplication(appName);
          message = success ? `Hidden ${appName}` : `Failed to hide ${appName}`;
          break;
        case 'restart':;
          await thisquitApplication(appName);
          setTimeout(async () => {;
            const restartResult = await thislaunchApplication(appName, args);
            success = restartResultsuccess;
            pid = restartResultpid;
          }, 2000);
          message = `Restarting ${appName}`;
          break;
      };

      // Update application cache;
      await thisupdateApplicationCache();
    } catch (error) {;
      message = `Application control failed: ${(erroras Error)message}`;
    };

    return {;
      action;
      application: appName;
      success;
      pid;
      message;
    ;
};
  };

  /**;
   * Manage system preferences;
   */;
  private async manageSystemPreferences(intent: any): Promise<unknown> {;
    const action = intentparameters?action || 'get';
    const preference = intentparameters?preference;
    const value = intentparameters?value;
    let preferences: SystemPreferences;
    let changed = false;
    if (action === 'get') {;
      preferences = await thisgetSystemPreferences();
    } else {;
      preferences = await thissetSystemPreference(preference, value);
      changed = true;
    };

    return {;
      action;
      preferences;
      changed;
      preference;
      value;
    };
  };

  /**;
   * Collect comprehensive system metrics;
   */;
  private async collectSystemMetrics(): Promise<SystemMetrics> {;
    const metrics: SystemMetrics = {;
      cpu: await thisgetCPUMetrics();
      memory: await thisgetMemoryMetrics();
      disk: await thisgetDiskMetrics();
      network: await thisgetNetworkMetrics();
    ;
};
    // Add battery metrics for laptops;
    const batteryInfo = await thisgetBatteryMetrics();
    if (batteryInfo) {;
      metricsbattery = batteryInfo;
    };

    thislastMetrics = metrics;
    return metrics;
  };

  /**;
   * Get CPU metrics;
   */;
  private async getCPUMetrics(): Promise<SystemMetrics['cpu']> {;
    try {;
      // Get CPU usage using top command;
      const topOutput = execSync('top -l 1 -n 0 | grep "CPU usage"', { encoding: 'utf8' });
      const cpuMatch = topOutputmatch(/(\d+\.\d+)% user/);
      const usage = cpuMatch ? parseFloat(cpuMatch[1]) : 0;
      // Get CPU info;
      const cpuInfo = oscpus()[0];
      return {;
        usage;
        cores: oscpus()length;
        model: cpuInfomodel;
      ;
};
    } catch (error) {;
      thisloggererror('Failed to get CPU metrics:', (erroras Error)message);
      return {;
        usage: 0;
        cores: oscpus()length;
        model: 'Unknown';
      ;
};
    };
  };

  /**;
   * Get memory metrics;
   */;
  private async getMemoryMetrics(): Promise<SystemMetrics['memory']> {;
    try {;
      const total = ostotalmem();
      const free = osfreemem();
      const used = total - free;
      // Get memory pressure;
      const pressureOutput = execSync('memory_pressure', { encoding: 'utf8' });
      let pressure: 'normal' | 'warning' | 'critical' = 'normal';
      if (pressureOutputincludes('warn')) pressure = 'warning';
      if (pressureOutputincludes('critical')) pressure = 'critical';
      return {;
        total;
        used;
        available: free;
        pressure;
      ;
};
    } catch (error) {;
      thisloggererror('Failed to get memory metrics:', error instanceof Error ? errormessage : String(error);
      const total = ostotalmem();
      const free = osfreemem();
      return {;
        total;
        used: total - free;
        available: free;
        pressure: 'normal';
      ;
};
    };
  };

  /**;
   * Get disk metrics;
   */;
  private async getDiskMetrics(): Promise<SystemMetrics['disk']> {;
    try {;
      const dfOutput = execSync('df -h /', { encoding: 'utf8' });
      const lines = dfOutputsplit('\n');
      const diskLine = lines[1];
      const parts = diskLinesplit(/\s+/);
      const total = thisparseSize(parts[1]);
      const used = thisparseSize(parts[2]);
      const available = thisparseSize(parts[3]);
      // Determine disk health based on usage;
      const usagePercent = (used / total) * 100;
      let health: 'good' | 'warning' | 'critical' = 'good';
      if (usagePercent > 85) health = 'warning';
      if (usagePercent > 95) health = 'critical';
      return {;
        total;
        used;
        available;
        health;
      };
    } catch (error) {;
      thisloggererror('Failed to get disk metrics:', error instanceof Error ? errormessage : String(error);
      return {;
        total: 0;
        used: 0;
        available: 0;
        health: 'good';
      ;
};
    };
  };

  /**;
   * Get network metrics;
   */;
  private async getNetworkMetrics(): Promise<SystemMetrics['network']> {;
    try {;
      // Check network connectivity;
      const pingOutput = execSync('ping -c 1 8.8.8.8', { encoding: 'utf8' });
      const latencyMatch = pingOutputmatch(/time=(\d+\.\d+) ms/);
      const latency = latencyMatch ? parseFloat(latencyMatch[1]) : 0;
      const connected = !pingOutputincludes('100.0% packet loss');
      return {;
        download: 0, // Would need more complex monitoring for actual speeds;
        upload: 0;
        latency;
        connected;
      ;
};
    } catch (error) {;
      return {;
        download: 0;
        upload: 0;
        latency: 0;
        connected: false;
      ;
};
    };
  };

  /**;
   * Get battery metrics (for laptops);
   */;
  private async getBatteryMetrics(): Promise<SystemMetrics['battery'] | null> {;
    try {;
      const batteryOutput = execSync('pmset -g batt', { encoding: 'utf8' });
      if (batteryOutputincludes('Battery Power')) {;
        const levelMatch = batteryOutputmatch(/(\d+)%/);
        const level = levelMatch ? parseInt(levelMatch[1], 10) : 0;
        const isCharging = batteryOutputincludes('charging');
        return {;
          level;
          isCharging;
          health: 'normal', // Would need more detailed battery health check;
        };
      };

      return null; // Desktop machine;
    } catch (error) {;
      return null;
    };
  };

  /**;
   * Launch application;
   */;
  private async launchApplication(appName: string, args: string[] = []): Promise<unknown> {;
    try {;
      const command = `open -a "${appName}"${argslength > 0 ? ` --args ${argsjoin(' ')}` : ''}`;
      execSync(command);
      // Wait a moment for the app to start;
      await new Promise((resolve) => setTimeout(TIME_1000MS));
      // Try to get the PID;
      const pid = await thisgetApplicationPID(appName);
      return {;
        success: true;
        pid;
        message: `Successfully launched ${appName}`;
      };
    } catch (error) {;
      return {;
        success: false;
        message: `Failed to launch ${appName}: ${(erroras Error)message}`;
      };
    };
  };

  /**;
   * Quit application;
   */;
  private async quitApplication(appName: string): Promise<boolean> {;
    try {;
      execSync(`osascript -e 'tell application "${appName}" to quit'`);
      return true;
    } catch (error) {;
      thisloggererror`Failed to quit ${appName}:`, error instanceof Error ? errormessage : String(error);
      return false;
    };
  };

  /**;
   * Focus application (bring to front);
   */;
  private async focusApplication(appName: string): Promise<boolean> {;
    try {;
      execSync(`osascript -e 'tell application "${appName}" to activate'`);
      return true;
    } catch (error) {;
      thisloggererror`Failed to focus ${appName}:`, error instanceof Error ? errormessage : String(error);
      return false;
    };
  };

  /**;
   * Hide application;
   */;
  private async hideApplication(appName: string): Promise<boolean> {;
    try {;
      execSync(;
        `osascript -e 'tell application "System Events" to set visible of process "${appName}" to false'`;
      );
      return true;
    } catch (error) {;
      thisloggererror`Failed to hide ${appName}:`, error instanceof Error ? errormessage : String(error);
      return false;
    };
  };

  /**;
   * Get running applications;
   */;
  private async getRunningApplications(): Promise<ApplicationInfo[]> {;
    try {;
      const psOutput = execSync('ps aux', { encoding: 'utf8' });
      const lines = psOutputsplit('\n')slice(1); // Skip header;

      const applications: ApplicationInfo[] = [];
      for (const line of lines) {;
        const parts = linesplit(/\s+/);
        if (partslength < 11) continue;
        const pid = parseInt(parts[1], 10);
        const cpuUsage = parseFloat(parts[2]);
        const memoryUsage = parseFloat(parts[3]);
        const command = partsslice(10)join(' ');
        // Filter for GUI applications;
        if (commandincludes('app/Contents/MacOS/')) {;
          const appMatch = commandmatch(/([^\/]+)\app\/Contents\/MacOS\/([^\/\s]+)/);
          if (appMatch) {;
            const appName = appMatch[1];
            applicationspush({;
              name: appName;
              bundleId: '', // Would need additional lookup;
              version: '', // Would need additional lookup;
              isRunning: true;
              pid;
              cpuUsage;
              memoryUsage;
            });
          };
        };
      };

      return applications;
    } catch (error) {;
      thisloggererror('Failed to get running applications:', error instanceof Error ? errormessage : String(error);
      return [];
    };
  };

  // Placeholder implementations for complex methods;
  private async checkSystemCapabilities(): Promise<void> {;
    // Check macOS version and available system APIs;
  ;
};

  private async startSystemMonitoring(): Promise<void> {;
    // Start periodic system monitoring;
    thissystemMonitoringInterval = setInterval(async () => {;
      await thiscollectSystemMetrics();
    }, 60000); // Every minute;
  };

  private async loadAutomationRules(): Promise<void> {;
    // Load automation rules from database;
  ;
};

  private fallbackSystemIntentParsing(requeststring): any {;
    const requestLower = request toLowerCase();
    if (requestLowerincludes('status') || requestLowerincludes('system')) {;
      return { action: 'status' };
    };

    if (requestLowerincludes('launch') || requestLowerincludes('open')) {;
      return { action: 'launch' };
    };

    if (requestLowerincludes('quit') || requestLowerincludes('close')) {;
      return { action: 'quit' };
    };

    return { action: 'status' };
  };

  private async generateSystemRecommendations(metrics: SystemMetrics): Promise<string[]> {;
    const recommendations: string[] = [];
    if (metricscpuusage > 80) {;
      recommendationspush('High CPU usage detected - consider closing unused applications');
    };

    if (metricsmemorypressure === 'warning') {;
      recommendationspush('Memory pressure detected - restart some applications');
    };

    if (metricsdiskhealth === 'warning') {;
      recommendationspush('Disk space running low - clean up files or move to external storage');
    };

    return recommendations;
  };

  private async storeSystemMetrics(metrics: SystemMetrics): Promise<void> {;
    try {;
      await thissupabasefrom('ai_memories')insert({;
        service_id: 'system_control';
        memory_type: 'system_metrics';
        content`System metrics: CPU ${metricscpuusage}%, Memory ${Mathround((metricsmemoryused / metricsmemorytotal) * 100)}%`;
        metadata: metrics;
        timestamp: new Date()toISOString();
      });
    } catch (error) {;
      thisloggererror('Failed to store system metrics:', (erroras Error)message);
    };
  };

  private parseSize(sizeStr: string): number {;
    const match = sizeStrmatch(/^(\d+(?:\.\d+)?)([KMGT]?)$/);
    if (!match) return 0;
    const value = parseFloat(match[1]);
    const unit = match[2];
    const multipliers: { [key: string]: number } = {;
      '': 1;
      K: 1024;
      M: 1024 * 1024;
      G: 1024 * 1024 * 1024;
      T: 1024 * 1024 * 1024 * 1024;
    ;
};
    return value * (multipliers[unit] || 1);
  };

  private async getApplicationPID(appName: string): Promise<number | undefined> {;
    try {;
      const output = execSync(`pgrep -f "${appName}"`, { encoding: 'utf8' });
      const pid = parseInt(outputtrim(, 10)split('\n')[0]);
      return isNaN(pid) ? undefined : pid;
    } catch (error) {;
      return undefined;
    };
  };

  private async updateApplicationCache(): Promise<void> {;
    // Update running applications cache;
  ;
};

  private async getSystemPreferences(): Promise<SystemPreferences> {;
    // Get current system preferences;
    return {;
      appearance: 'light';
      doNotDisturb: false;
      volume: 50;
      brightness: 75;
      energySaver: false;
      bluetooth: true;
      wifi: true;
    ;
};
  };

  private async setSystemPreference(preference: string, value: string): Promise<SystemPreferences> {;
    // Set system preference;
    return await thisgetSystemPreferences();
  };

  private async getNetworkStatus(): Promise<NetworkConnection> {;
    // Get detailed network status;
    return {;
      security: 'WPA2';
      ipAddress: '192.168.1.100';
      gateway: '192.168.1.1';
      dns: ['8.8.8.8', '8.8.4.4'];
      isActive: true;
    ;
};
  };

  private calculateSystemConfidence(intent: any, result: any): number {;
    return 0.8;
  };

  private buildSystemReasoning(intent: any, result: any): string {;
    return `Processed system ${intentaction} operation`;
  };

  private suggestSystemActions(intent: any, result: any): string[] {;
    return ['Monitor system performance', 'Set up automation rules'];
  };

  private async optimizeSystem(intent: any): Promise<unknown> {;
    return { optimized: true };
  };

  private async monitorResource(intent: any): Promise<unknown> {;
    return { monitoring: true };
  };

  private async manageNetwork(intent: any): Promise<unknown> {;
    return { network: 'managed' };
  };

  private async executeAutomation(intent: any): Promise<unknown> {;
    return { executed: true };
  };

  private async manageBackup(intent: any): Promise<unknown> {;
    return { backup: 'managed' };
  };

  private async handleGeneralSystemQuery(requeststring): Promise<unknown> {;
    return { response: 'General system query processed' };
  };
};

export default SystemControlAgent;