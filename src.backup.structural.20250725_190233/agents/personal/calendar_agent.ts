/**;
 * CalendarAgent - Intelligent calendar and scheduling management;
 * Integrates with macOS Calendar, Google Calendar, and provides natural language scheduling;
 */;

import type { AgentConfig, AgentContext, AgentResponse } from '../base_agent';
import { BaseAgent } from '../base_agent';
import type { SupabaseClient } from '@supabase/supabase-js';
import { execSync } from 'child_process';
import axios from 'axios';
import { logger } from '../../utils/logger';
interface CalendarEvent {;
  id?: string;
  title: string;
  startDate: Date;
  endDate: Date;
  location?: string;
  description?: string;
  attendees?: string[];
  calendar?: string;
  allDay?: boolean;
;
};

interface ScheduleConflict {;
  conflictingEvent: CalendarEvent;
  overlapStart: Date;
  overlapEnd: Date;
  severity: 'minor' | 'major' | 'complete';
;
};

interface SchedulingSuggestion {;
  suggestedTime: Date;
  confidence: number;
  reasoning: string;
  alternativeTimes: Date[];
;
};

export class CalendarAgent extends BaseAgent {;
  private supabase: SupabaseClient;
  private calendarPreferences: any = {;
};
  constructor(supabase: SupabaseClient) {;
    const config: AgentConfig = {;
      name: 'calendar_agent';
      description: 'Intelligent calendar management and scheduling assistant';
      priority: 8;
      capabilities: [;
        {;
          name: 'create_event';
          description: 'Create calendar events from natural language';
          inputSchema: {;
            type: 'object';
            properties: {;
              naturalLanguage: { type: 'string' ;
};
              calendar: { type: 'string', optional: true ;
};
            };
            required: ['naturalLanguage'];
          ;
};
          outputSchema: {;
            type: 'object';
            properties: {;
              event: { type: 'object' ;
};
              conflicts: { type: 'array' ;
};
            };
          };
        };
        {;
          name: 'find_free_time';
          description: 'Find optimal meeting times';
          inputSchema: {;
            type: 'object';
            properties: {;
              duration: { type: 'number' ;
};
              participants: { type: 'array' ;
};
              timeframe: { type: 'string' ;
};
              preferences: { type: 'object' ;
};
            };
            required: ['duration'];
          ;
};
          outputSchema: {;
            type: 'object';
            properties: {;
              suggestions: { type: 'array' ;
};
              conflicts: { type: 'array' ;
};
            };
          };
        };
        {;
          name: 'analyze_schedule';
          description: 'Analyze and optimize schedule patterns';
          inputSchema: {;
            type: 'object';
            properties: {;
              timeframe: { type: 'string' ;
};
              analysisType: { type: 'string' ;
};
            };
          };
          outputSchema: {;
            type: 'object';
            properties: {;
              insights: { type: 'object' ;
};
              recommendations: { type: 'array' ;
};
            };
          };
        };
      ];
      maxLatencyMs: 3000;
      retryAttempts: 2;
      dependencies: ['ollama_assistant'];
      memoryEnabled: true;
    ;
};
    super(config);
    thissupabase = supabase;
    thislogger = logger;
  };

  protected async onInitialize(): Promise<void> {;
    // Load user calendar preferences;
    await thisloadCalendarPreferences();
    // Check macOS Calendar access;
    await thischeckCalendarAccess();
    thisloggerinfo('âœ… CalendarAgent initialized with macOS Calendar integration');
  ;
};

  protected async process(_context: AgentContext & { memoryContext?: any }): Promise<AgentResponse> {;
    const { userRequest } = context;
    const startTime = Datenow();
    try {;
      // Parse the user request to determine intent;
      const intent = await thisparseCalendarIntent(userRequest);
      let result: any;
      switch (intentaction) {;
        case 'create_event':;
          result = await thiscreateEventFromNaturalLanguage(userRequest, intent);
          break;
        case 'find_time':;
          result = await thisfindOptimalMeetingTime(intent);
          break;
        case 'check_schedule':;
          result = await thisanalyzeSchedule(intent);
          break;
        case 'reschedule':;
          result = await thisrescheduleEvent(intent);
          break;
        case 'get_events':;
          result = await thisgetUpcomingEvents(intent);
          break;
        default:;
          result = await thishandleGeneralCalendarQuery(userRequest);
      };

      const confidence = thiscalculateConfidence(intent, result);
      return {;
        success: true;
        data: result;
        reasoning: thisbuildCalendarReasoning(intent, result);
        confidence;
        latencyMs: Datenow() - startTime;
        agentId: thisconfigname;
        nextActions: thissuggestNextActions(intent, result);
      };
    } catch (error) {;
      thisloggererror('CalendarAgent processing error instanceof Error ? errormessage : String(error) , error instanceof Error ? errormessage : String(error)';
      return {;
        success: false;
        data: null;
        reasoning: `Calendar operation failed: ${(erroras Error)message}`;
        confidence: 0.1;
        latencyMs: Datenow() - startTime;
        agentId: thisconfigname;
        error instanceof Error ? errormessage : String(error) (erroras Error)message;
      ;
};
    };
  };

  protected async onShutdown(): Promise<void> {;
    // Save any pending calendar operations;
    thisloggerinfo('CalendarAgent shutting down');
  ;
};

  /**;
   * Parse natural language to determine calendar intent;
   */;
  private async parseCalendarIntent(requeststring): Promise<unknown> {;
    const prompt = `Parse this calendar requestand extract the intent:`;

Request: "${request;
Determine:;
1. Action (create_event, find_time, check_schedule, reschedule, get_events);
2. Event details (title, date, time, duration, location, attendees);
3. Constraints (availability, preferences);
4. Context (urgency, type of meeting);

Respond with JSON: {;
  "action": "...";
  "eventDetails": {...;
};
  "constraints": {...;
};
  "context": {...;
};
}`;`;
    try {;
      // Use Ollama for natural language parsing;
      const response = await axiospost('http://localhost:11434/api/generate', {;
        model: 'llama3.2:3b';
        prompt;
        stream: false;
        format: 'json';
      });
      return JSONparse(responsedataresponse);
    } catch (error) {;
      // Fallback to basic parsing;
      return thisfallbackIntentParsing(request;
    };
  };

  /**;
   * Create calendar event from natural language;
   */;
  private async createEventFromNaturalLanguage(requeststring, intent: any): Promise<unknown> {;
    const eventDetails = intenteventDetails || {};
    // Parse date and time;
    const dateTime = await thisparseDateTime(request;

    const event: CalendarEvent = {;
      title: eventDetailstitle || thisextractEventTitle(request;
      startDate: dateTimestartDate;
      endDate: dateTimeendDate;
      location: eventDetailslocation;
      description: eventDetailsdescription;
      attendees: eventDetailsattendees || [];
      allDay: dateTimeallDay || false;
    ;
};
    // Check for conflicts;
    const conflicts = await thischeckForConflicts(event);
    if (conflictslength > 0 && thishasSignificantConflicts(conflicts)) {;
      return {;
        event;
        conflicts;
        created: false;
        suggestion: await thissuggestAlternativeTime(event, conflicts);
      };
    };

    // Create the event;
    const createdEvent = await thiscreateCalendarEvent(event);
    // Store in memory for future reference;
    await thisstoreEventMemory(createdEvent, request;
    return {;
      event: createdEvent;
      conflicts;
      created: true;
      eventId: createdEventid;
    ;
};
  };

  /**;
   * Find optimal meeting time;
   */;
  private async findOptimalMeetingTime(intent: any): Promise<unknown> {;
    const duration = intentduration || 60; // minutes;
    const timeframe = intenttimeframe || 'next_week';
    const participants = intentparticipants || [];
    // Get busy times for all participants;
    const busyTimes = await thisgetBusyTimes(participants, timeframe);
    // Find free slots;
    const freeSlots = await thisfindFreeTimeSlots(duration, busyTimes, timeframe);
    // Score and rank suggestions;
    const suggestions = await thisrankTimeSlots(freeSlots, intentpreferences);
    return {;
      suggestions: suggestionsslice(0, 5);
      participants;
      duration;
      timeframe;
      totalOptions: freeSlotslength;
    ;
};
  };

  /**;
   * Analyze schedule patterns and provide insights;
   */;
  private async analyzeSchedule(intent: any): Promise<unknown> {;
    const timeframe = intenttimeframe || 'this_week';
    const events = await thisgetEventsInTimeframe(timeframe);
    const _analysis= {;
      totalEvents: eventslength;
      totalHours: thiscalculateTotalHours(events);
      busyDays: thisidentifyBusyDays(events);
      freeTime: thiscalculateFreeTime(events);
      patterns: thisidentifyPatterns(events);
      recommendations: thisgenerateScheduleRecommendations(events);
    };
    return {;
      timeframe;
      _analysis;
      insights: await thisgenerateScheduleInsights(_analysis;
    ;
};
  };

  /**;
   * Create calendar event using macOS Calendar;
   */;
  private async createCalendarEvent(event: CalendarEvent): Promise<CalendarEvent> {;
    try {;
      // Escape strings for AppleScript;
      const escapeAppleScript = (str: string) => {;
        return strreplace(/"/g, '\\"')replace(/\\/g, '\\\\');
      };
      // Format dates for AppleScript;
      const formatDateForAppleScript = (date: Date) => {;
        return `${datetoLocaleDateString('en-US', {`;
          month: 'long';
          day: 'numeric';
          year: 'numeric';
        })} ${datetoLocaleTimeString('en-US')}`;`;
      };
      // Use AppleScript to create calendar event with proper escaping;
      const script = ``;
        tell application "Calendar";
          try;
            tell calendar "${escapeAppleScript(eventcalendar || 'Calendar')}";
              make new event with properties {;
                summary: "${escapeAppleScript(eventtitle)}";
                start date: date "${formatDateForAppleScript(eventstartDate)}";
                end date: date "${formatDateForAppleScript(eventendDate)}";
                description: "${escapeAppleScript(eventdescription || '')}";
                location: "${escapeAppleScript(eventlocation || '')}";
              };
            end tell;
            return "success";
          on errorerrMsg;
            return "error instanceof Error ? errormessage : String(error) " & errMsg;
          end try;
        end tell;
      `;`;
      const result = execSync(`osascript -e '${script}'`, { encoding: 'utf8' });
      if (resultincludes('error instanceof Error ? errormessage : String(error))) {;
        throw new Error(`AppleScript error instanceof Error ? errormessage : String(error) ${result}`);
      };

      // Generate ID for tracking;
      const eventId = `cal_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
      thisloggerinfo(`Successfully created calendar event: ${eventtitle}`);
      return {;
        ..event;
        id: eventId;
      ;
};
    } catch (error) {;
      thisloggererror('Failed to create macOS calendar event:', error instanceof Error ? errormessage : String(error);
      throw new Error(`Failed to create calendar event: ${(erroras Error)message}`);
    };
  };

  /**;
   * Check for schedule conflicts;
   */;
  private async checkForConflicts(newEvent: CalendarEvent): Promise<ScheduleConflict[]> {;
    try {;
      // Get existing events in the time range;
      const existingEvents = await thisgetEventsInRange(;
        new Date(newEventstartDategetTime() - 24 * 60 * 60 * 1000), // 1 day before;
        new Date(newEventendDategetTime() + 24 * 60 * 60 * 1000) // 1 day after;
      );
      const conflicts: ScheduleConflict[] = [];
      for (const event of existingEvents) {;
        const overlap = thiscalculateOverlap(newEvent, event);
        if (overlap) {;
          conflictspush({;
            conflictingEvent: event;
            overlapStart: overlapstart;
            overlapEnd: overlapend;
            severity: thiscalculateConflictSeverity(overlap, newEvent, event);
          });
        };
      };

      return conflicts;
    } catch (error) {;
      thisloggererror('Conflict checking failed:', error instanceof Error ? errormessage : String(error);
      return [];
    };
  };

  /**;
   * Get events from macOS Calendar in date range;
   */;
  private async getEventsInRange(startDate: Date, endDate: Date): Promise<CalendarEvent[]> {;
    try {;
      // Format dates for AppleScript;
      const formatDateForAppleScript = (date: Date) => {;
        return `${datetoLocaleDateString('en-US', {`;
          month: 'long';
          day: 'numeric';
          year: 'numeric';
        })} ${datetoLocaleTimeString('en-US')}`;`;
      };
      // Use AppleScript to query Calendar with better formatting;
      const script = ``;
        tell application "Calendar";
          set eventList to {};
          set startDateTime to date "${formatDateForAppleScript(startDate)}";
          set endDateTime to date "${formatDateForAppleScript(endDate)}";
          repeat with cal in calendars;
            try;
              set calEvents to (every event of cal whose start date â‰¥ startDateTime and start date â‰¤ endDateTime);
              repeat with evt in calEvents;
                set eventRecord to {};
                set eventRecord to eventRecord & {"title: " & (summary of evt as string);
};
                set eventRecord to eventRecord & {"start: " & (start date of evt as string);
};
                set eventRecord to eventRecord & {"end: " & (end date of evt as string);
};
                ;
                try;
                  set eventRecord to eventRecord & {"description: " & (description of evt as string);
};
                on error;
                  set eventRecord to eventRecord & {"description: ";
};
                end try;
                try;
                  set eventRecord to eventRecord & {"location: " & (location of evt as string);
};
                on error;
                  set eventRecord to eventRecord & {"location: ";
};
                end try;
                set end of eventList to (eventRecord as string);
              end repeat;
            on error;
              -- Skip calendar if access denied;
            end try;
          end repeat;
          return eventList;
        end tell;
      `;`;
      const result = execSync(`osascript -e '${script}'`, { encoding: 'utf8' });
      return thisparseAppleScriptEventResult(result);
    } catch (error) {;
      thisloggererror('Failed to get calendar events:', error instanceof Error ? errormessage : String(error);
      return [];
    };
  };

  /**;
   * Parse AppleScript result into CalendarEvent objects;
   */;
  private parseAppleScriptEventResult(scriptResult: string): CalendarEvent[] {;
    const events: CalendarEvent[] = [];
    try {;
      // Clean up the result string;
      const cleanResult = scriptResulttrim();
      if (!cleanResult || cleanResult === '{}') {;
        return events;
      };

      // Split individual event records;
      // AppleScript returns format like: "title:Event Name, start:Monday, January 1, 2024 at 9:00:00 AM, end:...";
      const eventStrings = cleanResultsplit(/(?=title:)/g)filter((str) => strtrim());
      for (const eventStr of eventStrings) {;
        try {;
          const event = thisparseIndividualEvent(eventStr);
          if (event) {;
            eventspush(event);
          };
        } catch (error) {;
          thisloggerwarn('Failed to parse individual event:', eventStr, error instanceof Error ? errormessage : String(error)  ;
};
      };
    } catch (error) {;
      thisloggererror('Failed to parse AppleScript result:', error instanceof Error ? errormessage : String(error)  ;
};

    return events;
  };

  /**;
   * Parse individual event from AppleScript output;
   */;
  private parseIndividualEvent(eventStr: string): CalendarEvent | null {;
    try {;
      const fields: Record<string, string> = {};
      // Extract fields using regex patterns;
      const patterns = {;
        title: /title:([^]+?)(?=,\s*(?:start|end|description|location):|$)/;
        start: /start:([^]+?)(?=,\s*(?:end|description|location):|$)/;
        end: /end:([^]+?)(?=,\s*(?:description|location):|$)/;
        description: /description:([^]+?)(?=,\s*location:|$)/;
        location: /location:([^]+?)$/;
      };
      for (const [field, _pattern of Objectentries(patterns)) {;
        const match = eventStrmatch(_pattern;
        if (match) {;
          fields[field] = match[1]trim();
        };
      };

      if (!fieldstitle || !fieldsstart || !fieldsend) {;
        return null;
      };

      // Parse dates;
      const startDate = new Date(fieldsstart);
      const endDate = new Date(fieldsend);
      if (isNaN(startDategetTime()) || isNaN(endDategetTime())) {;
        thisloggerwarn('Invalid date format in event:', fields);
        return null;
      };

      return {;
        id: `cal_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
        title: fieldstitle;
        startDate;
        endDate;
        description: fieldsdescription || '';
        location: fieldslocation || '';
        allDay: thisisAllDayEvent(startDate, endDate);
      };
    } catch (error) {;
      thisloggererror('Error parsing individual event:', error instanceof Error ? errormessage : String(error);
      return null;
    };
  };

  /**;
   * Determine if event is all-day based on times;
   */;
  private isAllDayEvent(startDate: Date, endDate: Date): boolean {;
    const start = startDategetHours() * 60 + startDategetMinutes();
    const end = endDategetHours() * 60 + endDategetMinutes();
    // Consider all-day if starts at midnight and ends at midnight or spans 24+ hours;
    return (;
      (start === 0 && end === 0) || endDategetTime() - startDategetTime() >= 24 * 60 * 60 * 1000;
    );
  };

  /**;
   * Parse date and time from natural language;
   */;
  private async parseDateTime(;
    text: string;
  ): Promise<{ startDate: Date; endDate: Date; allDay?: boolean }> {;
    // Enhanced date/time parsing with Ollama;
    const prompt = `Parse date and time from this text:`;

Text: "${text}";
Extract: 1. Start date and time;
2. End date and time (or calculate from duration);
3. Whether it's an all-day event;
4. Time zone if specified;

Current date/time: ${new Date()toISOString();
};

Respond with JSON: {;
  "startDate": "ISO string";
  "endDate": "ISO string";
  "allDay": boolean;
  "timezone": "string";
}`;`;
    try {;
      const response = await axiospost('http://localhost:11434/api/generate', {;
        model: 'llama3.2:3b';
        prompt;
        stream: false;
        format: 'json';
      });
      const parsed = JSONparse(responsedataresponse);
      return {;
        startDate: new Date(parsedstartDate);
        endDate: new Date(parsedendDate);
        allDay: parsedallDay;
      ;
};
    } catch (error) {;
      // Fallback to basic parsing;
      return thisfallbackDateTimeParsing(text);
    };
  };

  /**;
   * Load user calendar preferences;
   */;
  private async loadCalendarPreferences(): Promise<void> {;
    try {;
      const { data } = await thissupabase;
        from('ai_contexts');
        select('*');
        eq('context_type', 'calendar_preferences');
        eq('context_key', 'user_settings');
        single();
      if (data) {;
        thiscalendarPreferences = datacontent;
      } else {;
        // Set default preferences;
        thiscalendarPreferences = {;
          defaultCalendar: 'Calendar';
          workingHours: { start: '09:00', end: '17:00' ;
};
          timeZone: IntlDateTimeFormat()resolvedOptions()timeZone;
          defaultMeetingDuration: 60;
          bufferTime: 15;
        ;
};
      };
    } catch (error) {;
      thisloggererror('Failed to load calendar preferences:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Check macOS Calendar access;
   */;
  private async checkCalendarAccess(): Promise<boolean> {;
    try {;
      const script = ``;
        tell application "Calendar";
          try;
            get name of calendars;
            return "access_granted";
          on errorerrMsg;
            return "access_denied: " & errMsg;
          end try;
        end tell;
      `;`;
      const result = execSync(`osascript -e '${script}'`, { encoding: 'utf8' });
      if (resultincludes('access_denied')) {;
        thisloggerwarn(`Calendar access denied: ${result}`);
        return false;
      };

      thisloggerinfo('Calendar access confirmed');
      return true;
    } catch (error) {;
      thisloggerwarn('Calendar access check failed:', error instanceof Error ? errormessage : String(error);
      return false;
    };
  };

  /**;
   * Fallback intent parsing for when Ollama is unavailable;
   */;
  private fallbackIntentParsing(requeststring): any {;
    const requestLower = request toLowerCase();
    if (;
      requestLowerincludes('create') ||;
      requestLowerincludes('schedule') ||;
      requestLowerincludes('book');
    ) {;
      return { action: 'create_event', eventDetails: {} };
    };

    if (requestLowerincludes('free time') || requestLowerincludes('available')) {;
      return { action: 'find_time' };
    };

    if (requestLowerincludes('busy') || requestLowerincludes('schedule')) {;
      return { action: 'check_schedule' };
    };

    return { action: 'get_events' };
  };

  /**;
   * Fallback date/time parsing;
   */;
  private fallbackDateTimeParsing(text: string): {;
    startDate: Date;
    endDate: Date;
    allDay?: boolean;
  } {;
    const now = new Date();
    const startDate = new Date(nowgetTime() + 60 * 60 * 1000); // 1 hour from now;
    const endDate = new Date(startDategetTime() + 60 * 60 * 1000); // 1 hour duration;

    return { startDate, endDate, allDay: false };
  };

  // Additional utility methods would be implemented here...;
  private extractEventTitle(requeststring): string {;
    // Extract likely event title from request;
    return requestreplace(/create|schedule|book/gi, '')trim() || 'New Event';
  };

  private calculateConfidence(intent: any, result: any): number {;
    if (!resultcreated && resultconflicts?length > 0) return 0.6;
    if (resultcreated) return 0.9;
    return 0.7;
  };

  private buildCalendarReasoning(intent: any, result: any): string {;
    return `Processed calendar ${intentaction} requestwith ${resultconflicts?length || 0} conflicts found.`;
  };

  private suggestNextActions(intent: any, result: any): string[] {;
    const actions = [];
    if (resultconflicts?length > 0) {;
      actionspush('Review conflicts and choose alternative time');
    };
    if (resultcreated) {;
      actionspush('Add attendees if needed', 'Set reminders');
    };
    return actions;
  };

  private async storeEventMemory(event: CalendarEvent, originalRequest: string): Promise<void> {;
    try {;
      await thissupabasefrom('ai_memories')insert({;
        service_id: 'calendar_agent';
        memory_type: 'event_creation';
        content`Created event: ${eventtitle} at ${eventstartDatetoISOString()}`;
        metadata: { event, originalRequest };
        timestamp: new Date()toISOString();
      });
    } catch (error) {;
      thisloggererror('Failed to store event memory:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  // Placeholder implementations for complex methods;
  private hasSignificantConflicts(conflicts: ScheduleConflict[]): boolean {;
    return conflictssome((c) => cseverity === 'major' || cseverity === 'complete');
  };

  private async suggestAlternativeTime(;
    event: CalendarEvent;
    conflicts: ScheduleConflict[];
  ): Promise<unknown> {;
    // Implementation would suggest alternative times;
    return { suggestion: 'Consider scheduling 1 hour later' };
  };

  private calculateOverlap(;
    event1: CalendarEvent;
    event2: CalendarEvent;
  ): { start: Date; end: Date } | null {;
    const start1 = event1startDategetTime();
    const end1 = event1endDategetTime();
    const start2 = event2startDategetTime();
    const end2 = event2endDategetTime();
    // Check if there's any overlap;
    const overlapStart = Mathmax(start1, start2);
    const overlapEnd = Mathmin(end1, end2);
    if (overlapStart < overlapEnd) {;
      return {;
        start: new Date(overlapStart);
        end: new Date(overlapEnd);
      ;
};
    };

    return null;
  };

  private calculateConflictSeverity(;
    overlap: { start: Date; end: Date ;
};
    newEvent: CalendarEvent;
    existingEvent: CalendarEvent;
  ): 'minor' | 'major' | 'complete' {;
    const newEventDuration = newEventendDategetTime() - newEventstartDategetTime();
    const overlapDuration = overlapendgetTime() - overlapstartgetTime();
    const overlapPercentage = overlapDuration / newEventDuration;
    if (overlapPercentage >= 0.9) {;
      return 'complete';
    } else if (overlapPercentage >= 0.5) {;
      return 'major';
    } else {;
      return 'minor';
    };
  };

  private async getBusyTimes(participants: string[], timeframe: string): Promise<any[]> {;
    const busyTimes: any[] = [];
    const { startDate, endDate } = thisparseTimeframe(timeframe);
    // Get events for the specified timeframe;
    const events = await thisgetEventsInRange(startDate, endDate);
    // Add busy times from existing calendar events;
    for (const event of events) {;
      busyTimespush({;
        start: eventstartDate;
        end: eventendDate;
        participant: 'user';
        eventTitle: eventtitle;
      });
    };

    // TODO: Add logic to query other participants' calendars;
    // This would require integration with their calendar systems;

    return busyTimes;
  };

  private async findFreeTimeSlots(;
    duration: number;
    busyTimes: any[];
    timeframe: string;
  ): Promise<any[]> {;
    const freeSlots: any[] = [];
    const { startDate, endDate } = thisparseTimeframe(timeframe);
    const durationMs = duration * 60 * 1000; // Convert minutes to milliseconds;

    // Sort busy times by start date;
    const sortedBusyTimes = busyTimessort((a, b) => astartgetTime() - bstartgetTime());
    // Working hours (9 AM to 5 PM by default);
    const workingHours = thiscalendarPreferencesworkingHours || { start: '09:00', end: '17:00' };
    const currentTime = new Date(startDate);
    while (currentTime < endDate) {;
      const dayStart = thissetTimeToWorkingHours(new Date(currentTime), workingHoursstart);
      const dayEnd = thissetTimeToWorkingHours(new Date(currentTime), workingHoursend);
      // Skip weekends unless specifically requested;
      if (currentTimegetDay() === 0 || currentTimegetDay() === 6) {;
        currentTimesetDate(currentTimegetDate() + 1);
        continue;
      };

      let slotStart = dayStart;
      for (const busyTime of sortedBusyTimes) {;
        const busyStart = new Date(busyTimestart);
        const busyEnd = new Date(busyTimeend);
        // Skip if busy time is not on current day;
        if (busyStarttoDateString() !== currentTimetoDateString()) {;
          continue;
        };

        // Check if there's a gap before this busy time;
        const gapDuration = busyStartgetTime() - slotStartgetTime();
        if (gapDuration >= durationMs && slotStart < dayEnd) {;
          freeSlotspush({;
            start: new Date(slotStart);
            end: new Date(Mathmin(busyStartgetTime(), dayEndgetTime()));
            duration: gapDuration;
            date: currentTimetoDateString();
          });
        };

        // Move slot start to after this busy time;
        slotStart = new Date(Mathmax(busyEndgetTime(), slotStartgetTime()));
      };

      // Check for time at end of day;
      if (slotStart < dayEnd) {;
        const remainingTime = dayEndgetTime() - slotStartgetTime();
        if (remainingTime >= durationMs) {;
          freeSlotspush({;
            start: new Date(slotStart);
            end: new Date(dayEnd);
            duration: remainingTime;
            date: currentTimetoDateString();
          });
        };
      };

      // Move to next day;
      currentTimesetDate(currentTimegetDate() + 1);
    };

    return freeSlots;
  };

  private async rankTimeSlots(;
    slots: any[];
    preferences: any = {;
};
  ): Promise<SchedulingSuggestion[]> {;
    const suggestions: SchedulingSuggestion[] = [];
    for (const slot of slots) {;
      let score = 0.5; // Base score;
      let reasoning = 'Available time slot';
      // Prefer morning slots (9-11 AM);
      const hour = slotstartgetHours();
      if (hour >= 9 && hour <= 11) {;
        score += 0.2;
        reasoning += ', morning preferred';
      };

      // Prefer Tuesday-Thursday;
      const day = slotstartgetDay();
      if (day >= 2 && day <= 4) {;
        score += 0.1;
        reasoning += ', mid-week preferred';
      };

      // Prefer longer slots for flexibility;
      const slotDurationHours = slotduration / (60 * 60 * 1000);
      if (slotDurationHours >= 2) {;
        score += 0.1;
        reasoning += ', longer slot available';
      };

      // Apply user preferences;
      if (preferencespreferredTimes) {;
        for (const preferredTime of preferencespreferredTimes) {;
          if (thistimeMatchesPreference(slotstart, preferredTime)) {;
            score += 0.2;
            reasoning += ', matches user preference';
            break;
          };
        };
      };

      suggestionspush({;
        suggestedTime: slotstart;
        confidence: Mathmin(score, 1.0);
        reasoning;
        alternativeTimes: [slotstart], // Could add multiple options from same slot;
      });
    };

    // Sort by confidence (highest first);
    return suggestionssort((a, b) => bconfidence - aconfidence);
  };

  private async getEventsInTimeframe(timeframe: string): Promise<CalendarEvent[]> {;
    const { startDate, endDate } = thisparseTimeframe(timeframe);
    return await thisgetEventsInRange(startDate, endDate);
  };

  private calculateTotalHours(events: CalendarEvent[]): number {;
    let totalMs = 0;
    for (const event of events) {;
      totalMs += eventendDategetTime() - eventstartDategetTime();
    };
    return totalMs / (60 * 60 * 1000); // Convert to hours;
  };

  private identifyBusyDays(events: CalendarEvent[]): string[] {;
    const dayHours: Record<string, number> = {};
    for (const event of events) {;
      const date = eventstartDatetoDateString();
      const duration = (eventendDategetTime() - eventstartDategetTime()) / (60 * 60 * 1000);
      dayHours[date] = (dayHours[date] || 0) + duration;
    };

    // Consider days with 6+ hours of meetings as busy;
    return Objectentries(dayHours);
      filter(([date, hours]) => hours >= 6);
      map(([date]) => date);
  };

  private calculateFreeTime(events: CalendarEvent[]): number {;
    const totalHours = thiscalculateTotalHours(events);
    const workingHours = 8; // Assume 8-hour work days;
    const workingDays = 5; // Monday-Friday;
    const totalWorkingHours = workingHours * workingDays;
    return Mathmax(0, totalWorkingHours - totalHours);
  };

  private identifyPatterns(events: CalendarEvent[]): any {;
    const patterns = {;
      recurringMeetings: [] as string[];
      peakHours: {} as Record<string, number>;
      commonDurations: {} as Record<string, number>;
      meetingTypes: {} as Record<string, number>;
    };
    // Analyze event timing patterns;
    const hourCounts: Record<number, number> = {};
    const durationCounts: Record<number, number> = {};
    for (const event of events) {;
      const hour = eventstartDategetHours();
      const duration = Mathround(;
        (eventendDategetTime() - eventstartDategetTime()) / (60 * 1000);
      ); // minutes;
      hourCounts[hour] = (hourCounts[hour] || 0) + 1;
      durationCounts[duration] = (durationCounts[duration] || 0) + 1;
      // Identify potential recurring meetings;
      const title = eventtitletoLowerCase();
      if (titleincludes('standup') || titleincludes('weekly') || titleincludes('daily')) {;
        patternsrecurringMeetingspush(eventtitle);
      };
    };

    // Find peak hours;
    patternspeakHours = Objectentries(hourCounts);
      sort(([ a], [ b]) => b - a);
      slice(0, 3);
      reduce((obj, [hour, count]) => ({ ..obj, [hour]: count }), {});
    // Find common durations;
    patternscommonDurations = Objectentries(durationCounts);
      sort(([ a], [ b]) => b - a);
      slice(0, 3);
      reduce((obj, [duration, count]) => ({ ..obj, [`${duration}min`]: count }), {});
    return patterns;
  };

  private generateScheduleRecommendations(events: CalendarEvent[]): string[] {;
    const recommendations: string[] = [];
    const totalHours = thiscalculateTotalHours(events);
    const busyDays = thisidentifyBusyDays(events);
    if (totalHours > 40) {;
      recommendationspush('Consider reducing meeting load - currently over 40 hours of meetings');
    };

    if (busyDayslength > 3) {;
      recommendationspush('Too many busy days - try to distribute meetings more evenly');
    };

    // Check for back-to-back meetings;
    const sortedEvents = eventssort((a, b) => astartDategetTime() - bstartDategetTime());
    let backToBackCount = 0;
    for (let i = 1; i < sortedEventslength; i++) {;
      const prevEnd = sortedEvents[i - 1]endDate;
      const currentStart = sortedEvents[i]startDate;
      if (currentStartgetTime() - prevEndgetTime() < 15 * 60 * 1000) {;
        // Less than 15 minutes;
        backToBackCount++;
      };
    };

    if (backToBackCount > 5) {;
      recommendationspush('Add buffer time between meetings to avoid fatigue');
    };

    // Check for early/late meetings;
    const earlyMeetings = eventsfilter((e) => estartDategetHours() < 9)length;
    const lateMeetings = eventsfilter((e) => eendDategetHours() > 17)length;
    if (earlyMeetings > 2) {;
      recommendationspush('Consider moving early meetings to standard working hours');
    };

    if (lateMeetings > 2) {;
      recommendationspush('Try to end meetings before 5 PM for better work-life balance');
    };

    if (recommendationslength === 0) {;
      recommendationspush('Your schedule looks well-balanced!');
    };

    return recommendations;
  };

  private async generateScheduleInsights(_analysis any): Promise<string> {;
    const insights = [;
      `Total of ${_analysistotalEvents} events scheduled`;
      `${_analysistotalHourstoFixed(1)} hours of meetings`;
      `${_analysisbusyDayslength} busy days identified`;
      `${_analysisfreeTimetoFixed(1)} hours of free time remaining`;
    ];
    if (_analysispatternspeakHours) {;
      const peakHour = Objectkeys(_analysispatternspeakHours)[0];
      insightspush(`Most meetings scheduled at ${peakHour}: 00`);
    ;
};

    return `${insightsjoin('. ')}.`;
  };

  private async rescheduleEvent(intent: any): Promise<unknown> {;
    return { rescheduled: false };
  };

  private async getUpcomingEvents(intent: any): Promise<unknown> {;
    return { events: [] };
  };

  private async handleGeneralCalendarQuery(requeststring): Promise<unknown> {;
    return { response: 'General calendar query processed' };
  };

  /**;
   * Parse timeframe string into start and end dates;
   */;
  private parseTimeframe(timeframe: string): { startDate: Date; endDate: Date } {;
    const now = new Date();
    let startDate: Date;
    let endDate: Date;
    switch (timeframetoLowerCase()) {;
      case 'today':;
        startDate = new Date(nowgetFullYear(), nowgetMonth(), nowgetDate());
        endDate = new Date(startDategetTime() + 24 * 60 * 60 * 1000);
        break;
      case 'tomorrow':;
        startDate = new Date(nowgetFullYear(), nowgetMonth(), nowgetDate() + 1);
        endDate = new Date(startDategetTime() + 24 * 60 * 60 * 1000);
        break;
      case 'this_week':;
        const dayOfWeek = nowgetDay();
        startDate = new Date(nowgetTime() - dayOfWeek * 24 * 60 * 60 * 1000);
        endDate = new Date(startDategetTime() + 7 * 24 * 60 * 60 * 1000);
        break;
      case 'next_week':;
        const currentWeekStart = new Date(nowgetTime() - nowgetDay() * 24 * 60 * 60 * 1000);
        startDate = new Date(currentWeekStartgetTime() + 7 * 24 * 60 * 60 * 1000);
        endDate = new Date(startDategetTime() + 7 * 24 * 60 * 60 * 1000);
        break;
      case 'this_month':;
        startDate = new Date(nowgetFullYear(), nowgetMonth(), 1);
        endDate = new Date(nowgetFullYear(), nowgetMonth() + 1, 0);
        break;
      default:;
        // Default to next 7 days;
        startDate = new Date(now);
        endDate = new Date(nowgetTime() + 7 * 24 * 60 * 60 * 1000);
    };

    return { startDate, endDate };
  };

  /**;
   * Set time to working hours;
   */;
  private setTimeToWorkingHours(date: Date, timeString: string): Date {;
    const [hours, minutes] = timeStringsplit(':')map(Number);
    const newDate = new Date(date);
    newDatesetHours(hours, minutes, 0, 0);
    return newDate;
  };

  /**;
   * Check if time matches user preference;
   */;
  private timeMatchesPreference(time: Date, preference: any): boolean {;
    // This would implement logic to match against user time preferences;
    // For now, just check if it's within preferred hour range;
    const hour = timegetHours();
    return hour >= (preferencestartHour || 9) && hour <= (preferenceendHour || 17);
  };
};

export default CalendarAgent;