/**;
 * Enhanced PersonalAssistantAgent with Vector Memory;
 * Uses semantic memory search for intelligent, context-aware assistance;
 */;

import type { EnhancedAgentConfig } from '../enhanced_base_agent';
import { EnhancedBaseAgent } from '../enhanced_base_agent';
import type { AgentContext, AgentResponse } from '../base_agent';
import type { Memory } from '../../memory/enhanced_memory_system';
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Logger } from 'winston';
interface PersonalContext extends AgentContext {;
  userId: string;
  preferences: UserPreferences;
  currentLocation?: string;
  timeZone: string;
  workingHours: { start: string; end: string ;
};
  activeProjects: string[];
  recentActivity: ActivityLog[];
  relevantMemories: Memory[];
  memoryInsights: any;
  intent?: {;
    type: string;
    confidence: number;
    parameters?: any;
    requiresCoordination?: boolean;
    agentsNeeded?: string[];
    action?: string;
  ;
};
  historicalPatterns?: {;
    hasPatterns: boolean;
    recommendedApproach: string;
    patterns: any[];
  ;
};
  crossAgentInsights?: {;
    hasAnyHistory: boolean;
    insights: any[];
    agentInsights?: any[];
  ;
};
};

interface UserPreferences {;
  communication: {;
    tone: 'formal' | 'casual' | 'friendly';
    verbosity: 'brief' | 'normal' | 'detailed';
    notifications: boolean;
  ;
};
  automation: {;
    autoOrganizeFiles: boolean;
    autoSchedule: boolean;
    autoBackup: boolean;
    autoOptimize: boolean;
  ;
};
  privacy: {;
    dataRetention: number;
    shareAnalytics: boolean;
    localProcessingOnly: boolean;
  ;
};
  workflow: {;
    preferredTools: string[];
    workspaces: string[];
    integrations: string[];
  ;
};
};

interface ActivityLog {;
  timestamp: Date;
  action: string;
  context: string;
  outcome: 'success' | 'failure' | 'partial';
;
};

export default class EnhancedPersonalAssistantAgent extends EnhancedBaseAgent {;
  private availableAgents: Map<string, any> = new Map();
  private userContextCache: Map<string, PersonalContext> = new Map();
  constructor(config: EnhancedAgentConfig, supabase: SupabaseClient, logger: Logger) {;
    super(;);
      {;
        ..config;
        useVectorMemory: true;
        memorySearchThreshold: 0.6;
        maxMemoryResults: 15;
        autoLearn: true;
      ;
};
      supabase;
      logger;
    );
  };

  /**;
   * Initialize the personal assistant agent;
   */;
  protected async onInitialize(): Promise<void> {;
    thisloggerinfo('Enhanced Personal Assistant Agent initialized');
    // Initialize available agents and user context cache;
    await thisloadAvailableAgents();
  ;
};

  /**;
   * Shutdown the personal assistant agent;
   */;
  protected async onShutdown(): Promise<void> {;
    thisloggerinfo('Enhanced Personal Assistant Agent shutting down');
    // Clear caches and save state;
    thisuserContextCacheclear();
    thisavailableAgentsclear();
  ;
};

  /**;
   * Load available agents for coordination;
   */;
  private async loadAvailableAgents(): Promise<void> {;
    // Initialize with default agents;
    thisavailableAgentsset('file_manager', {;
      name: 'file_manager';
      capabilities: ['file_operations'];
    });
    thisavailableAgentsset('web_scraper', {;
      name: 'web_scraper';
      capabilities: ['web_data_extraction'];
    });
    thisavailableAgentsset('code_assistant', {;
      name: 'code_assistant';
      capabilities: ['code__analysis, 'code_generation'];
    });
  };

  /**;
   * Enhanced processing with memory-driven intelligence;
   */;
  protected async processWithMemory(context: PersonalContext): Promise<AgentResponse> {;
    try {;
      // Analyze requestintent with memory context;
      const intent = await thisanalyzeIntentWithMemory(context);
      // Get user context and preferences;
      const userContext = await thisgetUserContext(contextuserId || 'default');
      // Enhance context with user data;
      const enhancedContext = {;
        ..context;
        ..userContext;
        intent;
        historicalPatterns: thisextractHistoricalPatterns(contextrelevantMemories);
        crossAgentInsights: await thisgetCrossAgentInsights(contextuserRequest);
      };
      // Execute based on intent and memory insights;
      const response = await thisexecuteIntelligentAction(enhancedContext);
      // Learn from this interaction;
      await thisupdatePersonalLearning(enhancedContext, response);
      return response;
    } catch (error) {;
      thisloggererror('Enhanced personal assistant processing failed:', error instanceof Error ? errormessage : String(error);
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Analyze intent using memory context for better understanding;
   */;
  private async analyzeIntentWithMemory(context: PersonalContext): Promise<unknown> {;
    const request contextuserRequesttoLowerCase();
    const memories = contextrelevantMemories || [];
    // Base intent analysis;
    const intent = {;
      action: 'general';
      complexity: 0.5;
      requiresCoordination: false;
      agentsNeeded: ['personal_assistant'];
      confidence: 0.7;
      memoryInsights: contextmemoryInsights;
    };
    // Enhance with memory insights;
    if (memorieslength > 0) {;
      const memoryTypes = memoriesmap((m) => mmemoryType);
      const memoryContent = memoriesmap((m) => mcontentjoin(' ');
      // Check if this is a follow-up to previous actions;
      if (memoryTypesincludes('interaction') || memoryTypesincludes('task')) {;
        intentcomplexity += 0.2;
        intentconfidence += 0.1;
      };

      // Look for patterns in historical interactions;
      const hasSchedulingHistory =;
        memoryContentincludes('schedule') || memoryContentincludes('meeting');
      const hasFileHistory = memoryContentincludes('file') || memoryContentincludes('organize');
      const hasCodeHistory = memoryContentincludes('code') || memoryContentincludes('function');
      // Adjust agent selection based on memory patterns;
      if (hasSchedulingHistory && (requestincludes('time') || requestincludes('when'))) {;
        intentagentsNeededpush('calendar_agent');
      };

      if (hasFileHistory && (requestincludes('find') || requestincludes('organize'))) {;
        intentagentsNeededpush('file_manager');
      };

      if (hasCodeHistory && (requestincludes('code') || requestincludes('implement'))) {;
        intentagentsNeededpush('code_assistant');
      };
    };

    // Determine if coordination is needed;
    intentrequiresCoordination = intentagentsNeededlength > 1;
    // Multi-step task detection enhanced by memory;
    const multiStepIndicators = ['then', 'after', 'and', 'also', 'next'];
    const hasMultiStep = multiStepIndicatorssome((indicator) => requestincludes(indicator));
    if (hasMultiStep) {;
      intentcomplexity += 0.3;
      intentrequiresCoordination = true;
    };
;
    return intent;
  };

  /**;
   * Get or create user context with preferences;
   */;
  private async getUserContext(userId: string): Promise<PersonalContext> {;
    if (thisuserContextCachehas(userId)) {;
      return thisuserContextCacheget(userId)!;
    };

    try {;
      // Load user preferences from database;
      const { data: prefsData } = await thissupabase;
        from('agent_memory_preferences');
        select('preferences');
        eq('agent_name', 'personal_assistant');
        eq('user_id', userId);
        single();
      const preferences = prefsData?preferences || thisgetDefaultPreferences();
      const userContext: PersonalContext = {;
        requestId: `context_${Datenow()}`;
        timestamp: new Date();
        userRequest: '';
        metadata: {;
};
        userId;
        preferences;
        timeZone: 'America/Los_Angeles', // Would get from user settings;
        workingHours: { start: '09:00', end: '17:00' ;
};
        activeProjects: [];
        recentActivity: [];
        relevantMemories: [];
        memoryInsights: null;
      ;
};
      thisuserContextCacheset(userId, userContext);
      return userContext;
    } catch (error) {;
      thisloggerwarn('Failed to load user context, using defaults:', error instanceof Error ? errormessage : String(error);
      return {;
        requestId: `context_${Datenow()}`;
        timestamp: new Date();
        userRequest: '';
        metadata: {;
};
        userId;
        preferences: thisgetDefaultPreferences();
        timeZone: 'America/Los_Angeles';
        workingHours: { start: '09:00', end: '17:00' ;
};
        activeProjects: [];
        recentActivity: [];
        relevantMemories: [];
        memoryInsights: null;
      ;
};
    };
  };

  /**;
   * Extract patterns from historical memories;
   */;
  private extractHistoricalPatterns(memories: Memory[]): any {;
    if (!memorieslength) return { hasPatterns: false ;
};
    // Analyze time patterns;
    const timePattern = thisanalyzeTimePatterns(memories);
    // Analyze tool usage patterns;
    const toolPattern = thisanalyzeToolPatterns(memories);
    // Analyze success patterns;
    const successPattern = thisanalyzeSuccessPatterns(memories);
    return {;
      hasPatterns: true;
      timePattern;
      toolPattern;
      successPattern;
      recommendedApproach: thisgetRecommendedApproach(timePattern, toolPattern, successPattern);
    };
  };

  /**;
   * Get insights from other agents' memories;
   */;
  private async getCrossAgentInsights(requeststring): Promise<unknown> {;
    const otherAgents = [;
      'calendar_agent';
      'file_manager';
      'code_assistant';
      'photo_organizer';
      'system_control';
    ];
    try {;
      const crossAgentMemories = await thisfindCrossAgentMemories(requestotherAgents);
      return {;
        hasAnyHistory: Objectkeys(crossAgentMemories)length > 0;
        agentInsights: Objectentries(crossAgentMemories)map(([agent, memories]) => ({;
          agent;
          memoryCount: memorieslength;
          mostRelevant: `${memories[0]?contentsubstring(0, 100)}...`;
          avgImportance: memoriesreduce((sum, m) => sum + mimportanceScore, 0) / memorieslength;
        }));
      };
    } catch (error) {;
      thisloggerwarn('Failed to get cross-agent insights:', error instanceof Error ? errormessage : String(error);
      return { hasAnyHistory: false, agentInsights: [] };
    };
  };

  /**;
   * Execute intelligent action based on enhanced context;
   */;
  private async executeIntelligentAction(context: PersonalContext): Promise<AgentResponse> {;
    const { intent, historicalPatterns, crossAgentInsights } = context;
    // Use memory insights to improve response;
    let reasoning = `Processing requestwith ${contextrelevantMemories?length || 0} relevant memories.`;
    if (historicalPatterns?hasPatterns) {;
      reasoning += ` Found patterns in historical interactions: ${historicalPatternsrecommendedApproach}.`;
    };

    if (crossAgentInsights?hasAnyHistory) {;
      reasoning += ` Cross-agent _analysisshows relevant history in ${crossAgentInsightsagentInsights?length || 0} other agents.`;
    };

    // Generate response based on intent and memory;
    let response: any;
    if (intent?requiresCoordination) {;
      response = await thiscoordinateMultipleAgents(context, intent);
    } else if (;
      intent?agentsNeeded?length === 1 &&;
      intentagentsNeeded[0] !== 'personal_assistant';
    ) {;
      response = await thisdelegateToSpecificAgent(context, intentagentsNeeded[0]);
    } else {;
      response = await thishandleDirectly(context);
    };

    return {;
      success: true;
      data: response;
      reasoning;
      confidence: Mathmin(;
        (intent?confidence || 0.5) + (historicalPatterns?hasPatterns ? 0.1 : 0);
        1.0;
      );
      nextActions: thisgenerateSmartNextActions(context, response);
      latencyMs: 0, // Will be set by the base class;
      agentId: thisconfigname || 'personal_assistant';
    ;
};
  };

  /**;
   * Coordinate multiple agents based on memory insights;
   */;
  private async coordinateMultipleAgents(context: PersonalContext, intent: any): Promise<unknown> {;
    const steps = thisplanExecutionSteps(context, intent);
    const results: any[] = [];
    for (const step of steps) {;
      try {;
        stepstatus = 'in_progress';
        // Use memory context to inform each step;
        const stepResult = await thisexecuteStep(step, context);
        stepstatus = 'completed';
        stepresult = stepResult;
        resultspush(stepResult);
      } catch (error) {;
        stepstatus = 'failed';
        stepresult = { success: false, error instanceof Error ? errormessage : String(error) (erroras Error)message ;
};
        thisloggererror`Step ${stepid} failed:`, error instanceof Error ? errormessage : String(error)  ;
};
    };
;
    return {;
      coordination: 'multi_agent';
      steps;
      results;
      summary: thisgenerateCoordinationSummary(steps, results);
    };
  };

  /**;
   * Update personal learning based on interaction outcomes;
   */;
  private async updatePersonalLearning(;
    context: PersonalContext;
    response: AgentResponse;
  ): Promise<void> {;
    try {;
      // Store successful patterns;
      if (;
        responsesuccess &&;
        contextintent?agentsNeeded &&;
        contextintentagentsNeededlength > 1;
      ) {;
        await thismemorySystemstoreMemory(;
          'personal_assistant';
          'successful__pattern;
          `Multi-agent coordination: ${contextintentagentsNeededjoin(', ')} for requesttype: ${contextintentaction || 'unknown'}`;
          {;
            request_type: contextintentaction || 'unknown';
            agents_used: contextintentagentsNeeded;
            success_rate: 1.0;
            user_satisfaction: 'high', // Would come from user feedback;
            patterns_used: contexthistoricalPatterns;
          ;
};
        );
      };

      // Update user preferences based on successful interactions;
      if (responsesuccess) {;
        await thisupdateUserPreferences(contextuserId, context, response);
      };
    } catch (error) {;
      thisloggerwarn('Failed to update personal learning:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  /**;
   * Helper methods for _patternanalysis;
   */;
  private analyzeTimePatterns(memories: Memory[]): any {;
    // Analyze when user typically performs certain actions;
    const timeData = memories;
      filter((m) => mmetadata?timestamp);
      map((m) => ({;
        hour: new Date(mmetadatatimestamp)getHours();
        action: mmemoryType;
      }));
    if (timeDatalength === 0) return { hasTimePattern: false ;
};
    const hourFreq: Record<number, number> = {};
    timeDataforEach(({ hour }) => {;
      hourFreq[hour] = (hourFreq[hour] || 0) + 1;
    });
    const mostActiveHour = Objectentries(hourFreq)sort((a, b) => b[1] - a[1])[0];
    return {;
      hasTimePattern: true;
      mostActiveHour: parseInt(mostActiveHour[0], 10);
      totalActivities: timeDatalength;
    ;
};
  };

  private analyzeToolPatterns(memories: Memory[]): any {;
    const toolUsage = memories;
      map((m) => mserviceId);
      reduce(;
        (acc, tool) => {;
          acc[tool] = (acc[tool] || 0) + 1;
          return acc;
        };
        {} as Record<string, number>;
      );
    const preferredTool = Objectentries(toolUsage)sort((a, b) => b[1] - a[1])[0];
    return {;
      hasToolPreference: !!preferredTool;
      preferredTool: preferredTool?.[0];
      toolDistribution: toolUsage;
    ;
};
  };

  private analyzeSuccessPatterns(memories: Memory[]): any {;
    const successes = memoriesfilter(;
      (m) => mmetadata?responseSuccess === true || mmetadata?outcome === 'success';
    );
    return {;
      successRate: memorieslength > 0 ? successeslength / memorieslength : 0;
      totalInteractions: memorieslength;
      successfulInteractions: successeslength;
    ;
};
  };

  private getRecommendedApproach(timePattern: any, toolPattern: any, successPattern: any): string {;
    if (successPatternsuccessRate > 0.8) {;
      return 'Continue with proven approach based on historical success';
    };

    if (toolPatternhasToolPreference) {;
      return `Leverage preferred tool: ${toolPatternpreferredTool}`;
    };

    if (timePatternhasTimePattern) {;
      return `Consider user's typical activity time: ${timePatternmostActiveHour}:00`;
    };

    return 'Use adaptive approach based on requestcontext';
  };

  private getDefaultPreferences(): UserPreferences {;
    return {;
      communication: {;
        tone: 'friendly';
        verbosity: 'normal';
        notifications: true;
      ;
};
      automation: {;
        autoOrganizeFiles: false;
        autoSchedule: false;
        autoBackup: true;
        autoOptimize: true;
      ;
};
      privacy: {;
        dataRetention: 30;
        shareAnalytics: false;
        localProcessingOnly: true;
      ;
};
      workflow: {;
        preferredTools: [];
        workspaces: [];
        integrations: [];
      ;
};
    };
  };

  private planExecutionSteps(context: PersonalContext, intent: any): any[] {;
    // Create execution plan based on intent and memory insights;
    return intentagentsNeededmap((agent: string, index: number) => ({;
      id: `step_${index + 1}`;
      agent;
      action: intentaction;
      status: 'pending';
      context: {;
        userRequest: contextuserRequest;
        memoryContext: contextrelevantMemories?filter((m) => mserviceId === agent);
      ;
};
    }));
  };

  private async executeStep(step: any, context: PersonalContext): Promise<unknown> {;
    // Execute individual step with memory context;
    return {;
      agent: stepagent;
      action: stepaction;
      result: `Executed ${stepaction} using ${stepagent} with memory context`;
      success: true;
    ;
};
  };

  private generateCoordinationSummary(steps: any[], results: any[]): string {;
    const successful = resultsfilter((r) => rsuccess)length;
    return `Coordinated ${stepslength} agents, ${successful} successful operations`;
  };

  private async delegateToSpecificAgent(context: PersonalContext, agentName: string): Promise<unknown> {;
    return {;
      delegation: agentName;
      result: `Delegated to ${agentName} with memory context`;
      memoryEnhanced: true;
    ;
};
  };

  private async handleDirectly(context: PersonalContext): Promise<unknown> {;
    return {;
      handled: 'directly';
      response: `Processed requestdirectly using ${contextrelevantMemories?length || 0} memories`;
      insights: contextmemoryInsights;
    ;
};
  };

  private generateSmartNextActions(context: PersonalContext, response: any): string[] {;
    const actions = [];
    if (contextmemoryInsights?hasRelevantHistory) {;
      actionspush('Review related historical actions');
    };

    if (responsecoordination === 'multi_agent') {;
      actionspush('Monitor coordinated task progress');
    };

    actionspush('Update user preferences based on interaction');
    return actions;
  };

  private async updateUserPreferences(;
    userId: string;
    context: PersonalContext;
    response: AgentResponse;
  ): Promise<void> {;
    // Update user preferences based on successful patterns;
    const updates = {;
      last_successful__pattern contextintent;
      interaction_count: (contextpreferences as any)?interaction_count + 1 || 1;
      preferred_response_style: responseconfidence > 0.8 ? 'detailed' : 'brief';
    };
    await thissupabasefrom('agent_memory_preferences')upsert({;
      agent_name: 'personal_assistant';
      user_id: userId;
      preference_type: 'learning_updates';
      preferences: updates;
    });
  };
};
