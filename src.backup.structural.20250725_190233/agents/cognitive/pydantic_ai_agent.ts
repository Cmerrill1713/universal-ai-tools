/**;
 * Pydantic AI Agent - Provides type-safe, structured AI responses;
 * Integrates with PydanticAIService for validated interactions;
 */;

import { z } from 'zod';
import type { AgentContext, AgentResponse, PartialAgentResponse } from '../base_agent';
import { type CognitiveCapability, RealCognitiveAgent } from './real_cognitive_agent';
import { type AIRequest, getPydanticAIService } from '../../services/pydantic-ai-service';
import {;
  CodeGenerationSchema;
  CognitiveAnalysisSchema;
  TaskPlanSchema;
} from '../../services/pydantic-ai-service';
// Agent-specific response schemas;
const StructuredResponseSchema = zobject({;
  summary: zstring();
  details: zrecord(zany());
  confidence: znumber();
  sources: zarray(zstring())optional();
});
const ValidationResultSchema = zobject({;
  valid: zboolean();
  errors: zarray(,);
    zobject({;
      field: zstring();
      message: zstring();
      severity: zenum(['error', 'warning', 'info']);
    });
  );
  suggestions: zarray(zstring());
});
export class PydanticAIAgent extends RealCognitiveAgent {;
  private pydanticService = getPydanticAIService();
  constructor(config: any) {;
    super({;
      ..config;
      name: 'pydantic_ai';
      description: 'Provides type-safe, structured AI responses with validation';
      category: 'cognitive';
      capabilities: [;
        {;
          name: 'structured_response';
          description: 'Generate validated structured responses';
          inputSchema: {;
            type: 'object';
            properties: {;
              prompt: { type: 'string' ;
};
              schema: { type: 'object' ;
};
              context: { type: 'object' ;
};
            };
            required: ['prompt'];
          ;
};
          outputSchema: {;
            type: 'object';
            properties: {;
              data: { type: 'object' ;
};
              valid: { type: 'boolean' ;
};
              errors: { type: 'array' ;
};
            };
          };
        };
        {;
          name: 'validate_data';
          description: 'Validate data against schemas';
          inputSchema: {;
            type: 'object';
            properties: {;
              data: { type: 'object' ;
};
              schemaName: { type: 'string' ;
};
            };
            required: ['data', 'schemaName'];
          };
          outputSchema: {;
            type: 'object';
            properties: {;
              valid: { type: 'boolean' ;
};
              errors: { type: 'array' ;
};
            };
          };
        };
      ];
    });
  };

  protected setupCognitiveCapabilities(): void {;
    // Structured response capability;
    thiscognitiveCapabilitiesset('structured_response', {;
      name: 'structured_response';
      execute: async (input any, context: AgentContext) => {;
        return thisgenerateStructuredResponse(inputcontext);
      };
    });
    // Validation capability;
    thiscognitiveCapabilitiesset('validate', {;
      name: 'validate';
      execute: async (input any, context: AgentContext) => {;
        return thisvalidateData(inputcontext);
      };
    });
    // Cognitive _analysiscapability;
    thiscognitiveCapabilitiesset('analyze', {;
      name: 'analyze';
      execute: async (input any, context: AgentContext) => {;
        return thisperformCognitiveAnalysis(inputcontext);
      };
    });
    // Task planning capability;
    thiscognitiveCapabilitiesset('plan', {;
      name: 'plan';
      execute: async (input any, context: AgentContext) => {;
        return thiscreateTaskPlan(inputcontext);
      };
    });
    // Code generation capability;
    thiscognitiveCapabilitiesset('generate_code', {;
      name: 'generate_code';
      execute: async (input any, context: AgentContext) => {;
        return thisgenerateCode(inputcontext);
      };
    });
  };

  protected async selectCapability(context: AgentContext): Promise<CognitiveCapability | null> {;
    const request contextuserRequesttoLowerCase();
    // Check for specific capability requests;
    if (requestincludes('validate') || requestincludes('check')) {;
      return thiscognitiveCapabilitiesget('validate') || null;
    };

    if (requestincludes('analyze') || requestincludes('_analysis)) {;
      return thiscognitiveCapabilitiesget('analyze') || null;
    };

    if (requestincludes('plan') || requestincludes('task') || requestincludes('steps')) {;
      return thiscognitiveCapabilitiesget('plan') || null;
    };

    if (requestincludes('code') || requestincludes('generate') || requestincludes('implement')) {;
      return thiscognitiveCapabilitiesget('generate_code') || null;
    };

    // Default to structured response;
    return thiscognitiveCapabilitiesget('structured_response') || null;
  };

  /**;
   * Generate a structured response with validation;
   */;
  private async generateStructuredResponse(;
    inputany;
    context: AgentContext;
  ): Promise<AgentResponse> {;
    const startTime = Datenow();
    try {;
      const { prompt, schema, contextData } = _input;

      // Create the AI request;
      const requestPartial<AIRequest> = {;
        prompt: prompt || contextuserRequest;
        context: {;
          userId: contextuserId;
          sessionId: contextsessionId;
          metadata: contextData || contextmetadata;
          systemPrompt: 'Provide a structured response that matches the requested format exactly.';
          temperature: 0.7;
          maxTokens: 2000;
          memoryEnabled: true;
        ;
};
        validation: {;
          outputSchema: schema || StructuredResponseSchema;
          strictMode: true;
          retryAttempts: 3;
        ;
};
      };
      // Get response with schema validation;
      const response = schema;
        ? await thispydanticServicerequestWithSchema(requestschema);
        : await thispydanticServicerequestrequest;
      return {;
        success: responsesuccess;
        data: responsestructuredData || responsecontent;
        reasoning: responsereasoning;
        confidence: responseconfidence;
        message: responsesuccess;
          ? 'Generated structured response successfully';
          : 'Failed to generate valid structured response';
        latencyMs: Datenow() - startTime;
        agentId: thisconfigname;
        metadata: {;
          validation: responsevalidation;
          model: responsemodel;
          agentsInvolved: responsemetadataagentsInvolved;
        ;
};
      };
    } catch (error) {;
      return thiscreateErrorResponse(error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Validate data against known schemas;
   */;
  private async validateData(inputany, context: AgentContext): Promise<PartialAgentResponse> {;
    try {;
      const { data, schemaName } = _input;

      // Define available schemas;
      const schemas: Record<string, zZodSchema> = {;
        cognitive__analysis CognitiveAnalysisSchema;
        task_plan: TaskPlanSchema;
        code_generation: CodeGenerationSchema;
        structured_response: StructuredResponseSchema;
        validation_result: ValidationResultSchema;
      ;
};
      const schema = schemas[schemaName];
      if (!schema) {;
        throw new Error(`Unknown schema: ${schemaName}`);
      };

      // Validate the data;
      const result = schemasafeParse(data);
      const validationResult = {;
        valid: resultsuccess;
        errors: resultsuccess;
          ? [];
          : resulterrorerrorsmap((err) => ({;
              field: errpathjoin('.');
              message: errmessage;
              severity: 'error instanceof Error ? errormessage : String(error) as const;
            }));
        suggestions: resultsuccess;
          ? [];
          : [;
              'Ensure all required fields are present';
              'Check data types match the schema';
              'Validate nested objects conform to their schemas';
            ];
      ;
};
      return {;
        success: true;
        data: validationResult;
        reasoning: resultsuccess;
          ? 'Data validation passed successfully';
          : `Data validation failed with ${resulterrorerrorslength} errors`;
        confidence: resultsuccess ? 1.0 : 0.8;
        message: resultsuccess ? 'Data is valid according to schema' : 'Data validation failed';
      ;
};
    } catch (error) {;
      return thiscreateErrorResponse(error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Perform cognitive _analysisusing structured output;
   */;
  private async performCognitiveAnalysis(;
    inputany;
    context: AgentContext;
  ): Promise<PartialAgentResponse> {;
    try {;
      const content _inputcontent| contextuserRequest;
      const _analysis= await thispydanticServiceanalyzeCognitive(content{;
        userId: contextuserId;
        sessionId: contextsessionId;
        metadata: contextmetadata;
      });
      return {;
        success: true;
        data: _analysis;
        reasoning: `Analyzed contentand extracted ${_analysiskeyInsightslength} insights and ${_analysisentitieslength} entities`;
        confidence: _analysisconfidence;
        message: 'Cognitive _analysiscompleted successfully';
        nextActions: _analysisrecommendationsmap((r) => raction);
      ;
};
    } catch (error) {;
      return thiscreateErrorResponse(error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Create a structured task plan;
   */;
  private async createTaskPlan(inputany, context: AgentContext): Promise<PartialAgentResponse> {;
    try {;
      const objective = _inputobjective || contextuserRequest;
      const constraints = _inputconstraints || {};
      const plan = await thispydanticServiceplanTask(objective, constraints);
      return {;
        success: true;
        data: plan;
        reasoning: `Created task plan with ${planstepslength} steps requiring ${planrequiredAgentslength} agents`;
        confidence: 0.85;
        message: `Task plan created: estimated ${plantotalEstimatedTime} minutes`;
        nextActions: [`Execute step 1: ${plansteps[0]?description}`];
        metadata: {;
          totalSteps: planstepslength;
          requiredAgents: planrequiredAgents;
          risks: planrisks;
        ;
};
      };
    } catch (error) {;
      return thiscreateErrorResponse(error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Generate code with validation;
   */;
  private async generateCode(inputany, context: AgentContext): Promise<PartialAgentResponse> {;
    try {;
      const { specification, language = 'typescript', options = {} } = _input;
      const spec = specification || contextuserRequest;
      const codeGen = await thispydanticServicegenerateCode(spec, language, options);
      return {;
        success: true;
        data: codeGen;
        reasoning: `Generated ${language} code with ${codeGendependencieslength} dependencies`;
        confidence: 0.9;
        message: 'Code generated successfully';
        metadata: {;
          language: codeGenlanguage;
          hasTests: Boolean(codeGentestCases?length);
          complexity: codeGencomplexity;
        ;
};
      };
    } catch (error) {;
      return thiscreateErrorResponse(error instanceof Error ? errormessage : String(error);
    };
  };

  /**;
   * Generate reasoning for the agent's response;
   */;
  protected async generateReasoning(;
    context: AgentContext;
    capability: CognitiveCapability;
    result: any;
  ): Promise<string> {;
    const prompt = `As a Pydantic AI agent, explain the structured data processing approach for:`;

Request: "${contextuserRequest}";
Capability used: ${capabilityname;
};
Schema validation: ${resultvalid ? 'Successful' : 'Failed';
};
Data structure: ${resultdata ? 'Generated' : 'None';
};

Provide reasoning for:;
1. How the requestwas interpreted;
2. What schema validation was performed;
3. Why this structured approach was chosen;
4. How type safety was ensured`;`;

    return thisgenerateOllamaResponse(prompt, context);
  };

  /**;
   * Create errorresponse;
   */;
  protected createErrorResponse(error instanceof Error ? errormessage : String(error) unknown): AgentResponse {;
    return {;
      success: false;
      data: null;
      reasoning: 'An erroroccurred during processing';
      confidence: 0;
      error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      message: 'Failed to process request;
      latencyMs: 0;
      agentId: thisconfigname;
    ;
};
  };

  /**;
   * Override process method to use Pydantic AI service;
   */;
  protected async process(;
    context: AgentContext & { memoryContext?: any ;
};
  ): Promise<AgentResponse> {;
    const startTime = Datenow();
    try {;
      // Select and execute capability;
      const capability = await thisselectCapability(context);
      if (!capability) {;
        // Fallback to general structured response;
        return thisgenerateStructuredResponse({ prompt: contextuserRequest }, context);
      };

      // Execute the selected capability;
      const result = await capabilityexecute(;
        { contentcontextuserRequest, ..contextmetadata };
        context;
      );
      // Ensure result has proper AgentResponse structure;
      return {;
        ..result;
        latencyMs: resultlatencyMs || (Datenow() - startTime);
        agentId: resultagentId || thisconfigname;
      ;
};
    } catch (error) {;
      thisloggererror('PydanticAI processing failed:', error instanceof Error ? errormessage : String(error);
      return thiscreateErrorResponse(error instanceof Error ? errormessage : String(error);
    };
  };
};

// Export factory function;
export function createPydanticAIAgent(config?: any): PydanticAIAgent {;
  return new PydanticAIAgent(config || {});
};
