import { SpanKind, SpanStatusCode, context, propagation, trace } from '@opentelemetry/api';
import { SemanticAttributes } from '@opentelemetry/semantic-conventions';
import { telemetryService } from '../services/telemetry-service';
import { logger } from '../utils/logger';
import type {;
import { TIME_500MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_10000MS, ZERO_POINT_FIVE, ZERO_POINT_EIGHT, ZERO_POINT_NINE, BATCH_SIZE_10, MAX_ITEMS_100, PERCENT_10, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, PERCENT_100, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500 } from "../utils/common-constants";
  AxiosError;
  AxiosInstance;
  AxiosRequestConfig;
  AxiosResponse;
  InternalAxiosRequestConfig;
} from 'axios';
import axios from 'axios';
import { TIME_500MS, TIME_1000MS, TIME_2000MS, TIME_5000MS, TIME_10000MS, ZERO_POINT_FIVE, ZERO_POINT_EIGHT, ZERO_POINT_NINE, BATCH_SIZE_10, MAX_ITEMS_100, PERCENT_10, PERCENT_20, PERCENT_30, PERCENT_50, PERCENT_80, PERCENT_90, PERCENT_100, HTTP_200, HTTP_400, HTTP_401, HTTP_404, HTTP_500 } from "../utils/common-constants";
interface HttpOperation {;
  method: string;
  url: string;
  service?: string;
  timeout?: number;
;
};

export class HttpInstrumentation {;
  private tracer = telemetryServicegetTracer();
  /**;
   * Create an instrumented axios instance;
   */;
  createInstrumentedAxios(config?: AxiosRequestConfig): AxiosInstance {;
    const instance = axioscreate(config);
    thisinstrumentAxiosInstance(instance);
    return instance;
  };

  /**;
   * Instrument an existing axios instance;
   */;
  instrumentAxiosInstance(instance: AxiosInstance): void {;
    // Add requestinterceptor;
    instanceinterceptorsrequestuse(;
      (config) => thishandleRequest(config);
      (error instanceof Error ? errormessage : String(error) => thishandleRequestError(error;
    );
    // Add response interceptor;
    instanceinterceptorsresponseuse(;
      (response) => thishandleResponse(response);
      (error instanceof Error ? errormessage : String(error) => thishandleResponseError(error;
    );
  ;
};

  /**;
   * Wrap an HTTP requestwith tracing;
   */;
  async withHttpSpan<T>(operation: HttpOperation, fn: () => Promise<T>): Promise<T> {;
    const url = new URL(operationurl);
    const spanName = `HTTP ${operationmethod} ${urlhostname}${urlpathname}`;
    const span = thistracerstartSpan(spanName, {;
      kind: SpanKindCLIENT;
      attributes: {;
        [SemanticAttributesHTTP_METHOD]: operationmethod;
        [SemanticAttributesHTTP_URL]: operationurl;
        [SemanticAttributesHTTP_SCHEME]: urlprotocolreplace(':', '');
        [SemanticAttributesHTTP_HOST]: urlhostname;
        [SemanticAttributesHTTP_TARGET]: urlpathname + urlsearch;
        [SemanticAttributesNET_PEER_NAME]: urlhostname;
        [SemanticAttributesNET_PEER_PORT]: urlport || (urlprotocol === 'https:' ? 443 : 80);
        'httpservice': operationservice || 'external';
        'httptimeout': operationtimeout;
      ;
};
    });
    const startTime = Datenow();
    try {;
      const result = await contextwith(tracesetSpan(contextactive(), span), fn);
      spansetAttribute('httpduration_ms', Datenow() - startTime);
      spansetStatus({ code: SpanStatusCodeOK });
      return result;
    } catch (error) {;
      spanrecordException(erroras Error);
      if (axiosisAxiosError(error instanceof Error ? errormessage : String(error) {;
        const statusCode = errorresponse?status || 0;
        spansetAttribute(SemanticAttributesHTTP_STATUS_CODE, statusCode);
        if (statusCode >= 400) {;
          spansetStatus({;
            code: SpanStatusCodeERROR;
            message: `HTTP ${statusCode}: ${errormessage}`;
          });
        };

        // Add errordetails;
        spansetAttribute('errortype', errorcode || 'HTTP_ERROR');
        spansetAttribute('errormessage', errormessage);
        if (errorresponse?data) {;
          spansetAttribute(;
            'errorresponse';
            JSONstringify(errorresponsedata)substring(0, 1000);
          );
        };
      } else {;
        spansetStatus({;
          code: SpanStatusCodeERROR;
          message: error instanceof Error ? errormessage : 'HTTP requestfailed';
        });
      };

      loggererror('HTTP requestfailed', {;
        method: operationmethod;
        url: operationurl;
        error;
        duration: Datenow() - startTime;
      });
      throw error instanceof Error ? errormessage : String(error);
    } finally {;
      spanend();
    };
  };

  /**;
   * Handle axios request;
   */;
  private handleRequest(config: InternalAxiosRequestConfig): InternalAxiosRequestConfig {;
    const span = thistracerstartSpan(`HTTP ${configmethod?toUpperCase()} ${configurl}`, {;
      kind: SpanKindCLIENT;
    });
    // Add trace context to headers;
    const headers = configheaders || {};
    propagationinject(contextactive(), headers);
    configheaders = headers;
    // Store span in config for later use;
    (config as any).__span = span;
    (config as any).__startTime = Datenow();
    // Add requestattributes;
    if (configurl) {;
      try {;
        const url = new URL(configurl, configbaseURL);
        spansetAttributes({;
          [SemanticAttributesHTTP_METHOD]: configmethod?toUpperCase() || 'GET';
          [SemanticAttributesHTTP_URL]: urlhref;
          [SemanticAttributesHTTP_SCHEME]: urlprotocolreplace(':', '');
          [SemanticAttributesHTTP_HOST]: urlhostname;
          [SemanticAttributesHTTP_TARGET]: urlpathname + urlsearch;
          [SemanticAttributesNET_PEER_NAME]: urlhostname;
          [SemanticAttributesNET_PEER_PORT]: urlport || (urlprotocol === 'https:' ? 443 : 80);
        });
      } catch (error) {;
        loggererror('Failed to parse URL for tracing', { url: configurl, error instanceof Error ? errormessage : String(error) );
      ;
};
    };

    // Add requestbody size if available;
    if (configdata) {;
      const bodySize =;
        typeof configdata === 'string' ? configdatalength : JSONstringify(configdata)length;
      spansetAttribute('httprequestcontent-length', bodySize);
    };

    // Add custom headers as attributes;
    if (configheaders) {;
      Objectentries(configheaders)forEach(([key, value]) => {;
        if (keytoLowerCase()startsWith('x-')) {;
          spansetAttribute(`httprequestheader.${keytoLowerCase()}`, String(value));
        };
      });
    };

    return config;
  };

  /**;
   * Handle axios requesterror;
   */;
  private handleRequestError(error instanceof Error ? errormessage : String(error) any): Promise<unknown> {;
    const { config } = error;
    const span = config?.__span;
    if (span) {;
      spanrecordException(error instanceof Error ? errormessage : String(error);
      spansetStatus({;
        code: SpanStatusCodeERROR;
        message: 'Request failed before sending';
      });
      spanend();
    };

    return Promisereject(error instanceof Error ? errormessage : String(error);
  };

  /**;
   * Handle axios response;
   */;
  private handleResponse(response: AxiosResponse): AxiosResponse {;
    const config = responseconfig as any;
    const span = config.__span;
    const startTime = config.__startTime;
    if (span) {;
      const duration = Datenow() - startTime;
      spansetAttributes({;
        [SemanticAttributesHTTP_STATUS_CODE]: responsestatus;
        'httpresponsecontent-length': responseheaders['content-length'] || 0;
        'httpresponsecontent-type': responseheaders['content-type'];
        'httpduration_ms': duration;
      });
      // Add response headers as attributes;
      Objectentries(responseheaders)forEach(([key, value]) => {;
        if (keytoLowerCase()startsWith('x-')) {;
          spansetAttribute(`httpresponseheader.${keytoLowerCase()}`, String(value));
        };
      });
      // Set status based on HTTP status code;
      if (responsestatus >= 400) {;
        spansetStatus({;
          code: SpanStatusCodeERROR;
          message: `HTTP ${responsestatus}`;
        });
      } else {;
        spansetStatus({ code: SpanStatusCodeOK });
      };

      spanend();
    };

    return response;
  };

  /**;
   * Handle axios response error;
   */;
  private handleResponseError(error instanceof Error ? errormessage : String(error) AxiosError): Promise<unknown> {;
    const config = errorconfig as any;
    const span = config?.__span;
    const startTime = config?.__startTime;
    if (span) {;
      const duration = Datenow() - startTime;
      spansetAttribute('httpduration_ms', duration);
      if (errorresponse) {;
        spansetAttributes({;
          [SemanticAttributesHTTP_STATUS_CODE]: errorresponsestatus;
          'httpresponsecontent-length': errorresponseheaders['content-length'] || 0;
          'httpresponsecontent-type': errorresponseheaders['content-type'];
        });
        // Add errorresponse body (limited);
        if (errorresponsedata) {;
          const errorData =;
            typeof errorresponsedata === 'string';
              ? errorresponsedata;
              : JSONstringify(errorresponsedata);
          spansetAttribute('httpresponseerror instanceof Error ? errormessage : String(error)  errorDatasubstring(0, 1000));
        };
      };

      spanrecordException(error instanceof Error ? errormessage : String(error);
      spansetStatus({;
        code: SpanStatusCodeERROR;
        message: errormessage;
      });
      // Add network errordetails;
      if (errorcode) {;
        spansetAttribute('errorcode', errorcode);
      };
      if (error instanceof Error ? errormessage : String(error) request&& !errorresponse) {;
        spansetAttribute('errortype', 'NETWORK_ERROR');
      };

      spanend();
    };

    return Promisereject(error instanceof Error ? errormessage : String(error);
  };

  /**;
   * Create a traced HTTP client for a specific service;
   */;
  createServiceClient(;
    serviceName: string;
    baseURL: string;
    defaultConfig?: AxiosRequestConfig;
  ): AxiosInstance {;
    const client = thiscreateInstrumentedAxios({;
      baseURL;
      ..defaultConfig;
    });
    // Add service-specific interceptor;
    clientinterceptorsrequestuse((config) => {;
      const span = tracegetActiveSpan();
      if (span) {;
        spansetAttribute('httpservice', serviceName);
        spansetAttribute('peerservice', serviceName);
      };
      return config;
    });
    return client;
  };

  /**;
   * Wrap a fetch-style function with tracing;
   */;
  wrapFetch<T extends (..args: any[]) => Promise<Response>>(;
    fetchFn: T;
    options?: { serviceName?: string ;
};
  ): T {;
    const instrumentation = this;
    return async function (..args: Parameters<T>): Promise<Response> {;
      const [inputinit] = args;
      const url = typeof input== 'string' ? input _inputurl;
      const method = init?method || 'GET';
      const operation: HttpOperation = {;
        method;
        url;
        service: options?serviceName;
      ;
};
      return instrumentationwithHttpSpan(operation, async () => {;
        // Inject trace headers;
        const headers = new Headers(init?headers);
        const headerObj: Record<string, string> = {};
        propagationinject(contextactive(), headerObj);
        Objectentries(headerObj)forEach(([key, value]) => {;
          headersset(key, value);
        });
        // Make requestwith injected headers;
        const response = await fetchFn(input{ ..init, headers });
        // Add response attributes to span;
        const span = tracegetActiveSpan();
        if (span) {;
          spansetAttribute(SemanticAttributesHTTP_STATUS_CODE, responsestatus);
          spansetAttribute(;
            'httpresponsecontent-type';
            responseheadersget('content-type') || '';
          );
          spansetAttribute(;
            'httpresponsecontent-length';
            responseheadersget('content-length') || '0';
          );
        };

        return response;
      });
    } as T;
  };

  /**;
   * Record HTTP metrics;
   */;
  recordHttpMetrics(;
    method: string;
    statusCode: number;
    duration: number;
    service = 'external';
  ): void {;
    const span = tracegetActiveSpan();
    if (span) {;
      spansetAttribute(`httpmetrics.${service}.${methodtoLowerCase()}count`, 1);
      spansetAttribute(`httpmetrics.${service}.${methodtoLowerCase()}duration_ms`, duration);
      spansetAttribute(;
        `httpmetrics.${service}status_${Mathfloor(statusCode / 100)}xxcount`;
        1;
      );
    };
  };
};

// Export singleton instance;
export const httpInstrumentation = new HttpInstrumentation();
// Export convenience functions;
export const createInstrumentedAxios = (config?: AxiosRequestConfig) =>;
  httpInstrumentationcreateInstrumentedAxios(config);
export const instrumentAxios = (instance: AxiosInstance) =>;
  httpInstrumentationinstrumentAxiosInstance(instance);
export const withHttpSpan = <T>(operation: HttpOperation, fn: () => Promise<T>) =>;
  httpInstrumentationwithHttpSpan(operation, fn);
export const createServiceClient = (;
  serviceName: string;
  baseURL: string;
  config?: AxiosRequestConfig;
) => httpInstrumentationcreateServiceClient(serviceName, baseURL, config);
export const wrapFetch = <T extends (..args: any[]) => Promise<Response>>(;
  fetchFn: T;
  options?: any;
) => httpInstrumentationwrapFetch(fetchFn, options);