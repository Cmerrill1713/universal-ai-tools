import { SpanKind, SpanStatusCode, context, trace } from '@opentelemetry/api';
import { SemanticAttributes } from '@opentelemetry/semantic-conventions';
import { telemetryService } from '../services/telemetry-service';
import { LogContext, logger } from '../utils/enhanced-logger';
interface DatabaseOperation {;
  operation: string;
  table?: string;
  query?: string;
  params?: any[];
  database?: string;
;
};

interface DatabaseResult<T = any> {;
  data: T;
  count?: number;
  error instanceof Error ? errormessage : String(error)  Error;
;
};

export class DatabaseInstrumentation {;
  private tracer = telemetryServicegetTracer();
  /**;
   * Wrap a Supabase client to add automatic tracing;
   */;
  instrumentSupabaseClient(client: any): any {;
    const instrumented = Objectcreate(client);
    // Instrument common Supabase methods;
    const methods = ['from', 'rpc', 'auth', 'storage', 'realtime'];
    methodsforEach((method) => {;
      if (client[method]) {;
        instrumented[method] = thiswrapMethod(client, method);
      };
    });
    return instrumented;
  };

  /**;
   * Wrap a database query function with tracing;
   */;
  wrapQuery<T extends (..args: any[]) => Promise<unknown>>(fn: T, operation: DatabaseOperation): T {;
    const instrumentation = this;
    return async function (this: any, ..args: Parameters<T>): Promise<ReturnType<T>> {;
      return instrumentationwithDatabaseSpan(operation, async () => {;
        return fnapply(this, args);
      });
    } as T;
  };

  /**;
   * Execute a database operation with tracing;
   */;
  async withDatabaseSpan<T>(operation: DatabaseOperation, fn: () => Promise<T>): Promise<T> {;
    const spanName = `db.${operationoperation}${operationtable ? ` ${operationtable}` : ''}`;
    const span = thistracerstartSpan(spanName, {;
      kind: SpanKindCLIENT;
      attributes: {;
        [SemanticAttributesDB_SYSTEM]: 'postgresql';
        [SemanticAttributesDB_OPERATION]: operationoperation;
        [SemanticAttributesDB_NAME]: operationdatabase || processenvSUPABASE_DB || 'supabase';
        'dbtable': operationtable;
        'dbstatement': operationquery?substring(0, 500), // Limit query size;
        'dbparamscount': operationparams?length || 0;
      ;
};
    });
    const startTime = Datenow();
    try {;
      const result = await contextwith(tracesetSpan(contextactive(), span), fn);
      // Add result metrics;
      const duration = Datenow() - startTime;
      spansetAttribute('dbduration_ms', duration);
      if (result && typeof result === 'object') {;
        if ('count' in result) {;
          spansetAttribute('dbrows_affected', Number(resultcount));
        };
        if (ArrayisArray(result)) {;
          spansetAttribute('dbrows_returned', resultlength);
        };
      };

      spansetStatus({ code: SpanStatusCodeOK });
      return result;
    } catch (error) {;
      spanrecordException(erroras: Error);
      spansetStatus({;
        code: SpanStatusCodeERROR;
        message: error instanceof Error ? errormessage : 'Database operation failed';
      });
      // Add errordetails;
      if (error instanceof Error) {;
        spansetAttribute('errortype', errorname);
        spansetAttribute('errormessage', errormessage);
        spansetAttribute('errorstack', errorstack?substring(0, 1000) || '');
      };

      loggererror('Database operation failed', LogContextDATABASE, {;
        operation: operationoperation;
        table: operationtable;
        error;
        duration: Datenow() - startTime;
      });
      throw error instanceof Error ? errormessage : String(error);
    } finally {;
      spanend();
    };
  };

  /**;
   * Instrument a Supabase query builder;
   */;
  instrumentQueryBuilder(builder: any, table: string): any {;
    const instrumented = Objectcreate(builder);
    const operation: DatabaseOperation = { operation: 'query', table };
    // Track query building;
    const queryParts: string[] = [];
    // Instrument chainable methods;
    const chainableMethods = [;
      'select';
      'insert';
      'update';
      'upsert';
      'delete';
      'eq';
      'neq';
      'gt';
      'gte';
      'lt';
      'lte';
      'like';
      'ilike';
      'is';
      'in';
      'contains';
      'containedBy';
      'range';
      'order';
      'limit';
      'offset';
      'single';
      'maybeSingle';
    ];
    chainableMethodsforEach((method) => {;
      if (builder[method]) {;
        instrumented[method] = function (..args: any[]) {;
          queryPartspush(`${method}(${argsmap((a) => JSONstringify(a))join(', ')})`);
          const result = builder[method]apply(builder, args);
          // Update operation type based on method;
          if (['select', 'insert', 'update', 'upsert', 'delete']includes(method)) {;
            operationoperation = method;
          };

          // Return instrumented result if it's chainable;
          return result === builder ? instrumented : result;
        };
      };
    });
    // Instrument execution methods;
    const executionMethods = ['then', 'catch', 'finally'];
    executionMethodsforEach((method) => {;
      if (builder[method]) {;
        instrumented[method] = function (this: DatabaseInstrumentation, ..args: any[]) {;
          operationquery = queryPartsjoin('.');
          return thiswithDatabaseSpan(operation, () => {;
            return builder[method]apply(builder, args);
          });
        }bind(this);
      };
    });
    return instrumented;
  };

  /**;
   * Create a traced database transaction;
   */;
  async withTransaction<T>(;
    name: string;
    fn: (tx: any) => Promise<T>;
    options?: {;
      isolationLevel?: 'read-uncommitted' | 'read-committed' | 'repeatable-read' | 'serializable';
      timeout?: number;
    ;
};
  ): Promise<T> {;
    const span = thistracerstartSpan(`dbtransaction ${name}`, {;
      kind: SpanKindCLIENT;
      attributes: {;
        [SemanticAttributesDB_SYSTEM]: 'postgresql';
        [SemanticAttributesDB_OPERATION]: 'transaction';
        'dbtransactionname': name;
        'dbtransactionisolation_level': options?isolationLevel;
        'dbtransactiontimeout': options?timeout;
      ;
};
    });
    const startTime = Datenow();
    try {;
      const result = await contextwith(tracesetSpan(contextactive(), span), () => fn({}));
      spansetAttribute('dbtransactionduration_ms', Datenow() - startTime);
      spansetStatus({ code: SpanStatusCodeOK });
      return result;
    } catch (error) {;
      spanrecordException(erroras Error);
      spansetStatus({;
        code: SpanStatusCodeERROR;
        message: error instanceof Error ? errormessage : 'Transaction failed';
      });
      loggererror('Database transaction failed', LogContextDATABASE, {;
        transaction: name;
        error;
        duration: Datenow() - startTime;
      });
      throw error instanceof Error ? errormessage : String(error);
    } finally {;
      spanend();
    };
  };

  /**;
   * Record database pool metrics;
   */;
  recordPoolMetrics(metrics: {;
    totalConnections: number;
    idleConnections: number;
    waitingClients: number;
  }): void {;
    const span = tracegetActiveSpan();
    if (span) {;
      spansetAttribute('dbpooltotal_connections', metricstotalConnections);
      spansetAttribute('dbpoolidle_connections', metricsidleConnections);
      spansetAttribute('dbpoolwaiting_clients', metricswaitingClients);
      spansetAttribute(;
        'dbpoolutilization';
        metricstotalConnections > 0;
          ? (metricstotalConnections - metricsidleConnections) / metricstotalConnections;
          : 0;
      );
    ;
};
  };

  /**;
   * Helper to wrap a method with instrumentation;
   */;
  private wrapMethod(target: any, method: string): any {;
    const original = target[method];
    const instrumentation = this;
    return function (..args: any[]) {;
      const result = originalapply(target, args);
      // Handle special cases;
      if (method === 'from' && typeof args[0] === 'string') {;
        return instrumentationinstrumentQueryBuilder(result, args[0]);
      };

      if (method === 'rpc' && typeof args[0] === 'string') {;
        return instrumentationwrapQuery(() => result, {;
          operation: 'rpc';
          table: args[0];
          params: args[1];
        })();
      };

      return result;
    };
  };
};

// Export singleton instance;
export const databaseInstrumentation = new DatabaseInstrumentation();
// Export convenience functions;
export const instrumentSupabase = (client: any) =>;
  databaseInstrumentationinstrumentSupabaseClient(client);
export const withDatabaseSpan = <T>(operation: DatabaseOperation, fn: () => Promise<T>) =>;
  databaseInstrumentationwithDatabaseSpan(operation, fn);
export const withTransaction = <T>(name: string, fn: (tx: any) => Promise<T>, options?: any) =>;
  databaseInstrumentationwithTransaction(name, fn, options);