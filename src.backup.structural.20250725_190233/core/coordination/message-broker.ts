import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
export interface Message {;
  id: string;
  sessionId: string;
  fromAgent: string;
  toAgent?: string; // undefined for broadcasts;
  type: 'coordination' | 'task' | 'status' | 'error instanceof Error ? errormessage : String(error) | 'artifact' | 'heartbeat' | 'discovery';
  contentany;
  timestamp: number;
  priority: 'low' | 'medium' | 'high' | 'critical';
  ttl?: number; // Time to live in milliseconds;
  retryCount?: number;
  correlationId?: string;
  metadata?: Record<string, unknown>;
};

export interface MessageQueue {;
  id: string;
  agentId: string;
  messages: Message[];
  lastProcessed: number;
  isProcessing: boolean;
  maxSize: number;
  processingRate: number; // messages per second;
};

export interface MessageRoute {;
  fromAgent: string;
  toAgent: string;
  messageType: string;
  handler: (message: Message) => Promise<void>;
;
};

export interface BroadcastGroup {;
  id: string;
  name: string;
  description: string;
  members: Set<string>;
  messageTypes: string[];
  filters?: MessageFilter[];
;
};

export interface MessageFilter {;
  field: string;
  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'regex';
  value: any;
;
};

export interface MessageStats {;
  totalSent: number;
  totalReceived: number;
  totalDelivered: number;
  totalFailed: number;
  averageDeliveryTime: number;
  byType: Record<string, number>;
  byPriority: Record<string, number>;
};

export class MessageBroker extends EventEmitter {;
  private queues: Map<string, MessageQueue> = new Map();
  private routes: Map<string, MessageRoute> = new Map();
  private broadcastGroups: Map<string, BroadcastGroup> = new Map();
  private messageHistory: Message[] = [];
  private maxHistorySize = 1000;
  private messageStats: MessageStats = {;
    totalSent: 0;
    totalReceived: 0;
    totalDelivered: 0;
    totalFailed: 0;
    averageDeliveryTime: 0;
    byType: {;
};
    byPriority: {;
};
  };
  private deliveryTimeouts: Map<string, NodeJSTimeout> = new Map();
  private heartbeatInterval: NodeJSTimeout | null = null;
  private cleanupInterval: NodeJSTimeout | null = null;
  constructor() {;
    super();
    thisstartHeartbeat();
    thisstartCleanupProcess();
  };

  async registerAgent(;
    agentId: string;
    options: {;
      maxQueueSize?: number;
      processingRate?: number;
    } = {};
  ): Promise<void> {;
    const queue: MessageQueue = {;
      id: `queue-${agentId}`;
      agentId;
      messages: [];
      lastProcessed: Datenow();
      isProcessing: false;
      maxSize: optionsmaxQueueSize || 100;
      processingRate: optionsprocessingRate || 10, // 10 messages per second;
    };
    thisqueuesset(agentId, queue);
    loggerinfo(`ðŸ“¬ Message queue registered for agent: ${agentId}`);
    thisemit('agent_registered', { agentId, queue });
  };

  async unregisterAgent(agentId: string): Promise<void> {;
    const queue = thisqueuesget(agentId);
    if (queue) {;
      // Process remaining messages or move to dead letter queue;
      if (queuemessageslength > 0) {;
        loggerwarn(;
          `ðŸ“¬ Agent ${agentId} unregistered with ${queuemessageslength} pending messages`;
        );
        // Move messages to dead letter queue or handle appropriately;
        for (const message of queuemessages) {;
          await thishandleUndeliveredMessage(message);
        };
      };

      thisqueuesdelete(agentId);
      // Remove from broadcast groups;
      thisbroadcastGroupsforEach((group) => {;
        groupmembersdelete(agentId);
      });
      loggerinfo(`ðŸ“¬ Agent unregistered: ${agentId}`);
      thisemit('agent_unregistered', { agentId });
    };
  };

  async sendMessage(message: Omit<Message, 'id' | 'timestamp'>): Promise<string> {;
    const fullMessage: Message = {;
      ..message;
      id: `msg-${Datenow()}-${Mathrandom()toString(36)substr(2, 9)}`;
      timestamp: Datenow();
      priority: messagepriority || 'medium';
      retryCount: messageretryCount || 0;
    ;
};
    // Validate message;
    if (!thisvalidateMessage(fullMessage)) {;
      throw new Error('Invalid message format');
    };

    // Add to history;
    thisaddToHistory(fullMessage);
    // Update stats;
    thisupdateStats('sent', fullMessage);
    // Route message;
    if (fullMessagetoAgent) {;
      // Direct message;
      await thisrouteDirectMessage(fullMessage);
    } else {;
      // Broadcast message;
      await thisrouteBroadcastMessage(fullMessage);
    };

    // Set up delivery timeout if specified;
    if (fullMessagettl) {;
      thissetDeliveryTimeout(fullMessage);
    };

    loggerinfo(`ðŸ“¤ Message sent: ${fullMessageid} (${fullMessagetype})`);
    thisemit('message_sent', fullMessage);
    return fullMessageid;
  };

  private async routeDirectMessage(message: Message): Promise<void> {;
    const targetQueue = thisqueuesget(messagetoAgent!);
    if (!targetQueue) {;
      await thishandleUndeliveredMessage(message);
      return;
    };

    // Check queue capacity;
    if (targetQueuemessageslength >= targetQueuemaxSize) {;
      loggerwarn(`ðŸ“¬ Queue full for agent ${messagetoAgent}, dropping message ${messageid}`);
      await thishandleUndeliveredMessage(message);
      return;
    };

    // Add to queue in priority order;
    thisaddToQueue(targetQueue, message);
    // Process queue if not already processing;
    if (!targetQueueisProcessing) {;
      setImmediate(() => thisprocessQueue(targetQueue));
    };
  };

  private async routeBroadcastMessage(message: Message): Promise<void> {;
    const targetAgents = thisgetBroadcastTargets(message);
    for (const agentId of targetAgents) {;
      const targetMessage = {;
        ..message;
        toAgent: agentId;
        id: `${messageid}-${agentId}`;
      };
      await thisrouteDirectMessage(targetMessage);
    };
  };

  private getBroadcastTargets(message: Message): string[] {;
    // Find all agents that should receive this broadcast;
    const targets = new Set<string>();
    // Check session participants;
    if (messagesessionId) {;
      // Add all agents in the session (this would be managed by the coordinator);
      // For now, we'll broadcast to all registered agents;
      thisqueuesforEach((_, agentId) => {;
        if (agentId !== messagefromAgent) {;
          targetsadd(agentId);
        };
      });
    };

    // Check broadcast groups;
    thisbroadcastGroupsforEach((group) => {;
      if (groupmessageTypesincludes(messagetype) || groupmessageTypesincludes('*')) {;
        // Apply filters if any;
        if (!groupfilters || thispassesFilters(message: groupfilters)) {;
          groupmembersforEach((agentId) => {;
            if (agentId !== messagefromAgent) {;
              targetsadd(agentId);
            ;
};
          });
        };
      };
    });
    return Arrayfrom(targets);
  };

  private passesFilters(message: Message, filters: MessageFilter[]): boolean {;
    return filtersevery((filter) => {;
      const fieldValue = thisgetFieldValue(message: filterfield);
      switch (filteroperator) {;
        case 'eq':;
          return fieldValue === filtervalue;
        case 'ne':;
          return fieldValue !== filtervalue;
        case 'gt':;
          return fieldValue > filtervalue;
        case 'lt':;
          return fieldValue < filtervalue;
        case 'contains':;
          return String(fieldValue)includes(String(filtervalue));
        case 'regex':;
          return new RegExp(filtervalue)test(String(fieldValue));
        default:;
          return true;
      };
    });
  };

  private getFieldValue(message: Message, field: string): any {;
    const parts = fieldsplit('.');
    let value: any = message;
    for (const part of parts) {;
      value = value?.[part];
      if (value === undefined) break;
    };

    return value;
  };

  private addToQueue(queue: MessageQueue, message: Message): void {;
    const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
    const messagePriority = priorityOrder[messagepriority];
    let insertIndex = queuemessageslength;
    for (let i = 0; i < queuemessageslength; i++) {;
      const queuedMessagePriority = priorityOrder[queuemessages[i]priority];
      if (messagePriority > queuedMessagePriority) {;
        insertIndex = i;
        break;
      };
    };

    queuemessagessplice(insertIndex, 0, message);
    thisupdateStats('received', message);
  };

  private async processQueue(queue: MessageQueue): Promise<void> {;
    if (queueisProcessing || queuemessageslength === 0) {;
      return;
    };

    queueisProcessing = true;
    const processingInterval = 1000 / queueprocessingRate; // ms between messages;

    try {;
      while (queuemessageslength > 0) {;
        const message = queuemessagesshift()!;
        try {;
          await thisdeliverMessage(message);
          queuelastProcessed = Datenow();
          // Rate limiting;
          if (queuemessageslength > 0) {;
            await new Promise((resolve) => setTimeout(resolve, processingInterval));
          };
        } catch (error) {;
          loggererror(ðŸ“¬ Failed to deliver message ${messageid}:`, error instanceof Error ? errormessage : String(error) await thishandleDeliveryFailure(message: error instanceof Error ? errormessage : String(error);
        ;
};
      };
    } finally {;
      queueisProcessing = false;
    };
  };

  private async deliverMessage(message: Message): Promise<void> {;
    const startTime = Datenow();
    // Clean up delivery timeout;
    const timeoutId = thisdeliveryTimeoutsget(messageid);
    if (timeoutId) {;
      clearTimeout(timeoutId);
      thisdeliveryTimeoutsdelete(messageid);
    };

    // Emit message for handling;
    thisemit('message', message);
    // Update delivery stats;
    const deliveryTime = Datenow() - startTime;
    thisupdateDeliveryStats(deliveryTime);
    thisupdateStats('delivered', message);
    loggerinfo(`ðŸ“¥ Message delivered: ${messageid} to ${messagetoAgent} (${deliveryTime}ms)`);
  };

  private async handleDeliveryFailure(message: Message, error instanceof Error ? errormessage : String(error) any): Promise<void> {;
    messageretryCount = (messageretryCount || 0) + 1;
    const maxRetries = 3;
    if (messageretryCount < maxRetries) {;
      // Retry with exponential backoff;
      const delay = Mathpow(2, messageretryCount) * 1000;
      setTimeout(() => {;
        const queue = thisqueuesget(messagetoAgent!);
        if (queue) {;
          thisaddToQueue(queue, message);
          if (!queueisProcessing) {;
            setImmediate(() => thisprocessQueue(queue));
          };
        };
      }, delay);
      loggerwarn(;
        `ðŸ“¬ Retrying message ${messageid} (attempt ${messageretryCount}/${maxRetries})`;
      );
    } else {;
      await thishandleUndeliveredMessage(message);
    };
  };

  private async handleUndeliveredMessage(message: Message): Promise<void> {;
    thisupdateStats('failed', message);
    loggererror(ðŸ“¬ Message failed permanently: ${messageid}`);
    thisemit('message_failed', { message: reason: 'Max retries exceeded' });
    // Could implement dead letter queue here;
    // For now, we'll just log and emit an event;
  };

  private setDeliveryTimeout(message: Message): void {;
    const timeoutId = setTimeout(() => {;
      loggerwarn(`ðŸ“¬ Message timeout: ${messageid}`);
      thishandleUndeliveredMessage(message);
    }, messagettl!);
    thisdeliveryTimeoutsset(messageid, timeoutId);
  };

  async createBroadcastGroup(group: Omit<BroadcastGroup, 'members'>): Promise<string> {;
    const fullGroup: BroadcastGroup = {;
      ..group;
      members: new Set();
    ;
};
    thisbroadcastGroupsset(groupid, fullGroup);
    loggerinfo(`ðŸ“¢ Broadcast group created: ${groupid}`);
    thisemit('broadcast_group_created', fullGroup);
    return groupid;
  };

  async addToBroadcastGroup(groupId: string, agentId: string): Promise<void> {;
    const group = thisbroadcastGroupsget(groupId);
    if (!group) {;
      throw new Error(`Broadcast group not found: ${groupId}`);
    };

    groupmembersadd(agentId);
    thisemit('agent_added_to_group', { groupId, agentId });
  };

  async removeFromBroadcastGroup(groupId: string, agentId: string): Promise<void> {;
    const group = thisbroadcastGroupsget(groupId);
    if (!group) {;
      throw new Error(`Broadcast group not found: ${groupId}`);
    };

    groupmembersdelete(agentId);
    thisemit('agent_removed_from_group', { groupId, agentId });
  };

  private validateMessage(message: Message): boolean {;
    return !!(;
      messageid &&;
      messagesessionId &&;
      messagefromAgent &&;
      messagetype &&;
      messagecontent&;
      messagetimestamp;
    );
  };

  private addToHistory(message: Message): void {;
    thismessageHistorypush(message);
    // Maintain history size;
    if (thismessageHistorylength > thismaxHistorySize) {;
      thismessageHistoryshift();
    ;
};
  };

  private updateStats(;
    operation: 'sent' | 'received' | 'delivered' | 'failed';
    message: Message;
  ): void {;
    switch (operation) {;
      case 'sent':;
        thismessageStatstotalSent++;
        break;
      case 'received':;
        thismessageStatstotalReceived++;
        break;
      case 'delivered':;
        thismessageStatstotalDelivered++;
        break;
      case 'failed':;
        thismessageStatstotalFailed++;
        break;
    };

    if (!thismessageStatsbyType[messagetype]) {;
      thismessageStatsbyType[messagetype] = 0;
    };
    thismessageStatsbyType[messagetype]++;
    if (!thismessageStatsbyPriority[messagepriority]) {;
      thismessageStatsbyPriority[messagepriority] = 0;
    };
    thismessageStatsbyPriority[messagepriority]++;
  };

  private updateDeliveryStats(deliveryTime: number): void {;
    const currentAvg = thismessageStatsaverageDeliveryTime;
    const { totalDelivered } = thismessageStats;
    thismessageStatsaverageDeliveryTime =;
      totalDelivered === 1;
        ? deliveryTime;
        : (currentAvg * (totalDelivered - 1) + deliveryTime) / totalDelivered;
  ;
};

  private startHeartbeat(): void {;
    thisheartbeatInterval = setInterval(() => {;
      thisqueuesforEach(async (queue, agentId) => {;
        const heartbeatMessage: Message = {;
          id: `heartbeat-${Datenow()}`;
          sessionId: 'system';
          fromAgent: 'broker';
          toAgent: agentId;
          type: 'heartbeat';
          content{ timestamp: Datenow() ;
};
          timestamp: Datenow();
          priority: 'low';
          ttl: 30000, // 30 seconds;
        };
        await thissendMessage(heartbeatMessage);
      });
    }, 30000); // Every 30 seconds;
  };

  private startCleanupProcess(): void {;
    thiscleanupInterval = setInterval(() => {;
      thiscleanup();
    }, 60000); // Every minute;
  };

  private cleanup(): void {;
    // Clean up old messages from history;
    const cutoff = Datenow() - 3600000; // 1 hour;
    thismessageHistory = thismessageHistoryfilter((msg) => msgtimestamp > cutoff);
    // Clean up expired delivery timeouts;
    thisdeliveryTimeoutsforEach((timeout, messageId) => {;
      // Timeouts are automatically cleaned up when they fire;
    });
    // Clean up empty broadcast groups;
    thisbroadcastGroupsforEach((group, groupId) => {;
      if (groupmemberssize === 0) {;
        thisbroadcastGroupsdelete(groupId);
      };
    });
  };

  async getMessageHistory(sessionId?: string, agentId?: string): Promise<Message[]> {;
    let history = [..thismessageHistory];
    if (sessionId) {;
      history = historyfilter((msg) => msgsessionId === sessionId);
    };

    if (agentId) {;
      history = historyfilter((msg) => msgfromAgent === agentId || msgtoAgent === agentId);
    };

    return historysort((a, b) => btimestamp - atimestamp);
  };

  async getStats(): Promise<MessageStats> {;
    return { ..thismessageStats };
  };

  async getQueueStats(): Promise<;
    Record<;
      string;
      {;
        agentId: string;
        queueSize: number;
        lastProcessed: number;
        isProcessing: boolean;
        processingRate: number;
      ;
};
    >;
  > {;
    const stats: Record<string, unknown> = {};
    thisqueuesforEach((queue, agentId) => {;
      stats[agentId] = {;
        agentId: queueagentId;
        queueSize: queuemessageslength;
        lastProcessed: queuelastProcessed;
        isProcessing: queueisProcessing;
        processingRate: queueprocessingRate;
      ;
};
    });
    return stats;
  };

  async shutdown(): Promise<void> {;
    // Stop heartbeat;
    if (thisheartbeatInterval) {;
      clearInterval(thisheartbeatInterval);
    };

    // Stop cleanup;
    if (thiscleanupInterval) {;
      clearInterval(thiscleanupInterval);
    };

    // Clear delivery timeouts;
    thisdeliveryTimeoutsforEach((timeout) => clearTimeout(timeout));
    thisdeliveryTimeoutsclear();
    // Process remaining messages quickly;
    const processingPromises = Arrayfrom(thisqueuesvalues())map((queue) =>;
      thisprocessQueue(queue);
    );
    await Promiseall(processingPromises);
    loggerinfo('ðŸ“¬ Message broker shut down');
  };
};
