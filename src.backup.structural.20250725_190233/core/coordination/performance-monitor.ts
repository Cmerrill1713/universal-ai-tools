import { fetchWithTimeout } from '../utils/fetch-with-timeout';
import { logger } from '../../s../../utils/logger';
import type { BrowserAgent } from './agent-pool';
import type { Page } from 'puppeteer';
import type { Page as PlaywrightPage } from 'playwright';
import { EventEmitter } from 'events';
export interface PerformanceMetrics {;
  timestamp: number;
  pageLoadTime: number;
  firstContentfulPaint: number;
  largestContentfulPaint: number;
  cumulativeLayoutShift: number;
  firstInputDelay: number;
  timeToInteractive: number;
  totalBlockingTime: number;
  memoryUsage: {;
    usedJSHeapSize: number;
    totalJSHeapSize: number;
    jsHeapSizeLimit: number;
  ;
};
  networkRequests: {;
    total: number;
    successful: number;
    failed: number;
    totalSize: number;
    avgResponseTime: number;
  ;
};
  errors: string[];
;
};

export interface PerformanceReport {;
  agentId: string;
  browser: string;
  viewport: { width: number; height: number ;
};
  metrics: PerformanceMetrics;
  benchmarks: {;
    pageLoadGrade: 'A' | 'B' | 'C' | 'D' | 'F';
    performanceScore: number;
    recommendations: string[];
  ;
};
};

export class PerformanceMonitor extends EventEmitter {;
  private readonly baseUrl = 'http://localhost:5173';
  private readonly apiUrl = 'http://localhost:9999';
  private metrics: Map<string, PerformanceMetrics[]> = new Map();
  private isMonitoring = false;
  private monitoringInterval: NodeJSTimeout | null = null;
  constructor() {;
    super();
  };

  async start(): Promise<void> {;
    if (thisisMonitoring) {;
      return;
    };

    thisisMonitoring = true;
    loggerinfo('Starting Performance Monitor...');
    // Start continuous monitoring;
    thismonitoringInterval = setInterval(async () => {;
      try {;
        await thiscollectSystemMetrics();
      } catch (error) {;
        loggererror('Error collecting system metrics:', error instanceof Error ? errormessage : String(error);
      };
    }, 5000); // Collect metrics every 5 seconds;
    loggerinfo('Performance Monitor started');
  };

  async stop(): Promise<void> {;
    thisisMonitoring = false;
    if (thismonitoringInterval) {;
      clearInterval(thismonitoringInterval);
      thismonitoringInterval = null;
    };

    loggerinfo('Performance Monitor stopped');
  };

  async measureAgent(agent: BrowserAgent): Promise<PerformanceReport> {;
    loggerinfo(`Measuring performance for agent ${agentid}`);
    const startTime = Datenow();
    const metrics: PerformanceMetrics = {;
      timestamp: startTime;
      pageLoadTime: 0;
      firstContentfulPaint: 0;
      largestContentfulPaint: 0;
      cumulativeLayoutShift: 0;
      firstInputDelay: 0;
      timeToInteractive: 0;
      totalBlockingTime: 0;
      memoryUsage: {;
        usedJSHeapSize: 0;
        totalJSHeapSize: 0;
        jsHeapSizeLimit: 0;
      ;
};
      networkRequests: {;
        total: 0;
        successful: 0;
        failed: 0;
        totalSize: 0;
        avgResponseTime: 0;
      ;
};
      errors: [];
    ;
};
    try {;
      // Navigate to the app and measure performance;
      await thisnavigateAndMeasure(agent, metrics);
      // Collect Web Vitals;
      await thiscollectWebVitals(agent, metrics);
      // Collect memory usage;
      await thiscollectMemoryUsage(agent, metrics);
      // Collect network metrics;
      await thiscollectNetworkMetrics(agent, metrics);
      // Store metrics;
      const agentMetrics = thismetricsget(agentid) || [];
      agentMetricspush(metrics);
      thismetricsset(agentid, agentMetrics);
      // Generate performance report;
      const report: PerformanceReport = {;
        agentId: agentid;
        browser: agentbrowser;
        viewport: agentviewport;
        metrics;
        benchmarks: thisgenerateBenchmarks(metrics);
      ;
};
      loggerinfo(;
        `Performance measurement complete for agent ${agentid}: Score ${reportbenchmarksperformanceScore}`;
      );
      return report;
    } catch (error) {;
      loggererror(Performance measurement failed for agent ${agentid}:`, error instanceof Error ? errormessage : String(error);
      metricserrorspush(error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      return {;
        agentId: agentid;
        browser: agentbrowser;
        viewport: agentviewport;
        metrics;
        benchmarks: {;
          pageLoadGrade: 'F';
          performanceScore: 0;
          recommendations: ['Fix critical errors before performance optimization'];
        ;
};
      };
    };
  };

  private async navigateAndMeasure(;
    agent: BrowserAgent;
    metrics: PerformanceMetrics;
  ): Promise<void> {;
    const startTime = Datenow();
    if (agenttype === 'puppeteer') {;
      const page = agentpage as Page;
      // Enable performance monitoring;
      await pagesetCacheEnabled(false);
      // Navigate to the app;
      await pagegoto(thisbaseUrl, { waitUntil: 'networkidle0' });
      // Measure page load time;
      metricspageLoadTime = Datenow() - startTime;
    } else {;
      const page = agentpage as PlaywrightPage;
      // Navigate to the app;
      await pagegoto(thisbaseUrl, { waitUntil: 'networkidle' });
      // Measure page load time;
      metricspageLoadTime = Datenow() - startTime;
    };
  };

  private async collectWebVitals(agent: BrowserAgent, metrics: PerformanceMetrics): Promise<void> {;
    try {;
      if (agenttype === 'puppeteer') {;
        const page = agentpage as Page;
        // Collect performance metrics from the browser;
        const performanceMetrics: any = await pageevaluate(() => {;
          return new Promise((resolve) => {;
            // Use Performance Observer API to collect Web Vitals;
            const vitals: any = {};
            // Get paint timings;
            const paintEntries = performancegetEntriesByType('paint');
            paintEntriesforEach((entry) => {;
              if (entryname === 'first-contentful-paint') {;
                vitalsfirstContentfulPaint = entrystartTime;
              };
            });
            // Get LCP using Performance Observer;
            try {;
              const observer = new PerformanceObserver((list) => {;
                const entries = listgetEntries();
                if (entrieslength > 0) {;
                  vitalslargestContentfulPaint = entries[entrieslength - 1]startTime;
                };
              });
              observerobserve({ entryTypes: ['largest-contentful-paint'] });
            } catch (e) {;
              // LCP not supported in this browser;
            };

            // Get navigation timing;
            const navigation = performancegetEntriesByType(;
              'navigation';
            )[0] as PerformanceNavigationTiming;
            if (navigation) {;
              vitalstimeToInteractive = navigationdomInteractive - navigationfetchStart;
            };

            // Get memory usage if available;
            if ('memory' in performance) {;
              vitalsmemoryUsage = (performance as any)memory;
            };
;
            resolve(vitals);
          });
        });
        // Update metrics with collected data;
        if (performanceMetricsfirstContentfulPaint) {;
          metricsfirstContentfulPaint = performanceMetricsfirstContentfulPaint;
        };
        if (performanceMetricslargestContentfulPaint) {;
          metricslargestContentfulPaint = performanceMetricslargestContentfulPaint;
        };
        if (performanceMetricstimeToInteractive) {;
          metricstimeToInteractive = performanceMetricstimeToInteractive;
        };
        if (performanceMetricsmemoryUsage) {;
          metricsmemoryUsage = performanceMetricsmemoryUsage;
        };
      } else {;
        const page = agentpage as PlaywrightPage;
        // Collect performance metrics from Playwright;
        const performanceMetrics: any = await pageevaluate(() => {;
          const vitals: any = {};
          // Get paint timings;
          const paintEntries = performancegetEntriesByType('paint');
          paintEntriesforEach((entry) => {;
            if (entryname === 'first-contentful-paint') {;
              vitalsfirstContentfulPaint = entrystartTime;
            };
          });
          // Get navigation timing;
          const navigation = performancegetEntriesByType(;
            'navigation';
          )[0] as PerformanceNavigationTiming;
          if (navigation) {;
            vitalstimeToInteractive = navigationdomInteractive - navigationfetchStart;
          };

          // Get memory usage if available;
          if ('memory' in performance) {;
            vitalsmemoryUsage = (performance as any)memory;
          };
;
          return vitals;
        });
        // Update metrics with collected data;
        if (performanceMetricsfirstContentfulPaint) {;
          metricsfirstContentfulPaint = performanceMetricsfirstContentfulPaint;
        };
        if (performanceMetricstimeToInteractive) {;
          metricstimeToInteractive = performanceMetricstimeToInteractive;
        };
        if (performanceMetricsmemoryUsage) {;
          metricsmemoryUsage = performanceMetricsmemoryUsage;
        };
      };
    } catch (error) {;
      loggererror('Failed to collect Web Vitals:', error instanceof Error ? errormessage : String(error) metricserrorspush(;
        `Web Vitals collection failed: ${error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error)`;
      );
    ;
};
  };

  private async collectMemoryUsage(;
    agent: BrowserAgent;
    metrics: PerformanceMetrics;
  ): Promise<void> {;
    try {;
      if (agenttype === 'puppeteer') {;
        const page = agentpage as Page;
        // Get memory usage from the browser;
        const memoryUsage = await pageevaluate(() => {;
          if ('memory' in performance) {;
            return (performance as any)memory;
          };
          return null;
        });
        if (memoryUsage) {;
          metricsmemoryUsage = memoryUsage;
        };
      } else {;
        const page = agentpage as PlaywrightPage;
        // Get memory usage from Playwright;
        const memoryUsage = await pageevaluate(() => {;
          if ('memory' in performance) {;
            return (performance as any)memory;
          };
          return null;
        });
        if (memoryUsage) {;
          metricsmemoryUsage = memoryUsage;
        };
      };
    } catch (error) {;
      loggererror('Failed to collect memory usage:', error instanceof Error ? errormessage : String(error) metricserrorspush(;
        `Memory usage collection failed: ${error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error)`;
      );
    ;
};
  };

  private async collectNetworkMetrics(;
    agent: BrowserAgent;
    metrics: PerformanceMetrics;
  ): Promise<void> {;
    try {;
      if (agenttype === 'puppeteer') {;
        const page = agentpage as Page;
        // Get network metrics from the browser;
        const networkMetrics = await pageevaluate(() => {;
          const resourceEntries = performancegetEntriesByType('resource');
          const total = resourceEntrieslength;
          let successful = 0;
          let failed = 0;
          let totalSize = 0;
          let totalResponseTime = 0;
          resourceEntriesforEach((entry) => {;
            const resource = entry as PerformanceResourceTiming;
            if (resourcetransferSize !== undefined) {;
              totalSize += resourcetransferSize;
            };

            const responseTime = resourceresponseEnd - resourcerequestStart;
            if (responseTime > 0) {;
              totalResponseTime += responseTime;
              successful++;
            } else {;
              failed++;
            };
          });
          return {;
            total;
            successful;
            failed;
            totalSize;
            avgResponseTime: successful > 0 ? totalResponseTime / successful : 0;
          ;
};
        });
        metricsnetworkRequests = networkMetrics;
      } else {;
        const page = agentpage as PlaywrightPage;
        // Get network metrics from Playwright;
        const networkMetrics = await pageevaluate(() => {;
          const resourceEntries = performancegetEntriesByType('resource');
          const total = resourceEntrieslength;
          let successful = 0;
          let failed = 0;
          let totalSize = 0;
          let totalResponseTime = 0;
          resourceEntriesforEach((entry) => {;
            const resource = entry as PerformanceResourceTiming;
            if (resourcetransferSize !== undefined) {;
              totalSize += resourcetransferSize;
            };

            const responseTime = resourceresponseEnd - resourcerequestStart;
            if (responseTime > 0) {;
              totalResponseTime += responseTime;
              successful++;
            } else {;
              failed++;
            };
          });
          return {;
            total;
            successful;
            failed;
            totalSize;
            avgResponseTime: successful > 0 ? totalResponseTime / successful : 0;
          ;
};
        });
        metricsnetworkRequests = networkMetrics;
      };
    } catch (error) {;
      loggererror('Failed to collect network metrics:', error instanceof Error ? errormessage : String(error) metricserrorspush(;
        `Network metrics collection failed: ${error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error)`;
      );
    ;
};
  };

  private generateBenchmarks(metrics: PerformanceMetrics): PerformanceReport['benchmarks'] {;
    const recommendations: string[] = [];
    let score = 100;
    // Analyze page load time;
    if (metricspageLoadTime > 3000) {;
      score -= 20;
      recommendationspush(;
        'Page load time is too slow (>3s). Consider optimizing bundle size and lazy loading.';
      );
    } else if (metricspageLoadTime > 1000) {;
      score -= 10;
      recommendationspush('Page load time could be improved (<1s is optimal).');
    };

    // Analyze First Contentful Paint;
    if (metricsfirstContentfulPaint > 2000) {;
      score -= 15;
      recommendationspush(;
        'First Contentful Paint is too slow (>2s). Optimize critical rendering path.';
      );
    } else if (metricsfirstContentfulPaint > 1000) {;
      score -= 5;
      recommendationspush('First Contentful Paint could be improved (<1s is optimal).');
    };

    // Analyze Largest Contentful Paint;
    if (metricslargestContentfulPaint > 4000) {;
      score -= 20;
      recommendationspush(;
        'Largest Contentful Paint is too slow (>4s). Optimize images and critical resources.';
      );
    } else if (metricslargestContentfulPaint > 2500) {;
      score -= 10;
      recommendationspush('Largest Contentful Paint could be improved (<2.5s is optimal).');
    };

    // Analyze memory usage;
    if (metricsmemoryUsageusedJSHeapSize > 50 * 1024 * 1024) {;
      // 50MB;
      score -= 15;
      recommendationspush('High memory usage detected (>50MB). Check for memory leaks.');
    } else if (metricsmemoryUsageusedJSHeapSize > 25 * 1024 * 1024) {;
      // 25MB;
      score -= 5;
      recommendationspush('Memory usage is moderate (>25MB). Consider optimization.');
    };

    // Analyze network requests;
    if (metricsnetworkRequestsfailed > 0) {;
      score -= 25;
      recommendationspush(;
        `${metricsnetworkRequestsfailed} network requests failed. Check API connectivity.`;
      );
    };

    if (metricsnetworkRequestsavgResponseTime > 1000) {;
      score -= 15;
      recommendationspush(;
        'Average API response time is slow (>1s). Optimize backend performance.';
      );
    } else if (metricsnetworkRequestsavgResponseTime > 500) {;
      score -= 5;
      recommendationspush('Average API response time could be improved (<500ms is optimal).');
    };

    // Add errors penalty;
    if (metricserrorslength > 0) {;
      score -= metricserrorslength * 10;
      recommendationspush(`${metricserrorslength} errors detected. Fix critical issues first.`);
    };

    // Ensure score is within bounds;
    score = Mathmax(0, Mathmin(100, score));
    // Determine grade;
    let grade: 'A' | 'B' | 'C' | 'D' | 'F';
    if (score >= 90) grade = 'A';
    else if (score >= 80) grade = 'B';
    else if (score >= 70) grade = 'C';
    else if (score >= 60) grade = 'D';
    else grade = 'F';
    return {;
      pageLoadGrade: grade;
      performanceScore: score;
      recommendations;
    ;
};
  };

  private async collectSystemMetrics(): Promise<void> {;
    try {;
      // Test API health;
      const response = await fetchWithTimeout(`${thisapiUrl}/health`, { timeout: 30000 });
      const healthData = await responsejson();
      // Test API performance;
      const apiStartTime = Datenow();
      await fetch(`${thisapiUrl}/api/stats`, {;
        headers: {;
          'X-API-Key': processenvDEV_API_KEY || '';
          'X-AI-Service': 'local-ui';
        ;
};
      });
      const apiResponseTime = Datenow() - apiStartTime;
      loggerdebug(;
        `System metrics - API Health: ${healthDatastatus}, Response Time: ${apiResponseTime}ms`;
      );
    } catch (error) {;
      loggererror('Failed to collect system metrics:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  async runChecks(): Promise<unknown> {;
    const startTime = Datenow();
    try {;
      // Check UI availability;
      const uiResponse = await fetchWithTimeout(thisbaseUrl, { timeout: 30000 });
      const uiAvailable = uiResponseok;
      // Check API availability;
      const apiResponse = await fetchWithTimeout(`${thisapiUrl}/health`, { timeout: 30000 });
      const apiHealth = await apiResponsejson();
      const apiAvailable = apiHealthstatus === 'healthy';
      // Check API performance;
      const apiStartTime = Datenow();
      await fetch(`${thisapiUrl}/api/stats`, {;
        headers: {;
          'X-API-Key': processenvDEV_API_KEY || '';
          'X-AI-Service': 'local-ui';
        ;
};
      });
      const apiResponseTime = Datenow() - apiStartTime;
      const checks = {;
        duration: Datenow() - startTime;
        ui: {;
          available: uiAvailable;
          url: thisbaseUrl;
        };
        api: {;
          available: apiAvailable;
          responseTime: apiResponseTime;
          url: thisapiUrl;
        ;
};
        overall: uiAvailable && apiAvailable;
      ;
};
      loggerinfo(;
        `Performance checks complete: UI=${uiAvailable}, API=${apiAvailable}, Response Time=${apiResponseTime}ms`;
      );
      return checks;
    } catch (error) {;
      loggererror('Performance checks failed:', error instanceof Error ? errormessage : String(error);
      return {;
        duration: Datenow() - startTime;
        ui: { available: false, url: thisbaseUrl ;
};
        api: { available: false, responseTime: -1, url: thisapiUrl ;
};
        overall: false;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      ;
};
    };
  };

  getMetrics(agentId?: string): PerformanceMetrics[] {;
    if (agentId) {;
      return thismetricsget(agentId) || [];
    };

    // Return all metrics;
    const allMetrics: PerformanceMetrics[] = [];
    for (const agentMetrics of thismetricsvalues()) {;
      allMetricspush(..agentMetrics);
    };
    return allMetrics;
  };

  clearMetrics(agentId?: string): void {;
    if (agentId) {;
      thismetricsdelete(agentId);
    } else {;
      thismetricsclear();
    };
  };

  generateReport(): string {;
    const allMetrics = thisgetMetrics();
    if (allMetricslength === 0) {;
      return 'No performance metrics available';
    };

    const avgPageLoadTime =;
      allMetricsreduce((sum, m) => sum + mpageLoadTime, 0) / allMetricslength;
    const avgMemoryUsage =;
      allMetricsreduce((sum, m) => sum + mmemoryUsageusedJSHeapSize, 0) / allMetricslength;
    const totalErrors = allMetricsreduce((sum, m) => sum + merrorslength, 0);
    return ``;
Performance Report:;
- Average Page Load Time: ${avgPageLoadTimetoFixed(2)}ms;
- Average Memory Usage: ${(avgMemoryUsage / 1024 / 1024)toFixed(2)}MB;
- Total Errors: ${totalErrors;
};
- Metrics Collected: ${allMetricslength;
};
- Agents Monitored: ${thismetricssize;
};
    `trim();`;
  };
};
