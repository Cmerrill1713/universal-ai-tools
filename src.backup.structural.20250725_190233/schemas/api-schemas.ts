import { z } from 'zod';
// Common schemas;
const UUIDSchema = zstring()uuid();
const DateSchema = zstring()datetime();
const PaginationSchema = zobject({;
  limit: znumber()int()min(1)max(100)default(10);
  offset: znumber()int()min(0)default(0);
  sortBy: zstring()optional();
  sortOrder: zenum(['asc', 'desc'])default('desc');
});
// Memory schemas;
export const MemoryStoreSchema = zobject({;
  contentzstring()min(1)max(10000);
  metadata: zrecord(zany())default({});
  userId: zstring()uuid()optional();
  tags: zarray(zstring())optional();
});
export const MemorySearchSchema = zobject({;
  query: zstring()min(1)max(500);
  limit: znumber()int()min(1)max(50)default(10);
  filters: z;
    object({;
      userId: zstring()uuid()optional();
      tags: zarray(zstring())optional();
      dateFrom: DateSchemaoptional();
      dateTo: DateSchemaoptional();
    });
    optional();
});
export const MemoryUpdateSchema = zobject({;
  contentzstring()min(1)max(10000)optional();
  metadata: zrecord(zany())optional();
  tags: zarray(zstring())optional();
});
// Tool schemas;
export const ToolExecuteSchema = zobject({;
  toolName: zstring()min(1)max(100);
  inputzany();
  context: z;
    object({;
      userId: zstring()uuid()optional();
      sessionId: zstring()uuid()optional();
      metadata: zrecord(zany())optional();
    });
    optional();
  timeout: znumber()int()min(1000)max(300000)default(30000);
});
export const ToolRegisterSchema = zobject({;
  name: z;
    string();
    min(1);
    max(100);
    regex(/^[a-zA-Z0-9_-]+$/);
  description: zstring()min(1)max(500);
  version: zstring()regex(/^\d+\.\d+\.\d+$/);
  inputSchema: zrecord(zany());
  outputSchema: zrecord(zany());
  metadata: z;
    object({;
      author: zstring()optional();
      tags: zarray(zstring())optional();
      documentation: zstring()url()optional();
    });
    optional();
});
// Agent schemas;
export const AgentRequestSchema = zobject({;
  type: zenum(['analytical', 'creative', 'critical', 'systems', 'research']);
  task: zstring()min(1)max(5000);
  context: zrecord(zany())optional();
  options: z;
    object({;
      maxIterations: znumber()int()min(1)max(10)default(3);
      temperature: znumber()min(0)max(2)default(0.7);
      model: zstring()optional();
    });
    optional();
});
export const AgentCollaborateSchema = zobject({;
  agents: z;
    array(zenum(['analytical', 'creative', 'critical', 'systems', 'research']));
    min(2);
    max(5);
  task: zstring()min(1)max(5000);
  collaborationType: zenum(['sequential', 'parallel', 'debate'])default('sequential');
  maxRounds: znumber()int()min(1)max(10)default(3);
});
// Anti-hallucination schemas;
export const VerifyFactSchema = zobject({;
  claim: zstring()min(1)max(1000);
  context: zstring()max(5000)optional();
  sources: zarray(zstring()url())optional();
  confidenceThreshold: znumber()min(0)max(1)default(0.8);
});
export const CheckConsistencySchema = zobject({;
  statements: zarray(zstring()min(1)max(1000))min(2)max(10);
  context: zstring()max(5000)optional();
  strictMode: zboolean()default(false);
});
// Model schemas;
export const ModelInferenceSchema = zobject({;
  model: zstring()min(1)max(100);
  prompt: zstring()min(1)max(10000);
  messages: z;
    array(;
      zobject({;
        role: zenum(['system', 'user', 'assistant']);
        contentzstring()min(1)max(10000);
      });
    );
    optional();
  options: z;
    object({;
      temperature: znumber()min(0)max(2)default(0.7);
      maxTokens: znumber()int()min(1)max(100000)default(1000);
      topP: znumber()min(0)max(1)optional();
      frequencyPenalty: znumber()min(-2)max(2)optional();
      presencePenalty: znumber()min(-2)max(2)optional();
      stream: zboolean()default(false);
    });
    optional();
});
export const ModelListSchema = zobject({;
  provider: zenum(['openai', 'anthropic', 'local', 'all'])optional();
  capabilities: zarray(zstring())optional();
  ..PaginationSchemashape;
});
// Voice schemas;
export const VoiceTranscribeSchema = zobject({;
  audio: zstring()regex(/^data:audio\/(webm|wav|mp3|ogg);base64,/);
  language: zstring()length(2)optional();
  context: zstring()max(500)optional();
});
export const VoiceSynthesizeSchema = zobject({;
  text: zstring()min(1)max(5000);
  voiceId: zstring()min(1)max(100);
  voiceSettings: z;
    object({;
      stability: znumber()min(0)max(1)default(0.5);
      similarityBoost: znumber()min(0)max(1)default(0.5);
      style: znumber()min(0)max(1)default(0);
      pitch: znumber()min(-2)max(2)default(0);
      speakingRate: znumber()min(0.25)max(4)default(1);
    });
    optional();
  format: zenum(['mp3', 'wav', 'ogg'])default('mp3');
});
// Authentication schemas;
export const LoginSchema = zobject({;
  email: zstring()email();
  password: zstring()min(8)max(100);
});
export const RegisterSchema = zobject({;
  email: zstring()email();
  password: z;
    string();
    min(8);
    max(100);
    regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/);
  name: zstring()min(1)max(100)optional();
  metadata: zrecord(zany())optional();
});
export const APIKeyCreateSchema = zobject({;
  name: zstring()min(1)max(100);
  scopes: zarray(zenum(['read', 'write', 'admin']))min(1);
  expiresIn: znumber()int()min(3600)max(31536000)optional(), // 1 hour to 1 year;
});
// Health check schemas;
export const HealthCheckResponseSchema = zobject({;
  status: zenum(['healthy', 'degraded', 'unhealthy']);
  version: zstring();
  uptime: znumber();
  timestamp: DateSchema;
  services: zobject({;
    database: zboolean();
    redis: zboolean();
    memory: zboolean();
    models: zrecord(zboolean())optional();
  });
  metrics: z;
    object({;
      cpu: znumber()min(0)max(100);
      memory: zobject({;
        used: znumber();
        total: znumber();
        percentage: znumber()min(0)max(100);
      });
      requestsPerMinute: znumber()optional();
      averageResponseTime: znumber()optional();
    });
    optional();
});
// Error schemas;
export const ErrorResponseSchema = zobject({;
  error instanceof Error ? errormessage : String(error) zobject({;
    code: zstring();
    message: zstring();
    details: zany()optional();
    stack: zstring()optional(), // Only in development;
  });
  timestamp: DateSchema;
  requestId: zstring()uuid();
});
// Request/Response wrapper schemas;
export const APIRequestSchema = <T extends zZodType>(dataSchema: T) =>;
  zobject({;
    data: dataSchema;
    metadata: z;
      object({;
        requestId: zstring()uuid()optional();
        timestamp: DateSchemaoptional();
        version: zstring()optional();
      });
      optional();
  });
export const APIResponseSchema = <T extends zZodType>(dataSchema: T) =>;
  zobject({;
    success: zboolean();
    data: dataSchemaoptional();
    error instanceof Error ? errormessage : String(error) ErrorResponseSchemashapeerroroptional();
    metadata: zobject({;
      requestId: zstring()uuid();
      timestamp: DateSchema;
      version: zstring();
      processingTime: znumber();
    });
  });
// Batch operation schemas;
export const BatchOperationSchema = <T extends zZodType>(itemSchema: T) =>;
  zobject({;
    operations: z;
      array(;
        zobject({;
          id: zstring()uuid();
          operation: zenum(['create', 'update', 'delete']);
          data: itemSchema;
        });
      );
      min(1);
      max(100);
    options: z;
      object({;
        stopOnError: zboolean()default(false);
        parallel: zboolean()default(false);
      });
      optional();
  });
// WebSocket message schemas;
export const WebSocketMessageSchema = zobject({;
  type: zenum(['chat', 'agent_update', 'memory_sync', 'voice_stream', 'error instanceof Error ? errormessage : String(error));
  data: zany();
  timestamp: DateSchema;
  sessionId: zstring()uuid();
});
// File upload schemas;
export const FileUploadSchema = zobject({;
  filename: zstring()min(1)max(255);
  mimetype: zstring();
  size: z;
    number();
    int();
    min(1);
    max(100 * 1024 * 1024), // Max 100MB;
  purpose: zenum(['avatar', 'document', 'audio', 'model']);
  metadata: zrecord(zany())optional();
});
// Export validation middleware;
export function validateRequest<T extends zZodType>(schema: T) {;
  return (req: any, res: any, next: any) => {;
    try {;
      const result = schemaparse(reqbody);
      reqvalidatedData = result;
      next();
    } catch (error) {;
      if (error instanceof zZodError) {;
        resstatus(400)json({;
          success: false;
          error instanceof Error ? errormessage : String(error){;
            code: 'VALIDATION_ERROR';
            message: 'Invalid requestdata';
            details: errorerrors;
          ;
};
        });
      } else {;
        next(error instanceof Error ? errormessage : String(error)  ;
};
    };
  };
};

// Export type inference helpers;
export type MemoryStore = zinfer<typeof MemoryStoreSchema>;
export type MemorySearch = zinfer<typeof MemorySearchSchema>;
export type ToolExecute = zinfer<typeof ToolExecuteSchema>;
export type AgentRequest = zinfer<typeof AgentRequestSchema>;
export type ModelInference = zinfer<typeof ModelInferenceSchema>;
export type VoiceTranscribe = zinfer<typeof VoiceTranscribeSchema>;
export type VoiceSynthesize = zinfer<typeof VoiceSynthesizeSchema>;