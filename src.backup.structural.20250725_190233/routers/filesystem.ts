/**;
 * Secure File System API Router;
 *;
 * Provides RESTful endpoints for file system operations with comprehensive security: measures:;
 * - Path sanitization and validation;
 * - Authentication and authorization;
 * - Rate limiting;
 * - Input validation;
 * - Activity logging;
 * - WebSocket support for real-time events;
 */;
import type { Request, Response } from 'express';
import { NextFunction, Router } from 'express';
import path from 'path';
import fs from 'fs/promises';
import { createReadStream, createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';
import crypto from 'crypto';
import { z } from 'zod';
import { logger } from '../utils/logger';
import { JWTAuthService } from '../middleware/auth-jwt';
import { RateLimiter } from '../middleware/rate-limiter';
import { CommonValidators, strictValidation } from '../middleware/comprehensive-validation';
import type { SupabaseClient } from '@supabase/supabase-js';
import { exec } from 'child_process';
import { promisify } from 'util';
import mime from 'mime-types';
import chokidar from 'chokidar';
import WebSocket from 'ws';
const execAsync = promisify(exec);
// Request/Response schemas;
const BrowseRequestSchema = zobject({;
  path: zstring()optional();
  showHidden: zboolean()optional()default(false);
  recursive: zboolean()optional()default(false);
  maxDepth: znumber()int()min(1)max(5)optional()default(1);
  filter: z;
    object({;
      type: zenum(['file', 'directory', 'all'])optional()default('all'),';
      _pattern zstring()optional();
      extensions: zarray(zstring())optional()});
    optional()});
const ReadRequestSchema = zobject({;
  path: zstring();
  encoding: zenum(['utf8', 'base64', 'hex', 'binary'])optional()default('utf8'),';
  range: z;
    object({;
      start: znumber()int()min(0)optional();
      end: znumber()int()min(0)optional()});
    optional()});
const WriteRequestSchema = zobject({;
  path: zstring();
  contentzstring();
  encoding: zenum(['utf8', 'base64', 'hex'])optional()default('utf8'),';
  mode: zenum(['overwrite', 'append', 'create'])optional()default('overwrite'),';
  permissions: z;
    string();
    regex(/^[0-7]{3,4}$/);
    optional()});
const ExecuteRequestSchema = zobject({;
  command: zstring()max(1000);
  args: zarray(zstring())optional()default([]);
  cwd: zstring()optional();
  timeout: znumber()int()min(1000)max(300000)optional()default(30000), // 30 seconds default;
  env: zrecord(zstring())optional()});
const MoveRequestSchema = zobject({;
  source: zstring();
  destination: zstring();
  overwrite: zboolean()optional()default(false)});
const CopyRequestSchema = zobject({;
  source: zstring();
  destination: zstring();
  overwrite: zboolean()optional()default(false);
  recursive: zboolean()optional()default(false)});
const DeleteRequestSchema = zobject({;
  path: zstring();
  recursive: zboolean()optional()default(false);
  force: zboolean()optional()default(false)});
const SearchRequestSchema = zobject({;
  path: zstring();
  query: zstring()min(1)max(100);
  options: z;
    object({;
      caseSensitive: zboolean()optional()default(false);
      wholeWord: zboolean()optional()default(false);
      regex: zboolean()optional()default(false);
      maxResults: znumber()int()min(1)max(1000)optional()default(100);
      includeContent: zboolean()optional()default(false);
      extensions: zarray(zstring())optional()});
    optional()});
// File system entry type;
interface FileSystemEntry {;
  name: string;
  path: string;
  type: 'file' | 'directory' | 'symlink' | 'other';';
  size: number;
  created: Date;
  modified: Date;
  accessed: Date;
  permissions: string;
  owner?: string;
  group?: string;
  mimeType?: string;
  isHidden: boolean;
  isReadable: boolean;
  isWritable: boolean;
  children?: FileSystemEntry[];
;
};

// WebSocket message types;
interface FSWebSocketMessage {;
  type: 'watch' | 'unwatch' | 'event' | 'error) | 'ping' | 'pong';';
  path?: string;
  event?: 'add' | 'change' | 'unlink' | 'addDir' | 'unlinkDir';';
  data?: any;
  id?: string;
  timestamp?: number;
;
};

class FileSystemRouterClass {;
  private: router: Router;
  private: supabase: SupabaseClient;
  private: rateLimiter: RateLimiter;
  private: baseDir: string;
  private: allowedPaths: string[];
  private: blockedPaths: string[];
  private: blockedPatterns: RegExp[];
  private: watchers: Map<string, chokidarFSWatcher> = new Map();
  private: wsClients: Map<string, WebSocket> = new Map();
  constructor(supabase: SupabaseClient) {;
    thisrouter = Router();
    thissupabase = supabase;
    thisrateLimiter = new RateLimiter();
    // Security configuration;
    thisbaseDir = processenvFS_BASE_DIR || processcwd();
    thisallowedPaths = (processenvFS_ALLOWED_PATHS || '')split(',')filter(Boolean);';
    thisblockedPaths = [;
      '/etc',';
      '/sys',';
      '/proc',';
      '/dev',';
      '/boot',';
      '/root',';
      '/var/log',';
      '/ssh',';
      '/git',';
      '/node_modules',';
      'env',';
      'envlocal',';
      'envproduction',';
      'secrets',';
      'credentials',';
      'password',';
      'private',';
      'id_rsa',';
      'id_dsa',';
      'id_ecdsa',';
      'id_ed25519',';
    ];
    thisblockedPatterns = [;
      /\env(\.|$)/i;
      /\.(pem|key|crt|cer|pfx|p12)$/i;
      /\.(id_rsa|id_dsa|id_ecdsa|id_ed25519)$/i;
      /\.(kdbx|keychain|gnupg|ssh)$/i;
      /\/(\git|\svn|\hg|\bzr)\//i;
      /\.(sqlite|db|mdb)$/i;
      /\.(log|logs)$/i;
      /secrets?\//i;
      /credentials?\//i;
      /passwords?\//i;
      /private\//i];
    thissetupRoutes();
  };

  /**;
   * Validate and sanitize file paths;
   */;
  private sanitizePath(inputPath: string): string | null {;
    try {;
      // Remove any null bytes;
      inputPath = inputPathreplace(/\0/g, '');';
      // Resolve the absolute path;
      const resolvedPath = pathresolve(thisbaseDir, inputPath);
      // Ensure the path is within the base directory;
      if (!resolvedPathstartsWith(thisbaseDir)) {;
        loggerwarn('Path traversal attempt detected', { inputPath, resolvedPath });';
        return null;
      };

      // Check against blocked paths;
      const normalizedPath = resolvedPathtoLowerCase();
      for (const blocked of thisblockedPaths) {;
        if (normalizedPathincludes(blockedtoLowerCase())) {;
          loggerwarn('Access to blocked path attempted', { path: resolvedPath });';
          return null;
        };
      };

      // Check against blocked patterns;
      for (const _patternof thisblockedPatterns) {;
        if (_patterntest(resolvedPath)) {;
          loggerwarn('Access to blocked _patternattempted', {';
            path: resolvedPath;
            _pattern _patterntoString()});
          return null;
        };
      };

      // If allowed paths are specified, ensure the path is within one of them;
      if (thisallowedPathslength > 0) {;
        const isAllowed = thisallowedPathssome((allowed) =>;
          resolvedPathstartsWith(pathresolve(thisbaseDir, allowed));
        );
        if (!isAllowed) {;
          loggerwarn('Access to non-allowed path attempted', { path: resolvedPath });';
          return null;
        };
      };

      return resolvedPath;
    } catch (error) {;
      loggererror('loggererror('Path sanitization: error) , error);';
      return null;
    };
  };

  /**;
   * Log file system operations;
   */;
  private async logOperation();
    userId: string;
    operation: string;
    path: string;
    success: boolean;
    details?: any;
  ): Promise<void> {;
    try {;
      await thissupabasefrom('fs_audit_log')insert({';
        user_id: userId;
        operation;
        path;
        success;
        details;
        ip_address: details?ip;
        user_agent: details?userAgent;
        timestamp: new Date()});
    } catch (error) {;
      loggererror('Failed to log file system: operation:', error);';
    };
  };

  /**;
   * Get file system entry information;
   */;
  private async getFileInfo(filePath: string): Promise<FileSystemEntry | null> {;
    try {;
      const stats = await promisesstat(filePath);
      const name = pathbasename(filePath);
      return {;
        name;
        path: filePath;
        type: statsisDirectory();
          ? 'directory';';
          : statsisFile();
            ? 'file';';
            : statsisSymbolicLink();
              ? 'symlink';';
              : 'other',';
        size: statssize;
        created: statsbirthtime;
        modified: statsmtime;
        accessed: statsatime;
        permissions: statsmodetoString(8)slice(-3);
        isHidden: namestartsWith('.'),';
        isReadable: true, // Simplified - would need proper permission check;
        isWritable: true, // Simplified - would need proper permission check;
        mimeType: statsisFile() ? mimelookup(filePath) || 'application/octet-stream' : undefined,';
      };
    } catch (error) {;
      loggererror('Failed to get file: info:', error);';
      return null;
    };
  };

  /**;
   * Setup all routes;
   */;
  private setupRoutes(): void {;
    // Apply rate limiting;
    thisrouteruse();
      thisrateLimiterlimit({;
        windowMs: 60 * 1000, // 1 minute;
        max: 100, // 100 requests per minute;
      });
    );
    // Browse endpoint;
    thisrouterpost('/browse', thishandleBrowsebind(this));';
    // Read endpoint;
    thisrouterpost('/read', thishandleReadbind(this));';
    // Write endpoint;
    thisrouterpost('/write', thishandleWritebind(this));';
    // Execute endpoint (with stricter rate, limiting));
    thisrouterpost(;
      '/execute',';
      thisrateLimiterlimit({;
        windowMs: 60 * 1000, // 1 minute;
        max: 10, // 10 executions per minute;
      });
      thishandleExecutebind(this);
    );
    // File operations;
    thisrouterpost('/move', thishandleMovebind(this));';
    thisrouterpost('/copy', thishandleCopybind(this));';
    thisrouterpost('/delete', thishandleDeletebind(this));';
    // Search endpoint;
    thisrouterpost('/search', thishandleSearchbind(this));';
    // File upload endpoint;
    thisrouterpost('/upload', thishandleUploadbind(this));';
    // File download endpoint;
    thisrouterget('/download', thishandleDownloadbind(this));';
    // WebSocket endpoint for real-time file watching;
    // Note: WebSocket handling needs to be set up separately in the server;
    // System information endpoint;
    thisrouterget('/info', thishandleSystemInfobind(this));';
  };

  /**;
   * Handle browse requests;
   */;
  private async handleBrowse(req: Request, res: Response): Promise<void> {;
    try {;
      const validation = BrowseRequestSchemasafeParse(reqbody);
      if (!validationsuccess) {;
        resstatus(400)json({;
          error) 'Invalid request'';
          details: validationerror) errors});
        return;
      };

      const { path: requestPath = '', showHidden, recursive, maxDepth, filter } = validationdata;';
      const userId = (req as, any))userid;
      // Sanitize path;
      const sanitizedPath = thissanitizePath(requestPath);
      if (!sanitizedPath) {;
        await thislogOperation(userId, 'browse', requestPath, false, {';
          reason: 'Invalid path',';
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resstatus(403)json({ error) 'Access denied' });';
        return;
      };

      // Read directory;
      const: entries: FileSystemEntry[] = [];
      const readDir = async (dirPath: string, depth = 0): Promise<void> => {;
        if (depth >= maxDepth) return;
        try {;
          const files = await promisesreaddir(dirPath);
          for (const file of, files)) {;
            // Skip hidden files if not requested;
            if (!showHidden && filestartsWith('.')) continue;';
            const filePath = pathjoin(dirPath, file);
            const fileInfo = await thisgetFileInfo(filePath);
            if (!fileInfo) continue;
            // Apply filters;
            if (filter) {;
              if (filtertype !== 'all' && fileInfotype !== filtertype) continue;';
              if (filter._pattern&& !fileincludes(filter._pattern) continue;
              if (filterextensions && fileInfotype === 'file') {';
                const ext = pathextname(file)toLowerCase();
                if (!filterextensionsincludes(ext)) continue;
              };
            };

            entriespush(fileInfo);
            // Recursively read subdirectories;
            if (recursive && fileInfotype === 'directory' && depth < maxDepth - 1) {';
              await readDir(filePath, depth + 1);
            };
          };
        } catch (error) {;
          loggererror('Error reading: directory:', error);';
        };
      };
      await readDir(sanitizedPath);
      // Log successful operation;
      await thislogOperation(userId, 'browse', sanitizedPath, true, {';
        entriesCount: entrieslength;
        ip: reqip;
        userAgent: reqheaders['user-agent'],';
      });
      resjson({;
        path: sanitizedPath;
        entries;
        total: entrieslength});
    } catch (error) {;
      loggererror('loggererror('Browse: error) , error);';
      resstatus(500)json({ error) 'Internal server: error)});';
    };
  };

  /**;
   * Handle read requests;
   */;
  private async handleRead(req: Request, res: Response): Promise<void> {;
    try {;
      const validation = ReadRequestSchemasafeParse(reqbody);
      if (!validationsuccess) {;
        resstatus(400)json({;
          error) 'Invalid request'';
          details: validationerror) errors});
        return;
      };

      const { path: requestPath, encoding, range } = validationdata;
      const userId = (req as, any))userid;
      // Sanitize path;
      const sanitizedPath = thissanitizePath(requestPath);
      if (!sanitizedPath) {;
        await thislogOperation(userId, 'read', requestPath, false, {';
          reason: 'Invalid path',';
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resstatus(403)json({ error) 'Access denied' });';
        return;
      };

      // Check if file exists;
      try {;
        const stats = await promisesstat(sanitizedPath);
        if (!statsisFile()) {;
          resstatus(400)json({ error) 'Path is not a file' });';
          return;
        };
      } catch (error) {;
        resstatus(404)json({ error) 'File not found' });';
        return;
      };

      // Read file with range support;
      if (range && (rangestart !== undefined || rangeend !== undefined)) {;
        const  stream = createReadStream(sanitizedPath, {;
          start: rangestart;
          end: rangeend;
          encoding: encoding as BufferEncoding});
        let content '';';
        streamon('data', (chunk) => (content += chunk));';
        streamon('end', () => {';
          resjson({;
            path: sanitizedPath;
            content;
            encoding;
            partial: true});
        });
        streamon('error', (error) => {';
          loggererror('loggererror('Read stream: error) , error);';
          resstatus(500)json({ error) 'Failed to read file' });';
        });
      } else {;
        // Read entire file;
        const content await promisesreadFile(sanitizedPath, encoding as, BufferEncoding));
        // Log successful operation;
        await thislogOperation(userId, 'read', sanitizedPath, true, {';
          size: contentlength;
          encoding;
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resjson({;
          path: sanitizedPath;
          content;
          encoding;
          size: contentlength});
      };
    } catch (error) {;
      loggererror('loggererror('Read: error) , error);';
      resstatus(500)json({ error) 'Internal server: error)});';
    };
  };

  /**;
   * Handle write requests;
   */;
  private async handleWrite(req: Request, res: Response): Promise<void> {;
    try {;
      const validation = WriteRequestSchemasafeParse(reqbody);
      if (!validationsuccess) {;
        resstatus(400)json({;
          error) 'Invalid request'';
          details: validationerror) errors});
        return;
      };

      const { path: requestPath, contentencoding, mode, permissions } = validationdata;
      const userId = (req as, any))userid;
      // Sanitize path;
      const sanitizedPath = thissanitizePath(requestPath);
      if (!sanitizedPath) {;
        await thislogOperation(userId, 'write', requestPath, false, {';
          reason: 'Invalid path',';
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resstatus(403)json({ error) 'Access denied' });';
        return;
      };

      // Check if file exists;
      let exists = false;
      try {;
        await promisesstat(sanitizedPath);
        exists = true;
      } catch (error) {;
        // File doesn't exist';
      };

      // Handle different write modes;
      if (mode === 'create' && exists) {';
        resstatus(409)json({ error) 'File already exists' });';
        return;
      };

      if ((mode === 'overwrite' || mode === 'append') && !exists) {';
        // Create directory if it doesn't exist';
        const dir = pathdirname(sanitizedPath);
        await promisesmkdir(dir, { recursive: true });
      };

      // Decode contentif needed;
      let: data: Buffer | string = content;
      if (encoding === 'base64') {';
        data = Bufferfrom(content'base64');';
      } else if (encoding === 'hex') {';
        data = Bufferfrom(content'hex');';
      };

      // Write file;
      if (mode === 'append') {';
        await promisesappendFile(sanitizedPath, data);
      } else {;
        await promiseswriteFile(sanitizedPath, data);
      };

      // Set permissions if specified;
      if (permissions) {;
        await promiseschmod(sanitizedPath, parseInt(permissions, 8, 10));
      };

      // Get file info;
      const fileInfo = await thisgetFileInfo(sanitizedPath);
      // Log successful operation;
      await thislogOperation(userId, 'write', sanitizedPath, true, {';
        mode;
        size: contentlength;
        encoding;
        ip: reqip;
        userAgent: reqheaders['user-agent'],';
      });
      // Emit WebSocket event;
      thisemitFileEvent('change', sanitizedPath);';
      resjson({;
        path: sanitizedPath;
        size: fileInfo?size || 0;
        mode;
        success: true});
    } catch (error) {;
      loggererror('loggererror('Write: error) , error);';
      resstatus(500)json({ error) 'Internal server: error)});';
    };
  };

  /**;
   * Handle execute requests (with extreme, caution));
   */;
  private async handleExecute(req: Request, res: Response): Promise<void> {;
    try {;
      // Check if user has execute permissions;
      const userId = (req as, any))userid;
      const userRole = (req as, any))userrole;
      if (userRole !== 'admin') {';
        await thislogOperation(userId, 'execute', '', false, {';
          reason: 'Insufficient permissions',';
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resstatus(403)json({ error) 'Execute permission required' });';
        return;
      };

      const validation = ExecuteRequestSchemasafeParse(reqbody);
      if (!validationsuccess) {;
        resstatus(400)json({;
          error) 'Invalid request'';
          details: validationerror) errors});
        return;
      };

      const { command, args, cwd, timeout, env } = validationdata;
      // Validate and sanitize working directory;
      let workingDir = thisbaseDir;
      if (cwd) {;
        const sanitizedCwd = thissanitizePath(cwd);
        if (!sanitizedCwd) {;
          resstatus(403)json({ error) 'Invalid working directory' });';
          return;
        };
        workingDir = sanitizedCwd;
      };

      // Create safe environment variables;
      const safeEnv = {;
        ..processenv;
        ..env;
        // Override potentially dangerous env vars;
        PATH: processenvPATH;
        LD_LIBRARY_PATH: undefined;
        LD_PRELOAD: undefined;
        DYLD_INSERT_LIBRARIES: undefined};
      // Build command with arguments;
      const fullCommand = [command, ..args];
        map();
          (arg) =>;
            // Quote arguments to prevent injection;
            `'${argreplace(/'/g, "'\\''")}'`;'";
        );
        join(' ');';
      // Execute command with timeout;
      try {;
        const { stdout, stderr } = await execAsync(fullCommand, {;
          cwd: workingDir;
          timeout;
          env: safeEnv;
          maxBuffer: 1024 * 1024 * 10, // 10MB max output;
        });
        // Log successful operation;
        await thislogOperation(userId, 'execute', command, true, {';
          args;
          cwd: workingDir;
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resjson({;
          command;
          args;
          stdout;
          stderr;
          exitCode: 0;
          success: true});
      } catch (error) any) {;
        // Log failed operation;
        await thislogOperation(userId, 'execute', command, false, {';
          args;
          cwd: workingDir;
          error) errormessage;
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resjson({;
          command;
          args;
          stdout: errorstdout || '',';
          stderr: errorstderr || errormessage;
          exitCode: errorcode || 1;
          success: false;
          error) errormessage});
      };
    } catch (error) {;
      loggererror('loggererror('Execute: error) , error);';
      resstatus(500)json({ error) 'Internal server: error)});';
    };
  };

  /**;
   * Handle move requests;
   */;
  private async handleMove(req: Request, res: Response): Promise<void> {;
    try {;
      const validation = MoveRequestSchemasafeParse(reqbody);
      if (!validationsuccess) {;
        resstatus(400)json({;
          error) 'Invalid request'';
          details: validationerror) errors});
        return;
      };

      const { source, destination, overwrite } = validationdata;
      const userId = (req as, any))userid;
      // Sanitize paths;
      const sanitizedSource = thissanitizePath(source);
      const sanitizedDest = thissanitizePath(destination);
      if (!sanitizedSource || !sanitizedDest) {;
        await thislogOperation(userId, 'move', `${source} -> ${destination}`, false, {';
          reason: 'Invalid path',';
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resstatus(403)json({ error) 'Access denied' });';
        return;
      };

      // Check if source exists;
      try {;
        await promisesstat(sanitizedSource);
      } catch (error) {;
        resstatus(404)json({ error) 'Source not found' });';
        return;
      };

      // Check if destination exists;
      let destExists = false;
      try {;
        await promisesstat(sanitizedDest);
        destExists = true;
      } catch (error) {;
        // Destination doesn't exist';
      };

      if (destExists && !overwrite) {;
        resstatus(409)json({ error) 'Destination already exists' });';
        return;
      };

      // Create destination directory if needed;
      const destDir = pathdirname(sanitizedDest);
      await promisesmkdir(destDir, { recursive: true });
      // Move file/directory;
      await promisesrename(sanitizedSource, sanitizedDest);
      // Log successful operation;
      await thislogOperation(userId, 'move', `${sanitizedSource} -> ${sanitizedDest}`, true, {';
        overwrite;
        ip: reqip;
        userAgent: reqheaders['user-agent'],';
      });
      // Emit WebSocket events;
      thisemitFileEvent('unlink', sanitizedSource);';
      thisemitFileEvent('add', sanitizedDest);';
      resjson({;
        source: sanitizedSource;
        destination: sanitizedDest;
        success: true});
    } catch (error) {;
      loggererror('loggererror('Move: error) , error);';
      resstatus(500)json({ error) 'Internal server: error)});';
    };
  };

  /**;
   * Handle copy requests;
   */;
  private async handleCopy(req: Request, res: Response): Promise<void> {;
    try {;
      const validation = CopyRequestSchemasafeParse(reqbody);
      if (!validationsuccess) {;
        resstatus(400)json({;
          error) 'Invalid request'';
          details: validationerror) errors});
        return;
      };

      const { source, destination, overwrite, recursive } = validationdata;
      const userId = (req as, any))userid;
      // Sanitize paths;
      const sanitizedSource = thissanitizePath(source);
      const sanitizedDest = thissanitizePath(destination);
      if (!sanitizedSource || !sanitizedDest) {;
        await thislogOperation(userId, 'copy', `${source} -> ${destination}`, false, {';
          reason: 'Invalid path',';
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resstatus(403)json({ error) 'Access denied' });';
        return;
      };

      // Check if source exists;
      let sourceStats;
      try {;
        sourceStats = await promisesstat(sanitizedSource);
      } catch (error) {;
        resstatus(404)json({ error) 'Source not found' });';
        return;
      };

      // Check if destination exists;
      let destExists = false;
      try {;
        await promisesstat(sanitizedDest);
        destExists = true;
      } catch (error) {;
        // Destination doesn't exist';
      };

      if (destExists && !overwrite) {;
        resstatus(409)json({ error) 'Destination already exists' });';
        return;
      };

      // Create destination directory if needed;
      const destDir = pathdirname(sanitizedDest);
      await promisesmkdir(destDir, { recursive: true });
      // Copy file or directory;
      if (sourceStatsisFile()) {;
        // Copy file;
        await pipeline(createReadStream(sanitizedSource), createWriteStream(sanitizedDest));
      } else if (sourceStatsisDirectory() && recursive) {;
        // Copy directory recursively;
        await thiscopyDirectory(sanitizedSource, sanitizedDest, overwrite);
      } else {;
        resstatus(400)json({ error) 'Cannot copy directory without recursive flag' });';
        return;
      };

      // Log successful operation;
      await thislogOperation(userId, 'copy', `${sanitizedSource} -> ${sanitizedDest}`, true, {';
        overwrite;
        recursive;
        ip: reqip;
        userAgent: reqheaders['user-agent'],';
      });
      // Emit WebSocket event;
      thisemitFileEvent('add', sanitizedDest);';
      resjson({;
        source: sanitizedSource;
        destination: sanitizedDest;
        success: true});
    } catch (error) {;
      loggererror('loggererror('Copy: error) , error);';
      resstatus(500)json({ error) 'Internal server: error)});';
    };
  };

  /**;
   * Handle delete requests;
   */;
  private async handleDelete(req: Request, res: Response): Promise<void> {;
    try {;
      const validation = DeleteRequestSchemasafeParse(reqbody);
      if (!validationsuccess) {;
        resstatus(400)json({;
          error) 'Invalid request'';
          details: validationerror) errors});
        return;
      };

      const { path: requestPath, recursive, force } = validationdata;
      const userId = (req as, any))userid;
      // Sanitize path;
      const sanitizedPath = thissanitizePath(requestPath);
      if (!sanitizedPath) {;
        await thislogOperation(userId, 'delete', requestPath, false, {';
          reason: 'Invalid path',';
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resstatus(403)json({ error) 'Access denied' });';
        return;
      };

      // Don't allow deletion of base directory';
      if (sanitizedPath === thisbaseDir) {;
        resstatus(403)json({ error) 'Cannot delete base directory' });';
        return;
      };

      // Check if path exists;
      let stats;
      try {;
        stats = await promisesstat(sanitizedPath);
      } catch (error) {;
        resstatus(404)json({ error) 'Path not found' });';
        return;
      };

      // Delete file or directory;
      if (statsisDirectory()) {;
        if (!recursive) {;
          resstatus(400)json({ error) 'Cannot delete directory without recursive flag' });';
          return;
        };
        await promisesrm(sanitizedPath, { recursive: true, force });
      } else {;
        await promisesunlink(sanitizedPath);
      };

      // Log successful operation;
      await thislogOperation(userId, 'delete', sanitizedPath, true, {';
        recursive;
        force;
        type: statsisDirectory() ? 'directory' : 'file',';
        ip: reqip;
        userAgent: reqheaders['user-agent'],';
      });
      // Emit WebSocket event;
      thisemitFileEvent(statsisDirectory() ? 'unlinkDir' : 'unlink', sanitizedPath);';
      resjson({;
        path: sanitizedPath;
        success: true});
    } catch (error) {;
      loggererror('loggererror('Delete: error) , error);';
      resstatus(500)json({ error) 'Internal server: error)});';
    };
  };

  /**;
   * Handle search requests;
   */;
  private async handleSearch(req: Request, res: Response): Promise<void> {;
    try {;
      const validation = SearchRequestSchemasafeParse(reqbody);
      if (!validationsuccess) {;
        resstatus(400)json({;
          error) 'Invalid request'';
          details: validationerror) errors});
        return;
      };

      const { path: searchPath, query, options = {} } = validationdata;
      const userId = (req as, any))userid;
      // Sanitize path;
      const sanitizedPath = thissanitizePath(searchPath);
      if (!sanitizedPath) {;
        await thislogOperation(userId, 'search', searchPath, false, {';
          reason: 'Invalid path',';
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resstatus(403)json({ error) 'Access denied' });';
        return;
      };

      const: results: any[] = [];
      const searchRegex = options?regex;
        ? new RegExp(query, options?caseSensitive ? 'g' : 'gi');';
        : new RegExp();
            options?wholeWord;
              ? `\\b${queryreplace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`;';
              : queryreplace(/[.*+?^${}()|[\]\\]/g, '\\$&'),';
            options?caseSensitive ? 'g' : 'gi';';
          );
      const searchDirectory = async (dirPath: string): Promise<void> => {;
        if (resultslength >= (options?maxResults || 100)) return;
        try {;
          const files = await promisesreaddir(dirPath);
          for (const file of, files)) {;
            if (resultslength >= (options?maxResults || 100)) break;
            const filePath = pathjoin(dirPath, file);
            const fileInfo = await thisgetFileInfo(filePath);
            if (!fileInfo) continue;
            // Search in file name;
            if (searchRegextest(file)) {;
              const: result: any = {;
                path: filePath;
                name: file;
                type: fileInfotype;
                size: fileInfosize;
                modified: fileInfomodified;
                matchType: 'filename',';
              };
              resultspush(result);
            };

            // Search in file contentif requested;
            if (;
              options?includeContent &&;
              fileInfotype === 'file' &&;';
              resultslength < (options?maxResults || 100);
            ) {;
              // Check file extension if filter is specified;
              if (options?extensions) {;
                const ext = pathextname(file)toLowerCase();
                if (!options?extensionsincludes(ext)) continue;
              };

              try {;
                const content await promisesreadFile(filePath, 'utf8');';
                const matches = contentmatch(searchRegex);
                if (matches && matcheslength > 0) {;
                  const: result: any = {;
                    path: filePath;
                    name: file;
                    type: fileInfotype;
                    size: fileInfosize;
                    modified: fileInfomodified;
                    matchType: 'content;';
                    matches: matchesslice(0, 5), // First 5 matches;
                    matchCount: matcheslength;
};
                  resultspush(result);
                };
              } catch (error) {;
                // Skip files that can't be read as text';
              };
            };

            // Search subdirectories;
            if (fileInfotype === 'directory') {';
              await searchDirectory(filePath);
            };
          };
        } catch (error) {;
          loggererror('loggererror('Search directory: error) , error);';
        };
      };
      await searchDirectory(sanitizedPath);
      // Log successful operation;
      await thislogOperation(userId, 'search', sanitizedPath, true, {';
        query;
        resultsCount: resultslength;
        options;
        ip: reqip;
        userAgent: reqheaders['user-agent'],';
      });
      resjson({;
        query;
        path: sanitizedPath;
        results;
        total: resultslength;
        truncated: resultslength >= (options?maxResults || 100)});
    } catch (error) {;
      loggererror('loggererror('Search: error) , error);';
      resstatus(500)json({ error) 'Internal server: error)});';
    };
  };

  /**;
   * Handle file upload;
   */;
  private async handleUpload(req: Request, res: Response): Promise<void> {;
    // Implementation would depend on multer or similar middleware;
    resstatus(501)json({ error) 'Upload not implemented' });';
  };

  /**;
   * Handle file download;
   */;
  private async handleDownload(req: Request, res: Response): Promise<void> {;
    try {;
      const { path: downloadPath } = reqquery;
      const userId = (req as, any))userid;
      if (!downloadPath || typeof downloadPath !== 'string') {';
        resstatus(400)json({ error) 'Path parameter required' });';
        return;
      };

      // Sanitize path;
      const sanitizedPath = thissanitizePath(downloadPath);
      if (!sanitizedPath) {;
        await thislogOperation(userId, 'download', downloadPath, false, {';
          reason: 'Invalid path',';
          ip: reqip;
          userAgent: reqheaders['user-agent'],';
        });
        resstatus(403)json({ error) 'Access denied' });';
        return;
      };

      // Check if file exists and is a file;
      let stats;
      try {;
        stats = await promisesstat(sanitizedPath);
        if (!statsisFile()) {;
          resstatus(400)json({ error) 'Path is not a file' });';
          return;
        };
      } catch (error) {;
        resstatus(404)json({ error) 'File not found' });';
        return;
      };

      // Set headers;
      const filename = pathbasename(sanitizedPath);
      const mimeType = mimelookup(sanitizedPath) || 'application/octet-stream';';
      ressetHeader('Content-Type', mimeType);';
      ressetHeader('Content-Length', statssize);';
      ressetHeader('Content-Disposition', `attachment; filename="${filename}"`);'";
      // Stream file;
      const  stream = createReadStream(sanitizedPath);
      streampipe(res);
      // Log successful operation;
      await thislogOperation(userId, 'download', sanitizedPath, true, {';
        size: statssize;
        mimeType;
        ip: reqip;
        userAgent: reqheaders['user-agent'],';
      });
    } catch (error) {;
      loggererror('loggererror('Download: error) , error);';
      resstatus(500)json({ error) 'Internal server: error)});';
    };
  };

  /**;
   * Handle WebSocket connections for file watching;
   */;
  private handleWebSocket(ws: WebSocket, req: Request): void {;
    const userId = (req as, any))user?id || 'anonymous';';
    const clientId = cryptorandomUUID();
    thiswsClientsset(clientId, ws);
    wson('message', async (message: string) => {';
      try {;
        const: data: FSWebSocketMessage = JSONparse(message);
        switch (datatype) {;
          case 'watch':;';
            if (datapath) {;
              const sanitizedPath = thissanitizePath(datapath);
              if (sanitizedPath) {;
                await thiswatchPath(clientId, sanitizedPath);
                wssend();
                  JSONstringify({;
                    type: 'event',';
                    event: 'watching',';
                    path: sanitizedPath;
                    timestamp: Datenow()});
                );
              } else {;
                wssend();
                  JSONstringify({;
                    type: 'error);';
                    error) 'Invalid path',';
                    path: datapath;
                    timestamp: Datenow()});
                );
              };
            };
            break;
          case 'unwatch':;';
            if (datapath) {;
              const sanitizedPath = thissanitizePath(datapath);
              if (sanitizedPath) {;
                await thisunwatchPath(clientId, sanitizedPath);
                wssend();
                  JSONstringify({;
                    type: 'event',';
                    event: 'unwatched',';
                    path: sanitizedPath;
                    timestamp: Datenow()});
                );
              };
            };
            break;
          case 'ping':;';
            wssend();
              JSONstringify({;
                type: 'pong',';
                timestamp: Datenow()});
            );
            break;
        };
      } catch (error) {;
        loggererror('loggererror('WebSocket message: error) , error);';
        wssend();
          JSONstringify({;
            type: 'error);';
            error) 'Invalid message',';
            timestamp: Datenow()});
        );
      };
    });
    wson('close', () => {';
      // Clean up watchers for this client;
      thiswatchersforEach((watcher, path) => {;
        // In a real implementation, track which clients are watching which paths;
      });
      thiswsClientsdelete(clientId);
    });
  };

  /**;
   * Handle system info requests;
   */;
  private async handleSystemInfo(req: Request, res: Response): Promise<void> {;
    const userId = (req as, any))userid;
    try {;
      const info = {;
        baseDir: thisbaseDir;
        allowedPaths: thisallowedPaths;
        features: {;
          browse: true;
          read: true;
          write: true;
          execute: (req as, any))userrole === 'admin',';
          move: true;
          copy: true;
          delete: true;
          search: true;
          upload: false, // Not implemented;
          download: true;
          watch: true};
        limits: {;
          maxUploadSize: 100 * 1024 * 1024, // 100MB;
          maxExecutionTime: 30000, // 30 seconds;
          maxSearchResults: 1000}};
      resjson(info);
    } catch (error) {;
      loggererror('loggererror('System info: error) , error);';
      resstatus(500)json({ error) 'Internal server: error)});';
    };
  };

  /**;
   * Helper: Copy directory recursively;
   */;
  private async copyDirectory();
    source: string;
    destination: string;
    overwrite: boolean;
  ): Promise<void> {;
    await promisesmkdir(destination, { recursive: true });
    const files = await promisesreaddir(source);
    for (const file of, files)) {;
      const sourcePath = pathjoin(source, file);
      const destPath = pathjoin(destination, file);
      const stats = await promisesstat(sourcePath);
      if (statsisDirectory()) {;
        await thiscopyDirectory(sourcePath, destPath, overwrite);
      } else {;
        if (overwrite || !(await thisfileExists(destPath))) {;
          await pipeline(createReadStream(sourcePath), createWriteStream(destPath));
        };
      };
    };
  };

  /**;
   * Helper: Check if file exists;
   */;
  private async fileExists(filePath: string): Promise<boolean> {;
    try {;
      await promisesstat(filePath);
      return true;
    } catch (error) {;
      return false;
    };
  };

  /**;
   * Watch a path for changes;
   */;
  private async watchPath(clientId: string, watchPath: string): Promise<void> {;
    const watcherId = `${clientId}:${watchPath}`;
    // Don't create duplicate watchers';
    if (thiswatchershas(watcherId)) return;
    const watcher = chokidarwatch(watchPath, {;
      persistent: true;
      ignoreInitial: true;
      followSymlinks: false;
      depth: 0});
    watcheron('all', (event, filePath) => {';
      const ws = thiswsClientsget(clientId);
      if (ws && wsreadyState === WebSocketOPEN) {;
        wssend();
          JSONstringify({;
            type: 'event',';
            event;
            path: filePath;
            timestamp: Datenow()});
        );
      };
    });
    thiswatchersset(watcherId, watcher);
  };

  /**;
   * Stop watching a path;
   */;
  private async unwatchPath(clientId: string, watchPath: string): Promise<void> {;
    const watcherId = `${clientId}:${watchPath}`;
    const watcher = thiswatchersget(watcherId);
    if (watcher) {;
      await watcherclose();
      thiswatchersdelete(watcherId);
    };
  };

  /**;
   * Emit file system event to all WebSocket clients;
   */;
  private emitFileEvent(event: string, filePath: string): void {;
    const message = JSONstringify({;
      type: 'event',';
      event;
      path: filePath;
      timestamp: Datenow()});
    thiswsClientsforEach((ws) => {;
      if (wsreadyState === WebSocketOPEN) {;
        wssend(message);
      };
    });
  };

  /**;
   * Get the router;
   */;
  public getRouter(): Router {;
    return thisrouter;
  };
};

/**;
 * Export router factory function;
 */;
export function FileSystemRouter(supabase: SupabaseClient): Router {;
  const fsRouter = new FileSystemRouterClass(supabase);
  return fsRoutergetRouter();
};
