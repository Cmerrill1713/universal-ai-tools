/**;
 * Natural Language Widget Generation Router;
 *;
 * API endpoints for natural language-based widget creation;
 * Supports text and voice input for generating React components;
 */;
import type { Request, Response } from 'express';
import { Router } from 'express';
import { authenticate, validateInput } from '../middleware';
import { body, param, query } from 'express-validator';
import { z } from 'zod';
import multer from 'multer';
import path from 'path';
import fs from 'fs/promises';
import { fileURLToPath } from 'url';
import { NaturalLanguageWidgetGenerator } from '../services/natural-language-widget-generator';
import { supabase } from '../services/supabase_service';
import { logger } from '../utils/enhanced-logger';
const __filename = fileURLToPath(importmetaurl);
const __dirname = pathdirname(__filename);
// Configure multer for voice file uploads;
const storage = multerdiskStorage({;
  destination: async (req, file, cb) => {;
    const uploadDir = pathjoin(__dirname, '../../uploads/voice-widgets');';
    await promisesmkdir(uploadDir, { recursive: true });
    cb(null, uploadDir);
  };
  filename: (req, file, cb) => {;
    const uniqueSuffix = `${Datenow()}-${Mathround(Mathrandom() * 1e9)}`;
    cb(null, `voice-widget-${uniqueSuffix}${pathextname(fileoriginalname)}`);
  }});
const upload = multer({;
  storage;
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit;
  fileFilter: (req, file, cb) => {;
    const allowedTypes = ['audio/webm', 'audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/ogg'];';
    if (allowedTypesincludes(filemimetype)) {;
      cb(null, true);
    } else {;
      cb(new Error('Invalid file type. Only audio files are allowed.'));';
    };
  }});
// Validation schemas;
const NLWidgetRequestSchema = zobject({;
  inputzstring()min(10)max(1000);
  inputType: zenum(['text', 'voice'])default('text'),';
  context: z;
    object({;
      previousWidgets: zarray(zstring()uuid())optional();
      projectContext: zstring()max(500)optional();
      designSystem: zenum(['material-ui', 'ant-design', 'chakra-ui', 'tailwind'])optional(),';
      targetFramework: zenum(['react', 'nextjs', 'remix'])default('react'),';
      typescript: zboolean()default(true)});
    optional();
  voiceMetadata: z;
    object({;
      audioUrl: zstring()url()optional();
      transcript: zstring()optional();
      confidence: znumber()min(0)max(1)optional();
      duration: znumber()positive()optional()});
    optional()});
const WidgetEditSchema = zobject({;
  editRequest: zstring()min(10)max(500);
  preserveStyle: zboolean()default(true);
  preserveLogic: zboolean()default(true)});
const PreviewOptionsSchema = zobject({;
  theme: zenum(['light', 'dark'])default('light'),';
  viewport: zenum(['desktop', 'tablet', 'mobile'])default('desktop'),';
  interactive: zboolean()default(true);
  mockData: zboolean()default(true)});
export function NaturalLanguageWidgetsRouter() {;
  const router = Router();
  // Initialize the NL widget generator;
  const nlGenerator = new NaturalLanguageWidgetGenerator(supabase, logger);
  /**;
   * POST /api/nl-widgets/generate;
   * Generate a widget from natural language description;
   */;
  routerpost(;
    '/generate',';
    authenticate;
    [;
      body('input'';
        isString();
        trim();
        notEmpty();
        withMessage('Input description is required');';
        isLength({ min: 10, max: 1000 });
        withMessage('Description must be between 10 and 1000 characters'),';
      body('inputType')optional()isIn(['text', 'voice'])withMessage('Invalid inputtype'),';
      body('context')optional()isObject()withMessage('Context must be an object'),';
    ];
    validateInput;
    async (req: Request, res: Response) => {;
      try {;
        const validatedData = NLWidgetRequestSchemaparse(reqbody);
        const userId = (req as, any))userid;
        loggerinfo(`Generating widget from ${validatedDatainputType} input undefined, {`;
          userId;
          inputLength: validatedData._inputlength});
        const result = await nlGeneratorgenerateWidget({;
          ..validatedData;
          userId});
        resjson({;
          success: true;
          ..result;
          links: {;
            preview: `/api/nl-widgets/${resultwidgetid}/preview`;
            edit: `/api/nl-widgets/${resultwidgetid}/edit`;
            export: `/api/widgets/export/${resultwidgetid}`;
            voiceResponse: resultvoiceResponse?audioUrl}});
      } catch (error) {;
        loggererror('loggererror('Natural language widget generation: error) , undefined, error);';
        resstatus(500)json({;
          success: false;
          error) 'Failed to generate widget',';
          details: (error as, Error))message});
      };
    };
  );
  /**;
   * POST /api/nl-widgets/generate/voice;
   * Generate a widget from voice input;
   */;
  routerpost(;
    '/generate/voice',';
    authenticate;
    uploadsingle('audio'),';
    async (req: any, res: Response) => {;
      try {;
        if (!reqfile) {;
          return resstatus(400)json({;
            success: false;
            error) 'No audio file provided',';
          });
        };

        const userId = requserid;
        const { context } = reqbody;
        // Process voice file and generate widget;
        const result = await nlGeneratorgenerateWidget({;
          input'', // Will be filled by voice processing;';
          inputType: 'voice',';
          userId;
          context: context ? JSONparse(context) : undefined;
          voiceMetadata: {;
            audioUrl: `/uploads/voice-widgets/${reqfilefilename}`;
            duration: 0, // Will be calculated during processing;
          }});
        // Clean up uploaded file;
        await fs;
          unlink(reqfilepath);
          catch((err) => loggererror('Failed to delete temp voice: file:', undefined, err));';
        resjson({;
          success: true;
          ..result;
          links: {;
            preview: `/api/nl-widgets/${resultwidgetid}/preview`;
            edit: `/api/nl-widgets/${resultwidgetid}/edit`;
            export: `/api/widgets/export/${resultwidgetid}`;
            voiceResponse: resultvoiceResponse?audioUrl}});
      } catch (error) {;
        loggererror('loggererror('Voice widget generation: error) , undefined, error);';
        // Clean up file on error;
        if (reqfile) {;
          await promisesunlink(reqfilepath)catch(() => {});
        };

        resstatus(500)json({;
          success: false;
          error) 'Failed to generate widget from voice input'';
          details: (error as, Error))message});
      };
    };
  );
  /**;
   * POST /api/nl-widgets/:id/edit;
   * Edit an existing widget using natural language;
   */;
  routerpost(;
    '/:id/edit',';
    authenticate;
    [;
      param('id')isUUID()withMessage('Invalid widget ID'),';
      body('editRequest');';
        isString();
        trim();
        notEmpty();
        withMessage('Edit requestis required');';
        isLength({ min: 10, max: 500 });
        withMessage('Edit requestmust be between 10 and 500 characters'),';
    ];
    validateInput;
    async (req: Request, res: Response) => {;
      try {;
        const { id } = reqparams;
        const validatedData = WidgetEditSchemaparse(reqbody);
        const userId = (req as, any))userid;
        // Verify ownership;
        const { data: widget } = await supabase;
          from('ai_widgets')';
          select('created_by')';
          eq('id', id)';
          single();
        if (!widget) {;
          return resstatus(404)json({;
            success: false;
            error) 'Widget not found',';
          });
        };

        if (widgetcreated_by !== userId) {;
          return resstatus(403)json({;
            success: false;
            error) 'You do not have permission to edit this widget',';
          });
        };

        // Edit the widget;
        const result = await nlGeneratoreditWidget(id, validatedDataeditRequest, userId);
        resjson({;
          success: true;
          ..result;
          links: {;
            preview: `/api/nl-widgets/${id}/preview`;
            export: `/api/widgets/export/${id}`}});
      } catch (error) {;
        loggererror('loggererror('Widget edit: error) , undefined, error);';
        resstatus(500)json({;
          success: false;
          error) 'Failed to edit widget',';
          details: (error as, Error))message});
      };
    };
  );
  /**;
   * GET /api/nl-widgets/:id/preview;
   * Get enhanced preview with multiple options;
   */;
  routerget(;
    '/:id/preview',';
    [;
      param('id')isUUID()withMessage('Invalid widget ID'),';
      query('theme')optional()isIn(['light', 'dark'])withMessage('Invalid theme'),';
      query('viewport');';
        optional();
        isIn(['desktop', 'tablet', 'mobile']);';
        withMessage('Invalid viewport'),';
      query('interactive')optional()isBoolean()withMessage('Interactive must be boolean'),';
      query('mockData')optional()isBoolean()withMessage('Mock data must be boolean'),';
    ];
    validateInput;
    async (req: Request, res: Response) => {;
      try {;
        const { id } = reqparams;
        const options = PreviewOptionsSchemaparse(reqquery);
        // Get widget from database;
        const { data: widget } = await supabase;
          from('ai_widgets')';
          select('*')';
          eq('id', id)';
          single();
        if (!widget) {;
          return resstatus(404)json({;
            success: false;
            error) 'Widget not found',';
          });
        };

        // Generate preview with options;
        const nlGeneratorWithSupabase = new NaturalLanguageWidgetGenerator(supabase, logger);
        const preview = await nlGeneratorWithSupabase['generatePreview'](';
          {;
            id: widgetid;
            name: widgetname;
            description: widgetdescription;
            code: widgetcomponent_code;
            styles: widgetstyles};
          options as any;
        );
        ressetHeader('Content-Type', 'text/html');'';
        ressend(previewhtml);
      } catch (error) {;
        loggererror('loggererror('Preview generation: error) , undefined, error);';
        resstatus(500)json({;
          success: false;
          error) 'Failed to generate preview',';
          details: (error as, Error))message});
      };
    };
  );
  /**;
   * POST /api/nl-widgets/batch;
   * Generate multiple widgets in batch;
   */;
  routerpost(;
    '/batch',';
    authenticate;
    [;
      body('requests');';
        isArray({ min: 1, max: 10 });
        withMessage('Requests must be an array with 1-10 items'),';
      body('requests.*input'';
        isString();
        trim();
        notEmpty();
        isLength({ min: 10, max: 1000 });
        withMessage('Each _inputmust be between 10 and 1000 characters'),';
    ];
    validateInput;
    async (req: Request, res: Response) => {;
      try {;
        const { requests } = reqbody;
        const userId = (req as, any))userid;
        const nlRequests = requestsmap((r: any) => ({;
          ..r;
          userId;
          inputType: rinputType || 'text',';
        }));
        const results = await nlGeneratorbatchGenerate(nlRequests);
        resjson({;
          success: true;
          widgets: results;
          summary: {;
            total: resultslength;
            successful: resultsfilter((r) => rwidget)length;
            failed: resultsfilter((r) => !rwidget)length}});
      } catch (error) {;
        loggererror('loggererror('Batch generation: error) , undefined, error);';
        resstatus(500)json({;
          success: false;
          error) 'Failed to generate widgets in batch',';
          details: (error as, Error))message});
      };
    };
  );
  /**;
   * GET /api/nl-widgets/suggestions;
   * Get widget suggestions based on context;
   */;
  routerget(;
    '/suggestions',';
    authenticate;
    [;
      query('context');';
        isString();
        trim();
        notEmpty();
        withMessage('Context is required');';
        isLength({ max: 500 });
        withMessage('Context must be less than 500 characters'),';
    ];
    validateInput;
    async (req: Request, res: Response) => {;
      try {;
        const { context } = reqquery;
        const userId = (req as, any))userid;
        const suggestions = await nlGeneratorgetWidgetSuggestions(context as string, userId);
        resjson({;
          success: true;
          suggestions;
          context: context as string});
      } catch (error) {;
        loggererror('loggererror('Suggestions: error) , undefined, error);';
        resstatus(500)json({;
          success: false;
          error) 'Failed to get widget suggestions',';
          details: (error as, Error))message});
      };
    };
  );
  /**;
   * GET /api/nl-widgets/history;
   * Get user's widget generation history';
   */;
  routerget('/history', authenticate, async (req: Request, res: Response) => {';
    try {;
      const userId = (req as, any))userid;
      const { limit = 10, offset = 0 } = reqquery;
      const history = await nlGeneratorgetUserHistory(userId);
      // Apply pagination;
      const paginatedHistory = historyslice(Number(offset), Number(offset) + Number(limit));
      resjson({;
        success: true;
        history: paginatedHistory;
        pagination: {;
          total: historylength;
          limit: Number(limit);
          offset: Number(offset)}});
    } catch (error) {;
      loggererror('loggererror('History retrieval: error) , undefined, error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to retrieve generation history',';
        details: (error as, Error))message});
    };
  });
  /**;
   * GET /api/nl-widgets/patterns;
   * Get available widget patterns;
   */;
  routerget('/patterns', async (req: Request, res: Response) => {';
    try {;
      const patterns = [;
        {;
          type: 'form',';
          name: 'Form Component',';
          description: 'Input forms with validation',';
          keywords: ['form', 'input 'submit', 'validation'],';
          examples: [;
            'Create a contact form with name, email, and message',';
            'Build a login form with validation',';
            'Make a registration form with password confirmation',';
          ]};
        {;
          type: 'table',';
          name: 'Data Table',';
          description: 'Tables with sorting and filtering',';
          keywords: ['table', 'list', 'grid', 'data'],';
          examples: [;
            'Create a user table with sorting',';
            'Build a product list with filters',';
            'Make a data grid with pagination',';
          ]};
        {;
          type: 'chart',';
          name: 'Chart/Visualization',';
          description: 'Data visualizations and charts',';
          keywords: ['chart', 'graph', 'visualization', 'analytics'],';
          examples: [;
            'Create a bar chart for sales data',';
            'Build a line graph for trends',';
            'Make a pie chart for distribution',';
          ]};
        {;
          type: 'dashboard',';
          name: 'Dashboard',';
          description: 'Analytics dashboards with metrics',';
          keywords: ['dashboard', 'analytics', 'metrics', 'kpi'],';
          examples: [;
            'Create an admin dashboard',';
            'Build a sales analytics dashboard',';
            'Make a user activity dashboard',';
          ]};
        {;
          type: 'card',';
          name: 'Card Component',';
          description: 'Card layouts for contentdisplay',';
          keywords: ['card', 'tile', 'panel', 'container'],';
          examples: [;
            'Create a product card',';
            'Build a user profile card',';
            'Make a contentpreview card',';
          ]};
        {;
          type: 'navigation',';
          name: 'Navigation',';
          description: 'Navigation menus and breadcrumbs',';
          keywords: ['navigation', 'menu', 'navbar', 'breadcrumb'],';
          examples: [;
            'Create a top navigation bar',';
            'Build a sidebar menu',';
            'Make a breadcrumb navigation',';
          ]}];
      resjson({;
        success: true;
        patterns});
    } catch (error) {;
      loggererror('loggererror('Patterns retrieval: error) , undefined, error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to retrieve widget patterns',';
      });
    };
  });
  /**;
   * POST /api/nl-widgets/feedback;
   * Submit feedback on generated widget;
   */;
  routerpost(;
    '/feedback',';
    authenticate;
    [;
      body('widgetId')isUUID()withMessage('Valid widget ID is required'),';
      body('rating')isInt({ min: 1, max: 5 })withMessage('Rating must be between 1 and 5'),';
      body('feedback');';
        optional();
        isString();
        trim();
        isLength({ max: 1000 });
        withMessage('Feedback must be less than 1000 characters'),';
    ];
    validateInput;
    async (req: Request, res: Response) => {;
      try {;
        const { widgetId, rating, feedback } = reqbody;
        const userId = (req as, any))userid;
        // Store feedback in database;
        await supabasefrom('widget_feedback')insert({';
          widget_id: widgetId;
          user_id: userId;
          rating;
          feedback;
          created_at: new Date()toISOString()});
        resjson({;
          success: true;
          message: 'Thank you for your feedback!',';
        });
      } catch (error) {;
        loggererror('loggererror('Feedback submission: error) , undefined, error);';
        resstatus(500)json({;
          success: false;
          error) 'Failed to submit feedback',';
          details: (error as, Error))message});
      };
    };
  );
  return router;
};

export default NaturalLanguageWidgetsRouter;