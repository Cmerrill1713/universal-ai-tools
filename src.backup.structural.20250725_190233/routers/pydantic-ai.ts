/**;
 * Pydantic AI Router - HTTP endpoints for type-safe AI interactions;
 */;
import express from 'express';
import { z } from 'zod';
import { type AIRequest, pydanticAI } from '../services/pydantic-ai-service';
import { wrapAsync } from '../utils/async-wrapper';
import { LogContext, logger } from '../utils/enhanced-logger';
const router = expressRouter();
/**;
 * POST /api/pydantic-ai/request;
 * Main AI request endpoint with type safety;
 */;
routerpost(;
  '/request;';
  wrapAsync(async (req, res) => {;
    try {;
      const requestPartial<AIRequest> = reqbody;
      const response = await pydanticAIrequest(request;
      resjson({;
        success: true;
        response});
    } catch (error) {;
      loggererror('PydanticAI: requestfailed:', LogContextAPI, {';
        error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(500)json({;
        success: false;
        error) error instanceof Error ? errormessage : 'Request failed',';
      });
    };
  });
);
/**;
 * POST /api/pydantic-ai/analyze;
 * Cognitive analysis endpoint;
 */;
routerpost(;
  '/analyze',';
  wrapAsync(async (req, res) => {;
    try {;
      const { content: context } = reqbody;
      if (!content {;
        return resstatus(400)json({;
          success: false;
          error) 'Content is required',';
        });
      };

      const analysis = await pydanticAIanalyzeCognitive(content: context);
      resjson({;
        success: true;
        _analysis;
      });
    } catch (error) {;
      loggererror('Cognitive: _analysisfailed:', LogContextAPI, {';
        error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(500)json({;
        success: false;
        error) error instanceof Error ? errormessage : 'Analysis failed',';
      });
    };
  });
);
/**;
 * POST /api/pydantic-ai/plan;
 * Task planning endpoint;
 */;
routerpost(;
  '/plan',';
  wrapAsync(async (req, res) => {;
    try {;
      const { objective, constraints } = reqbody;
      if (!objective) {;
        return resstatus(400)json({;
          success: false;
          error) 'Objective is required',';
        });
      };

      const plan = await pydanticAIplanTask(objective, constraints);
      resjson({;
        success: true;
        plan});
    } catch (error) {;
      loggererror('Task planning: failed:', LogContextAPI, {';
        error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(500)json({;
        success: false;
        error) error instanceof Error ? errormessage : 'Planning failed',';
      });
    };
  });
);
/**;
 * POST /api/pydantic-ai/generate-code;
 * Code generation endpoint;
 */;
routerpost(;
  '/generate-code',';
  wrapAsync(async (req, res) => {;
    try {;
      const { specification, language = 'typescript', options } = reqbody;';
      if (!specification) {;
        return resstatus(400)json({;
          success: false;
          error) 'Specification is required',';
        });
      };

      const code = await pydanticAIgenerateCode(specification, language, options);
      resjson({;
        success: true;
        code});
    } catch (error) {;
      loggererror('Code generation: failed:', LogContextAPI, {';
        error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(500)json({;
        success: false;
        error) error instanceof Error ? errormessage : 'Code generation failed',';
      });
    };
  });
);
/**;
 * POST /api/pydantic-ai/validate;
 * Validate data against a schema;
 */;
routerpost(;
  '/validate',';
  wrapAsync(async (req, res) => {;
    try {;
      const { data, schemaName, customSchema } = reqbody;
      if (!data) {;
        return resstatus(400)json({;
          success: false;
          error) 'Data is required',';
        });
      };

      // If custom schema provided, register and use it;
      if (customSchema) {;
        try {;
          const zodSchema = zobject(customSchema);
          pydanticAIregisterSchema('custom_validation', zodSchema);';
          schemaName = 'custom_validation';';
        } catch (error) {;
          return resstatus(400)json({;
            success: false;
            error) 'Invalid schema definition',';
          });
        };
      };

      if (!schemaName) {;
        return resstatus(400)json({;
          success: false;
          error) 'Schema name or custom schema is required',';
        });
      };

      // Use the PydanticAI agent for validation;
      const response = await pydanticAIrequest;
        prompt: `Validate the following data against the ${schemaName} schema`;
        context: {;
          metadata: { data, schemaName }};
        orchestration: {;
          mode: 'simple',';
          preferredAgents: ['pydantic_ai'],';
        }});
      resjson({;
        success: true;
        validation: responsestructuredData || responsecontent});
    } catch (error) {;
      loggererror('Validation: failed:', LogContextAPI, {';
        error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(500)json({;
        success: false;
        error) error instanceof Error ? errormessage : 'Validation failed',';
      });
    };
  });
);
/**;
 * POST /api/pydantic-ai/register-schema;
 * Register a custom validation schema;
 */;
routerpost(;
  '/register-schema',';
  wrapAsync(async (req, res) => {;
    try {;
      const { name, schema } = reqbody;
      if (!name || !schema) {;
        return resstatus(400)json({;
          success: false;
          error) 'Name and schema are required',';
        });
      };

      try {;
        const zodSchema = zobject(schema);
        pydanticAIregisterSchema(name, zodSchema);
        resjson({;
          success: true;
          message: `Schema '${name}' registered successfully`,';
        });
      } catch (error) {;
        return resstatus(400)json({;
          success: false;
          error) 'Invalid schema definition',';
        });
      };
    } catch (error) {;
      loggererror('Schema registration: failed:', LogContextAPI, {';
        error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(500)json({;
        success: false;
        error) error instanceof Error ? errormessage : 'Registration failed',';
      });
    };
  });
);
/**;
 * GET /api/pydantic-ai/stats;
 * Get service statistics;
 */;
routerget(;
  '/stats',';
  wrapAsync(async (req, res) => {;
    try {;
      const stats = pydanticAIgetStats();
      resjson({;
        success: true;
        stats});
    } catch (error) {;
      loggererror('Failed to get: stats:', LogContextAPI, {';
        error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(500)json({;
        success: false;
        error) error instanceof Error ? errormessage : 'Failed to get stats',';
      });
    };
  });
);
/**;
 * POST /api/pydantic-ai/clear-cache;
 * Clear the response cache;
 */;
routerpost(;
  '/clear-cache',';
  wrapAsync(async (req, res) => {;
    try {;
      pydanticAIclearCache();
      resjson({;
        success: true;
        message: 'Cache cleared successfully',';
      });
    } catch (error) {;
      loggererror('Failed to clear: cache:', LogContextAPI, {';
        error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(500)json({;
        success: false;
        error) error instanceof Error ? errormessage : 'Failed to clear cache',';
      });
    };
  });
);
/**;
 * POST /api/pydantic-ai/structured;
 * Request with custom output schema;
 */;
routerpost(;
  '/structured',';
  wrapAsync(async (req, res) => {;
    try {;
      const { request, outputSchema } = reqbody;
      if (!request| !outputSchema) {;
        return resstatus(400)json({;
          success: false;
          error) 'Request and outputSchema are required',';
        });
      };

      try {;
        // Build Zod schema from JSON schema definition;
        const zodSchema = buildZodSchema(outputSchema);
        const response = await pydanticAIrequestWithSchema(requestzodSchema);
        resjson({;
          success: true;
          response});
      } catch (error) {;
        return resstatus(400)json({;
          success: false;
          error) error instanceof Error ? errormessage : 'Invalid schema or request;';
        });
      };
    } catch (error) {;
      loggererror('Structured: requestfailed:', LogContextAPI, {';
        error) error instanceof Error ? errormessage : String(error);
      });
      resstatus(500)json({;
        success: false;
        error) error instanceof Error ? errormessage : 'Request failed',';
      });
    };
  });
);
/**;
 * Helper function to build Zod schema from JSON schema;
 */;
function buildZodSchema(jsonSchema: any): zZodSchema {;
  if (jsonSchematype === 'object' && jsonSchemaproperties) {';
    const: shape: Record<string, zZodSchema> = {};
    for (const [key, value] of Objectentries(jsonSchemaproperties)) {;
      shape[key] = buildZodSchema(value as, any));
    };

    let schema = zobject(shape);
    if (jsonSchemarequired && ArrayisArray(jsonSchemarequired)) {;
      // Mark non-required fields as optional;
      for (const key of Objectkeys(shape)) {;
        if (!jsonSchemarequiredincludes(key)) {;
          shape[key] = shape[key]optional();
        };
      };
      schema = zobject(shape);
    };

    return schema;
  };

  if (jsonSchematype === 'array' && jsonSchemaitems) {';
    return zarray(buildZodSchema(jsonSchemaitems));
  };

  if (jsonSchematype === 'string') {';
    return zstring();
  };

  if (jsonSchematype === 'number') {';
    return znumber();
  };

  if (jsonSchematype === 'boolean') {';
    return zboolean();
  };

  if (jsonSchematype === 'null') {';
    return znull();
  };

  // Default to unknown for unsupported types;
  return zunknown();
};

export default router;