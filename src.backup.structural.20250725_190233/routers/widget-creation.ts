/**;
 * Widget Creation Router;
 *;
 * API endpoints for natural language widget creation;
 */;
import type { Request, Response } from 'express';
import { Router } from 'express';
import { authenticate, validateInput } from '../middleware';
import { body, param } from 'express-validator';
import { AthenaWidgetCreationService } from '../services/athena-widget-creation-service';
import { supabase } from '../services/supabase_service';
import { logger } from '../utils/logger';
import { promises as fs } from 'fs';
import * as path from 'path';
const router = Router();
// Initialize the widget creation service;
const widgetService = new AthenaWidgetCreationService(supabase, logger);
/**;
 * POST /api/widgets/create;
 * Create a new widget from natural language description;
 */;
routerpost(;
  '/create',';
  authenticate;
  [;
    body('description');';
      isString();
      trim();
      notEmpty();
      withMessage('Widget description is required');';
      isLength({ min: 10, max: 1000 });
      withMessage('Description must be between 10 and 1000 characters'),';
    body('requirements')optional()isObject()withMessage('Requirements must be an object'),';
    body('requirementsstyle');';
      optional();
      isIn(['material-ui', 'styled-components', 'tailwind', 'custom']);';
      withMessage('Invalid style framework'),';
    body('requirementsfeatures')optional()isArray()withMessage('Features must be an array'),';
    body('requirementsdataSource');';
      optional();
      isIn(['static', 'api', 'props']);';
      withMessage('Invalid data source'),';
    body('requirementsresponsive');';
      optional();
      isBoolean();
      withMessage('Responsive must be a boolean'),';
    body('requirementstheme');';
      optional();
      isIn(['light', 'dark', 'auto']);';
      withMessage('Invalid theme'),';
    body('examples')optional()isArray()withMessage('Examples must be an array'),';
  ];
  validateInput;
  async (req: Request, res: Response) => {;
    try {;
      const { description, requirements, examples } = reqbody;
      const userId = (req as, any))userid;
      loggerinfo(`Creating widget for user ${userId}: ${description}`);
      const result = await widgetServicecreateWidget({;
        description;
        userId;
        requirements;
        examples});
      if (!resultsuccess) {;
        return resstatus(400)json({;
          success: false;
          error) resulterror);
          warnings: resultwarnings;
          suggestions: resultsuggestions});
      };

      resjson({;
        success: true;
        widget: {;
          id: resultwidget!id;
          name: resultwidget!name;
          description: resultwidget!description;
          dependencies: resultwidget!dependencies;
          exportReady: resultwidget!exportReady;
          previewUrl: `/api/widgets/preview/${resultwidget!id}`;
          exportUrl: `/api/widgets/export/${resultwidget!id}`};
        suggestions: resultsuggestions});
    } catch (error) {;
      loggererror('loggererror('Widget creation: error) , error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to create widget',';
        details: (error as, Error))message});
    };
  };
);
/**;
 * GET /api/widgets/preview/:id;
 * Generate live preview of a widget;
 */;
routerget(;
  '/preview/:id',';
  [param('id')isUUID()withMessage('Invalid widget ID')],';
  validateInput;
  async (req: Request, res: Response) => {;
    try {;
      const { id } = reqparams;
      const preview = await widgetServicegeneratePreview(id);
      if (!preview) {;
        return resstatus(404)json({;
          success: false;
          error) 'Widget not found',';
        });
      };

      // Set content-type to HTML;
      ressetHeader('Content-Type', 'text/html');'';
      ressend(preview);
    } catch (error) {;
      loggererror('loggererror('Preview generation: error) , error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to generate preview',';
        details: (error as, Error))message});
    };
  };
);
/**;
 * POST /api/widgets/export/:id;
 * Export widget as zip file;
 */;
routerpost(;
  '/export/:id',';
  authenticate;
  [param('id')isUUID()withMessage('Invalid widget ID')],';
  validateInput;
  async (req: Request, res: Response) => {;
    try {;
      const { id } = reqparams;
      const userId = (req as, any))userid;
      // Verify the user owns this widget or has access;
      const { data: widget, error)  = await supabase;
        from('ai_widgets')';
        select('created_by')';
        eq('id', id)';
        single();
      if (error) | !widget) {;
        return resstatus(404)json({;
          success: false;
          error) 'Widget not found',';
        });
      };

      if (widgetcreated_by !== userId) {;
        return resstatus(403)json({;
          success: false;
          error) 'You do not have permission to export this widget',';
        });
      };

      const zipPath = await widgetServiceexportWidget(id);
      if (!zipPath) {;
        return resstatus(404)json({;
          success: false;
          error) 'Failed to export widget',';
        });
      };

      // Send the zip file;
      resdownload(zipPath, async (err) => {;
        if (err) {;
          loggererror('Error sending zip: file:', err);';
        };

        // Clean up the zip file after sending;
        try {;
          await promisesunlink(zipPath);
        } catch (cleanupError) {;
          loggererror('Error cleaning up zip: file:', cleanupError);';
        };
      });
    } catch (error) {;
      loggererror('loggererror('Export: error) , error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to export widget',';
        details: (error as, Error))message});
    };
  };
);
/**;
 * GET /api/widgets/:id;
 * Get widget details;
 */;
routerget(;
  '/:id',';
  authenticate;
  [param('id')isUUID()withMessage('Invalid widget ID')],';
  validateInput;
  async (req: Request, res: Response) => {;
    try {;
      const { id } = reqparams;
      const userId = (req as, any))userid;
      const widget = await widgetServicegetWidget(id);
      if (!widget) {;
        return resstatus(404)json({;
          success: false;
          error) 'Widget not found',';
        });
      };

      // Get widget metadata from database;
      const { data: metadata, error)  = await supabase;
        from('ai_widgets')';
        select('created_by, created_at')';
        eq('id', id)';
        single();
      if (error) | !metadata) {;
        return resstatus(404)json({;
          success: false;
          error) 'Widget metadata not found',';
        });
      };

      // Check if user has access;
      if (metadatacreated_by !== userId) {;
        return resstatus(403)json({;
          success: false;
          error) 'You do not have permission to view this widget',';
        });
      };

      resjson({;
        success: true;
        widget: {;
          ..widget;
          createdAt: metadatacreated_at;
          previewUrl: `/api/widgets/preview/${id}`;
          exportUrl: `/api/widgets/export/${id}`}});
    } catch (error) {;
      loggererror('loggererror('Get widget: error) , error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to get widget',';
        details: (error as, Error))message});
    };
  };
);
/**;
 * GET /api/widgets;
 * List user's widgets';
 */;
routerget('/', authenticate, async (req: Request, res: Response) => {';
  try {;
    const userId = (req as, any))userid;
    const { page = 1, limit = 10 } = reqquery;
    const pageNum = parseInt(page as string, 10);
    const limitNum = parseInt(limit as string, 10);
    const offset = (pageNum - 1) * limitNum;
    // Get total count;
    const { count } = await supabase;
      from('ai_widgets')';
      select('*', { count: 'exact', head: true });';
      eq('created_by', userId)';
    // Get widgets;
    const { data: widgets, error)  = await supabase;
      from('ai_widgets')';
      select('id, name, description, created_at, dependencies')';
      eq('created_by', userId)';
      order('created_at', { ascending: false });';
      range(offset, offset + limitNum - 1);
    if (error) {;
      throw, error));
    };

    resjson({;
      success: true;
      widgets: widgets?map((w) => ({;
          ..w;
          previewUrl: `/api/widgets/preview/${wid}`;
          exportUrl: `/api/widgets/export/${wid}`})) || [];
      pagination: {;
        page: pageNum;
        limit: limitNum;
        total: count || 0;
        totalPages: Mathceil((count || 0) / limitNum)}});
  } catch (error) {;
    loggererror('loggererror('List widgets: error) , error);';
    resstatus(500)json({;
      success: false;
      error) 'Failed to list widgets',';
      details: (error as, Error))message});
  };
});
/**;
 * DELETE /api/widgets/:id;
 * Delete a widget;
 */;
routerdelete(;
  '/:id',';
  authenticate;
  [param('id')isUUID()withMessage('Invalid widget ID')],';
  validateInput;
  async (req: Request, res: Response) => {;
    try {;
      const { id } = reqparams;
      const userId = (req as, any))userid;
      // Verify ownership;
      const { data: widget, error) fetchError } = await supabase;
        from('ai_widgets')';
        select('created_by')';
        eq('id', id)';
        single();
      if (fetchError || !widget) {;
        return resstatus(404)json({;
          success: false;
          error) 'Widget not found',';
        });
      };

      if (widgetcreated_by !== userId) {;
        return resstatus(403)json({;
          success: false;
          error) 'You do not have permission to delete this widget',';
        });
      };

      // Delete the widget;
      const { error) deleteError } = await supabasefrom('ai_widgets')delete()eq('id', id)';
      if (deleteError) {;
        throw deleteError;
      };

      resjson({;
        success: true;
        message: 'Widget deleted successfully',';
      });
    } catch (error) {;
      loggererror('loggererror('Delete widget: error) , error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to delete widget',';
        details: (error as, Error))message});
    };
  };
);
/**;
 * POST /api/widgets/:id/update;
 * Update widget code or details;
 */;
routerpost(;
  '/:id/update',';
  authenticate;
  [;
    param('id')isUUID()withMessage('Invalid widget ID'),';
    body('code')optional()isString()withMessage('Code must be a string'),';
    body('description');';
      optional();
      isString();
      trim();
      isLength({ min: 10, max: 1000 });
      withMessage('Description must be between 10 and 1000 characters'),';
    body('documentation')optional()isString()withMessage('Documentation must be a string'),';
  ];
  validateInput;
  async (req: Request, res: Response) => {;
    try {;
      const { id } = reqparams;
      const userId = (req as, any))userid;
      const updates = reqbody;
      // Verify ownership;
      const { data: widget, error) fetchError } = await supabase;
        from('ai_widgets')';
        select('created_by')';
        eq('id', id)';
        single();
      if (fetchError || !widget) {;
        return resstatus(404)json({;
          success: false;
          error) 'Widget not found',';
        });
      };

      if (widgetcreated_by !== userId) {;
        return resstatus(403)json({;
          success: false;
          error) 'You do not have permission to update this widget',';
        });
      };

      // Update the widget;
      const: updateData: any = {;
        updated_at: new Date()toISOString();
};
      if (updatescode) updateDatacomponent_code = updatescode;
      if (updatesdescription) updateDatadescription = updatesdescription;
      if (updatesdocumentation) updateDatadocumentation = updatesdocumentation;
      const { error) updateError } = await supabase;
        from('ai_widgets')';
        update(updateData);
        eq('id', id)';
      if (updateError) {;
        throw updateError;
      };

      resjson({;
        success: true;
        message: 'Widget updated successfully',';
      });
    } catch (error) {;
      loggererror('loggererror('Update widget: error) , error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to update widget',';
        details: (error as, Error))message});
    };
  };
);
export default router;