import { Router } from 'express';
import { z } from 'zod';
import type { SupabaseClient } from '@supabase/supabase-js';
import { dspyService } from '../services/dspy-service';
import { logger } from '../utils/logger';
import { v4 as uuidv4 } from 'uuid';
import { EnhancedMemorySystem } from '../memory/enhanced_memory_system';
import type { DSPyOrchestrationRequest } from '../services/dspy-service';
// Request validation schema;
const chatRequestSchema = zobject({;
  message: zstring()min(1);
  conversationId: zstring()optional();
  sessionId: zstring()optional();
  context: zrecord(zany())optional()});
export function ChatRouter(supabase: SupabaseClient) {;
  const router = Router();
  const memorySystem = new EnhancedMemorySystem(supabase, logger);
  /**;
   * Main chat endpoint with memory persistence;
   */;
  routerpost('/', async (req: any, res) => {';
    try {;
      const data = chatRequestSchemaparse(reqbody);
      ;
      // Generate IDs if not provided;
      const conversationId = dataconversationId || uuidv4();
      const sessionId = datasessionId || uuidv4();
      const requestId = uuidv4();
      // Retrieve conversation history if conversationId exists;
      let: conversationHistory: any[] = [];
      if (dataconversationId) {;
        try {;
          const searchOptions = {;
            query: '',';
            filters: {;
              conversationId: dataconversationId};
            limit: 20;
            orderBy: 'timestamp',';
            orderDirection: 'desc' as const,';
          };
          ;
          conversationHistory = await memorySystemsearchMemories(searchOptions);
          loggerinfo(`Retrieved ${conversationHistorylength} previous messages for conversation ${conversationId}`);
        } catch (error) {;
          loggerwarn('Failed to retrieve conversation: history:', error);';
        };
      };

      // Create orchestration request with conversation context;
      const: orchestrationRequest: DSPyOrchestrationRequest = {;
        requestId;
        userRequest: datamessage;
        userId: reqaiServiceId || 'user',';
        orchestrationMode: 'adaptive',';
        context: {;
          ..datacontext;
          conversationId;
          sessionId;
          conversationHistory: conversationHistorymap(memory => ({;
            content: memorycontent;
            metadata: memorymetadata;
            timestamp: memorycreated_at}))};
        timestamp: new Date();
};
      // Notify UI about memory activity;
      const { agentCollaborationWS } = await import('../services/agent-collaboration-websocket');';
      agentCollaborationWSupdateAgentStatus({;
        agentId: 'memory',';
        agentName: 'Memory Agent',';
        status: 'working',';
        currentTask: 'Processing chat history',';
        progress: 20;
        timestamp: new Date();
        metadata: {;
          participatingIn: requestId}});
      ;
      // Store user message in memory;
      await memorySystemstoreMemory(;
        reqaiServiceId || 'user',';
        'conversation',';
        datamessage;
        {;
          conversationId;
          sessionId;
          requestId;
          type: 'user_message',';
          timestamp: new Date()};
        [] // Keywords extracted automatically;
      );
      // Execute orchestration;
      const response = await dspyServiceorchestrate(orchestrationRequest);
      // Store assistant response in memory if successful;
      if (responsesuccess) {;
        const responseContent = typeof responseresult === 'string' ';
          ? responseresult ;
          : JSONstringify(responseresult);
        ;
        await memorySystemstoreMemory(;
          'assistant',';
          'conversation',';
          responseContent;
          {;
            conversationId;
            sessionId;
            requestId;
            type: 'assistant_message',';
            confidence: responseconfidence;
            participatingAgents: responseparticipatingAgents;
            timestamp: new Date()};
          [] // Keywords extracted automatically;
        );
      };

      // Return chat response;
      resjson({;
        success: responsesuccess;
        message: responseresult;
        conversationId;
        sessionId;
        requestId;
        confidence: responseconfidence;
        participatingAgents: responseparticipatingAgents});
    } catch (error) {;
      loggererror('Chat: error)', error);';
      if (error instanceof zZodError) {;
        resstatus(400)json({;
          success: false;
          error) 'Invalid request format',';
          details: errorerrors});
      } else {;
        resstatus(500)json({;
          success: false;
          error) 'Chat request failed',';
          message: error instanceof Error ? errormessage : 'Unknown error',';
        });
      };
    };
  });
  /**;
   * Get conversation history;
   */;
  routerget('/history/:conversationId', async (req: any, res) => {';
    try {;
      const { conversationId } = reqparams;
      const limit = parseInt(reqquerylimit) || 50;
      const offset = parseInt(reqqueryoffset) || 0;
      // Search for conversation messages;
      const searchOptions = {;
        query: '',';
        filters: {;
          conversationId};
        limit;
        offset;
        orderBy: 'timestamp',';
        orderDirection: 'asc' as const,';
      };
      const messages = await memorySystemsearchMemories(searchOptions);
      resjson({;
        success: true;
        conversationId;
        messages: messagesmap(memory => ({;
          id: memoryid;
          content: memorycontent;
          type: memorymetadatatype;
          timestamp: memorycreated_at;
          metadata: memorymetadata}));
        total: messageslength});
    } catch (error) {;
      loggererror('Failed to retrieve conversation: history:', error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to retrieve conversation history',';
        message: error instanceof Error ? errormessage : 'Unknown error',';
      });
    };
  });
  /**;
   * Clear conversation history (for privacy/cleanup);
   */;
  routerdelete('/history/:conversationId', async (req: any, res) => {';
    try {;
      const { conversationId } = reqparams;
      // Note: This would need to be implemented in the memory system;
      // For now, we'll just log the request';
      loggerinfo(`Request to clear conversation: history: ${conversationId}`);
      resjson({;
        success: true;
        message: 'Conversation history cleared',';
        conversationId});
    } catch (error) {;
      loggererror('Failed to clear conversation: history:', error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to clear conversation history',';
        message: error instanceof Error ? errormessage : 'Unknown error',';
      });
    };
  });
  return router;
};