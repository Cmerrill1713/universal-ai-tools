import { Router } from 'express';
import { z } from 'zod';
import type { SupabaseClient } from '@supabase/supabase-js';
import { dspyService, type DSPyOrchestrationRequest } from '../services/dspy-service';
import { logger } from '../utils/logger';
import { v4 as uuidv4 } from 'uuid';
import { EnhancedMemorySystem } from '../memory/enhanced_memory_system';
// Request validation schemas;
const orchestrationRequestSchema = zobject({;
  userRequest: zstring()min(1);
  orchestrationMode: zenum(['simple', 'standard', 'cognitive', 'adaptive'])optional(),';
  context: zrecord(zany())optional();
  conversationId: zstring()optional();
  sessionId: zstring()optional()});
const coordinationRequestSchema = zobject({;
  task: zstring()min(1);
  availableAgents: zarray(zstring());
  context: zrecord(zany())optional()});
const knowledgeSearchSchema = zobject({;
  query: zstring()min(1);
  filters: zrecord(zany())optional();
  limit: znumber()optional()});
const knowledgeExtractSchema = zobject({;
  content: zstring()min(1);
  context: zrecord(zany())optional()});
const knowledgeEvolveSchema = zobject({;
  existingKnowledge: zstring();
  newInformation: zstring()});
const promptOptimizationSchema = zobject({;
  examples: zarray(;
    zobject({;
      input: zstring();
      output: zstring();
      metadata: zrecord(zany())optional()});
  )});
export function OrchestrationRouter(supabase: SupabaseClient) {;
  const router = Router();
  const memorySystem = new EnhancedMemorySystem(supabase, logger);
  /**;
   * Main orchestration endpoint - replaces enhanced orchestrator;
   */;
  routerpost('/orchestrate', async (req: any, res) => {';
    try {;
      const data = orchestrationRequestSchemaparse(reqbody);
      // Create orchestration request;
      const: orchestrationRequest: DSPyOrchestrationRequest = {;
        requestId: uuidv4();
        userRequest: datauserRequest;
        userId: reqaiServiceId;
        orchestrationMode: dataorchestrationMode;
        context: {;
          ..datacontext;
          conversationId: dataconversationId;
          sessionId: datasessionId};
        timestamp: new Date();
};
      // Log the orchestration request;
      await supabasefrom('ai_orchestration_logs')insert({';
        request_id: orchestrationRequestrequestId;
        service_id: reqaiServiceId;
        userrequest: datauserRequest;
        orchestration_mode: dataorchestrationMode || 'auto',';
        status: 'processing',';
        created_at: new Date()});
      // Execute orchestration through DSPy service;
      const response = await dspyServiceorchestrate(orchestrationRequest);
      // Update orchestration log;
      await supabase;
        from('ai_orchestration_logs')';
        update({;
          status: responsesuccess ? 'completed' : 'failed',';
          response_data: responseresult;
          execution_time_ms: responseexecutionTime;
          confidence: responseconfidence;
          participating_agents: responseparticipatingAgents;
          completed_at: new Date()});
        eq('request_id', orchestrationRequestrequestId)';
      // Store conversation in memory system if successful;
      if (responsesuccess) {;
        try {;
          // Notify UI that memory agent is working;
          const { agentCollaborationWS } = await import('../services/agent-collaboration-websocket');';
          agentCollaborationWSupdateAgentStatus({;
            agentId: 'memory',';
            agentName: 'Memory Agent',';
            status: 'working',';
            currentTask: 'Storing conversation',';
            progress: 30;
            timestamp: new Date();
            metadata: {;
              participatingIn: orchestrationRequestrequestId}});
          ;
          // Store user request;
          await memorySystemstoreMemory(;
            reqaiServiceId || 'system',';
            'conversation',';
            `User: ${datauserRequest}`;
            {;
              conversationId: dataconversationId;
              sessionId: datasessionId;
              requestId: orchestrationRequestrequestId;
              timestamp: orchestrationRequesttimestamp;
              type: 'user_message',';
            };
            [] // Keywords will be extracted automatically;
          );
          // Store agent response;
          const responseContent = typeof responseresult === 'string' ';
            ? responseresult ;
            : JSONstringify(responseresult);
          ;
          await memorySystemstoreMemory(;
            reqaiServiceId || 'system',';
            'conversation',';
            `Assistant: ${responseContent}`;
            {;
              conversationId: dataconversationId;
              sessionId: datasessionId;
              requestId: orchestrationRequestrequestId;
              timestamp: new Date();
              type: 'assistant_message',';
              confidence: responseconfidence;
              participatingAgents: responseparticipatingAgents;
              orchestrationMode: responsemode};
            [] // Keywords will be extracted automatically;
          );
          loggerinfo('Conversation stored in memory system', {';
            conversationId: dataconversationId;
            requestId: orchestrationRequestrequestId});
          ;
          // Complete memory agent task;
          agentCollaborationWScompleteAgentTask('memory', {';
            stored: true;
            conversationId: dataconversationId});
        } catch (memoryError) {;
          // Log error but don't fail the request';
          loggererror('Failed to store conversation in: memory:', memoryError);';
          ;
          // Update memory agent status to error;
          const { agentCollaborationWS } = await import('../services/agent-collaboration-websocket');';
          agentCollaborationWSupdateAgentStatus({;
            agentId: 'memory',';
            agentName: 'Memory Agent',';
            status: 'error',';
            currentTask: 'Failed to store conversation',';
            timestamp: new Date()});
        };
      };

      resjson({;
        success: responsesuccess;
        requestId: responserequestId;
        data: responseresult;
        mode: responsemode;
        confidence: responseconfidence;
        reasoning: responsereasoning;
        participatingAgents: responseparticipatingAgents;
        executionTime: responseexecutionTime});
    } catch (error) {;
      loggererror('Orchestration: error)', error);';
      if (error instanceof zZodError) {;
        resstatus(400)json({;
          success: false;
          error) 'Invalid request format',';
          details: errorerrors});
      } else {;
        resstatus(500)json({;
          success: false;
          error) 'Orchestration failed',';
          message: error instanceof Error ? errormessage : 'Unknown error'';
        });
      };
    };
  });
  /**;
   * Agent coordination endpoint;
   */;
  routerpost('/coordinate', async (req: any, res) => {';
    try {;
      const data = coordinationRequestSchemaparse(reqbody);
      const result = await dspyServicecoordinateAgents(;
        datatask;
        dataavailableAgents;
        datacontext || {};
      );
      resjson({;
        success: true;
        ..result});
    } catch (error) {;
      loggererror('Coordination: error)', error);';
      if (error instanceof zZodError) {;
        resstatus(400)json({;
          success: false;
          error) 'Invalid request format',';
          details: errorerrors});
      } else {;
        resstatus(500)json({;
          success: false;
          error) 'Coordination failed',';
          message: error instanceof Error ? errormessage : 'Unknown error'';
        });
      };
    };
  });
  /**;
   * Knowledge search endpoint;
   */;
  routerpost('/knowledge/search', async (req: any, res) => {';
    try {;
      const data = knowledgeSearchSchemaparse(reqbody);
      const result = await dspyServicesearchKnowledge(dataquery, {;
        filters: datafilters;
        limit: datalimit});
      resjson({;
        success: true;
        ..result});
    } catch (error) {;
      loggererror('Knowledge search: error)', error);';
      if (error instanceof zZodError) {;
        resstatus(400)json({;
          success: false;
          error) 'Invalid request format',';
          details: errorerrors});
      } else {;
        resstatus(500)json({;
          success: false;
          error) 'Knowledge search failed',';
          message: error instanceof Error ? errormessage : 'Unknown error'';
        });
      };
    };
  });
  /**;
   * Knowledge extraction endpoint;
   */;
  routerpost('/knowledge/extract', async (req: any, res) => {';
    try {;
      const data = knowledgeExtractSchemaparse(reqbody);
      const result = await dspyServiceextractKnowledge(datacontent: datacontext || {});
      resjson({;
        success: true;
        ..result});
    } catch (error) {;
      loggererror('Knowledge extraction: error)', error);';
      if (error instanceof zZodError) {;
        resstatus(400)json({;
          success: false;
          error) 'Invalid request format',';
          details: errorerrors});
      } else {;
        resstatus(500)json({;
          success: false;
          error) 'Knowledge extraction failed',';
          message: error instanceof Error ? errormessage : 'Unknown error'';
        });
      };
    };
  });
  /**;
   * Knowledge evolution endpoint;
   */;
  routerpost('/knowledge/evolve', async (req: any, res) => {';
    try {;
      const data = knowledgeEvolveSchemaparse(reqbody);
      const result = await dspyServiceevolveKnowledge(dataexistingKnowledge, datanewInformation);
      resjson({;
        success: true;
        ..result});
    } catch (error) {;
      loggererror('Knowledge evolution: error)', error);';
      if (error instanceof zZodError) {;
        resstatus(400)json({;
          success: false;
          error) 'Invalid request format',';
          details: errorerrors});
      } else {;
        resstatus(500)json({;
          success: false;
          error) 'Knowledge evolution failed',';
          message: error instanceof Error ? errormessage : 'Unknown error'';
        });
      };
    };
  });
  /**;
   * Prompt optimization endpoint;
   */;
  routerpost('/optimize/prompts', async (req: any, res) => {';
    try {;
      const data = promptOptimizationSchemaparse(reqbody);
      const result = await dspyServiceoptimizePrompts(dataexamples);
      resjson({;
        success: true;
        ..result});
    } catch (error) {;
      loggererror('Prompt optimization: error)', error);';
      if (error instanceof zZodError) {;
        resstatus(400)json({;
          success: false;
          error) 'Invalid request format',';
          details: errorerrors});
      } else {;
        resstatus(500)json({;
          success: false;
          error) 'Prompt optimization failed',';
          message: error instanceof Error ? errormessage : 'Unknown error'';
        });
      };
    };
  });
  /**;
   * Service status endpoint;
   */;
  routerget('/status', async (req: any, res) => {';
    try {;
      const status = dspyServicegetStatus();
      resjson({;
        success: true;
        service: 'dspy-orchestration',';
        ..status;
        timestamp: new Date()toISOString()});
    } catch (error) {;
      loggererror('Status check: error)', error);';
      resstatus(500)json({;
        success: false;
        error) 'Failed to get service status',';
      });
    };
  });
  return router;
};
