import type { Request, RequestHandler, Response } from 'express';
import { Router } from 'express';
import bcrypt from 'bcryptjs';
import rateLimit from 'express-rate-limit';
import { body, validationResult } from 'express-validator';
import { createClient } from '@supabase/supabase-js';
import { JWTAuthService } from '../middleware/auth-jwt';
import type { AuthRequest } from '../middleware/auth';
import { logger } from '../utils/logger';
import { config } from '../config';
import { securityConfig } from '../config/security';
export class AuthRouter {;
  private router: Router;
  private supabase;
  private jwtService: JWTAuthService;
  constructor() {;
    thisrouter = Router();
    thissupabase = createClient(configsupabaseurl, configsupabaseserviceKey);
    thisjwtService = new JWTAuthService(thissupabase);
    thissetupRoutes();
    thissetupRateLimiting();
  };

  private setupRateLimiting() {;
    // Rate limiting for authentication endpoints;
    const authLimiter = rateLimit({;
      windowMs: 15 * 60 * 1000, // 15 minutes;
      max: 5, // 5 attempts per window;
      message: {;
        error instanceof Error ? errormessage : String(error) 'Too many authentication attempts';
        message: 'Please try again later';
        retryAfter: 15 * 60, // 15 minutes in seconds;
      };
      standardHeaders: true;
      legacyHeaders: false;
      keyGenerator: (req) => {;
        // Rate limit by IP and email if provided;
        const email = reqbody?email || '';
        return `${reqip}-${email}`;
      };
      skip: (req) => {;
        // Skip rate limiting for whitelisted IPs;
        return securityConfigrateLimitingwhitelistincludes(reqip || '');
      };
    });
    const registerLimiter = rateLimit({;
      windowMs: 60 * 60 * 1000, // 1 hour;
      max: 3, // 3 registrations per hour per IP;
      message: {;
        error instanceof Error ? errormessage : String(error) 'Too many registration attempts';
        message: 'Please try again later';
        retryAfter: 60 * 60, // 1 hour in seconds;
      };
      standardHeaders: true;
      legacyHeaders: false;
    });
    const refreshLimiter = rateLimit({;
      windowMs: 5 * 60 * 1000, // 5 minutes;
      max: 10, // 10 refresh attempts per 5 minutes;
      message: {;
        error instanceof Error ? errormessage : String(error) 'Too many token refresh attempts';
        message: 'Please try again later';
        retryAfter: 5 * 60, // 5 minutes in seconds;
      };
      standardHeaders: true;
      legacyHeaders: false;
    });
    // Apply rate limiting to specific routes;
    thisrouteruse('/login', authLimiter);
    thisrouteruse('/register', registerLimiter);
    thisrouteruse('/refresh', refreshLimiter);
  };

  private setupRoutes() {;
    // Input validation middleware;
    const validateRegistration = [;
      body('email')isEmail()normalizeEmail()withMessage('Valid email is required');
      body('password');
        isLength({ min: 8 });
        matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/);
        withMessage(;
          'Password must be at least 8 characters with uppercase, lowercase, number, and special character';
        );
      body('firstName');
        isLength({ min: 1, max: 50 });
        trim();
        escape();
        withMessage('First name is required (max 50 characters)');
      body('lastName');
        isLength({ min: 1, max: 50 });
        trim();
        escape();
        withMessage('Last name is required (max 50 characters)');
    ];
    const validateLogin = [;
      body('email')isEmail()normalizeEmail()withMessage('Valid email is required');
      body('password')isLength({ min: 1 })withMessage('Password is required');
    ];
    const validateRefresh = [;
      body('refreshToken')isLength({ min: 1 })withMessage('Refresh token is required');
    ];
    // Routes;
    thisrouterpost('/register', validateRegistration, thisregisterbind(this));
    thisrouterpost('/login', validateLogin, thisloginbind(this));
    thisrouterpost('/refresh', validateRefresh, thisrefreshbind(this));
    thisrouterpost(;
      '/logout';
      thisjwtServiceauthenticate() as RequestHandler;
      thislogoutbind(this) as RequestHandler;
    );
    thisrouterpost(;
      '/logout-all';
      thisjwtServiceauthenticate() as RequestHandler;
      thislogoutAllbind(this) as RequestHandler;
    );
    thisrouterget(;
      '/sessions';
      thisjwtServiceauthenticate() as RequestHandler;
      thisgetSessionsbind(this) as RequestHandler;
    );
    thisrouterdelete(;
      '/sessions/: tokenId';
      thisjwtServiceauthenticate() as RequestHandler;
      thisrevokeSessionbind(this) as RequestHandler;
    );
    thisrouterget(;
      '/security-info';
      thisjwtServiceauthenticate() as RequestHandler;
      thisgetSecurityInfobind(this) as RequestHandler;
    );
    thisrouterpost(;
      '/change-password';
      thisjwtServiceauthenticate() as RequestHandler;
      thischangePasswordbind(this) as RequestHandler;
    );
    thisrouterget(;
      '/profile';
      thisjwtServiceauthenticate() as RequestHandler;
      thisgetProfilebind(this) as RequestHandler;
    );
  ;
};

  /**;
   * User registration;
   */;
  private async register(req: Request, res: Response) {;
    try {;
      // Check for validation errors;
      const errors = validationResult(req);
      if (!errorsisEmpty()) {;
        return resstatus(400)json({;
          error instanceof Error ? errormessage : String(error) 'Validation failed';
          details: errorsarray();
        });
      };

      const { email, password, firstName, lastName } = reqbody;
      // Check rate limiting for this IP;
      const rateLimitCheck = thisjwtServiceisAuthRateLimited(reqip || '');
      if (rateLimitChecklimited) {;
        return resstatus(429)json({;
          error instanceof Error ? errormessage : String(error) 'Too many failed attempts';
          message: 'Please try again later';
          retryAfter: rateLimitCheckretryAfter;
        });
      };

      // Check if user already exists;
      const { data: existingUser } = await thissupabase;
        from('users');
        select('id');
        eq('email', email);
        single();
      if (existingUser) {;
        thisjwtServicerecordAuthAttempt(reqip || '', false);
        return resstatus(409)json({;
          error instanceof Error ? errormessage : String(error) 'User already exists';
          message: 'An account with this email already exists';
        });
      };

      // Hash password;
      const hashedPassword = await bcrypthash(password, 12);
      // Create user;
      const { data: user, error } = await thissupabase;
        from('users');
        insert({;
          email;
          password_hash: hashedPassword;
          first_name: firstName;
          last_name: lastName;
          role: 'user';
          is_active: true;
          email_verified: false;
          created_at: new Date();
        });
        select('id, email, role');
        single();
      if (error || !user) {;
        loggererror('User registration failed:', error);
        thisjwtServicerecordAuthAttempt(reqip || '', false);
        return resstatus(500)json({;
          error instanceof Error ? errormessage : String(error) 'Registration failed';
          message: 'Unable to create user account';
        });
      };

      // Generate token pair;
      const tokens = await thisjwtServicegenerateTokenPair(userid, useremail, userrole, req);
      thisjwtServicerecordAuthAttempt(reqip || '', true);
      // Set secure cookie for refresh token in production;
      if (configserverisProduction) {;
        rescookie('refreshToken', tokensrefreshToken, {;
          httpOnly: true;
          secure: true;
          sameSite: 'strict';
          maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days;
        });
      };

      resstatus(201)json({;
        message: 'User registered successfully';
        user: {;
          id: userid;
          email: useremail;
          role: userrole;
        ;
};
        accessToken: tokensaccessToken;
        refreshToken: configserverisProduction ? undefined : tokensrefreshToken;
        expiresIn: tokensexpiresIn;
      });
    } catch (error) {;
      loggererror('Registration error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Internal server error';
        message: 'Registration failed due to server error';
      });
    };
  };

  /**;
   * User login;
   */;
  private async login(req: Request, res: Response) {;
    try {;
      // Check for validation errors;
      const errors = validationResult(req);
      if (!errorsisEmpty()) {;
        return resstatus(400)json({;
          error instanceof Error ? errormessage : String(error) 'Validation failed';
          details: errorsarray();
        });
      };

      const { email, password } = reqbody;
      // Check rate limiting for this IP;
      const rateLimitCheck = thisjwtServiceisAuthRateLimited(reqip || '');
      if (rateLimitChecklimited) {;
        return resstatus(429)json({;
          error instanceof Error ? errormessage : String(error) 'Too many failed attempts';
          message: 'Please try again later';
          retryAfter: rateLimitCheckretryAfter;
        });
      };

      // Get user;
      const { data: user, error } = await thissupabase;
        from('users');
        select('id, email, password_hash, role, is_active');
        eq('email', email);
        single();
      if (error || !user) {;
        thisjwtServicerecordAuthAttempt(reqip || '', false);
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Invalid credentials';
          message: 'Email or password is incorrect';
        });
      };

      if (!useris_active) {;
        thisjwtServicerecordAuthAttempt(reqip || '', false);
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Account disabled';
          message: 'Your account has been disabled';
        });
      };

      // Verify password;
      const passwordValid = await bcryptcompare(password, userpassword_hash);
      if (!passwordValid) {;
        thisjwtServicerecordAuthAttempt(reqip || '', false);
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Invalid credentials';
          message: 'Email or password is incorrect';
        });
      };

      // Generate token pair;
      const tokens = await thisjwtServicegenerateTokenPair(userid, useremail, userrole, req);
      thisjwtServicerecordAuthAttempt(reqip || '', true);
      // Update last login;
      await thissupabasefrom('users')update({ last_login: new Date() })eq('id', userid);
      // Set secure cookie for refresh token in production;
      if (configserverisProduction) {;
        rescookie('refreshToken', tokensrefreshToken, {;
          httpOnly: true;
          secure: true;
          sameSite: 'strict';
          maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days;
        });
      };

      resjson({;
        message: 'Login successful';
        user: {;
          id: userid;
          email: useremail;
          role: userrole;
        ;
};
        accessToken: tokensaccessToken;
        refreshToken: configserverisProduction ? undefined : tokensrefreshToken;
        expiresIn: tokensexpiresIn;
      });
    } catch (error) {;
      loggererror('Login error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Internal server error';
        message: 'Login failed due to server error';
      });
    };
  };

  /**;
   * Refresh access token;
   */;
  private async refresh(req: Request, res: Response) {;
    try {;
      // Check for validation errors;
      const errors = validationResult(req);
      if (!errorsisEmpty()) {;
        return resstatus(400)json({;
          error instanceof Error ? errormessage : String(error) 'Validation failed';
          details: errorsarray();
        });
      };

      const refreshToken = reqbodyrefreshToken || reqcookies?refreshToken;
      if (!refreshToken) {;
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Refresh token required';
          message: 'No refresh token provided';
        });
      };

      // Refresh tokens;
      const newTokens = await thisjwtServicerefreshAccessToken(refreshToken, req);
      if (!newTokens) {;
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Invalid refresh token';
          message: 'The refresh token is invalid or expired';
        });
      };

      // Set new secure cookie for refresh token in production;
      if (configserverisProduction) {;
        rescookie('refreshToken', newTokensrefreshToken, {;
          httpOnly: true;
          secure: true;
          sameSite: 'strict';
          maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days;
        });
      };

      resjson({;
        message: 'Token refreshed successfully';
        accessToken: newTokensaccessToken;
        refreshToken: configserverisProduction ? undefined : newTokensrefreshToken;
        expiresIn: newTokensexpiresIn;
      });
    } catch (error) {;
      loggererror('Token refresh error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Internal server error';
        message: 'Token refresh failed due to server error';
      });
    };
  };

  /**;
   * Logout (revoke current session);
   */;
  private async logout(req: AuthRequest, res: Response) {;
    try {;
      const authHeader = reqheadersauthorization;
      if (authHeader && authHeaderstartsWith('Bearer ')) {;
        const token = authHeadersubstring(7);
        const payload = thisjwtServiceverifyAccessToken(token);
        if (payload && payloadjti) {;
          await thisjwtServicerevokeRefreshToken(requser!id, payloadjti);
        };
      };

      // Clear cookie in production;
      if (configserverisProduction) {;
        resclearCookie('refreshToken');
      };

      resjson({;
        message: 'Logout successful';
      });
    } catch (error) {;
      loggererror('Logout error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Internal server error';
        message: 'Logout failed due to server error';
      });
    };
  };

  /**;
   * Logout from all devices;
   */;
  private async logoutAll(req: AuthRequest, res: Response) {;
    try {;
      await thisjwtServicerevokeAllUserTokens(requser!id);
      // Clear cookie in production;
      if (configserverisProduction) {;
        resclearCookie('refreshToken');
      ;
};

      resjson({;
        message: 'Logged out from all devices successfully';
      });
    } catch (error) {;
      loggererror('Logout all error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Internal server error';
        message: 'Logout failed due to server error';
      });
    };
  };

  /**;
   * Get user sessions;
   */;
  private async getSessions(req: AuthRequest, res: Response) {;
    try {;
      const sessions = await thisjwtServicegetUserSessions(requser!id);
      resjson({;
        sessions: sessionsmap((session) => ({;
          id: sessiontokenId;
          createdAt: sessioncreatedAt;
          expiresAt: sessionexpiresAt;
          userAgent: sessionuserAgent;
          ipAddress: sessionipAddress;
          isCurrent: false, // You could implement current session detection;
        }));
      });
    } catch (error) {;
      loggererror('Get sessions error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Internal server error';
        message: 'Failed to retrieve sessions';
      });
    };
  };

  /**;
   * Revoke specific session;
   */;
  private async revokeSession(req: AuthRequest, res: Response) {;
    try {;
      const { tokenId } = reqparams;
      const success = await thisjwtServicerevokeSession(requser!id, tokenId);
      if (success) {;
        resjson({;
          message: 'Session revoked successfully';
        });
      } else {;
        resstatus(404)json({;
          error instanceof Error ? errormessage : String(error) 'Session not found';
          message: 'The specified session could not be found';
        });
      };
    } catch (error) {;
      loggererror('Revoke session error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Internal server error';
        message: 'Failed to revoke session';
      });
    };
  };

  /**;
   * Get security information;
   */;
  private async getSecurityInfo(req: AuthRequest, res: Response) {;
    try {;
      const securityInfo = await thisjwtServicegetUserSecurityInfo(requser!id);
      resjson({;
        activeSessions: securityInfosessionslength;
        recentActivity: securityInforecentActivity;
        failedAttempts24h: securityInfofailedAttempts;
        accountStatus: 'active', // You could implement account status logic;
      });
    } catch (error) {;
      loggererror('Get security info error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Internal server error';
        message: 'Failed to retrieve security information';
      });
    };
  };

  /**;
   * Change password;
   */;
  private async changePassword(req: Request, res: Response) {;
    try {;
      const errors = validationResult(req);
      if (!errorsisEmpty()) {;
        return resstatus(400)json({;
          error instanceof Error ? errormessage : String(error) 'Validation failed';
          details: errorsarray();
        });
      };

      const { currentPassword, newPassword } = reqbody;
      const user = (req as AuthRequest)user!;
      // Get current password hash;
      const { data: userData, error } = await thissupabase;
        from('users');
        select('password_hash');
        eq('id', userid);
        single();
      if (error || !userData) {;
        return resstatus(404)json({;
          error instanceof Error ? errormessage : String(error) 'User not found';
          message: 'User account not found';
        });
      };

      // Verify current password;
      const passwordValid = await bcryptcompare(currentPassword, userDatapassword_hash);
      if (!passwordValid) {;
        return resstatus(401)json({;
          error instanceof Error ? errormessage : String(error) 'Invalid password';
          message: 'Current password is incorrect';
        });
      };

      // Hash new password;
      const hashedPassword = await bcrypthash(newPassword, 12);
      // Update password;
      const { error instanceof Error ? errormessage : String(error) updateError } = await thissupabase;
        from('users');
        update({ password_hash: hashedPassword });
        eq('id', userid);
      if (updateError) {;
        loggererror('Password update failed:', updateError);
        return resstatus(500)json({;
          error instanceof Error ? errormessage : String(error) 'Password update failed';
          message: 'Unable to update password';
        });
      };

      // Revoke all existing sessions for security;
      await thisjwtServicerevokeAllUserTokens(userid);
      resjson({;
        message: 'Password changed successfully';
        note: 'All sessions have been logged out for security';
      });
    } catch (error) {;
      loggererror('Change password error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Internal server error';
        message: 'Password change failed due to server error';
      });
    };
  };

  /**;
   * Get user profile;
   */;
  private async getProfile(req: AuthRequest, res: Response) {;
    try {;
      const { data: user, error } = await thissupabase;
        from('users');
        select('id, email, first_name, last_name, role, created_at, last_login, is_active');
        eq('id', requser!id);
        single();
      if (error || !user) {;
        return resstatus(404)json({;
          error instanceof Error ? errormessage : String(error) 'User not found';
          message: 'User profile not found';
        });
      };

      resjson({;
        user: {;
          id: userid;
          email: useremail;
          firstName: userfirst_name;
          lastName: userlast_name;
          role: userrole;
          createdAt: usercreated_at;
          lastLogin: userlast_login;
          isActive: useris_active;
        ;
};
      });
    } catch (error) {;
      loggererror('Get profile error instanceof Error ? errormessage : String(error)', error);
      resstatus(500)json({;
        error instanceof Error ? errormessage : String(error) 'Internal server error';
        message: 'Failed to retrieve user profile';
      });
    };
  };

  public getRouter(): Router {;
    return thisrouter;
  };
};

export default AuthRouter;