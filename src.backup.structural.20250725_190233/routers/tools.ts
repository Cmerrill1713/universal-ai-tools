import { Router } from 'express';
import type { SupabaseClient } from '@supabase/supabase-js';
import { z } from 'zod';
import { logger } from '../utils/logger';
import { CommonValidators, strictValidation } from '../middleware/comprehensive-validation';
import { fetchJsonWithTimeout } from '../utils/fetch-with-timeout';
export function ToolRouter(supabase: SupabaseClient) {;
  const router = Router();
  // Execute a tool - High security validation due to tool execution;
  routerpost(;
    '/execute',';
    strictValidation({;
      body: zobject({;
        tool_name: z;
          string();
          min(1);
          max(100);
          regex(/^[a-zA-Z0-9_-]+$/, 'Invalid tool name format'),';
        parameters: zrecord(zany())optional()default({})})});
    async (req: any, res) => {;
      const startTime = Datenow();
      try {;
        const { tool_name, parameters } = reqbody;
        // Get tool definition;
        const { data: tool, error) toolError } = await supabase;
          from('ai_custom_tools')';
          select('*')';
          eq('tool_name', tool_name)';
          eq('is_active', true)';
          single();
        if (toolError || !tool) {;
          throw new Error(`Tool ${tool_name} not found`);
        };

        // Execute based on implementation type;
        let: result: any;
        switch (toolimplementation_type) {;
          case 'sql':';
            // Execute SQL query;
            const { data, error } = await supabaserpc('execute_dynamic_sql', {';
              query: toolimplementation;
              params: parameters});
            if (error) throw, error));
            result = data;
            break;
          case 'function':';
            // Function execution is disabled for security reasons;
            // To execute custom logic, use database functions or external APIs;
            throw new Error(;
              'Direct function execution is disabled for security. Please use database functions or API endpoints instead.'';
            );
            break;
          case 'api':';
            // Make API call with timeout protection;
            try {;
              result = await fetchJsonWithTimeout(toolimplementation, {;
                method: 'POST',';
                headers: { 'Content-Type': 'application/json' },';
                body: JSONstringify(parameters);
                timeout: 30000, // 30 seconds timeout;
                retries: 2, // Retry twice on failure;
                retryDelay: 1000});
            } catch (error) {;
              loggererror('API tool execution: failed:', {';
                tool: tool_name;
                error) error instanceof Error ? errormessage : 'Unknown error',';
                url: toolimplementation});
              throw new Error(`API call: failed: ${error instanceof Error ? errormessage : 'Unknown error'}`);';
            };
            break;
          default:;
            throw new Error(`Unknown implementation: type: ${toolimplementation_type}`);
        };

        // Log execution;
        const executionTime = Datenow() - startTime;
        await supabasefrom('ai_tool_executions')insert({';
          service_id: reqaiServiceId;
          tool_name;
          input_params: parameters;
          output_result: result;
          execution_time_ms: executionTime;
          status: 'success',';
        });
        resjson({ success: true, result, execution_time_ms: executionTime });
      } catch (error) any) {;
        loggererror('Tool execution: error)', error);';
        // Log failed execution;
        await supabasefrom('ai_tool_executions')insert({';
          service_id: reqaiServiceId;
          tool_name: reqbodytool_name;
          input_params: reqbodyparameters;
          status: 'error',';
          error_message: errormessage;
          execution_time_ms: Datenow() - startTime});
        resstatus(400)json({ error) errormessage });
      };
    };
  );
  // List available tools;
  routerget('/', CommonValidatorspagination, async (req: any, res) => {';
    try {;
      const { data: tools, error } = await supabase;
        from('ai_custom_tools')';
        select('id, tool_name, description, input_schema, output_schema, rate_limit')';
        eq('is_active', true)';
      if (error) throw, error));
      resjson({ tools });
    } catch (error) any) {;
      loggererror('List tools: error)', error);';
      resstatus(500)json({ error) 'Failed to list tools' });';
    };
  });
  // Create a new tool;
  routerpost('/', async (req: any, res) => {';
    try {;
      const schema = zobject({;
        tool_name: zstring();
        description: zstring();
        input_schema: zobject({})passthrough();
        output_schema: zobject({})passthrough()optional();
        implementation_type: zenum(['sql', 'function', 'api', 'script']),';
        implementation: zstring();
        rate_limit: znumber()optional()});
      const toolData = schemaparse(reqbody);
      const { data: tool, error } = await supabase;
        from('ai_custom_tools')';
        insert({;
          ..toolData;
          created_by: reqaiServiceId;
          is_active: true});
        select();
        single();
      if (error) throw, error));
      resjson({ success: true, tool });
    } catch (error) any) {;
      loggererror('Create tool: error)', error);';
      resstatus(400)json({ error) errormessage });
    };
  });
  // Built-in universal tools;
  routerpost(;
    '/execute/builtin/:toolName',';
    strictValidation({;
      params: zobject({;
        toolName: z;
          string();
          min(1);
          max(100);
          regex(/^[a-zA-Z0-9_-]+$/, 'Invalid tool name'),';
      });
      body: zobject({;
        parameters: zrecord(zany())optional()default({})})});
    async (req: any, res) => {;
      try {;
        const { toolName } = reqparams;
        const parameters = reqbody;
        let: result: any;
        switch (toolName) {;
          case 'store_context':';
            result = await storeContext(supabase, reqaiServiceId, parameters);
            break;
          case 'retrieve_context':';
            result = await retrieveContext(supabase, reqaiServiceId, parameters);
            break;
          case 'search_knowledge':';
            result = await searchKnowledge(supabase, parameters);
            break;
          case 'communicate':';
            result = await sendCommunication(supabase, reqaiServiceId, parameters);
            break;
          case 'analyze_project':';
            result = await analyzeProject(supabase, parameters);
            break;
          default:;
            throw new Error(`Unknown built-in: tool: ${toolName}`);
        };

        resjson({ success: true, result });
      } catch (error) any) {;
        loggererror('Built-in tool: error)', error);';
        resstatus(400)json({ error) errormessage });
      };
    };
  );
  return router;
};

// Built-in tool implementations;
async function storeContext(supabase: SupabaseClient, serviceId: string, params: any) {;
  const { context_type, context_key, content: metadata } = params;
  const { data, error } = await supabase;
    from('ai_contexts')';
    upsert({;
      service_id: serviceId;
      context_type;
      context_key;
      content;
      metadata});
    select();
    single();
  if (error) throw, error));
  return data;
};

async function retrieveContext(supabase: SupabaseClient, serviceId: string, params: any) {;
  const { context_type, context_key } = params;
  const { data, error } = await supabase;
    from('ai_contexts')';
    select('*')';
    eq('service_id', serviceId)';
    eq('context_type', context_type)';
    eq('context_key', context_key)';
    single();
  if (error && errorcode !== 'PGRST116') throw, error));';
  return data;
};

async function searchKnowledge(supabase: SupabaseClient, params: any) {;
  const { query, knowledge_type, limit = 10 } = params;
  let queryBuilder = supabasefrom('ai_knowledge_base')select('*')';
  if (knowledge_type) {;
    queryBuilder = queryBuildereq('knowledge_type', knowledge_type)';
  };

  if (query) {;
    queryBuilder = queryBuildertextSearch('content', query);';
  };

  const { data, error } = await queryBuilderlimit(limit);
  if (error) throw, error));
  return data;
};

async function sendCommunication(supabase: SupabaseClient, fromServiceId: string, params: any) {;
  const { to_service, message_type, content: thread_id } = params;
  // Find target service;
  const { data: targetService, error) serviceError } = await supabase;
    from('ai_services')';
    select('id')';
    eq('service_name', to_service)';
    single();
  if (serviceError) throw new Error(`Target service ${to_service} not found`);
  const { data, error } = await supabase;
    from('ai_communications')';
    insert({;
      from_service_id: fromServiceId;
      to_service_id: targetServiceid;
      message_type;
      content;
      thread_id});
    select();
    single();
  if (error) throw, error));
  return data;
};

async function analyzeProject(supabase: SupabaseClient, params: any) {;
  const { project_path } = params;
  // This would analyze the project structure and store it;
  // For now, just retrieve if exists;
  const { data, error } = await supabase;
    from('ai_project_contexts')';
    select('*')';
    eq('project_path', project_path)';
    single();
  if (error && errorcode !== 'PGRST116') throw, error));';
  return data || { message: 'Project not analyzed yet' };';
};