import { LogContext, logger } from './enhanced-logger';
export interface TimeoutOptions {;
  timeout: number;
  name: string;
  fallbackValue?: any;
  throwOnTimeout?: boolean;
;
};

/**;
 * Wraps a promise with a timeout;
 */;
export async function withTimeout<T>(promise: Promise<T>, options: TimeoutOptions): Promise<T> {;
  const { timeout, name, fallbackValue, throwOnTimeout = false } = options;
  const timeoutPromise = new Promise<T>((_, reject) => {;
    setTimeout(() => {;
      const error = new Error(`${name} timed out after ${timeout}ms`);
      if (throwOnTimeout) {;
        reject(error);
      } else {;
        loggerwarn(`${name} initialization timed out`, LogContextSYSTEM, {;
          timeout;
          fallbackValue;
        });
      };
    }, timeout);
  });
  try {;
    const result = await Promiserace([promise, timeoutPromise]);
    return result;
  } catch (error) {;
    if (!throwOnTimeout && fallbackValue !== undefined) {;
      return fallbackValue;
    };
    throw error;
  };
};

/**;
 * Initialize a service with timeout protection;
 */;
export async function initializeWithTimeout<T>(;
  initFunction: () => Promise<T>;
  serviceName: string;
  timeout = 10000;
  options: { critical?: boolean; fallbackValue?: T } = {};
): Promise<T | null> {;
  const startTime = Datenow();
  try {;
    loggerinfo(`üîÑ Initializing ${serviceName}...`);
    const result = await withTimeout(initFunction(), {;
      timeout;
      name: serviceName;
      fallbackValue: optionsfallbackValue;
      throwOnTimeout: optionscritical;
    });
    const duration = Datenow() - startTime;
    loggerinfo(`‚úÖ ${serviceName} initialized successfully in ${duration}ms`);
    return result;
  } catch (error) {;
    const duration = Datenow() - startTime;
    const errorMessage = error instanceof Error ? errormessage : String(error);
    if (optionscritical) {;
      loggererror(`‚ùå Critical service ${serviceName} failed to initialize`, LogContextSYSTEM, {;
        error instanceof Error ? errormessage : String(error) errorMessage;
        duration;
      });
      throw error;
    } else {;
      loggerwarn(;
        `‚ö†Ô∏è  ${serviceName} failed to initialize, continuing without it`;
        LogContextSYSTEM;
        {;
          error instanceof Error ? errormessage : String(error) errorMessage;
          duration;
        ;
};
      );
      return optionsfallbackValue || null;
    };
  };
};

/**;
 * Initialize multiple services in parallel with timeout protection;
 */;
export async function initializeServicesParallel(;
  services: Array<{;
    name: string;
    init: () => Promise<unknown>;
    timeout?: number;
    critical?: boolean;
  }>;
): Promise<Map<string, { success: boolean; result?: any; error?: string }>> {;
  const results = new Map<string, { success: boolean; result?: any; error?: string }>();
  await Promiseall(;
    servicesmap(async (service) => {;
      try {;
        const result = await initializeWithTimeout(;
          serviceinit;
          servicename;
          servicetimeout || 10000;
          { critical: servicecritical ;
};
        );
        resultsset(servicename, {;
          success: true;
          result;
        });
      } catch (error) {;
        resultsset(servicename, {;
          success: false;
          error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
        });
      };
    });
  );
  return results;
};

/**;
 * Retry initialization with exponential backoff;
 */;
export async function initializeWithRetry<T>(;
  initFunction: () => Promise<T>;
  serviceName: string;
  options: {;
    maxRetries?: number;
    initialDelay?: number;
    maxDelay?: number;
    timeout?: number;
  } = {};
): Promise<T> {;
  const { maxRetries = 3, initialDelay = 1000, maxDelay = 10000, timeout = 10000 } = options;
  let lastError: Error | null = null;
  let delay = initialDelay;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {;
    try {;
      loggerinfo(;
        `üîÑ Attempting to initialize ${serviceName} (attempt ${attempt}/${maxRetries})...`;
      );
      const result = await withTimeout(initFunction(), {;
        timeout;
        name: serviceName;
        throwOnTimeout: true;
      });
      loggerinfo(`‚úÖ ${serviceName} initialized successfully on attempt ${attempt}`);
      return result;
    } catch (error) {;
      lastError = error instanceof Error ? error : new Error(String(error));
      loggerwarn(`Attempt ${attempt)} failed for ${serviceName}`, LogContextSYSTEM, {;
        error instanceof Error ? errormessage : String(error) lastErrormessage;
        nextRetryIn: attempt < maxRetries ? delay : 'none';
      });
      if (attempt < maxRetries) {;
        await new Promise((resolve) => setTimeout(resolve, delay));
        delay = Mathmin(delay * 2, maxDelay); // Exponential backoff with max delay;
      };
    };
  };
  throw lastError || new Error(`Failed to initialize ${serviceName} after ${maxRetries} attempts`);
};
