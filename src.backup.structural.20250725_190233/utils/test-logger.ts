/* eslint-disable no-undef */;
/**;
 * Test Logging Utility for Universal AI Tools;
 *;
 * Specialized logging for tests with detailed failure analysis;
 * screenshot capture, performance tracking, and Sweet Athena test debugging;
 */;
import { EnhancedLogger, LogContext, logger } from './enhanced-logger';
import * as fs from 'fs/promises';
import * as path from 'path';
export interface TestContext {;
  testName: string;
  testSuite: string;
  testType: 'unit' | 'integration' | 'e2e' | 'performance' | 'visual';
  environment: 'development' | 'testing' | 'staging' | 'production';
  browser?: string;
  viewport?: { width: number; height: number ;
};
  sessionId: string;
;
};

export interface TestResult {;
  testId: string;
  context: TestContext;
  status: 'pass' | 'fail' | 'skip' | 'timeout';
  duration: number;
  startTime: Date;
  endTime: Date;
  error?: Error;
  assertions?: AssertionResult[];
  screenshots?: string[];
  performanceMetrics?: PerformanceMetrics[];
  memoryUsage?: NodeJSMemoryUsage;
  coverage?: CoverageData;
;
};

export interface AssertionResult {;
  description: string;
  status: 'pass' | 'fail';
  expected?: any;
  actual?: any;
  error?: string;
  stackTrace?: string;
;
};

export interface PerformanceMetrics {;
  operation: string;
  duration: number;
  timestamp: Date;
  metadata?: Record<string, unknown>;
};

export interface CoverageData {;
  lines: { total: number; covered: number; percentage: number ;
};
  functions: { total: number; covered: number; percentage: number ;
};
  branches: { total: number; covered: number; percentage: number ;
};
  statements: { total: number; covered: number; percentage: number ;
};
};

export interface SweetAthenaTestData {;
  interactionType: string;
  personalityMood: string;
  sweetnessLevel: number;
  userInput?: string;
  expectedResponse?: string;
  actualResponse?: string;
  avatarState?: any;
  animationMetrics?: PerformanceMetrics[];
;
};

export class TestLogger {;
  private enhancedLogger: EnhancedLogger;
  private testResults: Map<string, TestResult> = new Map();
  private testTimers: Map<string, number> = new Map();
  private screenshotDir: string;
  private logDir: string;
  constructor() {;
    thisenhancedLogger = new EnhancedLogger('test-runner');
    thisscreenshotDir = pathjoin(processcwd(), 'tests', 'screenshots');
    thislogDir = pathjoin(processcwd(), 'logs', 'tests');
    thisensureDirectories();
  };
  private async ensureDirectories() {;
    try {;
      await fsmkdir(thisscreenshotDir, { recursive: true });
      await fsmkdir(thislogDir, { recursive: true });
    } catch (error) {;
      loggererror('Failed to create test directories:', error);
    };
  };

  // Start a test run;
  startTest(context: TestContext): string {;
    const testId = `${contexttestSuite}_${contexttestName}_${Datenow()}`;
    const startTime = new Date();
    thistestTimersset(testId, Datenow());
    const testResult: TestResult = {;
      testId;
      context;
      status: 'pass', // Default to pass, will be updated if it fails;
      duration: 0;
      startTime;
      endTime: startTime, // Will be updated when test ends;
      assertions: [];
      screenshots: [];
      performanceMetrics: [];
      memoryUsage: processmemoryUsage();
    ;
};
    thistestResultsset(testId, testResult);
    loggerinfo(`Test started: ${contexttestName}`, LogContextTEST, {;
      test_id: testId;
      test_context: context;
      memory_at_start: testResultmemoryUsage;
    });
    return testId;
  };

  // End a test run;
  endTest(testId: string, status: 'pass' | 'fail' | 'skip' | 'timeout', error?: Error): TestResult {;
    const testResult = thistestResultsget(testId);
    if (!testResult) {;
      throw new Error(`Test ${testId} not found`);
    };
    const endTime = new Date();
    const startTimestamp = thistestTimersget(testId);
    const duration = startTimestamp ? Datenow() - startTimestamp : 0;
    testResultstatus = status;
    testResultendTime = endTime;
    testResultduration = duration;
    testResulterror = error;
    // Clean up timer;
    thistestTimersdelete(testId);
    // Log test completion;
    const level = status === 'fail' ? 'error' : (status === 'skip' ? 'warn' : 'info');
    const logStatus = status === 'timeout' ? 'fail' : (status as 'pass' | 'fail' | 'skip');
    loggerlogTestResult(testResultcontexttestName, logStatus, duration, {;
      test_id: testId;
      test_context: testResultcontext;
      assertions_count: testResultassertions?length || 0;
      screenshots_count: testResultscreenshots?length || 0;
      performance_metrics_count: testResultperformanceMetrics?length || 0;
      error_message: error?message || 'No error';
      memory_delta: thiscalculateMemoryDelta(testResultmemoryUsage!, processmemoryUsage());
    });
    // Generate test report if it failed;
    if (status === 'fail') {;
      thisgenerateFailureReport(testResult);
    };
    return testResult;
  };

  // Add assertion result;
  addAssertion(testId: string, assertion: AssertionResult) {;
    const testResult = thistestResultsget(testId);
    if (!testResult) {;
      consolewarn(`Test ${testId)} not found for assertion`);
      return;
    };
    testResultassertions = testResultassertions || [];
    testResultassertionspush(assertion);
    if (assertionstatus === 'fail') {;
      testResultstatus = 'fail';
      loggererror(`Assertion failed in ${testResultcontexttestName}`, LogContextTEST, {;
        test_id: testId;
        assertion;
        test_context: testResultcontext;
      });
    } else {;
      loggerdebug(`Assertion passed: ${assertiondescription)}`, LogContextTEST, {;
        test_id: testId;
        assertion_description: assertiondescription;
      });
    };
  };

  // Capture screenshot for visual tests;
  async captureScreenshot(;
    testId: string;
    description: string;
    screenshotData: Buffer | string;
  ): Promise<string> {;
    const testResult = thistestResultsget(testId);
    if (!testResult) {;
      throw new Error(`Test ${testId} not found`);
    };
    const filename = `${testId}_${descriptionreplace(/[^a-zA-Z0-9]/g, '_')}_${Datenow()}png`;
    const filepath = pathjoin(thisscreenshotDir, filename);
    try {;
      if (typeof screenshotData === 'string') {;
        // Base64 data;
        const base64Data = screenshotDatareplace(/^data:image\/\w+;base64,/, '');
        await fswriteFile(filepath, base64Data, 'base64');
      } else {;
        // Buffer data;
        await fswriteFile(filepath, screenshotData);
      };
      testResultscreenshots = testResultscreenshots || [];
      testResultscreenshotspush(filepath);
      loggerinfo(`Screenshot captured for test ${testResultcontexttestName)}`, LogContextTEST, {;
        test_id: testId;
        screenshot_path: filepath;
        description;
      });
      return filepath;
    } catch (error) {;
      loggererror(`Failed to capture screenshot for test ${testId)}`, LogContextTEST, {;
        test_id: testId;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
        description;
      });
      throw error;
    };
  };

  // Add performance metric;
  addPerformanceMetric(testId: string, metric: PerformanceMetrics) {;
    const testResult = thistestResultsget(testId);
    if (!testResult) {;
      consolewarn(`Test ${testId)} not found for performance metric`);
      return;
    };
    testResultperformanceMetrics = testResultperformanceMetrics || [];
    testResultperformanceMetricspush(metric);
    loggerdebug(;
      `Performance metric recorded for ${testResultcontexttestName}`;
      LogContextPERFORMANCE;
      {;
        test_id: testId;
        metric;
        test_context: testResultcontext;
      ;
};
    );
  };

  // Sweet Athena specific test logging;
  logAthenaTestInteraction(testId: string, athenaData: SweetAthenaTestData) {;
    const testResult = thistestResultsget(testId);
    if (!testResult) {;
      consolewarn(`Test ${testId)} not found for Athena interaction`);
      return;
    };
    loggerinfo(;
      `Sweet Athena test interaction in ${testResultcontexttestName}`;
      LogContextATHENA;
      {;
        test_id: testId;
        athena_data: athenaData;
        test_context: testResultcontext;
      ;
};
    );
    // Add animation performance metrics if available;
    if (athenaDataanimationMetrics) {;
      athenaDataanimationMetricsforEach((metric) => {;
        thisaddPerformanceMetric(testId, metric);
      });
    };
  };

  // Log test environment setup;
  logTestEnvironmentSetup(environment: Record<string, unknown>) {;
    loggerinfo('Test environment setup', LogContextTEST, {;
      environment;
      node_version: processversion;
      platform: processplatform;
      arch: processarch;
      memory_total: `${Mathround(processmemoryUsage()heapTotal / 1024 / 1024)}MB`;
    });
  };

  // Log test suite start;
  logTestSuiteStart(suiteName: string, testCount: number) {;
    loggerinfo(`Test suite started: ${suiteName)}`, LogContextTEST, {;
      suite_name: suiteName;
      test_count: testCount;
      timestamp: new Date()toISOString();
    });
  };

  // Log test suite completion;
  logTestSuiteComplete(;
    suiteName: string;
    results: { passed: number; failed: number; skipped: number; total: number ;
};
  ) {;
    const success = resultsfailed === 0;
    const level = success ? 'info' : 'error';
    const logMessage = `Test suite completed: ${suiteName}`;
    const logMeta = {;
      context: LogContextTEST;
      suite_name: suiteName;
      results;
      success_rate: `${((resultspassed / resultstotal) * 100)toFixed(2)}%`;
      timestamp: new Date()toISOString();
    ;
};
    if (level === 'error') {;
      loggererror(logMessage, LogContextTEST, logMeta);
    } else {;
      loggerinfo(logMessage, LogContextTEST, logMeta);
    };
  };

  // Generate detailed failure report;
  private async generateFailureReport(testResult: TestResult) {;
    const reportData = {;
      test_id: testResulttestId;
      test_name: testResultcontexttestName;
      test_suite: testResultcontexttestSuite;
      test_type: testResultcontexttestType;
      environment: testResultcontextenvironment;
      status: testResultstatus;
      duration: testResultduration;
      error instanceof Error ? errormessage : String(error) testResulterror;
        ? {;
            message: testResulterrormessage;
            stack: testResulterrorstack;
            name: testResulterrorname;
          };
        : null;
      assertions: testResultassertions;
      screenshots: testResultscreenshots;
      performance_metrics: testResultperformanceMetrics;
      memory_usage: testResultmemoryUsage;
      timestamp: testResultendTimetoISOString();
    ;
};
    const filename = `failure_report_${testResulttestId}json`;
    const filepath = pathjoin(thislogDir, filename);
    try {;
      await fswriteFile(filepath, JSONstringify(reportData, null, 2));
      loggerinfo(`Failure report generated for ${testResultcontexttestName)}`, LogContextTEST, {;
        test_id: testResulttestId;
        report_path: filepath;
      });
    } catch (error) {;
      loggererror(`Failed to generate failure report for ${testResulttestId)}`, LogContextTEST, {;
        test_id: testResulttestId;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error);
      });
    };
  };

  // Get all test results;
  getAllTestResults(): TestResult[] {;
    return Arrayfrom(thistestResultsvalues());
  };

  // Get test results by status;
  getTestResultsByStatus(status: 'pass' | 'fail' | 'skip' | 'timeout'): TestResult[] {;
    return thisgetAllTestResults()filter((result) => resultstatus === status);
  };

  // Calculate memory delta;
  private calculateMemoryDelta(initial: NodeJSMemoryUsage, final: NodeJSMemoryUsage) {;
    return {;
      heapUsed: finalheapUsed - initialheapUsed;
      heapTotal: finalheapTotal - initialheapTotal;
      external: finalexternal - initialexternal;
      rss: finalrss - initialrss;
    ;
};
  };

  // Generate test summary report;
  async generateSummaryReport(): Promise<string> {;
    const allResults = thisgetAllTestResults();
    const summary = {;
      total: allResultslength;
      passed: allResultsfilter((r) => rstatus === 'pass')length;
      failed: allResultsfilter((r) => rstatus === 'fail')length;
      skipped: allResultsfilter((r) => rstatus === 'skip')length;
      timeout: allResultsfilter((r) => rstatus === 'timeout')length;
      average_duration: allResultsreduce((sum, r) => sum + rduration, 0) / allResultslength;
      success_rate:;
        (allResultsfilter((r) => rstatus === 'pass')length / allResultslength) * 100;
    };
    const reportData = {;
      summary;
      timestamp: new Date()toISOString();
      detailed_results: allResults;
    };
    const filename = `test_summary_${Datenow()}json`;
    const filepath = pathjoin(thislogDir, filename);
    await fswriteFile(filepath, JSONstringify(reportData, null, 2));
    loggerinfo('Test summary report generated', LogContextTEST, {;
      summary;
      report_path: filepath;
    });
    return filepath;
  };

  // Cleanup resources;
  async cleanup() {;
    thistestResultsclear();
    thistestTimersclear();
    await thisenhancedLoggershutdown();
  };
};

// Create singleton instance for tests;
export const testLogger = new TestLogger();
// Convenience functions for easy test integration;
export const startTest = (context: TestContext) => testLoggerstartTest(context);
export const endTest = (;
  testId: string;
  status: 'pass' | 'fail' | 'skip' | 'timeout';
  error?: Error;
) => testLoggerendTest(testId, status, error);
export const addAssertion = (testId: string, assertion: AssertionResult) =>;
  testLoggeraddAssertion(testId, assertion);
export const captureScreenshot = (;
  testId: string;
  description: string;
  screenshotData: Buffer | string;
) => testLoggercaptureScreenshot(testId, description, screenshotData);
export const addPerformanceMetric = (testId: string, metric: PerformanceMetrics) =>;
  testLoggeraddPerformanceMetric(testId, metric);
export const logAthenaTestInteraction = (testId: string, athenaData: SweetAthenaTestData) =>;
  testLoggerlogAthenaTestInteraction(testId, athenaData);
export default testLogger;