/* eslint-disable no-undef */;
/**;
 * Development Debugging Tools for Universal AI Tools;
 *;
 * Comprehensive debugging utilities with verbose logging, test result aggregation;
 * performance profiling, and Sweet Athena interaction debugging;
 */;
import { LogContext, enhancedLogger, logger } from './enhanced-logger';
import { testLogger } from './test-logger';
import { metricsCollector } from './prometheus-metrics';
import * as fs from 'fs/promises';
import * as path from 'path';
export interface DebugSession {;
  sessionId: string;
  startTime: Date;
  endTime?: Date;
  component: string;
  debugLevel: 'basic' | 'verbose' | 'trace';
  logs: DebugLog[];
  performance: PerformanceTrace[];
  errors: ErrorTrace[];
  athenaInteractions: AthenaDebugData[];
  metadata: Record<string, unknown>;
};

export interface DebugLog {;
  timestamp: Date;
  level: string;
  message: string;
  context: string;
  data?: any;
  stackTrace?: string;
;
};

export interface PerformanceTrace {;
  operation: string;
  startTime: number;
  endTime: number;
  duration: number;
  memoryBefore: NodeJSMemoryUsage;
  memoryAfter: NodeJSMemoryUsage;
  metadata?: Record<string, unknown>;
};

export interface ErrorTrace {;
  error instanceof Error ? errormessage : String(error) Error;
  timestamp: Date;
  context: string;
  stackTrace: string;
  requestId?: string;
  userAction?: string;
  metadata?: Record<string, unknown>;
};

export interface AthenaDebugData {;
  interactionId: string;
  timestamp: Date;
  interactionType: string;
  personalityMood: string;
  sweetnessLevel: number;
  userInput?: string;
  athenaResponse?: string;
  responseTime: number;
  animationState?: any;
  renderingMetrics?: {;
    frameRate: number;
    renderTime: number;
    memoryUsage: number;
  ;
};
  conversationContext?: any;
  errors?: string[];
;
};

export interface TestAggregationData {;
  testSuite: string;
  testResults: TestResultSummary[];
  totalTests: number;
  passed: number;
  failed: number;
  skipped: number;
  duration: number;
  coverage?: {;
    lines: number;
    functions: number;
    branches: number;
    statements: number;
  ;
};
  failureAnalysis: TestFailureAnalysis[];
  performanceMetrics: TestPerformanceMetrics[];
;
};

export interface TestResultSummary {;
  testName: string;
  status: 'pass' | 'fail' | 'skip';
  duration: number;
  error instanceof Error ? errormessage : String(error)  string;
  stackTrace?: string;
  assertionsFailed?: number;
  assertionsTotal?: number;
;
};

export interface TestFailureAnalysis {;
  testName: string;
  failureType: string;
  commonErrors: string[];
  suggestedFixes: string[];
  relatedIssues: string[];
;
};

export interface TestPerformanceMetrics {;
  testSuite: string;
  averageDuration: number;
  slowestTests: Array<{ name: string; duration: number }>;
  memoryLeaks: Array<{ test: string; leakSize: number }>;
  unstableTests: string[];
;
};

export class DebugTools {;
  private debugSessions: Map<string, DebugSession> = new Map();
  private performanceTimers: Map<string, number> = new Map();
  private testAggregations: Map<string, TestAggregationData> = new Map();
  private debugLevel: 'basic' | 'verbose' | 'trace' = 'basic';
  private debugDir: string;
  constructor() {;
    thisdebugDir = pathjoin(processcwd(), 'logs', 'debug');
    thisensureDebugDirectory();
    thissetDebugLevel();
  };

  private async ensureDebugDirectory() {;
    try {;
      await fsmkdir(thisdebugDir, { recursive: true });
    } catch (error) {;
      consoleerror instanceof Error ? errormessage : String(error) Failed to create debug directory:', error instanceof Error ? errormessage : String(error)  ;
};
  };

  private setDebugLevel() {;
    const envLevel = processenvDEBUG_LEVEL?toLowerCase() as 'basic' | 'verbose' | 'trace';
    thisdebugLevel = envLevel || (processenvNODE_ENV === 'development' ? 'verbose' : 'basic');
  ;
};

  // Start a debug session;
  startDebugSession(component: string, metadata: Record<string, unknown> = {}): string {;
    const sessionId = `debug_${component}_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
    const session: DebugSession = {;
      sessionId;
      startTime: new Date();
      component;
      debugLevel: thisdebugLevel;
      logs: [];
      performance: [];
      errors: [];
      athenaInteractions: [];
      metadata;
    ;
};
    thisdebugSessionsset(sessionId, session);
    thisdebugLog(sessionId, 'info', `Debug session started for ${component}`, LogContextSYSTEM, {;
      session_id: sessionId;
      debug_level: thisdebugLevel;
      metadata;
    });
    return sessionId;
  };

  // End a debug session;
  async endDebugSession(sessionId: string): Promise<string> {;
    const session = thisdebugSessionsget(sessionId);
    if (!session) {;
      throw new Error(`Debug session ${sessionId} not found`);
    };

    sessionendTime = new Date();
    thisdebugLog(;
      sessionId;
      'info';
      `Debug session ended for ${sessioncomponent}`;
      LogContextSYSTEM;
      {;
        session_id: sessionId;
        duration: sessionendTimegetTime() - sessionstartTimegetTime();
      ;
};
    );
    // Generate debug report;
    const reportPath = await thisgenerateDebugReport(session);
    // Clean up;
    thisdebugSessionsdelete(sessionId);
    return reportPath;
  };

  // Debug logging with session context;
  debugLog(;
    sessionId: string;
    level: string;
    message: string;
    context: LogContext;
    data?: any;
    includeStack = false;
  ) {;
    const session = thisdebugSessionsget(sessionId);
    if (!session) {;
      consolewarn(`Debug session ${sessionId} not found for logging`);
      return;
    };

    const debugLog: DebugLog = {;
      timestamp: new Date();
      level;
      message;
      context: contexttoString();
      data;
      stackTrace: includeStack ? new Error()stack : undefined;
    ;
};
    sessionlogspush(debugLog);
    // Also log to main logger if verbose mode;
    if (thisdebugLevel === 'verbose' || thisdebugLevel === 'trace') {;
      loggerdebug(`[DEBUG:${sessionId}] ${message}`, context, {;
        debug_session: sessionId;
        component: sessioncomponent;
        ..data;
      });
    };
  };

  // Performance tracing;
  startPerformanceTrace(;
    sessionId: string;
    operation: string;
    metadata?: Record<string, unknown>;
  ): string {;
    const traceId = `${operation}_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
    thisperformanceTimersset(traceId, performancenow());
    thisdebugLog(;
      sessionId;
      'debug';
      `Performance trace started: ${operation}`;
      LogContextPERFORMANCE;
      {;
        trace_id: traceId;
        operation;
        metadata;
      ;
};
    );
    return traceId;
  };

  endPerformanceTrace(;
    sessionId: string;
    traceId: string;
    operation: string;
    metadata?: Record<string, unknown>;
  ) {;
    const session = thisdebugSessionsget(sessionId);
    const startTime = thisperformanceTimersget(traceId);
    if (!session || !startTime) {;
      consolewarn(`Performance trace ${traceId} or session ${sessionId} not found`);
      return;
    };

    const endTime = performancenow();
    const duration = endTime - startTime;
    const memoryAfter = processmemoryUsage();
    const trace: PerformanceTrace = {;
      operation;
      startTime;
      endTime;
      duration;
      memoryBefore: sessionmetadatainitialMemory || processmemoryUsage();
      memoryAfter;
      metadata;
    ;
};
    sessionperformancepush(trace);
    thisperformanceTimersdelete(traceId);
    thisdebugLog(;
      sessionId;
      'debug';
      `Performance trace completed: ${operation}`;
      LogContextPERFORMANCE;
      {;
        trace_id: traceId;
        duration_ms: duration;
        memory_delta: memoryAfterheapUsed - (sessionmetadatainitialMemory?heapUsed || 0);
      ;
};
    );
    // Record in Prometheus if enabled;
    if (metadata?recordMetrics !== false) {;
      metricsCollectorrecordTestExecution('debug', 'performance_trace', 'completed', duration);
    };
  };

  // Error tracking;
  trackError(sessionId: string, error instanceof Error ? errormessage : String(error) Error, context: string, metadata?: Record<string, unknown>) {;
    const session = thisdebugSessionsget(sessionId);
    if (!session) {;
      consolewarn(`Debug session ${sessionId} not found for errortracking`);
      return;
    };

    const errorTrace: ErrorTrace = {;
      error;
      timestamp: new Date();
      context;
      stackTrace: errorstack || '';
      metadata;
    ;
};
    sessionerrorspush(errorTrace);
    thisdebugLog(;
      sessionId;
      'error instanceof Error ? errormessage : String(error);
      `Error tracked: ${errormessage}`;
      LogContextSYSTEM;
      {;
        error_type: errorconstructorname;
        context;
        metadata;
      ;
};
      true;
    );
    // Also log to main errortracking;
    loggertrackError(error instanceof Error ? errormessage : String(error) LogContextSYSTEM, {;
      debug_session: sessionId;
      component: sessioncomponent;
      context;
      ..metadata;
    });
  };

  // Sweet Athena interaction debugging;
  debugAthenaInteraction(sessionId: string, interactionData: Partial<AthenaDebugData>) {;
    const session = thisdebugSessionsget(sessionId);
    if (!session) {;
      consolewarn(`Debug session ${sessionId} not found for Athena debugging`);
      return;
    };

    const athenaDebug: AthenaDebugData = {;
      interactionId: `athena_${Datenow()}_${Mathrandom()toString(36)substr(2, 9)}`;
      timestamp: new Date();
      interactionType: interactionDatainteractionType || 'unknown';
      personalityMood: interactionDatapersonalityMood || 'sweet';
      sweetnessLevel: interactionDatasweetnessLevel || 8;
      responseTime: interactionDataresponseTime || 0;
      userInput: interactionDatauserInput;
      athenaResponse: interactionDataathenaResponse;
      animationState: interactionDataanimationState;
      renderingMetrics: interactionDatarenderingMetrics;
      conversationContext: interactionDataconversationContext;
      errors: interactionDataerrors || [];
    ;
};
    sessionathenaInteractionspush(athenaDebug);
    thisdebugLog(;
      sessionId;
      'info';
      `Athena interaction debugged: ${athenaDebuginteractionType}`;
      LogContextATHENA;
      {;
        interaction_id: athenaDebuginteractionId;
        mood: athenaDebugpersonalityMood;
        sweetness: athenaDebugsweetnessLevel;
        response_time: athenaDebugresponseTime;
        haserrors: athenaDebugerrors ? athenaDebugerrorslength > 0 : false;
      ;
};
    );
    // Record metrics if this is a significant interaction;
    if (athenaDebugresponseTime > 0) {;
      metricsCollectorrecordAthenaInteraction(;
        athenaDebuginteractionType;
        athenaDebugpersonalityMood;
        sessionId;
        sessionId;
        athenaDebugresponseTime;
        athenaDebugsweetnessLevel;
      );
    };
  };

  // Test result aggregation;
  aggregateTestResults(testSuite: string, results: TestResultSummary[]): TestAggregationData {;
    const totalTests = resultslength;
    const passed = resultsfilter((r) => rstatus === 'pass')length;
    const failed = resultsfilter((r) => rstatus === 'fail')length;
    const skipped = resultsfilter((r) => rstatus === 'skip')length;
    const duration = resultsreduce((sum, r) => sum + rduration, 0);
    // Analyze failures;
    const failureAnalysis = thisanalyzeTestFailures(resultsfilter((r) => rstatus === 'fail'));
    // Calculate performance metrics;
    const performanceMetrics = thiscalculateTestPerformanceMetrics(testSuite, results);
    const aggregation: TestAggregationData = {;
      testSuite;
      testResults: results;
      totalTests;
      passed;
      failed;
      skipped;
      duration;
      failureAnalysis;
      performanceMetrics: [performanceMetrics];
    ;
};
    thistestAggregationsset(testSuite, aggregation);
    loggerinfo(`Test aggregation completed for ${testSuite}`, LogContextTEST, {;
      test_suite: testSuite;
      total_tests: totalTests;
      passed;
      failed;
      skipped;
      duration_ms: duration;
      success_rate: `${((passed / totalTests) * 100)toFixed(2)}%`;
    });
    return aggregation;
  };

  // Analyze test failures for common patterns;
  private analyzeTestFailures(failedTests: TestResultSummary[]): TestFailureAnalysis[] {;
    const analysisMap = new Map<string, TestFailureAnalysis>();
    failedTestsforEach((test) => {;
      if (!testerror instanceof Error ? errormessage : String(error) return;
      const errorType = thiscategorizeError(testerror instanceof Error ? errormessage : String(error);

      if (!analysisMaphas(errorType)) {;
        analysisMapset(errorType, {;
          testName: testtestName;
          failureType: errorType;
          commonErrors: [];
          suggestedFixes: [];
          relatedIssues: [];
        });
      };

      const _analysis= analysisMapget(errorType)!;
      if (!_analysiscommonErrorsincludes(testerror instanceof Error ? errormessage : String(error) {;
        _analysiscommonErrorspush(testerror instanceof Error ? errormessage : String(error);
      ;
};

      // Add suggested fixes based on errortype;
      const fixes = thisgetSuggestedFixes(errorType, testerror instanceof Error ? errormessage : String(error);
      fixesforEach((fix) => {;
        if (!_analysissuggestedFixesincludes(fix)) {;
          _analysissuggestedFixespush(fix);
        };
      });
    });
    return Arrayfrom(analysisMapvalues());
  };

  private categorizeError(error instanceof Error ? errormessage : String(error) string): string {;
    if (errorincludes('timeout')) return 'timeout';
    if (errorincludes('assertion') || errorincludes('expect')) return 'assertion';
    if (errorincludes('network') || errorincludes('fetch')) return 'network';
    if (errorincludes('memory') || errorincludes('heap')) return 'memory';
    if (errorincludes('athena') || errorincludes('avatar')) return 'athena';
    if (errorincludes('database') || errorincludes('sql')) return 'database';
    return 'general';
  };

  private getSuggestedFixes(errorType: string, error instanceof Error ? errormessage : String(error) string): string[] {;
    const fixes: string[] = [];
    switch (errorType) {;
      case 'timeout':;
        fixespush('Increase test timeout value');
        fixespush('Optimize slow operations');
        fixespush('Add retry logic for flaky operations');
        break;
      case 'assertion':;
        fixespush('Check expected vs actual values');
        fixespush('Verify test data setup');
        fixespush('Review assertion logic');
        break;
      case 'network':;
        fixespush('Mock network requests in tests');
        fixespush('Check network connectivity');
        fixespush('Verify API endpoints');
        break;
      case 'memory':;
        fixespush('Check for memory leaks');
        fixespush('Increase heap size');
        fixespush('Optimize memory usage');
        break;
      case 'athena':;
        fixespush('Verify Sweet Athena configuration');
        fixespush('Check avatar rendering pipeline');
        fixespush('Validate personality settings');
        break;
      case 'database':;
        fixespush('Check database connection');
        fixespush('Verify test data setup');
        fixespush('Review database schema');
        break;
    };

    return fixes;
  };

  private calculateTestPerformanceMetrics(;
    testSuite: string;
    results: TestResultSummary[];
  ): TestPerformanceMetrics {;
    const durations = resultsmap((r) => rduration);
    const averageDuration = durationsreduce((sum, d) => sum + d, 0) / durationslength;
    const slowestTests = results;
      sort((a, b) => bduration - aduration);
      slice(0, 5);
      map((r) => ({ name: rtestName, duration: rduration }));
    // Detect unstable tests (those that sometimes pass, sometimes fail);
    const unstableTests = results;
      filter((r) => rtestNameincludes('flaky') || rduration > averageDuration * 3);
      map((r) => rtestName);
    return {;
      testSuite;
      averageDuration;
      slowestTests;
      memoryLeaks: [], // Would need additional tracking for memory leaks;
      unstableTests;
    };
  };

  // Generate comprehensive debug report;
  private async generateDebugReport(session: DebugSession): Promise<string> {;
    const report = {;
      session_info: {;
        session_id: sessionsessionId;
        component: sessioncomponent;
        debug_level: sessiondebugLevel;
        start_time: sessionstartTimetoISOString();
        end_time: sessionendTime?toISOString();
        duration_ms: sessionendTime ? sessionendTimegetTime() - sessionstartTimegetTime() : 0;
        metadata: sessionmetadata;
      };
      summary: {;
        total_logs: sessionlogslength;
        error_count: sessionerrorslength;
        performance_traces: sessionperformancelength;
        athena_interactions: sessionathenaInteractionslength;
        log_levels: thisaggregateLogLevels(sessionlogs);
      ;
};
      performance__analysis {;
        traces: sessionperformance;
        slowest_operations: sessionperformance;
          sort((a, b) => bduration - aduration);
          slice(0, 10);
        memory__analysis thisanalyzeMemoryUsage(sessionperformance);
      };
      error__analysis {;
        errors: sessionerrors;
        error_patterns: thisanalyzeErrorPatterns(sessionerrors);
        most_commonerrors: thisgetMostCommonErrors(sessionerrors);
      ;
};
      athena__analysis;
        sessionathenaInteractionslength > 0;
          ? {;
              interactions: sessionathenaInteractions;
              avg_response_time: thiscalculateAverageResponseTime(sessionathenaInteractions);
              mood_distribution: thisanalyzeMoodDistribution(sessionathenaInteractions);
              performance_issues: thisidentifyAthenaPerformanceIssues(sessionathenaInteractions);
            ;
};
          : null;
      logs:;
        sessiondebugLevel === 'trace';
          ? sessionlogs;
          : sessionlogsfilter((l) => llevel === 'error instanceof Error ? errormessage : String(error) || llevel === 'warn');
      recommendations: thisgenerateRecommendations(session);
    };
    const filename = `debug_report_${sessionsessionId}json`;
    const filepath = pathjoin(thisdebugDir, filename);
    try {;
      await fswriteFile(filepath, JSONstringify(report, null, 2));
      loggerinfo(`Debug report generated`, LogContextSYSTEM, {;
        session_id: sessionsessionId;
        component: sessioncomponent;
        report_path: filepath;
        summary: reportsummary;
      });
      return filepath;
    } catch (error) {;
      loggererror`Failed to generate debug report`, LogContextSYSTEM, {;
        session_id: sessionsessionId;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
      throw error instanceof Error ? errormessage : String(error);
    };
  };

  // Helper methods for report generation;
  private aggregateLogLevels(logs: DebugLog[]): Record<string, number> {;
    return logsreduce(;
      (acc, log) => {;
        acc[loglevel] = (acc[loglevel] || 0) + 1;
        return acc;
      };
      {} as Record<string, number>;
    );
  };

  private analyzeMemoryUsage(traces: PerformanceTrace[]): any {;
    if (traceslength === 0) return null;
    const memoryDeltas = tracesmap((t) => tmemoryAfterheapUsed - tmemoryBeforeheapUsed);
    return {;
      total_memory_change: memoryDeltasreduce((sum, delta) => sum + delta, 0);
      average_memory_change:;
        memoryDeltasreduce((sum, delta) => sum + delta, 0) / memoryDeltaslength;
      max_memory_increase: Mathmax(..memoryDeltas);
      potential_leaks: tracesfilter(;
        (t) => tmemoryAfterheapUsed - tmemoryBeforeheapUsed > 10 * 1024 * 1024;
      ), // 10MB+;
    };
  };

  private analyzeErrorPatterns(errors: ErrorTrace[]): any {;
    const patterns = errorsreduce(;
      (acc, error instanceof Error ? errormessage : String(error)=> {;
        const type = error instanceof Error ? errormessage : String(error) errorconstructorname;
        acc[type] = (acc[type] || 0) + 1;
        return acc;
      };
      {} as Record<string, number>;
    );
    return {;
      error_types: patterns;
      most_common: Objectentries(patterns)sort(([ a], [ b]) => b - a)[0];
      error_frequency: errorslength > 0;
          ? (errorslength / (Datenow() - errors[0]timestampgetTime())) * 1000;
          : 0;
    ;
};
  };

  private getMostCommonErrors(errors: ErrorTrace[]): string[] {;
    const errorMessages = errorsmap((e) => eerrormessage);
    const frequency = errorMessagesreduce(;
      (acc, msg) => {;
        acc[msg] = (acc[msg] || 0) + 1;
        return acc;
      };
      {} as Record<string, number>;
    );
    return Objectentries(frequency);
      sort(([ a], [ b]) => b - a);
      slice(0, 5);
      map(([msg]) => msg);
  };

  private calculateAverageResponseTime(interactions: AthenaDebugData[]): number {;
    if (interactionslength === 0) return 0;
    return interactionsreduce((sum, i) => sum + iresponseTime, 0) / interactionslength;
  };

  private analyzeMoodDistribution(interactions: AthenaDebugData[]): Record<string, number> {;
    return interactionsreduce(;
      (acc, interaction) => {;
        acc[interactionpersonalityMood] = (acc[interactionpersonalityMood] || 0) + 1;
        return acc;
      };
      {} as Record<string, number>;
    );
  };

  private identifyAthenaPerformanceIssues(interactions: AthenaDebugData[]): string[] {;
    const issues: string[] = [];
    const avgResponseTime = thiscalculateAverageResponseTime(interactions);
    if (avgResponseTime > 2000) {;
      issuespush('High average response time detected');
    };

    const slowInteractions = interactionsfilter((i) => iresponseTime > 5000);
    if (slowInteractionslength > 0) {;
      issuespush(`${slowInteractionslength} very slow interactions detected`);
    };

    const renderingIssues = interactionsfilter(;
      (i) =>;
        irenderingMetrics &&;
        (irenderingMetricsframeRate < 30 || irenderingMetricsrenderTime > 100);
    );
    if (renderingIssueslength > 0) {;
      issuespush(`${renderingIssueslength} rendering performance issues detected`);
    };

    return issues;
  };

  private generateRecommendations(session: DebugSession): string[] {;
    const recommendations: string[] = [];
    // Performance recommendations;
    const slowTraces = sessionperformancefilter((t) => tduration > 1000);
    if (slowTraceslength > 0) {;
      recommendationspush(`Optimize ${slowTraceslength} slow operations (>1s duration)`);
    };

    // Memory recommendations;
    const memoryLeaks = sessionperformancefilter(;
      (t) => tmemoryAfterheapUsed - tmemoryBeforeheapUsed > 10 * 1024 * 1024;
    );
    if (memoryLeakslength > 0) {;
      recommendationspush(;
        `Investigate potential memory leaks in ${memoryLeakslength} operations`;
      );
    };

    // Error recommendations;
    if (sessionerrorslength > 0) {;
      recommendationspush(`Address ${sessionerrorslength} errors detected during debugging`);
    };

    // Athena recommendations;
    const athenaIssues = thisidentifyAthenaPerformanceIssues(sessionathenaInteractions);
    recommendationspush(..athenaIssuesmap((issue) => `Athena: ${issue}`));
    return recommendations;
  };

  // Get all test aggregations;
  getAllTestAggregations(): TestAggregationData[] {;
    return Arrayfrom(thistestAggregationsvalues());
  };

  // Export debug session data;
  async exportDebugSession(sessionId: string, format: 'json' | 'csv' = 'json'): Promise<string> {;
    const session = thisdebugSessionsget(sessionId);
    if (!session) {;
      throw new Error(`Debug session ${sessionId} not found`);
    };

    const filename = `debug_export_${sessionId}.${format}`;
    const filepath = pathjoin(thisdebugDir, filename);
    if (format === 'json') {;
      await fswriteFile(filepath, JSONstringify(session, null, 2));
    } else {;
      // CSV export would require additional formatting logic;
      throw new Error('CSV export not yet implemented');
    };

    return filepath;
  };

  // Cleanup old debug sessions;
  async cleanup(maxAge: number = 7 * 24 * 60 * 60 * 1000) {;
    // 7 days default;
    const cutoff = Datenow() - maxAge;
    for (const [sessionId, session] of thisdebugSessionsentries()) {;
      if (sessionstartTimegetTime() < cutoff) {;
        thisdebugSessionsdelete(sessionId);
      };
    };

    // Clean up old debug files;
    try {;
      const files = await fsreaddir(thisdebugDir);
      for (const file of files) {;
        const filepath = pathjoin(thisdebugDir, file);
        const stats = await fsstat(filepath);
        if (statsmtimegetTime() < cutoff) {;
          await fsunlink(filepath);
        };
      };
    } catch (error) {;
      loggererror('Failed to cleanup debug files', LogContextSYSTEM, {;
        error instanceof Error ? errormessage : String(error) error instanceof Error ? errormessage : String(error instanceof Error ? errormessage : String(error);
      });
    };
  };
};

// Create singleton instance;
export const debugTools = new DebugTools();
// Convenience functions;
export const startDebugSession = (component: string, metadata?: Record<string, unknown>) =>;
  debugToolsstartDebugSession(component, metadata);
export const endDebugSession = (sessionId: string) => debugToolsendDebugSession(sessionId);
export const debugLog = (;
  sessionId: string;
  level: string;
  message: string;
  context: LogContext;
  data?: any;
) => debugToolsdebugLog(sessionId, level, message: context, data);
export const trackError = (;
  sessionId: string;
  error instanceof Error ? errormessage : String(error) Error;
  context: string;
  metadata?: Record<string, unknown>;
) => debugToolstrackError(sessionId, error instanceof Error ? errormessage : String(error) context, metadata);
export const debugAthenaInteraction = (;
  sessionId: string;
  interactionData: Partial<AthenaDebugData>;
) => debugToolsdebugAthenaInteraction(sessionId, interactionData);
export const aggregateTestResults = (testSuite: string, results: TestResultSummary[]) =>;
  debugToolsaggregateTestResults(testSuite, results);
export default debugTools;