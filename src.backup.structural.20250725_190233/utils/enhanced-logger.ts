/**;
 * Enhanced Logging System for Universal AI Tools;
 * ;
 * Comprehensive logging infrastructure with structured logging, error tracking;
 * performance metrics, and specialized logging for Sweet Athena interactions;
 */;
import winston from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';
import { Performance } from 'perf_hooks';
import os from 'os';
// Define log levels and contexts;
export enum LogLevel {;
  ERROR = 'error';
  WARN = 'warn';
  INFO = 'info';
  HTTP = 'http';
  DEBUG = 'debug';
  VERBOSE = 'verbose';
};

export enum LogContext {;
  SYSTEM = 'system';
  API = 'api';
  HTTP = 'http';
  GRAPHQL = 'graphql';
  ATHENA = 'athena';
  CONVERSATION = 'conversation';
  AVATAR = 'avatar';
  MEMORY = 'memory';
  DSPY = 'dspy';
  DATABASE = 'database';
  PERFORMANCE = 'performance';
  SECURITY = 'security';
  ERROR = 'error';
  TEST = 'test';
  CACHE = 'cache';
};

// Performance metrics interface;
export interface PerformanceMetrics {;
  operation: string;
  duration: number;
  memory_used: number;
  cpu_usage?: number;
  context: LogContext;
  metadata?: Record<string, any>;
};

// Error tracking interface;
export interface ErrorTracking {;
  error_id: string;
  error_type: string;
  message: string;
  stack?: string;
  user_id?: string;
  session_id?: string;
  context: LogContext;
  metadata?: Record<string, any>;
};

// Sweet Athena specific logging interface;
export interface AthenaInteraction {;
  interaction_id: string;
  interaction_type: 'conversation' | 'avatar_animation' | 'mood_change' | 'teach_me' | 'memory_access';
  userinput?: string;
  athena_response?: string;
  personality_mood: string;
  sweetness_level: number;
  performance_metrics?: PerformanceMetrics;
  user_satisfaction?: number;
  session_id: string;
  timestamp: Date;
;
};

// Custom log formats;
const createCustomFormat = (service: string) => {;
  return winstonformatcombine(;
    winstonformattimestamp();
    winstonformaterrors({ stack: true });
    winstonformatsplat();
    winstonformatprintf(({ timestamp, level, message: context, ..meta }: any) => {;
      const metaString = Objectkeys(meta)length ? JSONstringify(meta, null, 2) : '';
      return `${timestamp} [${service}] ${leveltoUpperCase()} [${context || 'SYSTEM'}]: ${message} ${metaString}`;
    });
  );
};
const createJSONFormat = (service: string) => {;
  return winstonformatcombine(;
    winstonformattimestamp();
    winstonformaterrors({ stack: true });
    winstonformatjson();
    winstonformatprintf((info: any) => {;
      return JSONstringify({;
        timestamp: infotimestamp;
        service;
        level: infolevel;
        context: infocontext || 'SYSTEM';
        message: infomessage;
        ..info;
      });
    });
  );
};
// Enhanced Logger Class;
export class EnhancedLogger {;
  private logger: winstonLogger;
  private performanceTimers: Map<string, number> = new Map();
  private errorCounts: Map<string, number> = new Map();
  private service: string;
  constructor(service = 'universal-ai-tools') {;
    thisservice = service;
    // Create transports based on environment;
    const transports: winstontransport[] = [;
      // Console transport with colored output for development;
      new winstontransportsConsole({;
        level: processenvNODE_ENV === 'production' ? 'info' : 'debug';
        format: processenvNODE_ENV === 'production' ;
          ? createJSONFormat(service);
          : winstonformatcombine(;
              winstonformatcolorize();
              createCustomFormat(service);
            );
      });
      // Daily rotating file for all logs;
      new DailyRotateFile({;
        filename: `logs/${service}-%DATE%log`;
        datePattern: 'YYYY-MM-DD';
        maxSize: '20m';
        maxFiles: '14d';
        level: 'debug';
        format: createJSONFormat(service);
      });
      // Separate error log file;
      new DailyRotateFile({;
        filename: `logs/${service}-error-%DATE%log`;
        datePattern: 'YYYY-MM-DD';
        maxSize: '20m';
        maxFiles: '30d';
        level: 'error';
        format: createJSONFormat(service);
      });
      // Performance logs;
      new DailyRotateFile({;
        filename: `logs/${service}-performance-%DATE%log`;
        datePattern: 'YYYY-MM-DD';
        maxSize: '20m';
        maxFiles: '7d';
        level: 'info';
        format: createJSONFormat(service);
        // Only log performance-related entries;
        // Note: Using custom format to filter performance logs;
      });
    ];
    // Add Athena-specific logs in development;
    if (processenvNODE_ENV !== 'production') {;
      transportspush(;
        new DailyRotateFile({;
          filename: `logs/sweet-athena-%DATE%log`;
          datePattern: 'YYYY-MM-DD';
          maxSize: '10m';
          maxFiles: '7d';
          level: 'debug';
          format: createJSONFormat('sweet-athena');
          // Note: Using custom format to filter Athena logs;
        });
      );
    };

    thislogger = winstoncreateLogger({;
      level: processenvLOG_LEVEL || 'info';
      defaultMeta: { ;
        service;
        pid: processpid;
        hostname: oshostname();
        node_version: processversion;
      ;
};
      transports;
      exitOnError: false;
    });
    // Handle uncaught exceptions and unhandled rejections;
    thisloggerexceptionshandle(;
      new DailyRotateFile({;
        filename: `logs/${service}-exceptions-%DATE%log`;
        datePattern: 'YYYY-MM-DD';
        maxSize: '10m';
        maxFiles: '30d';
      });
    );
    thisloggerrejectionshandle(;
      new DailyRotateFile({;
        filename: `logs/${service}-rejections-%DATE%log`;
        datePattern: 'YYYY-MM-DD';
        maxSize: '10m';
        maxFiles: '30d';
      });
    );
  };

  // Core logging methods;
  error(message: string, context: LogContext = LogContextSYSTEM, meta?: any) {;
    thisincrementErrorCount(context);
    thisloggererror(message, { context, ..meta });
  };

  warn(message: string, context: LogContext = LogContextSYSTEM, meta?: any) {;
    thisloggerwarn(message, { context, ..meta });
  };

  info(message: string, context: LogContext = LogContextSYSTEM, meta?: any) {;
    thisloggerinfo(message, { context, ..meta });
  };

  debug(message: string, context: LogContext = LogContextSYSTEM, meta?: any) {;
    thisloggerdebug(message, { context, ..meta });
  };

  verbose(message: string, context: LogContext = LogContextSYSTEM, meta?: any) {;
    thisloggerverbose(message, { context, ..meta });
  };

  // Performance monitoring methods;
  startTimer(operation: string): string {;
    const timerId = `${operation}_${Datenow()}_${Mathrandom()}`;
    thisperformanceTimersset(timerId, performancenow());
    return timerId;
  };

  endTimer(timerId: string, operation: string, context: LogContext = LogContextPERFORMANCE, metadata?: Record<string, any>): PerformanceMetrics {;
    const startTime = thisperformanceTimersget(timerId);
    if (!startTime) {;
      thiswarn(`Timer ${timerId} not found for operation ${operation}`, LogContextPERFORMANCE);
      return {;
        operation;
        duration: -1;
        memory_used: processmemoryUsage()heapUsed;
        context;
        metadata;
      ;
};
    };

    const duration = performancenow() - startTime;
    const memoryUsage = processmemoryUsage();
    const metrics: PerformanceMetrics = {;
      operation;
      duration;
      memory_used: memoryUsageheapUsed;
      context;
      metadata;
    ;
};
    thisperformanceTimersdelete(timerId);
    // Log performance metrics;
    thisinfo(`Performance: ${operation} completed in ${durationtoFixed(2)}ms`, LogContextPERFORMANCE, {;
      metrics;
      memory_mb: (memoryUsageheapUsed / 1024 / 1024)toFixed(2);
      memory_total_mb: (memoryUsageheapTotal / 1024 / 1024)toFixed(2);
    });
    return metrics;
  };

  // Error tracking with aggregation;
  trackError(error instanceof Error ? errormessage : String(error) Error | string, context: LogContext, metadata?: Record<string, any>): ErrorTracking {;
    const errorId = `${context}_${Datenow()}_${Mathrandom()}`;
    const errorType = error instanceof Error ? errorconstructorname : 'StringError';
    const message = error instanceof Error ? errormessage : error;
    const stack = error instanceof Error ? errorstack : undefined;
    const tracking: ErrorTracking = {;
      error_id: errorId;
      error_type: errorType;
      message;
      stack;
      context;
      metadata: {;
        ..metadata;
        timestamp: new Date()toISOString();
        environment: processenvNODE_ENV || 'development';
      ;
};
    };
    thiserror(`Error tracked: ${message}`, context, {;
      error_tracking: tracking;
      stack;
    });
    return tracking;
  };

  // Sweet Athena specific logging;
  logAthenaInteraction(interaction: AthenaInteraction) {;
    thisinfo(`Sweet Athena Interaction: ${interactioninteraction_type}`, LogContextATHENA, {;
      athena_interaction: interaction;
      performance_ms: interactionperformance_metrics?duration;
      mood: interactionpersonality_mood;
      sweetness: interactionsweetness_level;
    });
  };

  logConversationTurn(userInput: string, athenaResponse: string, sessionId: string, metadata?: Record<string, any>) {;
    const interactionId = `conv_${sessionId}_${Datenow()}`;
    thisinfo('Conversation turn completed', LogContextCONVERSATION, {;
      interaction_id: interactionId;
      session_id: sessionId;
      userinput_length: userInputlength;
      athena_response_length: athenaResponselength;
      timestamp: new Date()toISOString();
      ..metadata;
    });
    // In development, log full conversation for debugging;
    if (processenvNODE_ENV !== 'production') {;
      thisdebug('Full conversation turn', LogContextCONVERSATION, {;
        interaction_id: interactionId;
        userinput: userInput;
        athena_response: athenaResponse;
        session_id: sessionId;
      });
    };
  };

  // API request/response logging;
  logAPIRequest(method: string, url: string, statusCode: number, duration: number, metadata?: Record<string, any>) {;
    const level = statusCode >= 400 ? 'error' : statusCode >= 300 ? 'warn' : 'info';
    thisloggerlog(level, `API ${method} ${url} - ${statusCode}`, {;
      context: LogContextAPI;
      method;
      url;
      status_code: statusCode;
      duration_ms: duration;
      ..metadata;
    });
  };

  // Memory system logging;
  logMemoryOperation(operation: string, details: Record<string, any>) {;
    thisinfo(`Memory operation: ${operation}`, LogContextMEMORY, {;
      operation;
      ..details;
    });
  };

  // Database operation logging;
  logDatabaseOperation(operation: string, table: string, duration: number, details?: Record<string, any>) {;
    thisinfo(`Database: ${operation} on ${table}`, LogContextDATABASE, {;
      operation;
      table;
      duration_ms: duration;
      ..details;
    });
  };

  // Security event logging;
  logSecurityEvent(event: string, severity: 'low' | 'medium' | 'high' | 'critical', details: Record<string, any>) {;
    const level = severity === 'critical' ? 'error' : severity === 'high' ? 'warn' : 'info';
    thisloggerlog(level, `Security Event: ${event}`, {;
      context: LogContextSECURITY;
      event;
      severity;
      timestamp: new Date()toISOString();
      ..details;
    });
  };

  // Test logging for debugging test failures;
  logTestResult(testName: string, status: 'pass' | 'fail' | 'skip', duration: number, details?: Record<string, any>) {;
    const level = status === 'fail' ? 'error' : 'info';
    thisloggerlog(level, `Test: ${testName} - ${status}`, {;
      context: LogContextTEST;
      test_name: testName;
      status;
      duration_ms: duration;
      ..details;
    });
  };

  // Get error statistics;
  getErrorCounts(): Record<string, number> {;
    return ObjectfromEntries(thiserrorCounts);
  };

  // Helper method to increment error counts;
  private incrementErrorCount(context: LogContext) {;
    const key = contexttoString();
    thiserrorCountsset(key, (thiserrorCountsget(key) || 0) + 1);
  };

  // Get current performance timers (for debugging);
  getActiveTimers(): string[] {;
    return Arrayfrom(thisperformanceTimerskeys());
  };

  // Graceful shutdown;
  async shutdown(): Promise<void> {;
    return new Promise((resolve) => {;
      thisloggeron('finish', resolve);
      thisloggerend();
    });
  };
};

// Create singleton instance;
export const enhancedLogger = new EnhancedLogger();
// Export convenience methods;
export const logger = {;
  error instanceof Error ? errormessage : String(error) (message: string, context?: LogContext, meta?: any) => enhancedLoggererror(message: context, meta);
  warn: (message: string, context?: LogContext, meta?: any) => enhancedLoggerwarn(message: context, meta);
  info: (message: string, context?: LogContext, meta?: any) => enhancedLoggerinfo(message: context, meta);
  debug: (message: string, context?: LogContext, meta?: any) => enhancedLoggerdebug(message: context, meta);
  verbose: (message: string, context?: LogContext, meta?: any) => enhancedLoggerverbose(message: context, meta);
  // Performance methods;
  startTimer: (operation: string) => enhancedLoggerstartTimer(operation);
  endTimer: (timerId: string, operation: string, context?: LogContext, metadata?: Record<string, any>) => ;
    enhancedLoggerendTimer(timerId, operation, context, metadata);
  // Specialized logging;
  trackError: (error instanceof Error ? errormessage : String(error) Error | string, context: LogContext, metadata?: Record<string, any>) => ;
    enhancedLoggertrackError(error instanceof Error ? errormessage : String(error) context, metadata);
  logAthenaInteraction: (interaction: AthenaInteraction) => enhancedLoggerlogAthenaInteraction(interaction);
  logConversationTurn: (userInput: string, athenaResponse: string, sessionId: string, metadata?: Record<string, any>) =>;
    enhancedLoggerlogConversationTurn(userInput, athenaResponse, sessionId, metadata);
  logAPIRequest: (method: string, url: string, statusCode: number, duration: number, metadata?: Record<string, any>) =>;
    enhancedLoggerlogAPIRequest(method, url, statusCode, duration, metadata);
  logMemoryOperation: (operation: string, details: Record<string, any>) =>;
    enhancedLoggerlogMemoryOperation(operation, details);
  logDatabaseOperation: (operation: string, table: string, duration: number, details?: Record<string, any>) =>;
    enhancedLoggerlogDatabaseOperation(operation, table, duration, details);
  logSecurityEvent: (event: string, severity: 'low' | 'medium' | 'high' | 'critical', details: Record<string, any>) =>;
    enhancedLoggerlogSecurityEvent(event, severity, details);
  logTestResult: (testName: string, status: 'pass' | 'fail' | 'skip', duration: number, details?: Record<string, any>) =>;
    enhancedLoggerlogTestResult(testName, status, duration, details);
  // Utility methods;
  getErrorCounts: () => enhancedLoggergetErrorCounts();
  getActiveTimers: () => enhancedLoggergetActiveTimers();
  shutdown: () => enhancedLoggershutdown();
;
};
export default logger;