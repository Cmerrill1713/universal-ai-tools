import { execSync  } from 'child_process';
import * as os from 'os';
import { logger  } from './logger';
/**;
 * Metal Performance Optimizer for Apple Silicon;
 * Optimizes LLM inference on M1/M2/M3 chips using Metal GPU acceleration;
 */;
export class MetalOptimizer {;
  private isAppleSilicon = false;
  private gpuInfo: any = {;
};
  private metalSupported = false;
  constructor() {;
    thisdetectHardware();
  };

  /**;
   * Detect Apple Silicon and Metal support;
   */;
  private detectHardware() {;
    try {;
      const platform = osplatform();
      const arch = osarch();
      thisisAppleSilicon = platform === 'darwin' && arch === 'arm64';';

      if (thisisAppleSilicon) {;
        // Check for Metal support;
        const systemInfo = execSync('system_profiler SPDisplaysDataType', { encoding: 'utf-8' });';
        thismetalSupported = systemInfoincludes('Metal');';

        // Get GPU info;
        const gpuMatch = systemInfomatch(/Chipset Model: (.+)/);
        if (gpuMatch) {;
          thisgpuInfomodel = gpuMatch[1]trim();
        };

        // Get unified memory size;
        const memInfo = execSync('sysctl hwmemsize', { encoding: 'utf-8' });';
        const memMatch = memInfomatch(/hwmemsize: (\d+)/);
        if (memMatch) {;
          thisgpuInfounifiedMemory = `${Mathround(parseInt(memMatch[1], 10) / (1024 * 1024 * 1024))} GB`;
        };
      };
      loggerinfo(`üçé Apple Silicon detected: ${thisgpuInfomodel || 'Unknown')}`);';
        loggerinfo(`   Unified Memory: ${thisgpuInfounifiedMemory}`);
        loggerinfo(`   Metal Support: ${thismetalSupported ? 'Yes' : 'No'}`);';
      };
    } catch (error) {;
      loggerdebug('Hardware detection error instanceof Error ? errormessage : String(error) ', error);';
    };
  };

  /**;
   * Get optimized settings for Ollama on Metal;
   */;
  getOllamaMetalSettings(): Record<string, unknown> {;
    if (!thisisAppleSilicon) {;
      return {};
    };

    // Optimal settings for different Apple Silicon chips;
    const settings: Record<string, unknown> = {;
      // Use Metal GPU acceleration;
      OLLAMA_NUM_GPU: 999, // Use all GPU layers;
      OLLAMA_GPU_LAYERS: 999, // Maximum GPU offloading;

      // Memory settings;
      OLLAMA_MAX_LOADED_MODELS: 1, // Focus memory on single model;
      OLLAMA_KEEP_ALIVE: '5m', // Keep model in memory for 5 minutes';

      // Performance settings;
      OLLAMA_NUM_THREAD: thisgetOptimalThreadCount();
      OLLAMA_BATCH_SIZE: thisgetOptimalBatchSize();
      // Metal-specific;
      GGML_METAL: 1;
      GGML_METAL_SPLIT_TENSOR: 1, // Better memory distribution;
    };
    // Adjust based on unified memory;
    const memSize = parseInt(thisgpuInfounifiedMemory, 10) || 8;
    if (memSize >= 32) {;
      settingsOLLAMA_MAX_LOADED_MODELS = 3;
      settingsOLLAMA_BATCH_SIZE = 512;
    } else if (memSize >= 16) {;
      settingsOLLAMA_MAX_LOADED_MODELS = 2;
      settingsOLLAMA_BATCH_SIZE = 256;
    };
;
    return settings;
  };

  /**;
   * Get optimized settings for LM Studio on Metal;
   */;
  getLMStudioMetalSettings(): Record<string, unknown> {;
    if (!thisisAppleSilicon) {;
      return {};
    };

    return {;
      // GPU settings;
      n_gpu_layers: -1, // Use all layers on GPU;
      use_mlock: true, // Lock model in memory;
      use_metal: true;
      // Performance settings;
      n_threads: thisgetOptimalThreadCount();
      n_batch: thisgetOptimalBatchSize();
      // Context settings;
      n_ctx: thisgetOptimalContextSize();
      // Sampling settings for better performance;
      repeat_penalty: 1.1;
      temperature: 0.7;
      top_k: 40;
      top_p: 0.95;
      // Metal-specific optimizations;
      metal_split_tensors: true;
      metal_graph_optimization: true;
    ;
};
  };

  /**;
   * Get optimal thread count for Apple Silicon;
   */;
  private getOptimalThreadCount(): number {;
    const cpus = oscpus();
    const performanceCores = cpusfilter();
      (cpu) => cpumodelincludes('Apple') && !cpumodelincludes('Efficiency')';
    )length;
    // Use 75% of performance cores for LLM, leave some for system;
    return Mathmax(1, Mathfloor(performanceCores * 0.75)) || 4;
  };

  /**;
   * Get optimal batch size based on memory;
   */;
  private getOptimalBatchSize(): number {;
    const memSize = parseInt(thisgpuInfounifiedMemory, 10) || 8;
    if (memSize >= 64) return 1024;
    if (memSize >= 32) return 512;
    if (memSize >= 16) return 256;
    return 128;
  };

  /**;
   * Get optimal context size;
   */;
  private getOptimalContextSize(): number {;
    const memSize = parseInt(thisgpuInfounifiedMemory, 10) || 8;
    if (memSize >= 64) return 32768;
    if (memSize >= 32) return 16384;
    if (memSize >= 16) return 8192;
    return 4096;
  };

  /**;
   * Optimize model loading parameters;
   */;
  getModelLoadingParams(modelSize: string): Record<string, unknown> {;
    const params: Record<string, unknown> = {;
      use_metal: thismetalSupported;
      use_gpu: thismetalSupported;
    ;
};
    // Adjust based on model size;
    const sizeGB = thisparseModelSize(modelSize);
    const memSize = parseInt(thisgpuInfounifiedMemory, 10) || 8;
    if (sizeGB > memSize * 0.6) {;
      // Model is large relative to memory;
      paramsuse_mmap = true; // Memory-mapped loading;
      paramslow_vram = true; // Conservative memory usage;
      paramsn_gpu_layers = Mathfloor((memSize / sizeGB) * 32); // Partial GPU offload;
    } else {;
      // Model fits comfortably;
      paramsuse_mmap = false;
      paramsn_gpu_layers = -1; // Full GPU offload;
    };

    return params;
  };

  /**;
   * Parse model size from string (eg., "7B", "13B")";
   */;
  private parseModelSize(size: string): number {;
    const match = sizematch(/(d+)B/i);
    if (match) {;
      return parseInt(match[1], 10);
    };
    return 7; // Default assumption;
  };

  /**;
   * Get system resource usage;
   */;
  async getResourceUsage(): Promise<{;
    cpuUsage: number;
    memoryUsage: number;
    gpuMemoryUsage?: number;
  }> {;
    const cpus = oscpus();
    const totalCpu =;
      cpusreduce((acc, cpu) => {;
        const total = Objectvalues(cputimes)reduce((a, b) => a + b);
        const { idle } = cputimes;
        return acc + ((total - idle) / total) * 100;
      }, 0) / cpuslength;
    const totalMem = ostotalmem();
    const freeMem = osfreemem();
    const memoryUsage = ((totalMem - freeMem) / totalMem) * 100;
    const usage: {;
      cpuUsage: number;
      memoryUsage: number;
      gpuMemoryUsage?: number;
    } = {;
      cpuUsage: Mathround(totalCpu);
      memoryUsage: Mathround(memoryUsage);
    ;
};
    // Try to get GPU memory usage (Metal);
    if (thisisAppleSilicon) {;
      try {;
        // This is approximate - Metal doesn't expose detailed GPU memory';
        const vmstat = execSync('vm_stat', { encoding: 'utf-8' });';
        const wiredMatch = vmstatmatch(/Pages wired down: \s+(\d+)/);
        if (wiredMatch) {;
          const wiredPages = parseInt(wiredMatch[1], 10);
          const pageSize = 16384; // 16KB pages on Apple Silicon;
          const wiredMemory = (wiredPages * pageSize) / (1024 * 1024 * 1024);
          usagegpuMemoryUsage = Mathround();
            (wiredMemory / parseInt(thisgpuInfounifiedMemory, 10)) * 100;
          );
        };
      } catch (error) {;
        // Ignore errors;
      };
    };
;
    return usage;
  };

  /**;
   * Optimize environment for Metal acceleration;
   */;
  setupMetalEnvironment(): void {;
    if (!thisisAppleSilicon || !thismetalSupported) {;
      return;
    };

    // Set environment variables for optimal Metal performance;
    const metalEnv = {;
      // Metal Performance Shaders;
      METAL_DEVICE_WRAPPER_TYPE: 'Metal',';
      METAL_PERFORMANCE_SHADERS: '1',';

      // Unified memory hints;
      METAL_UNIFIED_MEMORY: '1',';

      // Debugging (disable in production);
      METAL_GPU_CAPTURE_ENABLED: processenvNODE_ENV === 'development' ? '1' : '0',';

      // Thread performance;
      METAL_MAX_COMMAND_BUFFER_SIZE: '256',';
    };
    Objectentries(metalEnv)forEach(([key, value]) => {;
      processenv[key] = value;
    });
    loggerinfo('‚úÖ Metal environment optimized for Apple Silicon');';
  };

  /**;
   * Get performance recommendations;
   */;
  getPerformanceRecommendations(): string[] {;
    const recommendations: string[] = [];
    if (!thisisAppleSilicon) {;
      recommendationspush('Not running on Apple Silicon - Metal optimizations not available');';
      return recommendations;
    };

    const memSize = parseInt(thisgpuInfounifiedMemory, 10) || 8;
    // Model size recommendations;
    if (memSize < 16) {;
      recommendationspush(`With ${memSize)}GB memory, use 7B parameter models or smaller`);
      recommendationspush('Consider quantized models (Q4_K_M or Q5_K_M) for better performance');';
    } else if (memSize < 32) {;
      recommendationspush(`With ${memSize)}GB memory, you can run up to 13B parameter models`);
      recommendationspush('Use Q5_K_M or Q6_K quantization for optimal quality/performance');';
    } else {;
      recommendationspush(`With ${memSize)}GB memory, you can run large models (30B+)`);
      recommendationspush('Consider running multiple smaller models for ensemble inference');';
    };

    // Performance tips;
    recommendationspush('Close memory-intensive apps for better LLM performance');';
    recommendationspush('Use batch processing for multiple queries');';
    recommendationspush('Enable model caching to reduce loading times');';

    return recommendations;
  };

  /**;
   * Benchmark Metal performance;
   */;
  async benchmarkMetal(modelPath: string): Promise<{;
    loadTime: number;
    inferenceTime: number;
    tokensPerSecond: number;
  }> {;
    // This would run actual benchmarks;
    // For now, return estimates based on hardware;
    const memSize = parseInt(thisgpuInfounifiedMemory, 10) || 8;
    return {;
      loadTime: memSize >= 32 ? 2000 : 5000, // ms;
      inferenceTime: memSize >= 32 ? 50 : 100, // ms per token;
      tokensPerSecond: memSize >= 32 ? 20 : 10;
    ;
};
  };

  /**;
   * Get status summary;
   */;
  getStatus(): {;
    platform: string;
    isAppleSilicon: boolean;
    metalSupported: boolean;
    gpuInfo: any;
    recommendations: string[];
  } {;
    return {;
      platform: `${osplatform()} ${osarch()}`;
      isAppleSilicon: thisisAppleSilicon;
      metalSupported: thismetalSupported;
      gpuInfo: thisgpuInfo;
      recommendations: thisgetPerformanceRecommendations();
    ;
};
  };
};

// Export singleton;
export const metalOptimizer = new MetalOptimizer();