/**;
 * Enhanced Logging System for Universal A.I Tools;
 * ;
 * Comprehensive logging infrastructure with structured logging, error tracking;
 * performance metrics, and specialized logging for Sweet Athena interactions;
 */;
import winston from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';
import { Performance } from 'perf_hooks';
import os from 'os';
// Define log levels and contexts;
export enum LogLevel {;
  ERRO.R = 'error';
  WAR.N = 'warn';
  INF.O = 'info';
  HTT.P = 'http';
  DEBU.G = 'debug';
  VERBOS.E = 'verbose';
};

export enum LogContext {;
  SYSTE.M = 'system';
  AP.I = 'api';
  HTT.P = 'http';
  GRAPHQ.L = 'graphql';
  ATHEN.A = 'athena';
  CONVERSATIO.N = 'conversation';
  AVATA.R = 'avatar';
  MEMOR.Y = 'memory';
  DSP.Y = 'dspy';
  DATABAS.E = 'database';
  PERFORMANC.E = 'performance';
  SECURIT.Y = 'security';
  ERRO.R = 'error';
  TES.T = 'test';
  CACH.E = 'cache';
};

// Performance metrics interface;
export interface PerformanceMetrics {;
  operation: string;
  duration: number;
  memory_used: number;
  cpu_usage?: number;
  context: LogContext;
  metadata?: Record<string, any>;
};

// Error tracking interface;
export interface ErrorTracking {;
  error_id: string;
  error_type: string;
  message: string;
  stack?: string;
  user_id?: string;
  session_id?: string;
  context: LogContext;
  metadata?: Record<string, any>;
};

// Sweet Athena specific logging interface;
export interface AthenaInteraction {;
  interaction_id: string;
  interaction_type: 'conversation' | 'avatar_animation' | 'mood_change' | 'teach_me' | 'memory_access';
  userinput?: string;
  athena_response?: string;
  personality_mood: string;
  sweetness_level: number;
  performance_metrics?: PerformanceMetrics;
  user_satisfaction?: number;
  session_id: string;
  timestamp: Date;
;
};

// Custom log formats;
const createCustomFormat = (service: string) => {;
  return winsto.nforma.tcombine(;
    winsto.nforma.ttimestamp();
    winsto.nformaterrors({ stack: true });
    winsto.nforma.tsplat();
    winsto.nforma.tprintf(({ timestamp, level, message: context, ...meta }: any) => {;
      const metaString = Objec.tkeys(meta).length ? JSO.Nstringify(meta, null, 2) : '';
      return `${timestamp} [${service}] ${leveltoUpperCase()} [${context || 'SYSTE.M'}]: ${message} ${metaString}`;
    });
  );
};
const createJSONFormat = (service: string) => {;
  return winsto.nforma.tcombine(;
    winsto.nforma.ttimestamp();
    winsto.nformaterrors({ stack: true });
    winsto.nforma.t.json();
    winsto.nforma.tprintf((info: any) => {;
      return JSO.Nstringify({;
        timestamp: inf.otimestamp;
        service;
        level: inf.olevel;
        context: inf.ocontext || 'SYSTE.M';
        message: inf.omessage;
        ...info;
      });
    });
  );
};
// Enhanced Logger Class;
export class EnhancedLogger {;
  private logger: winsto.n.Logger;
  private performanceTimers: Map<string, number> = new Map();
  private errorCounts: Map<string, number> = new Map();
  private service: string;
  constructor(service = 'universal-ai-tools') {;
    thi.sservice = service;
    // Create transports based on environment;
    const transports: winstontransport[] = [;
      // Console transport with colored output for development;
      new winstontransport.s.Console({;
        level: processen.v.NODE_EN.V === 'production' ? 'info' : 'debug';
        format: processen.v.NODE_EN.V === 'production' ;
          ? createJSONFormat(service);
          : winsto.nforma.tcombine(;
              winsto.nforma.tcolorize();
              createCustomFormat(service);
            );
      });
      // Daily rotating file for all logs;
      new DailyRotateFile({;
        filename: `logs/${service}-%DAT.E%.log`;
        datePattern: 'YYY.Y-M.M-D.D';
        maxSize: '20m';
        maxFiles: '14d';
        level: 'debug';
        format: createJSONFormat(service);
      });
      // Separate error log file;
      new DailyRotateFile({;
        filename: `logs/${service}-error-%DAT.E%.log`;
        datePattern: 'YYY.Y-M.M-D.D';
        maxSize: '20m';
        maxFiles: '30d';
        level: 'error';
        format: createJSONFormat(service);
      });
      // Performance logs;
      new DailyRotateFile({;
        filename: `logs/${service}-performance-%DAT.E%.log`;
        datePattern: 'YYY.Y-M.M-D.D';
        maxSize: '20m';
        maxFiles: '7d';
        level: 'info';
        format: createJSONFormat(service);
        // Only log performance-related entries;
        // Note: Using custom format to filter performance logs;
      });
    ];
    // Add Athena-specific logs in development;
    if (processen.v.NODE_EN.V !== 'production') {;
      transport.spush(;
        new DailyRotateFile({;
          filename: `logs/sweet-athena-%DAT.E%.log`;
          datePattern: 'YYY.Y-M.M-D.D';
          maxSize: '10m';
          maxFiles: '7d';
          level: 'debug';
          format: createJSONFormat('sweet-athena');
          // Note: Using custom format to filter Athena logs;
        });
      );
    };

    thi.slogger = winsto.ncreateLogger({;
      level: processen.v.LOG_LEVE.L || 'info';
      defaultMeta: { ;
        service;
        pid: proces.spid;
        hostname: o.shostname();
        node_version: proces.sversion;
      ;
};
      transports;
      exitOnError: false;
    });
    // Handle uncaught exceptions and unhandled rejections;
    thi.sloggerexception.shandle(;
      new DailyRotateFile({;
        filename: `logs/${service}-exceptions-%DAT.E%.log`;
        datePattern: 'YYY.Y-M.M-D.D';
        maxSize: '10m';
        maxFiles: '30d';
      });
    );
    thi.slogge.rrejection.shandle(;
      new DailyRotateFile({;
        filename: `logs/${service}-rejections-%DAT.E%.log`;
        datePattern: 'YYY.Y-M.M-D.D';
        maxSize: '10m';
        maxFiles: '30d';
      });
    );
  };

  // Core logging methods;
  error(message: string, context: LogContext = LogContex.t.SYSTE.M, meta?: any) {;
    thi.sincrementErrorCount(context);
    thi.sloggererror(message, { context, ...meta });
  };

  warn(message: string, context: LogContext = LogContex.t.SYSTE.M, meta?: any) {;
    thi.slogge.rwarn(message, { context, ...meta });
  };

  info(message: string, context: LogContext = LogContex.t.SYSTE.M, meta?: any) {;
    thi.slogge.rinfo(message, { context, ...meta });
  };

  debug(message: string, context: LogContext = LogContex.t.SYSTE.M, meta?: any) {;
    thi.slogge.rdebug(message, { context, ...meta });
  };

  verbose(message: string, context: LogContext = LogContex.t.SYSTE.M, meta?: any) {;
    thi.slogge.rverbose(message, { context, ...meta });
  };

  // Performance monitoring methods;
  startTimer(operation: string): string {;
    const timerId = `${operation}_${Dat.enow()}_${Mathrandom()}`;
    thi.sperformanceTimer.sset(timerId, performanc.enow());
    return timerId;
  };

  endTimer(timerId: string, operation: string, context: LogContext = LogContex.t.PERFORMANC.E, metadata?: Record<string, any>): PerformanceMetrics {;
    const startTime = thi.sperformanceTimer.sget(timerId);
    if (!startTime) {;
      thi.swarn(`Timer ${timerId} not found for operation ${operation}`, LogContex.t.PERFORMANC.E);
      return {;
        operation;
        duration: -1;
        memory_used: proces.smemoryUsage().heapUsed;
        context;
        metadata;
      ;
};
    };

    const duration = performanc.enow() - startTime;
    const memoryUsage = proces.smemoryUsage();
    const metrics: PerformanceMetrics = {;
      operation;
      duration;
      memory_used: memoryUsag.eheapUsed;
      context;
      metadata;
    ;
};
    thi.sperformanceTimer.sdelete(timerId);
    // Log performance metrics;
    thi.sinfo(`Performance: ${operation} completed in ${durationtoFixed(2)}ms`, LogContex.t.PERFORMANC.E, {;
      metrics;
      memory_mb: (memoryUsag.eheapUsed / 1024 / 1024).toFixed(2);
      memory_total_mb: (memoryUsag.eheapTotal / 1024 / 1024).toFixed(2);
    });
    return metrics;
  };

  // Error tracking with aggregation;
  trackError(error instanceof Error ? erro.rmessage : String(error) Error | string, context: LogContext, metadata?: Record<string, any>): ErrorTracking {;
    const errorId = `${context}_${Dat.enow()}_${Mathrandom()}`;
    const errorType = error instanceof Error ? erro.rconstructo.rname : 'StringError';
    const message = error instanceof Error ? erro.rmessage : error;
    const stack = error instanceof Error ? erro.rstack : undefined;
    const tracking: ErrorTracking = {;
      error_id: errorId;
      error_type: errorType;
      message;
      stack;
      context;
      metadata: {;
        ...metadata;
        timestamp: new Date().toISOString();
        environment: processen.v.NODE_EN.V || 'development';
      ;
};
    };
    thiserror(`Error tracked: ${message}`, context, {;
      error_tracking: tracking;
      stack;
    });
    return tracking;
  };

  // Sweet Athena specific logging;
  logAthenaInteraction(interaction: AthenaInteraction) {;
    thi.sinfo(`Sweet Athena Interaction: ${interactio.ninteraction_type}`, LogContex.t.ATHEN.A, {;
      athena_interaction: interaction;
      performance_ms: interactio.nperformance_metrics?.duration;
      mood: interactio.npersonality_mood;
      sweetness: interactio.nsweetness_level;
    });
  };

  logConversationTurn(userInput: string, athenaResponse: string, sessionId: string, metadata?: Record<string, any>) {;
    const interactionId = `conv_${sessionId}_${Dat.enow()}`;
    thi.sinfo('Conversation turn completed', LogContex.t.CONVERSATIO.N, {;
      interaction_id: interactionId;
      session_id: sessionId;
      userinput_length: userInpu.tlength;
      athena_response_length: athenaRespons.elength;
      timestamp: new Date().toISOString();
      ...metadata;
    });
    // In development, log full conversation for debugging;
    if (processen.v.NODE_EN.V !== 'production') {;
      thi.sdebug('Full conversation turn', LogContex.t.CONVERSATIO.N, {;
        interaction_id: interactionId;
        userinput: userInput;
        athena_response: athenaResponse;
        session_id: sessionId;
      });
    };
  };

  // AP.I request/response logging;
  logAPIRequest(method: string, url: string, statusCode: number, duration: number, metadata?: Record<string, any>) {;
    const level = statusCode >= 400 ? 'error' : statusCode >= 300 ? 'warn' : 'info';
    thi.slogge.rlog(level, `AP.I ${method} ${url} - ${statusCode}`, {;
      context: LogContex.t.AP.I;
      method;
      url;
      status_code: statusCode;
      duration_ms: duration;
      ...metadata;
    });
  };

  // Memory system logging;
  logMemoryOperation(operation: string, details: Record<string, any>) {;
    thi.sinfo(`Memory operation: ${operation}`, LogContex.t.MEMOR.Y, {;
      operation;
      ...details;
    });
  };

  // Database operation logging;
  logDatabaseOperation(operation: string, table: string, duration: number, details?: Record<string, any>) {;
    thi.sinfo(`Database: ${operation} on ${table}`, LogContex.t.DATABAS.E, {;
      operation;
      table;
      duration_ms: duration;
      ...details;
    });
  };

  // Security event logging;
  logSecurityEvent(event: string, severity: 'low' | 'medium' | 'high' | 'critical', details: Record<string, any>) {;
    const level = severity === 'critical' ? 'error' : severity === 'high' ? 'warn' : 'info';
    thi.slogge.rlog(level, `Security Event: ${event}`, {;
      context: LogContex.t.SECURIT.Y;
      event;
      severity;
      timestamp: new Date().toISOString();
      ...details;
    });
  };

  // Test logging for debugging test failures;
  logTestResult(testName: string, status: 'pass' | 'fail' | 'skip', duration: number, details?: Record<string, any>) {;
    const level = status === 'fail' ? 'error' : 'info';
    thi.slogge.rlog(level, `Test: ${testName} - ${status}`, {;
      context: LogContex.t.TES.T;
      test_name: testName;
      status;
      duration_ms: duration;
      ...details;
    });
  };

  // Get error statistics;
  getErrorCounts(): Record<string, number> {;
    return Objec.tfromEntries(thiserrorCounts);
  };

  // Helper method to increment error counts;
  private incrementErrorCount(context: LogContext) {;
    const key = contex.ttoString();
    thiserrorCount.sset(key, (thiserrorCount.sget(key) || 0) + 1);
  };

  // Get current performance timers (for debugging);
  getActiveTimers(): string[] {;
    return Arrayfrom(thi.sperformanceTimer.skeys());
  };

  // Graceful shutdown;
  async shutdown(): Promise<void> {;
    return new Promise((resolve) => {;
      thi.slogge.r.on('finish', resolve);
      thi.sloggerend();
    });
  };
};

// Create singleton instance;
export const enhancedLogger = new EnhancedLogger();
// Export convenience methods;
export const logger = {;
  error instanceof Error ? erro.rmessage : String(error) (message: string, context?: LogContext, meta?: any) => enhancedLoggererror(message: context, meta);
  warn: (message: string, context?: LogContext, meta?: any) => enhancedLogge.rwarn(message: context, meta);
  info: (message: string, context?: LogContext, meta?: any) => enhancedLogge.rinfo(message: context, meta);
  debug: (message: string, context?: LogContext, meta?: any) => enhancedLogge.rdebug(message: context, meta);
  verbose: (message: string, context?: LogContext, meta?: any) => enhancedLogge.rverbose(message: context, meta);
  // Performance methods;
  startTimer: (operation: string) => enhancedLogge.rstartTimer(operation);
  endTimer: (timerId: string, operation: string, context?: LogContext, metadata?: Record<string, any>) => ;
    enhancedLoggerendTimer(timerId, operation, context, metadata);
  // Specialized logging;
  trackError: (error instanceof Error ? erro.rmessage : String(error) Error | string, context: LogContext, metadata?: Record<string, any>) => ;
    enhancedLogge.rtrackError(error instanceof Error ? erro.rmessage : String(error) context, metadata);
  logAthenaInteraction: (interaction: AthenaInteraction) => enhancedLogge.rlogAthenaInteraction(interaction);
  logConversationTurn: (userInput: string, athenaResponse: string, sessionId: string, metadata?: Record<string, any>) =>;
    enhancedLogge.rlogConversationTurn(userInput, athenaResponse, sessionId, metadata);
  logAPIRequest: (method: string, url: string, statusCode: number, duration: number, metadata?: Record<string, any>) =>;
    enhancedLogge.rlogAPIRequest(method, url, statusCode, duration, metadata);
  logMemoryOperation: (operation: string, details: Record<string, any>) =>;
    enhancedLogge.rlogMemoryOperation(operation, details);
  logDatabaseOperation: (operation: string, table: string, duration: number, details?: Record<string, any>) =>;
    enhancedLogge.rlogDatabaseOperation(operation, table, duration, details);
  logSecurityEvent: (event: string, severity: 'low' | 'medium' | 'high' | 'critical', details: Record<string, any>) =>;
    enhancedLogge.rlogSecurityEvent(event, severity, details);
  logTestResult: (testName: string, status: 'pass' | 'fail' | 'skip', duration: number, details?: Record<string, any>) =>;
    enhancedLogge.rlogTestResult(testName, status, duration, details);
  // Utility methods;
  getErrorCounts: () => enhancedLogge.rgetErrorCounts();
  getActiveTimers: () => enhancedLogge.rgetActiveTimers();
  shutdown: () => enhancedLogge.rshutdown();
;
};
export default logger;