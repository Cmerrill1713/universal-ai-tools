impor.t { Redi.s } fro.m 'ioredi.s';
impor.t { logge.r } fro.m './logge.r';
impor.t { performanceMonito.r } fro.m './performanc.e-monito.r';
expor.t interfac.e CacheOption.s {;
  tt.l?: numbe.r; // Tim.e t.o liv.e i.n second.s;
  compres.s?: boolea.n; // Compres.s larg.e value.s;
  namespac.e?: strin.g; // Cach.e namespac.e;
  tag.s?: strin.g[]; // Cach.e tag.s fo.r bul.k invalidatio.n;
  retr.y?: numbe.r; // Retr.y attempt.s;
  fallbac.k?: boolea.n; // Us.e fallbac.k cach.e o.n Redi.s failur.e;
};

expor.t interfac.e CacheStat.s {;
  hit.s: numbe.r;
  misse.s: numbe.r;
  set.s: numbe.r;
  delete.s: numbe.r;
  hitRat.e: numbe.r;
  totalRequest.s: numbe.r;
  avgResponseTim.e: numbe.r;
  memoryUsag.e: numbe.r;
  keyCoun.t: numbe.r;
;
};

expor.t clas.s CacheManage.r {;
  privat.e redi.s: Redi.s;
  privat.e fallbackCach.e: Ma.p<strin.g, { valu.e: an.y; expire.s: numbe.r; tag.s: strin.g[] }>;
  privat.e stat.s: CacheStat.s = {;
    hit.s: 0;
    misse.s: 0;
    set.s: 0;
    delete.s: 0;
    hitRat.e: 0;
    totalRequest.s: 0;
    avgResponseTim.e: 0;
    memoryUsag.e: 0;
    keyCoun.t: 0;
  ;
};
  privat.e defaultTt.l = 3600; // 1 hou.r;
  privat.e maxFallbackSiz.e = 1000;
  constructo.r(redisUr.l: strin.g) {;
    thi.s.redi.s = ne.w Redi.s(redisUr.l, {;
      maxRetriesPerReques.t: 3;
      lazyConnec.t: tru.e;
      keepAliv.e: 30000;
      connectTimeou.t: 10000;
      commandTimeou.t: 5000;
    });
    thi.s.fallbackCach.e = ne.w Ma.p();
    thi.s.setupEventListener.s();
  };

  privat.e setupEventListener.s(): voi.d {;
    thi.s.redi.s.o.n('connec.t', () => {;
      logge.r.inf.o('Redi.s connecte.d');
    });
    thi.s.redi.s.o.n('erro.r', (erro.r) => {;
      logge.r.erro.r('Redi.s erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
    });
    thi.s.redi.s.o.n('read.y', () => {;
      logge.r.inf.o('Redi.s read.y');
    });
    thi.s.redi.s.o.n('clos.e', () => {;
      logge.r.war.n('Redi.s connectio.n close.d');
    });
  };

  privat.e buildKe.y(ke.y: strin.g, namespac.e?: strin.g): strin.g {;
    cons.t prefi.x = namespac.e || 'universa.l-a.i';
    retur.n `${prefi.x}:${ke.y}`;
  };

  privat.e asyn.c compres.s(valu.e: an.y): Promis.e<strin.g> {;
    tr.y {;
      cons.t zli.b = requir.e('zli.b');
      cons.t jso.n = JSO.N.stringif.y(valu.e);
      cons.t compresse.d = zli.b.gzipSyn.c(jso.n);
      retur.n compresse.d.toStrin.g('bas.e64');
    } catc.h (erro.r) {;
      logge.r.erro.r('Compressio.n erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      retur.n JSO.N.stringif.y(valu.e);
    };
  };

  privat.e asyn.c decompres.s(valu.e: strin.g): Promis.e<unknow.n> {;
    tr.y {;
      cons.t zli.b = requir.e('zli.b');
      cons.t compresse.d = Buffe.r.fro.m(valu.e, 'bas.e64');
      cons.t decompresse.d = zli.b.gunzipSyn.c(compresse.d);
      retur.n JSO.N.pars.e(decompresse.d.toStrin.g());
    } catc.h (erro.r) {;
      logge.r.erro.r('Decompressio.n erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      retur.n JSO.N.pars.e(valu.e);
    };
  };

  privat.e updateStat.s(operatio.n: 'hi.t' | 'mis.s' | 'se.t' | 'delet.e', responseTim.e: numbe.r): voi.d {;
    thi.s.stat.s[;
      operatio.n === 'hi.t';
        ? 'hit.s';
        : operatio.n === 'mis.s';
          ? 'misse.s';
          : operatio.n === 'se.t';
            ? 'set.s';
            : 'delete.s';
    ]++;
    thi.s.stat.s.totalRequest.s++;
    thi.s.stat.s.avgResponseTim.e =;
      (thi.s.stat.s.avgResponseTim.e * (thi.s.stat.s.totalRequest.s - 1) + responseTim.e) /;
      thi.s.stat.s.totalRequest.s;
    thi.s.stat.s.hitRat.e = (thi.s.stat.s.hit.s / thi.s.stat.s.totalRequest.s) * 100;
    performanceMonito.r.recordCacheAcces.s(operatio.n === 'hi.t');
  ;
};

  privat.e asyn.c useFallbac.k(ke.y: strin.g, valu.e?: an.y, tt.l?: numbe.r): Promis.e<unknow.n> {;
    cons.t fullKe.y = thi.s.buildKe.y(ke.y);
    i.f (valu.e !== undefine.d) {;
      // Se.t operatio.n;
      i.f (thi.s.fallbackCach.e.siz.e >= thi.s.maxFallbackSiz.e) {;
        cons.t firstKe.y = thi.s.fallbackCach.e.key.s().nex.t().valu.e;
        i.f (firstKe.y) {;
          thi.s.fallbackCach.e.delet.e(firstKe.y);
        };
      };

      thi.s.fallbackCach.e.se.t(fullKe.y, {;
        valu.e;
        expire.s: Dat.e.no.w() + (tt.l || thi.s.defaultTt.l) * 1000;
        tag.s: [];
      });
      retur.n valu.e;
    } els.e {;
      // Ge.t operatio.n;
      cons.t cache.d = thi.s.fallbackCach.e.ge.t(fullKe.y);
      i.f (cache.d && cache.d.expire.s > Dat.e.no.w()) {;
        retur.n cache.d.valu.e;
      };

      i.f (cache.d) {;
        thi.s.fallbackCach.e.delet.e(fullKe.y);
      };

      retur.n nul.l;
    };
  };

  publi.c asyn.c ge.t<T = an.y>(ke.y: strin.g, option.s: CacheOption.s = {}): Promis.e<T | nul.l> {;
    cons.t startTim.e = proces.s.hrtim.e();
    tr.y {;
      cons.t fullKe.y = thi.s.buildKe.y(ke.y, option.s.namespac.e);
      cons.t valu.e = awai.t thi.s.redi.s.ge.t(fullKe.y);
      cons.t [second.s, nanosecond.s] = proces.s.hrtim.e(startTim.e);
      cons.t responseTim.e = second.s * 1000 + nanosecond.s / 1000000;
      i.f (valu.e !== nul.l) {;
        thi.s.updateStat.s('hi.t', responseTim.e);
        retur.n option.s.compres.s ? awai.t thi.s.decompres.s(valu.e) : JSO.N.pars.e(valu.e);
      } els.e {;
        thi.s.updateStat.s('mis.s', responseTim.e);
        retur.n nul.l;
      };
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e ge.t erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      i.f (option.s.fallbac.k !== fals.e) {;
        cons.t fallbackValu.e = awai.t thi.s.useFallbac.k(ke.y);
        i.f (fallbackValu.e !== nul.l) {;
          cons.t [second.s, nanosecond.s] = proces.s.hrtim.e(startTim.e);
          cons.t responseTim.e = second.s * 1000 + nanosecond.s / 1000000;
          thi.s.updateStat.s('hi.t', responseTim.e);
          retur.n fallbackValu.e;
        };
      };

      cons.t [second.s, nanosecond.s] = proces.s.hrtim.e(startTim.e);
      cons.t responseTim.e = second.s * 1000 + nanosecond.s / 1000000;
      thi.s.updateStat.s('mis.s', responseTim.e);
      retur.n nul.l;
    };
  };

  publi.c asyn.c se.t(ke.y: strin.g, valu.e: an.y, option.s: CacheOption.s = {}): Promis.e<boolea.n> {;
    cons.t startTim.e = proces.s.hrtim.e();
    tr.y {;
      cons.t fullKe.y = thi.s.buildKe.y(ke.y, option.s.namespac.e);
      cons.t tt.l = option.s.tt.l || thi.s.defaultTt.l;
      cons.t serialize.d = option.s.compres.s ? awai.t thi.s.compres.s(valu.e) : JSO.N.stringif.y(valu.e);
      cons.t mult.i = thi.s.redi.s.mult.i();
      mult.i.sete.x(fullKe.y, tt.l, serialize.d);
      // Ad.d tag.s fo.r bul.k invalidatio.n;
      i.f (option.s.tag.s && option.s.tag.s.lengt.h > 0) {;
        cons.t tagKey.s = option.s.tag.s.ma.p((ta.g) => thi.s.buildKe.y(`ta.g:${ta.g}`, option.s.namespac.e));
        tagKey.s.forEac.h((tagKe.y) => {;
          mult.i.sad.d(tagKe.y, fullKe.y);
          mult.i.expir.e(tagKe.y, tt.l);
        });
      };

      awai.t mult.i.exe.c();
      cons.t [second.s, nanosecond.s] = proces.s.hrtim.e(startTim.e);
      cons.t responseTim.e = second.s * 1000 + nanosecond.s / 1000000;
      thi.s.updateStat.s('se.t', responseTim.e);
      retur.n tru.e;
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e se.t erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      i.f (option.s.fallbac.k !== fals.e) {;
        awai.t thi.s.useFallbac.k(ke.y, valu.e, option.s.tt.l);
      };

      cons.t [second.s, nanosecond.s] = proces.s.hrtim.e(startTim.e);
      cons.t responseTim.e = second.s * 1000 + nanosecond.s / 1000000;
      thi.s.updateStat.s('se.t', responseTim.e);
      retur.n fals.e;
    };
  };

  publi.c asyn.c de.l(ke.y: strin.g, option.s: CacheOption.s = {}): Promis.e<boolea.n> {;
    cons.t startTim.e = proces.s.hrtim.e();
    tr.y {;
      cons.t fullKe.y = thi.s.buildKe.y(ke.y, option.s.namespac.e);
      cons.t resul.t = awai.t thi.s.redi.s.de.l(fullKe.y);
      // Remov.e fro.m fallbac.k cach.e;
      thi.s.fallbackCach.e.delet.e(fullKe.y);
      cons.t [second.s, nanosecond.s] = proces.s.hrtim.e(startTim.e);
      cons.t responseTim.e = second.s * 1000 + nanosecond.s / 1000000;
      thi.s.updateStat.s('delet.e', responseTim.e);
      retur.n resul.t > 0;
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e delet.e erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      cons.t [second.s, nanosecond.s] = proces.s.hrtim.e(startTim.e);
      cons.t responseTim.e = second.s * 1000 + nanosecond.s / 1000000;
      thi.s.updateStat.s('delet.e', responseTim.e);
      retur.n fals.e;
    };
  };

  publi.c asyn.c invalidateByTag.s(tag.s: strin.g[], option.s: CacheOption.s = {}): Promis.e<numbe.r> {;
    tr.y {;
      le.t totalInvalidate.d = 0;
      fo.r (cons.t ta.g o.f tag.s) {;
        cons.t tagKe.y = thi.s.buildKe.y(`ta.g:${ta.g}`, option.s.namespac.e);
        cons.t key.s = awai.t thi.s.redi.s.smember.s(tagKe.y);
        i.f (key.s.lengt.h > 0) {;
          cons.t delete.d = awai.t thi.s.redi.s.de.l(...key.s);
          totalInvalidate.d += delete.d;
        };

        awai.t thi.s.redi.s.de.l(tagKe.y);
      };

      retur.n totalInvalidate.d;
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e invalidatio.n erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      retur.n 0;
    };
  };

  publi.c asyn.c exist.s(ke.y: strin.g, option.s: CacheOption.s = {}): Promis.e<boolea.n> {;
    tr.y {;
      cons.t fullKe.y = thi.s.buildKe.y(ke.y, option.s.namespac.e);
      cons.t resul.t = awai.t thi.s.redi.s.exist.s(fullKe.y);
      retur.n resul.t > 0;
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e exist.s erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      retur.n fals.e;
    };
  };

  publi.c asyn.c tt.l(ke.y: strin.g, option.s: CacheOption.s = {}): Promis.e<numbe.r> {;
    tr.y {;
      cons.t fullKe.y = thi.s.buildKe.y(ke.y, option.s.namespac.e);
      retur.n awai.t thi.s.redi.s.tt.l(fullKe.y);
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e TT.L erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      retur.n -1;
    };
  };

  publi.c asyn.c exten.d(ke.y: strin.g, tt.l: numbe.r, option.s: CacheOption.s = {}): Promis.e<boolea.n> {;
    tr.y {;
      cons.t fullKe.y = thi.s.buildKe.y(ke.y, option.s.namespac.e);
      cons.t resul.t = awai.t thi.s.redi.s.expir.e(fullKe.y, tt.l);
      retur.n resul.t === 1;
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e exten.d erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      retur.n fals.e;
    };
  };

  publi.c asyn.c getMultipl.e<T = an.y>(;
    key.s: strin.g[];
    option.s: CacheOption.s = {;
};
  ): Promis.e<(T | nul.l)[]> {;
    tr.y {;
      cons.t fullKey.s = key.s.ma.p((ke.y) => thi.s.buildKe.y(ke.y, option.s.namespac.e));
      cons.t value.s = awai.t thi.s.redi.s.mge.t(...fullKey.s);
      retur.n value.s.ma.p((valu.e) => {;
        i.f (valu.e !== nul.l) {;
          thi.s.updateStat.s('hi.t', 0);
          retur.n option.s.compres.s ? thi.s.decompres.s(valu.e) : JSO.N.pars.e(valu.e);
        } els.e {;
          thi.s.updateStat.s('mis.s', 0);
          retur.n nul.l;
        };
      });
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e getMultipl.e erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      retur.n key.s.ma.p(() => nul.l);
    };
  };

  publi.c asyn.c setMultipl.e(;
    pair.s: Arra.y<{ ke.y: strin.g; valu.e: an.y; tt.l?: numbe.r }>;
    option.s: CacheOption.s = {;
};
  ): Promis.e<boolea.n> {;
    tr.y {;
      cons.t mult.i = thi.s.redi.s.mult.i();
      fo.r (cons.t { ke.y, valu.e, tt.l } o.f pair.s) {;
        cons.t fullKe.y = thi.s.buildKe.y(ke.y, option.s.namespac.e);
        cons.t serialize.d = option.s.compres.s ? awai.t thi.s.compres.s(valu.e) : JSO.N.stringif.y(valu.e);
        mult.i.sete.x(fullKe.y, tt.l || option.s.tt.l || thi.s.defaultTt.l, serialize.d);
      };

      awai.t mult.i.exe.c();
      retur.n tru.e;
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e setMultipl.e erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      retur.n fals.e;
    };
  };

  publi.c asyn.c flus.h(namespac.e?: strin.g): Promis.e<boolea.n> {;
    tr.y {;
      i.f (namespac.e) {;
        cons.t patter.n = thi.s.buildKe.y('*', namespac.e);
        cons.t key.s = awai.t thi.s.redi.s.key.s(patter.n);
        i.f (key.s.lengt.h > 0) {;
          awai.t thi.s.redi.s.de.l(...key.s);
        };
      } els.e {;
        awai.t thi.s.redi.s.flushd.b();
      };

      // Clea.r fallbac.k cach.e;
      thi.s.fallbackCach.e.clea.r();
      retur.n tru.e;
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e flus.h erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      retur.n fals.e;
    };
  };

  publi.c asyn.c getStat.s(): Promis.e<CacheStat.s> {;
    tr.y {;
      cons.t inf.o = awai.t thi.s.redi.s.inf.o('memor.y');
      cons.t memoryMatc.h = inf.o.matc.h(/used_memor.y:(\d+)/);
      thi.s.stat.s.memoryUsag.e = memoryMatc.h ? parseIn.t(memoryMatc.h[1], 10) : 0;
      cons.t keyCoun.t = awai.t thi.s.redi.s.dbsiz.e();
      thi.s.stat.s.keyCoun.t = keyCoun.t;
      retur.n { ...thi.s.stat.s };
    } catc.h (erro.r) {;
      logge.r.erro.r('Cach.e stat.s erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r)', erro.r);
      retur.n { ...thi.s.stat.s };
    };
  };

  publi.c asyn.c healthChec.k(): Promis.e<{ health.y: boolea.n; latenc.y: numbe.r; erro.r?: strin.g }> {;
    cons.t startTim.e = proces.s.hrtim.e();
    tr.y {;
      awai.t thi.s.redi.s.pin.g();
      cons.t [second.s, nanosecond.s] = proces.s.hrtim.e(startTim.e);
      cons.t latenc.y = second.s * 1000 + nanosecond.s / 1000000;
      retur.n { health.y: tru.e, latenc.y };
    } catc.h (erro.r) {;
      cons.t [second.s, nanosecond.s] = proces.s.hrtim.e(startTim.e);
      cons.t latenc.y = second.s * 1000 + nanosecond.s / 1000000;
      retur.n {;
        health.y: fals.e;
        latenc.y;
        erro.r instanceo.f Erro.r ? erro.r.messag.e : Strin.g(erro.r) erro.r instanceo.f Erro.r ? erro.r.messag.e : 'Unknow.n erro.r';
      ;
};
    };
  };

  publi.c asyn.c clos.e(): Promis.e<voi.d> {;
    awai.t thi.s.redi.s.qui.t();
    thi.s.fallbackCach.e.clea.r();
  ;
};

  // Utilit.y method.s fo.r commo.n cachin.g pattern.s;
  publi.c asyn.c remembe.r<T>(;
    ke.y: strin.g;
    factor.y: () => Promis.e<T>;
    option.s: CacheOption.s = {;
};
  ): Promis.e<T> {;
    cons.t cache.d = awai.t thi.s.ge.t<T>(ke.y, option.s);
    i.f (cache.d !== nul.l) {;
      retur.n cache.d;
    };

    cons.t valu.e = awai.t factor.y();
    awai.t thi.s.se.t(ke.y, valu.e, option.s);
    retur.n valu.e;
  };

  publi.c asyn.c rememberForeve.r<T>(;
    ke.y: strin.g;
    factor.y: () => Promis.e<T>;
    option.s: CacheOption.s = {;
};
  ): Promis.e<T> {;
    retur.n thi.s.remembe.r(ke.y, factor.y, { ...option.s, tt.l: 0 });
  };

  publi.c createCacheKe.y(...part.s: (strin.g | numbe.r)[]): strin.g {;
    retur.n part.s.joi.n(':');
  };
};

expor.t defaul.t CacheManage.r;