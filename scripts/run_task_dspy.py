#!/usr/bin/env python3
import json
import subprocess
import sys
import tempfile
import pathlib
import difflib
import os
import asyncio
import websockets
from typing import Dict, Any, Optional

ROOT = pathlib.Path(__file__).resolve().parents[1]

def call_dspy_pipeline(task: str) -> Dict[str, Any]:
    """
    Use your existing DSPy WebSocket server for the development pipeline
    """
    async def run_pipeline():
        uri = "ws://localhost:8766"  # Your DSPy server
        
        try:
            async with websockets.connect(uri) as websocket:
                # Send development task to DSPy cognitive chain
                request = {
                    "requestId": f"dev-{int(asyncio.get_event_loop().time())}",
                    "method": "development_pipeline",
                    "params": {
                        "task": task,
                        "task_type": "development",
                        "agents": ["planner", "implementer", "reviewer"],
                        "context": {
                            "repo_root": str(ROOT),
                            "tech_stack": ["typescript", "rust", "go", "python"],
                            "validation_required": True
                        }
                    }
                }
                
                await websocket.send(json.dumps(request))
                response = await websocket.recv()
                return json.loads(response)
        except Exception as e:
            return {"error": f"WebSocket connection failed: {e}"}
    
    # Run async pipeline
    return asyncio.run(run_pipeline())

def apply_dspy_patches(patches: list):
    """Apply patches from DSPy implementer agent"""
    for patch in patches:
        patch_path = ROOT / patch["path"]
        
        # Use git apply for safety
        p = subprocess.run(
            ["git", "apply", "-p0"], 
            input=patch["patch_unified"], 
            text=True, 
            cwd=ROOT,
            capture_output=True
        )
        
        if p.returncode != 0:
            raise RuntimeError(f"Patch application failed: {p.stderr}")

def run_validator() -> tuple[bool, Dict, str, str]:
    """Run the validator script"""
    p = subprocess.run([sys.executable, "scripts/validator.py"], cwd=ROOT, capture_output=True, text=True)
    ok = (p.returncode == 0)
    data = {}
    try:
        data = json.loads(p.stdout or "{}")
    except Exception as e:
        data = {"parse_error": str(e), "stdout": p.stdout, "stderr": p.stderr}
    return ok, data, p.stdout, p.stderr

def main():
    task = sys.argv[1] if len(sys.argv) > 1 else "Add comprehensive error handling to AsyncTechnicalAnalysisService"
    
    print(f"üöÄ Processing task with DSPy: {task}")
    
    # Use DSPy cognitive chain for planning
    print("üß† DSPy cognitive reasoning...")
    dspy_result = call_dspy_pipeline(task)
    
    if "error" in dspy_result:
        print(f"‚ùå DSPy pipeline failed: {dspy_result['error']}")
        sys.exit(1)
    
    # Extract plan from DSPy response
    plan_data = dspy_result.get("data", {})
    patches = plan_data.get("patches", [])
    
    if not patches:
        print("‚ùå No patches generated by DSPy")
        sys.exit(1)
    
    # Apply patches from DSPy implementer
    print(f"‚öôÔ∏è Applying {len(patches)} patches...")
    try:
        apply_dspy_patches(patches)
    except Exception as e:
        print(f"‚ùå Failed to apply patches: {e}")
        sys.exit(1)
    
    # 3) Validate + Fix loop
    attempts = 2
    ok, data, _, _ = run_validator()
    
    while not ok and attempts > 0:
        print(f"üîß DSPy auto-fixing (attempts left: {attempts})...")
        
        # Use DSPy for fixing too
        fix_request = {
            "task": task,
            "validator_errors": data,
            "previous_patches": patches
        }
        
        fix_result = call_dspy_pipeline(f"Fix validation errors: {json.dumps(fix_request)}")
        fix_patches = fix_result.get("data", {}).get("patches", [])
        
        if fix_patches:
            try:
                apply_dspy_patches(fix_patches)
                ok, data, _, _ = run_validator()
            except Exception as e:
                print(f"‚ùå Failed to apply fix patches: {e}")
                break
        
        attempts -= 1
    
    if not ok:
        print("‚ùå Validation still failing after DSPy fixes")
        print(json.dumps(data, indent=2))
        sys.exit(1)
    
    # DSPy reviewer (already built into your cognitive chain)
    review_result = dspy_result.get("data", {}).get("review", {})
    if review_result.get("decision") != "approve":
        print(f"‚ùå DSPy reviewer rejected: {review_result.get('notes', 'No notes')}")
        sys.exit(2)
    
    print("‚úÖ All checks passed and DSPy reviewer approved!")
    
    # Store example for MIPROv2 continuous learning
    learning_example = {
        "task": task,
        "success": True,
        "validation_results": data,
        "patches_applied": len(patches),
        "review_decision": "approved"
    }
    
    print(f"üìä Learning example stored: {json.dumps(learning_example, indent=2)}")
    
    sys.exit(0)

if __name__ == "__main__":
    main()
