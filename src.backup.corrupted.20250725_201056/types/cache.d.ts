import type { Consistency.Strategy, Eviction.Policy } from './config/cache';
export interface Cache.Config {;
  backend: 'redis' | 'memory',;
  defaultT.T.L: number,;
  eviction.Policy: Eviction.Policy,;
  consistency.Strategy: Consistency.Strategy,;
  enable.Compression: boolean,;
  enable.Distributed: boolean,;
  enable.Metrics: boolean,;
  enable.Warmup: boolean,;
};
export interface Cache.Stats {;
  hits: number,;
  misses: number,;
  evictions: number,;
  compression.Ratio: number,;
};
export interface Cache.Options {;
  ttl?: number;
  tags?: string[];
  version?: string;
  compress?: boolean;
};
export interface Cache.Entry<T = any> {;
  data: T,;
  version: string,;
  tags: string[],;
  created.At: number,;
  expires.At?: number;
  compressed: boolean,;
  checksum: string,;
};
export interface Versioned.Data<T = any> {;
  data: T,;
  schema: string,;
  version: string,;
  created.At: number,;
  migrated.From?: string;
};
export interface Migration.Function<T.From = any, T.To = any> {;
  (data: T.From): T.To | Promise<T.To>;
};
export interface Version.Migration {;
  from: string,;
  to: string,;
  migrate: Migration.Function,;
  rollback?: Migration.Function;
};
export interface Conflict.Resolution<T = any> {;
  strategy: 'newest' | 'merge' | 'custom',;
  resolver?: (current: T, incoming: T) => T | Promise<T>;
};
export interface Cache.Backend<T = any> {;
  get(key: string): Promise<T | null>;
  set(key: string, value: T, ttl?: number): Promise<void>;
  delete(key: string): Promise<boolean>;
  has(key: string): Promise<boolean>;
  clear(): Promise<void>;
  disconnect(): Promise<void>;
};
export interface CacheMiddleware.Config {;
  ttl?: number;
  tags?: string[];
  version?: string;
  vary.By?: string[];
  stale.While.Revalidate?: number;
  must.Revalidate?: boolean;
  public?: boolean;
  private?: boolean;
  no.Store?: boolean;
  no.Cache?: boolean;
};
export interface Cached.Response {;
  status: number,;
  headers: Record<string, string>;
  body: any,;
  etag: string,;
  last.Modified: string,;
};
export interface WriteBehind.Options {;
  local.Cache.Size?: number;
  localCacheT.T.L?: number;
  remoteT.T.L?: number;
  namespace?: string;
  batch.Size?: number;
  flush.Interval?: number;
  max.Retries?: number;
  retry.Delay?: number;
  serializer?: (value: any) => string,;
  deserializer?: (data: string) => any,;
  on.Write.Error?: (error instanceof Error ? error.message : String(error) Error, batch: Write.Operation[]) => void,;
};
export interface Write.Operation {;
  key: string,;
  value: any,;
  ttl: number,;
  timestamp: number,;
  retries: number,;
};
export interface Cache.Metrics {;
  hit.Rate: number,;
  miss.Rate: number,;
  eviction.Rate: number,;
  average.Latency: number,;
  memory.Usage: number,;
  queue.Size?: number;
};
export interface Cache.Event {;
  type: 'hit' | 'miss' | 'set' | 'delete' | 'evict' | 'expire' | 'error instanceof Error ? error.message : String(error);';
  key?: string;
  tags?: string[];
  timestamp: number,;
  metadata?: any;
};